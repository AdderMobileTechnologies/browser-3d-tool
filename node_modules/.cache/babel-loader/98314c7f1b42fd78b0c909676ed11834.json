{"ast":null,"code":"!function (e, t) {\n  var i = [],\n      r = e.CANNON || this.CANNON,\n      n = e.OIMO || this.OIMO,\n      o = e.earcut || this.earcut;\n\n  if (\"object\" == typeof exports && \"object\" == typeof module) {\n    try {\n      r = r || require(\"cannon\");\n    } catch (e) {}\n\n    try {\n      n = n || require(\"oimo\");\n    } catch (e) {}\n\n    try {\n      o = o || require(\"earcut\");\n    } catch (e) {}\n\n    module.exports = t(r, n, o);\n  } else if (\"function\" == typeof define && define.amd) require.specified && require.specified(\"cannon\") && i.push(\"cannon\"), require.specified && require.specified(\"oimo\") && i.push(\"oimo\"), require.specified && require.specified(\"earcut\") && i.push(\"earcut\"), define(\"babylonjs\", i, t);else if (\"object\" == typeof exports) {\n    try {\n      r = r || require(\"cannon\");\n    } catch (e) {}\n\n    try {\n      n = n || require(\"oimo\");\n    } catch (e) {}\n\n    try {\n      o = o || require(\"earcut\");\n    } catch (e) {}\n\n    exports.babylonjs = t(r, n, o);\n  } else e.BABYLON = t(r, n, o);\n}(this, function (i, t, m) {\n  i = i || this.CANNON, t = t || this.OIMO, m = m || this.earcut;\n\n  var r,\n      e,\n      n,\n      o,\n      s,\n      a,\n      l,\n      c,\n      h,\n      u,\n      d,\n      f,\n      p,\n      _,\n      g,\n      v,\n      b = this && this.__decorate || function (e, t, i, r) {\n    var n,\n        o = arguments.length,\n        s = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, i) : r;\n    if (\"object\" == typeof Reflect && \"function\" == typeof Reflect.decorate) s = Reflect.decorate(e, t, i, r);else for (var a = e.length - 1; 0 <= a; a--) (n = e[a]) && (s = (o < 3 ? n(s) : 3 < o ? n(t, i, s) : n(t, i)) || s);\n    return 3 < o && s && Object.defineProperty(t, i, s), s;\n  },\n      T = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var i in t) t.hasOwnProperty(i) && (e[i] = t[i]);\n  }, function (e, t) {\n    function i() {\n      this.constructor = e;\n    }\n\n    r(e, t), e.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i());\n  });\n\n  !function (b) {\n    var e = function () {\n      function e() {\n        this._defines = {}, this._currentRank = 32, this._maxRank = -1;\n      }\n\n      return e.prototype.unBindMesh = function () {\n        this._mesh = null;\n      }, e.prototype.addFallback = function (e, t) {\n        this._defines[e] || (e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e), this._defines[e] = new Array()), this._defines[e].push(t);\n      }, e.prototype.addCPUSkinningFallback = function (e, t) {\n        this._mesh = t, e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e);\n      }, Object.defineProperty(e.prototype, \"isMoreFallbacks\", {\n        get: function () {\n          return this._currentRank <= this._maxRank;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.reduce = function (e, t) {\n        if (this._mesh && this._mesh.computeBonesUsingShaders && 0 < this._mesh.numBoneInfluencers && this._mesh.material) {\n          this._mesh.computeBonesUsingShaders = !1, e = e.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\"), t._bonesComputationForcedToCPU = !0;\n\n          for (var i = this._mesh.getScene(), r = 0; r < i.meshes.length; r++) {\n            var n = i.meshes[r];\n            if (n.material && n.computeBonesUsingShaders && 0 !== n.numBoneInfluencers) if (n.material.getEffect() === t) n.computeBonesUsingShaders = !1;else if (n.subMeshes) for (var o = 0, s = n.subMeshes; o < s.length; o++) {\n              if (s[o].effect === t) {\n                n.computeBonesUsingShaders = !1;\n                break;\n              }\n            }\n          }\n        } else {\n          var a = this._defines[this._currentRank];\n          if (a) for (r = 0; r < a.length; r++) e = e.replace(\"#define \" + a[r], \"\");\n          this._currentRank++;\n        }\n\n        return e;\n      }, e;\n    }();\n\n    b.EffectFallbacks = e;\n\n    var t = function () {};\n\n    b.EffectCreationOptions = t;\n\n    var i = function () {\n      function y(n, e, t, i, r, o, s, a, l, c) {\n        void 0 === i && (i = null), void 0 === o && (o = null), void 0 === s && (s = null), void 0 === a && (a = null), void 0 === l && (l = null);\n        var h,\n            u,\n            d = this;\n\n        if (this.uniqueId = 0, this.onCompileObservable = new b.Observable(), this.onErrorObservable = new b.Observable(), this._bonesComputationForcedToCPU = !1, this._uniformBuffersNames = {}, this._isReady = !1, this._compilationError = \"\", this.name = n, e.attributes) {\n          var f = e;\n          if (this._engine = t, this._attributesNames = f.attributes, this._uniformsNames = f.uniformsNames.concat(f.samplers), this._samplers = f.samplers.slice(), this.defines = f.defines, this.onError = f.onError, this.onCompiled = f.onCompiled, this._fallbacks = f.fallbacks, this._indexParameters = f.indexParameters, this._transformFeedbackVaryings = f.transformFeedbackVaryings, f.uniformBuffersNames) for (var p = 0; p < f.uniformBuffersNames.length; p++) this._uniformBuffersNames[f.uniformBuffersNames[p]] = p;\n        } else this._engine = r, this.defines = o, this._uniformsNames = t.concat(i), this._samplers = i ? i.slice() : [], this._attributesNames = e, this.onError = l, this.onCompiled = a, this._indexParameters = c, this._fallbacks = s;\n\n        this.uniqueId = y._uniqueIdSeed++, n.vertexElement ? (h = document.getElementById(n.vertexElement)) || (h = n.vertexElement) : h = n.vertex || n, n.fragmentElement ? (u = document.getElementById(n.fragmentElement)) || (u = n.fragmentElement) : u = n.fragment || n, this._loadVertexShader(h, function (e) {\n          d._processIncludes(e, function (e) {\n            d._processShaderConversion(e, !1, function (r) {\n              d._loadFragmentShader(u, function (e) {\n                d._processIncludes(e, function (e) {\n                  d._processShaderConversion(e, !0, function (e) {\n                    if (n) {\n                      var t = n.vertexElement || n.vertex || n,\n                          i = n.fragmentElement || n.fragment || n;\n                      d._vertexSourceCode = \"#define SHADER_NAME vertex:\" + t + \"\\n\" + r, d._fragmentSourceCode = \"#define SHADER_NAME fragment:\" + i + \"\\n\" + e;\n                    } else d._vertexSourceCode = r, d._fragmentSourceCode = e;\n\n                    d._prepareEffect();\n                  });\n                });\n              });\n            });\n          });\n        });\n      }\n\n      return Object.defineProperty(y.prototype, \"onBindObservable\", {\n        get: function () {\n          return this._onBindObservable || (this._onBindObservable = new b.Observable()), this._onBindObservable;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(y.prototype, \"key\", {\n        get: function () {\n          return this._key;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), y.prototype.isReady = function () {\n        return this._isReady;\n      }, y.prototype.getEngine = function () {\n        return this._engine;\n      }, y.prototype.getProgram = function () {\n        return this._program;\n      }, y.prototype.getAttributesNames = function () {\n        return this._attributesNames;\n      }, y.prototype.getAttributeLocation = function (e) {\n        return this._attributes[e];\n      }, y.prototype.getAttributeLocationByName = function (e) {\n        var t = this._attributesNames.indexOf(e);\n\n        return this._attributes[t];\n      }, y.prototype.getAttributesCount = function () {\n        return this._attributes.length;\n      }, y.prototype.getUniformIndex = function (e) {\n        return this._uniformsNames.indexOf(e);\n      }, y.prototype.getUniform = function (e) {\n        return this._uniforms[this._uniformsNames.indexOf(e)];\n      }, y.prototype.getSamplers = function () {\n        return this._samplers;\n      }, y.prototype.getCompilationError = function () {\n        return this._compilationError;\n      }, y.prototype.executeWhenCompiled = function (t) {\n        this.isReady() ? t(this) : this.onCompileObservable.add(function (e) {\n          t(e);\n        });\n      }, y.prototype._loadVertexShader = function (e, t) {\n        var i;\n        if (b.Tools.IsWindowObjectExist() && e instanceof HTMLElement) return void t(b.Tools.GetDOMTextContent(e));\n        \"base64:\" !== e.substr(0, 7) ? y.ShadersStore[e + \"VertexShader\"] ? t(y.ShadersStore[e + \"VertexShader\"]) : (i = \".\" === e[0] || \"/\" === e[0] || -1 < e.indexOf(\"http\") ? e : b.Engine.ShadersRepository + e, this._engine._loadFile(i + \".vertex.fx\", t)) : t(window.atob(e.substr(7)));\n      }, y.prototype._loadFragmentShader = function (e, t) {\n        var i;\n        if (b.Tools.IsWindowObjectExist() && e instanceof HTMLElement) return void t(b.Tools.GetDOMTextContent(e));\n        \"base64:\" !== e.substr(0, 7) ? y.ShadersStore[e + \"PixelShader\"] ? t(y.ShadersStore[e + \"PixelShader\"]) : y.ShadersStore[e + \"FragmentShader\"] ? t(y.ShadersStore[e + \"FragmentShader\"]) : (i = \".\" === e[0] || \"/\" === e[0] || -1 < e.indexOf(\"http\") ? e : b.Engine.ShadersRepository + e, this._engine._loadFile(i + \".fragment.fx\", t)) : t(window.atob(e.substr(7)));\n      }, y.prototype._dumpShadersSource = function (e, t, i) {\n        var r = (1 < this._engine.webGLVersion ? \"#version 300 es\\n#define WEBGL2 \\n\" : \"\") + (i ? i + \"\\n\" : \"\");\n        t = r + t;\n        var n = 2,\n            o = /\\n/gm,\n            s = \"\\n1\\t\" + (e = r + e).replace(o, function () {\n          return \"\\n\" + n++ + \"\\t\";\n        });\n        n = 2;\n        var a = \"\\n1\\t\" + t.replace(o, function () {\n          return \"\\n\" + n++ + \"\\t\";\n        });\n        this.name.vertexElement ? (b.Tools.Error(\"Vertex shader: \" + this.name.vertexElement + s), b.Tools.Error(\"Fragment shader: \" + this.name.fragmentElement + a)) : this.name.vertex ? (b.Tools.Error(\"Vertex shader: \" + this.name.vertex + s), b.Tools.Error(\"Fragment shader: \" + this.name.fragment + a)) : (b.Tools.Error(\"Vertex shader: \" + this.name + s), b.Tools.Error(\"Fragment shader: \" + this.name + a));\n      }, y.prototype._processShaderConversion = function (e, t, i) {\n        var r = this._processPrecision(e);\n\n        if (1 != this._engine.webGLVersion) {\n          if (-1 === r.indexOf(\"#version 3\")) {\n            var n = -1 !== r.search(/#extension.+GL_EXT_draw_buffers.+require/),\n                o = r.replace(/#extension.+(GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g, \"\");\n            o = (o = (o = o.replace(/varying(?![\\n\\r])\\s/g, t ? \"in \" : \"out \")).replace(/attribute[ \\t]/g, \"in \")).replace(/[ \\t]attribute/g, \" in\"), t && (o = (o = (o = (o = (o = (o = (o = (o = o.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\")).replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\")).replace(/texture2D\\s*\\(/g, \"texture(\")).replace(/textureCube\\s*\\(/g, \"texture(\")).replace(/gl_FragDepthEXT/g, \"gl_FragDepth\")).replace(/gl_FragColor/g, \"glFragColor\")).replace(/gl_FragData/g, \"glFragData\")).replace(/void\\s+?main\\s*\\(/g, (n ? \"\" : \"out vec4 glFragColor;\\n\") + \"void main(\")), i(o);\n          } else i(r.replace(\"#version 300 es\", \"\"));\n        } else i(r);\n      }, y.prototype._processIncludes = function (e, t) {\n        for (var i = this, r = /#include<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g, n = r.exec(e), o = new String(e); null != n;) {\n          var s = n[1];\n\n          if (-1 !== s.indexOf(\"__decl__\") && (s = s.replace(/__decl__/, \"\"), this._engine.supportsUniformBuffers && (s = (s = s.replace(/Vertex/, \"Ubo\")).replace(/Fragment/, \"Ubo\")), s += \"Declaration\"), !y.IncludesShadersStore[s]) {\n            var a = b.Engine.ShadersRepository + \"ShadersInclude/\" + s + \".fx\";\n            return void this._engine._loadFile(a, function (e) {\n              y.IncludesShadersStore[s] = e, i._processIncludes(o, t);\n            });\n          }\n\n          var l = y.IncludesShadersStore[s];\n          if (n[2]) for (var c = n[3].split(\",\"), h = 0; h < c.length; h += 2) {\n            var u = new RegExp(c[h], \"g\"),\n                d = c[h + 1];\n            l = l.replace(u, d);\n          }\n\n          if (n[4]) {\n            var f = n[5];\n\n            if (-1 !== f.indexOf(\"..\")) {\n              var p = f.split(\"..\"),\n                  _ = parseInt(p[0]),\n                  m = parseInt(p[1]),\n                  g = l.slice(0);\n\n              l = \"\", isNaN(m) && (m = this._indexParameters[p[1]]);\n\n              for (var v = _; v < m; v++) this._engine.supportsUniformBuffers || (g = g.replace(/light\\{X\\}.(\\w*)/g, function (e, t) {\n                return t + \"{X}\";\n              })), l += g.replace(/\\{X\\}/g, v.toString()) + \"\\n\";\n            } else this._engine.supportsUniformBuffers || (l = l.replace(/light\\{X\\}.(\\w*)/g, function (e, t) {\n              return t + \"{X}\";\n            })), l = l.replace(/\\{X\\}/g, f);\n          }\n\n          o = o.replace(n[0], l), n = r.exec(e);\n        }\n\n        t(o);\n      }, y.prototype._processPrecision = function (e) {\n        return -1 === e.indexOf(\"precision highp float\") ? e = this._engine.getCaps().highPrecisionShaderSupported ? \"precision highp float;\\n\" + e : \"precision mediump float;\\n\" + e : this._engine.getCaps().highPrecisionShaderSupported || (e = e.replace(\"precision highp float\", \"precision mediump float\")), e;\n      }, y.prototype._rebuildProgram = function (e, t, i, r) {\n        var n = this;\n        this._isReady = !1, this._vertexSourceCodeOverride = e, this._fragmentSourceCodeOverride = t, this.onError = function (e, t) {\n          r && r(t);\n        }, this.onCompiled = function () {\n          for (var e = n.getEngine().scenes, t = 0; t < e.length; t++) e[t].markAllMaterialsAsDirty(b.Material.TextureDirtyFlag);\n\n          i && i(n._program);\n        }, this._fallbacks = null, this._prepareEffect();\n      }, y.prototype.getSpecificUniformLocations = function (e) {\n        return this._engine.getUniforms(this._program, e);\n      }, y.prototype._prepareEffect = function () {\n        var t = this._attributesNames,\n            e = this.defines,\n            i = this._fallbacks;\n        this._valueCache = {};\n        var r = this._program;\n\n        try {\n          var n,\n              o = this._engine;\n          if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._program = o.createRawShaderProgram(this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, void 0, this._transformFeedbackVaryings) : this._program = o.createShaderProgram(this._vertexSourceCode, this._fragmentSourceCode, e, void 0, this._transformFeedbackVaryings), this._program.__SPECTOR_rebuildProgram = this._rebuildProgram.bind(this), o.supportsUniformBuffers) for (var s in this._uniformBuffersNames) this.bindUniformBlock(s, this._uniformBuffersNames[s]);\n\n          for (this._uniforms = o.getUniforms(this._program, this._uniformsNames), this._attributes = o.getAttributes(this._program, t), n = 0; n < this._samplers.length; n++) {\n            null == this.getUniform(this._samplers[n]) && (this._samplers.splice(n, 1), n--);\n          }\n\n          o.bindSamplers(this), this._compilationError = \"\", this._isReady = !0, this.onCompiled && this.onCompiled(this), this.onCompileObservable.notifyObservers(this), this.onCompileObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh(), r && this.getEngine()._deleteProgram(r);\n        } catch (e) {\n          this._compilationError = e.message, b.Tools.Error(\"Unable to compile effect:\"), b.Tools.Error(\"Uniforms: \" + this._uniformsNames.map(function (e) {\n            return \" \" + e;\n          })), b.Tools.Error(\"Attributes: \" + t.map(function (e) {\n            return \" \" + e;\n          })), b.Tools.Error(\"Error: \" + this._compilationError), r && (this._program = r, this._isReady = !0, this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this)), i && i.isMoreFallbacks ? (b.Tools.Error(\"Trying next fallback.\"), this.defines = i.reduce(this.defines, this), this._prepareEffect()) : (this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this), this.onErrorObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh());\n        }\n      }, Object.defineProperty(y.prototype, \"isSupported\", {\n        get: function () {\n          return \"\" === this._compilationError;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), y.prototype._bindTexture = function (e, t) {\n        this._engine._bindTexture(this._samplers.indexOf(e), t);\n      }, y.prototype.setTexture = function (e, t) {\n        this._engine.setTexture(this._samplers.indexOf(e), this.getUniform(e), t);\n      }, y.prototype.setDepthStencilTexture = function (e, t) {\n        this._engine.setDepthStencilTexture(this._samplers.indexOf(e), this.getUniform(e), t);\n      }, y.prototype.setTextureArray = function (e, t) {\n        if (-1 === this._samplers.indexOf(e + \"Ex\")) for (var i = this._samplers.indexOf(e), r = 1; r < t.length; r++) this._samplers.splice(i + r, 0, e + \"Ex\");\n\n        this._engine.setTextureArray(this._samplers.indexOf(e), this.getUniform(e), t);\n      }, y.prototype.setTextureFromPostProcess = function (e, t) {\n        this._engine.setTextureFromPostProcess(this._samplers.indexOf(e), t);\n      }, y.prototype.setTextureFromPostProcessOutput = function (e, t) {\n        this._engine.setTextureFromPostProcessOutput(this._samplers.indexOf(e), t);\n      }, y.prototype._cacheMatrix = function (e, t) {\n        var i = this._valueCache[e],\n            r = t.updateFlag;\n        return (void 0 === i || i !== r) && (this._valueCache[e] = r, !0);\n      }, y.prototype._cacheFloat2 = function (e, t, i) {\n        var r = this._valueCache[e];\n        if (!r) return r = [t, i], this._valueCache[e] = r, !0;\n        var n = !1;\n        return r[0] !== t && (r[0] = t, n = !0), r[1] !== i && (r[1] = i, n = !0), n;\n      }, y.prototype._cacheFloat3 = function (e, t, i, r) {\n        var n = this._valueCache[e];\n        if (!n) return n = [t, i, r], this._valueCache[e] = n, !0;\n        var o = !1;\n        return n[0] !== t && (n[0] = t, o = !0), n[1] !== i && (n[1] = i, o = !0), n[2] !== r && (n[2] = r, o = !0), o;\n      }, y.prototype._cacheFloat4 = function (e, t, i, r, n) {\n        var o = this._valueCache[e];\n        if (!o) return o = [t, i, r, n], this._valueCache[e] = o, !0;\n        var s = !1;\n        return o[0] !== t && (o[0] = t, s = !0), o[1] !== i && (o[1] = i, s = !0), o[2] !== r && (o[2] = r, s = !0), o[3] !== n && (o[3] = n, s = !0), s;\n      }, y.prototype.bindUniformBuffer = function (e, t) {\n        var i = this._uniformBuffersNames[t];\n        void 0 !== i && y._baseCache[i] !== e && (y._baseCache[i] = e, this._engine.bindUniformBufferBase(e, i));\n      }, y.prototype.bindUniformBlock = function (e, t) {\n        this._engine.bindUniformBlock(this._program, e, t);\n      }, y.prototype.setInt = function (e, t) {\n        var i = this._valueCache[e];\n        return void 0 !== i && i === t || (this._valueCache[e] = t, this._engine.setInt(this.getUniform(e), t)), this;\n      }, y.prototype.setIntArray = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setIntArray(this.getUniform(e), t), this;\n      }, y.prototype.setIntArray2 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setIntArray2(this.getUniform(e), t), this;\n      }, y.prototype.setIntArray3 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setIntArray3(this.getUniform(e), t), this;\n      }, y.prototype.setIntArray4 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setIntArray4(this.getUniform(e), t), this;\n      }, y.prototype.setFloatArray = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setFloatArray(this.getUniform(e), t), this;\n      }, y.prototype.setFloatArray2 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setFloatArray2(this.getUniform(e), t), this;\n      }, y.prototype.setFloatArray3 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setFloatArray3(this.getUniform(e), t), this;\n      }, y.prototype.setFloatArray4 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setFloatArray4(this.getUniform(e), t), this;\n      }, y.prototype.setArray = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setArray(this.getUniform(e), t), this;\n      }, y.prototype.setArray2 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setArray2(this.getUniform(e), t), this;\n      }, y.prototype.setArray3 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setArray3(this.getUniform(e), t), this;\n      }, y.prototype.setArray4 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setArray4(this.getUniform(e), t), this;\n      }, y.prototype.setMatrices = function (e, t) {\n        return t && (this._valueCache[e] = null, this._engine.setMatrices(this.getUniform(e), t)), this;\n      }, y.prototype.setMatrix = function (e, t) {\n        return this._cacheMatrix(e, t) && this._engine.setMatrix(this.getUniform(e), t), this;\n      }, y.prototype.setMatrix3x3 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setMatrix3x3(this.getUniform(e), t), this;\n      }, y.prototype.setMatrix2x2 = function (e, t) {\n        return this._valueCache[e] = null, this._engine.setMatrix2x2(this.getUniform(e), t), this;\n      }, y.prototype.setFloat = function (e, t) {\n        var i = this._valueCache[e];\n        return void 0 !== i && i === t || (this._valueCache[e] = t, this._engine.setFloat(this.getUniform(e), t)), this;\n      }, y.prototype.setBool = function (e, t) {\n        var i = this._valueCache[e];\n        return void 0 !== i && i === t || (this._valueCache[e] = t, this._engine.setBool(this.getUniform(e), t ? 1 : 0)), this;\n      }, y.prototype.setVector2 = function (e, t) {\n        return this._cacheFloat2(e, t.x, t.y) && this._engine.setFloat2(this.getUniform(e), t.x, t.y), this;\n      }, y.prototype.setFloat2 = function (e, t, i) {\n        return this._cacheFloat2(e, t, i) && this._engine.setFloat2(this.getUniform(e), t, i), this;\n      }, y.prototype.setVector3 = function (e, t) {\n        return this._cacheFloat3(e, t.x, t.y, t.z) && this._engine.setFloat3(this.getUniform(e), t.x, t.y, t.z), this;\n      }, y.prototype.setFloat3 = function (e, t, i, r) {\n        return this._cacheFloat3(e, t, i, r) && this._engine.setFloat3(this.getUniform(e), t, i, r), this;\n      }, y.prototype.setVector4 = function (e, t) {\n        return this._cacheFloat4(e, t.x, t.y, t.z, t.w) && this._engine.setFloat4(this.getUniform(e), t.x, t.y, t.z, t.w), this;\n      }, y.prototype.setFloat4 = function (e, t, i, r, n) {\n        return this._cacheFloat4(e, t, i, r, n) && this._engine.setFloat4(this.getUniform(e), t, i, r, n), this;\n      }, y.prototype.setColor3 = function (e, t) {\n        return this._cacheFloat3(e, t.r, t.g, t.b) && this._engine.setColor3(this.getUniform(e), t), this;\n      }, y.prototype.setColor4 = function (e, t, i) {\n        return this._cacheFloat4(e, t.r, t.g, t.b, i) && this._engine.setColor4(this.getUniform(e), t, i), this;\n      }, y.prototype.setDirectColor4 = function (e, t) {\n        return this._cacheFloat4(e, t.r, t.g, t.b, t.a) && this._engine.setDirectColor4(this.getUniform(e), t), this;\n      }, y.RegisterShader = function (e, t, i) {\n        t && (y.ShadersStore[e + \"PixelShader\"] = t), i && (y.ShadersStore[e + \"VertexShader\"] = i);\n      }, y.ResetCache = function () {\n        y._baseCache = {};\n      }, y._uniqueIdSeed = 0, y._baseCache = {}, y.ShadersStore = {}, y.IncludesShadersStore = {}, y;\n    }();\n\n    b.Effect = i;\n  }($a || ($a = {})), function (e) {\n    var t = function () {\n      function e() {}\n\n      return e.KEYDOWN = 1, e.KEYUP = 2, e;\n    }();\n\n    e.KeyboardEventTypes = t;\n\n    var i = function (e, t) {\n      this.type = e, this.event = t;\n    },\n        r = function (r) {\n      function e(e, t) {\n        var i = r.call(this, e, t) || this;\n        return i.type = e, i.event = t, i.skipOnPointerObservable = !1, i;\n      }\n\n      return T(e, r), e;\n    }(e.KeyboardInfo = i);\n\n    e.KeyboardInfoPre = r;\n  }($a || ($a = {})), function (s) {\n    var e = function () {\n      function e() {}\n\n      return e.POINTERDOWN = 1, e.POINTERUP = 2, e.POINTERMOVE = 4, e.POINTERWHEEL = 8, e.POINTERPICK = 16, e.POINTERTAP = 32, e.POINTERDOUBLETAP = 64, e;\n    }();\n\n    s.PointerEventTypes = e;\n\n    var t = function (e, t) {\n      this.type = e, this.event = t;\n    },\n        i = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e, t) || this;\n        return n.ray = null, n.skipOnPointerObservable = !1, n.localPosition = new s.Vector2(i, r), n;\n      }\n\n      return T(e, o), e;\n    }(s.PointerInfoBase = t);\n\n    s.PointerInfoPre = i;\n\n    var r = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, t) || this;\n        return r.pickInfo = i, r;\n      }\n\n      return T(e, n), e;\n    }(t);\n\n    s.PointerInfo = r;\n  }($a || ($a = {})), function (f) {\n    f.ToGammaSpace = 1 / 2.2, f.ToLinearSpace = 2.2, f.Epsilon = .001;\n\n    var t = function () {\n      function n(e, t, i) {\n        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = 0), this.r = e, this.g = t, this.b = i;\n      }\n\n      return n.prototype.toString = function () {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n      }, n.prototype.getClassName = function () {\n        return \"Color3\";\n      }, n.prototype.getHashCode = function () {\n        var e = this.r || 0;\n        return e = 397 * (e = 397 * e ^ (this.g || 0)) ^ (this.b || 0);\n      }, n.prototype.toArray = function (e, t) {\n        return void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, this;\n      }, n.prototype.toColor4 = function (e) {\n        return void 0 === e && (e = 1), new i(this.r, this.g, this.b, e);\n      }, n.prototype.asArray = function () {\n        var e = new Array();\n        return this.toArray(e, 0), e;\n      }, n.prototype.toLuminance = function () {\n        return .3 * this.r + .59 * this.g + .11 * this.b;\n      }, n.prototype.multiply = function (e) {\n        return new n(this.r * e.r, this.g * e.g, this.b * e.b);\n      }, n.prototype.multiplyToRef = function (e, t) {\n        return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, this;\n      }, n.prototype.equals = function (e) {\n        return e && this.r === e.r && this.g === e.g && this.b === e.b;\n      }, n.prototype.equalsFloats = function (e, t, i) {\n        return this.r === e && this.g === t && this.b === i;\n      }, n.prototype.scale = function (e) {\n        return new n(this.r * e, this.g * e, this.b * e);\n      }, n.prototype.scaleToRef = function (e, t) {\n        return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, this;\n      }, n.prototype.scaleAndAddToRef = function (e, t) {\n        return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, this;\n      }, n.prototype.clampToRef = function (e, t, i) {\n        return void 0 === e && (e = 0), void 0 === t && (t = 1), i.r = f.Scalar.Clamp(this.r, e, t), i.g = f.Scalar.Clamp(this.g, e, t), i.b = f.Scalar.Clamp(this.b, e, t), this;\n      }, n.prototype.add = function (e) {\n        return new n(this.r + e.r, this.g + e.g, this.b + e.b);\n      }, n.prototype.addToRef = function (e, t) {\n        return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, this;\n      }, n.prototype.subtract = function (e) {\n        return new n(this.r - e.r, this.g - e.g, this.b - e.b);\n      }, n.prototype.subtractToRef = function (e, t) {\n        return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, this;\n      }, n.prototype.clone = function () {\n        return new n(this.r, this.g, this.b);\n      }, n.prototype.copyFrom = function (e) {\n        return this.r = e.r, this.g = e.g, this.b = e.b, this;\n      }, n.prototype.copyFromFloats = function (e, t, i) {\n        return this.r = e, this.g = t, this.b = i, this;\n      }, n.prototype.set = function (e, t, i) {\n        return this.copyFromFloats(e, t, i);\n      }, n.prototype.toHexString = function () {\n        var e = 255 * this.r | 0,\n            t = 255 * this.g | 0,\n            i = 255 * this.b | 0;\n        return \"#\" + f.Scalar.ToHex(e) + f.Scalar.ToHex(t) + f.Scalar.ToHex(i);\n      }, n.prototype.toLinearSpace = function () {\n        var e = new n();\n        return this.toLinearSpaceToRef(e), e;\n      }, n.prototype.toLinearSpaceToRef = function (e) {\n        return e.r = Math.pow(this.r, f.ToLinearSpace), e.g = Math.pow(this.g, f.ToLinearSpace), e.b = Math.pow(this.b, f.ToLinearSpace), this;\n      }, n.prototype.toGammaSpace = function () {\n        var e = new n();\n        return this.toGammaSpaceToRef(e), e;\n      }, n.prototype.toGammaSpaceToRef = function (e) {\n        return e.r = Math.pow(this.r, f.ToGammaSpace), e.g = Math.pow(this.g, f.ToGammaSpace), e.b = Math.pow(this.b, f.ToGammaSpace), this;\n      }, n.FromHexString = function (e) {\n        if (\"#\" !== e.substring(0, 1) || 7 !== e.length) return new n(0, 0, 0);\n        var t = parseInt(e.substring(1, 3), 16),\n            i = parseInt(e.substring(3, 5), 16),\n            r = parseInt(e.substring(5, 7), 16);\n        return n.FromInts(t, i, r);\n      }, n.FromArray = function (e, t) {\n        return void 0 === t && (t = 0), new n(e[t], e[t + 1], e[t + 2]);\n      }, n.FromInts = function (e, t, i) {\n        return new n(e / 255, t / 255, i / 255);\n      }, n.Lerp = function (e, t, i) {\n        var r = new n(0, 0, 0);\n        return n.LerpToRef(e, t, i, r), r;\n      }, n.LerpToRef = function (e, t, i, r) {\n        r.r = e.r + (t.r - e.r) * i, r.g = e.g + (t.g - e.g) * i, r.b = e.b + (t.b - e.b) * i;\n      }, n.Red = function () {\n        return new n(1, 0, 0);\n      }, n.Green = function () {\n        return new n(0, 1, 0);\n      }, n.Blue = function () {\n        return new n(0, 0, 1);\n      }, n.Black = function () {\n        return new n(0, 0, 0);\n      }, n.White = function () {\n        return new n(1, 1, 1);\n      }, n.Purple = function () {\n        return new n(.5, 0, .5);\n      }, n.Magenta = function () {\n        return new n(1, 0, 1);\n      }, n.Yellow = function () {\n        return new n(1, 1, 0);\n      }, n.Gray = function () {\n        return new n(.5, .5, .5);\n      }, n.Teal = function () {\n        return new n(0, 1, 1);\n      }, n.Random = function () {\n        return new n(Math.random(), Math.random(), Math.random());\n      }, n;\n    }();\n\n    f.Color3 = t;\n\n    var i = function () {\n      function o(e, t, i, r) {\n        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 1), this.r = e, this.g = t, this.b = i, this.a = r;\n      }\n\n      return o.prototype.addInPlace = function (e) {\n        return this.r += e.r, this.g += e.g, this.b += e.b, this.a += e.a, this;\n      }, o.prototype.asArray = function () {\n        var e = new Array();\n        return this.toArray(e, 0), e;\n      }, o.prototype.toArray = function (e, t) {\n        return void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, this;\n      }, o.prototype.add = function (e) {\n        return new o(this.r + e.r, this.g + e.g, this.b + e.b, this.a + e.a);\n      }, o.prototype.subtract = function (e) {\n        return new o(this.r - e.r, this.g - e.g, this.b - e.b, this.a - e.a);\n      }, o.prototype.subtractToRef = function (e, t) {\n        return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t.a = this.a - e.a, this;\n      }, o.prototype.scale = function (e) {\n        return new o(this.r * e, this.g * e, this.b * e, this.a * e);\n      }, o.prototype.scaleToRef = function (e, t) {\n        return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t.a = this.a * e, this;\n      }, o.prototype.scaleAndAddToRef = function (e, t) {\n        return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, t.a += this.a * e, this;\n      }, o.prototype.clampToRef = function (e, t, i) {\n        return void 0 === e && (e = 0), void 0 === t && (t = 1), i.r = f.Scalar.Clamp(this.r, e, t), i.g = f.Scalar.Clamp(this.g, e, t), i.b = f.Scalar.Clamp(this.b, e, t), i.a = f.Scalar.Clamp(this.a, e, t), this;\n      }, o.prototype.multiply = function (e) {\n        return new o(this.r * e.r, this.g * e.g, this.b * e.b, this.a * e.a);\n      }, o.prototype.multiplyToRef = function (e, t) {\n        return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t.a = this.a * e.a, t;\n      }, o.prototype.toString = function () {\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n      }, o.prototype.getClassName = function () {\n        return \"Color4\";\n      }, o.prototype.getHashCode = function () {\n        var e = this.r || 0;\n        return e = 397 * (e = 397 * (e = 397 * e ^ (this.g || 0)) ^ (this.b || 0)) ^ (this.a || 0);\n      }, o.prototype.clone = function () {\n        return new o(this.r, this.g, this.b, this.a);\n      }, o.prototype.copyFrom = function (e) {\n        return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;\n      }, o.prototype.copyFromFloats = function (e, t, i, r) {\n        return this.r = e, this.g = t, this.b = i, this.a = r, this;\n      }, o.prototype.set = function (e, t, i, r) {\n        return this.copyFromFloats(e, t, i, r);\n      }, o.prototype.toHexString = function () {\n        var e = 255 * this.r | 0,\n            t = 255 * this.g | 0,\n            i = 255 * this.b | 0,\n            r = 255 * this.a | 0;\n        return \"#\" + f.Scalar.ToHex(e) + f.Scalar.ToHex(t) + f.Scalar.ToHex(i) + f.Scalar.ToHex(r);\n      }, o.prototype.toLinearSpace = function () {\n        var e = new o();\n        return this.toLinearSpaceToRef(e), e;\n      }, o.prototype.toLinearSpaceToRef = function (e) {\n        return e.r = Math.pow(this.r, f.ToLinearSpace), e.g = Math.pow(this.g, f.ToLinearSpace), e.b = Math.pow(this.b, f.ToLinearSpace), e.a = this.a, this;\n      }, o.prototype.toGammaSpace = function () {\n        var e = new o();\n        return this.toGammaSpaceToRef(e), e;\n      }, o.prototype.toGammaSpaceToRef = function (e) {\n        return e.r = Math.pow(this.r, f.ToGammaSpace), e.g = Math.pow(this.g, f.ToGammaSpace), e.b = Math.pow(this.b, f.ToGammaSpace), e.a = this.a, this;\n      }, o.FromHexString = function (e) {\n        if (\"#\" !== e.substring(0, 1) || 9 !== e.length) return new o(0, 0, 0, 0);\n        var t = parseInt(e.substring(1, 3), 16),\n            i = parseInt(e.substring(3, 5), 16),\n            r = parseInt(e.substring(5, 7), 16),\n            n = parseInt(e.substring(7, 9), 16);\n        return o.FromInts(t, i, r, n);\n      }, o.Lerp = function (e, t, i) {\n        var r = new o(0, 0, 0, 0);\n        return o.LerpToRef(e, t, i, r), r;\n      }, o.LerpToRef = function (e, t, i, r) {\n        r.r = e.r + (t.r - e.r) * i, r.g = e.g + (t.g - e.g) * i, r.b = e.b + (t.b - e.b) * i, r.a = e.a + (t.a - e.a) * i;\n      }, o.FromColor3 = function (e, t) {\n        return void 0 === t && (t = 1), new o(e.r, e.g, e.b, t);\n      }, o.FromArray = function (e, t) {\n        return void 0 === t && (t = 0), new o(e[t], e[t + 1], e[t + 2], e[t + 3]);\n      }, o.FromInts = function (e, t, i, r) {\n        return new o(e / 255, t / 255, i / 255, r / 255);\n      }, o.CheckColors4 = function (e, t) {\n        if (e.length === 3 * t) {\n          for (var i = [], r = 0; r < e.length; r += 3) {\n            var n = r / 3 * 4;\n            i[n] = e[r], i[n + 1] = e[r + 1], i[n + 2] = e[r + 2], i[n + 3] = 1;\n          }\n\n          return i;\n        }\n\n        return e;\n      }, o;\n    }();\n\n    f.Color4 = i;\n\n    var p = function () {\n      function u(e, t) {\n        void 0 === e && (e = 0), void 0 === t && (t = 0), this.x = e, this.y = t;\n      }\n\n      return u.prototype.toString = function () {\n        return \"{X: \" + this.x + \" Y:\" + this.y + \"}\";\n      }, u.prototype.getClassName = function () {\n        return \"Vector2\";\n      }, u.prototype.getHashCode = function () {\n        var e = this.x || 0;\n        return e = 397 * e ^ (this.y || 0);\n      }, u.prototype.toArray = function (e, t) {\n        return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, this;\n      }, u.prototype.asArray = function () {\n        var e = new Array();\n        return this.toArray(e, 0), e;\n      }, u.prototype.copyFrom = function (e) {\n        return this.x = e.x, this.y = e.y, this;\n      }, u.prototype.copyFromFloats = function (e, t) {\n        return this.x = e, this.y = t, this;\n      }, u.prototype.set = function (e, t) {\n        return this.copyFromFloats(e, t);\n      }, u.prototype.add = function (e) {\n        return new u(this.x + e.x, this.y + e.y);\n      }, u.prototype.addToRef = function (e, t) {\n        return t.x = this.x + e.x, t.y = this.y + e.y, this;\n      }, u.prototype.addInPlace = function (e) {\n        return this.x += e.x, this.y += e.y, this;\n      }, u.prototype.addVector3 = function (e) {\n        return new u(this.x + e.x, this.y + e.y);\n      }, u.prototype.subtract = function (e) {\n        return new u(this.x - e.x, this.y - e.y);\n      }, u.prototype.subtractToRef = function (e, t) {\n        return t.x = this.x - e.x, t.y = this.y - e.y, this;\n      }, u.prototype.subtractInPlace = function (e) {\n        return this.x -= e.x, this.y -= e.y, this;\n      }, u.prototype.multiplyInPlace = function (e) {\n        return this.x *= e.x, this.y *= e.y, this;\n      }, u.prototype.multiply = function (e) {\n        return new u(this.x * e.x, this.y * e.y);\n      }, u.prototype.multiplyToRef = function (e, t) {\n        return t.x = this.x * e.x, t.y = this.y * e.y, this;\n      }, u.prototype.multiplyByFloats = function (e, t) {\n        return new u(this.x * e, this.y * t);\n      }, u.prototype.divide = function (e) {\n        return new u(this.x / e.x, this.y / e.y);\n      }, u.prototype.divideToRef = function (e, t) {\n        return t.x = this.x / e.x, t.y = this.y / e.y, this;\n      }, u.prototype.divideInPlace = function (e) {\n        return this.divideToRef(e, this);\n      }, u.prototype.negate = function () {\n        return new u(-this.x, -this.y);\n      }, u.prototype.scaleInPlace = function (e) {\n        return this.x *= e, this.y *= e, this;\n      }, u.prototype.scale = function (e) {\n        var t = new u(0, 0);\n        return this.scaleToRef(e, t), t;\n      }, u.prototype.scaleToRef = function (e, t) {\n        return t.x = this.x * e, t.y = this.y * e, this;\n      }, u.prototype.scaleAndAddToRef = function (e, t) {\n        return t.x += this.x * e, t.y += this.y * e, this;\n      }, u.prototype.equals = function (e) {\n        return e && this.x === e.x && this.y === e.y;\n      }, u.prototype.equalsWithEpsilon = function (e, t) {\n        return void 0 === t && (t = f.Epsilon), e && f.Scalar.WithinEpsilon(this.x, e.x, t) && f.Scalar.WithinEpsilon(this.y, e.y, t);\n      }, u.prototype.floor = function () {\n        return new u(Math.floor(this.x), Math.floor(this.y));\n      }, u.prototype.fract = function () {\n        return new u(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\n      }, u.prototype.length = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      }, u.prototype.lengthSquared = function () {\n        return this.x * this.x + this.y * this.y;\n      }, u.prototype.normalize = function () {\n        var e = this.length();\n        if (0 === e) return this;\n        var t = 1 / e;\n        return this.x *= t, this.y *= t, this;\n      }, u.prototype.clone = function () {\n        return new u(this.x, this.y);\n      }, u.Zero = function () {\n        return new u(0, 0);\n      }, u.One = function () {\n        return new u(1, 1);\n      }, u.FromArray = function (e, t) {\n        return void 0 === t && (t = 0), new u(e[t], e[t + 1]);\n      }, u.FromArrayToRef = function (e, t, i) {\n        i.x = e[t], i.y = e[t + 1];\n      }, u.CatmullRom = function (e, t, i, r, n) {\n        var o = n * n,\n            s = n * o;\n        return new u(.5 * (2 * t.x + (-e.x + i.x) * n + (2 * e.x - 5 * t.x + 4 * i.x - r.x) * o + (-e.x + 3 * t.x - 3 * i.x + r.x) * s), .5 * (2 * t.y + (-e.y + i.y) * n + (2 * e.y - 5 * t.y + 4 * i.y - r.y) * o + (-e.y + 3 * t.y - 3 * i.y + r.y) * s));\n      }, u.Clamp = function (e, t, i) {\n        var r = e.x;\n        r = (r = r > i.x ? i.x : r) < t.x ? t.x : r;\n        var n = e.y;\n        return new u(r, n = (n = n > i.y ? i.y : n) < t.y ? t.y : n);\n      }, u.Hermite = function (e, t, i, r, n) {\n        var o = n * n,\n            s = n * o,\n            a = 2 * s - 3 * o + 1,\n            l = -2 * s + 3 * o,\n            c = s - 2 * o + n,\n            h = s - o;\n        return new u(e.x * a + i.x * l + t.x * c + r.x * h, e.y * a + i.y * l + t.y * c + r.y * h);\n      }, u.Lerp = function (e, t, i) {\n        return new u(e.x + (t.x - e.x) * i, e.y + (t.y - e.y) * i);\n      }, u.Dot = function (e, t) {\n        return e.x * t.x + e.y * t.y;\n      }, u.Normalize = function (e) {\n        var t = e.clone();\n        return t.normalize(), t;\n      }, u.Minimize = function (e, t) {\n        return new u(e.x < t.x ? e.x : t.x, e.y < t.y ? e.y : t.y);\n      }, u.Maximize = function (e, t) {\n        return new u(e.x > t.x ? e.x : t.x, e.y > t.y ? e.y : t.y);\n      }, u.Transform = function (e, t) {\n        var i = u.Zero();\n        return u.TransformToRef(e, t, i), i;\n      }, u.TransformToRef = function (e, t, i) {\n        var r = e.x * t.m[0] + e.y * t.m[4] + t.m[12],\n            n = e.x * t.m[1] + e.y * t.m[5] + t.m[13];\n        i.x = r, i.y = n;\n      }, u.PointInTriangle = function (e, t, i, r) {\n        var n = .5 * (-i.y * r.x + t.y * (-i.x + r.x) + t.x * (i.y - r.y) + i.x * r.y),\n            o = n < 0 ? -1 : 1,\n            s = (t.y * r.x - t.x * r.y + (r.y - t.y) * e.x + (t.x - r.x) * e.y) * o,\n            a = (t.x * i.y - t.y * i.x + (t.y - i.y) * e.x + (i.x - t.x) * e.y) * o;\n        return 0 < s && 0 < a && s + a < 2 * n * o;\n      }, u.Distance = function (e, t) {\n        return Math.sqrt(u.DistanceSquared(e, t));\n      }, u.DistanceSquared = function (e, t) {\n        var i = e.x - t.x,\n            r = e.y - t.y;\n        return i * i + r * r;\n      }, u.Center = function (e, t) {\n        var i = e.add(t);\n        return i.scaleInPlace(.5), i;\n      }, u.DistanceOfPointFromSegment = function (e, t, i) {\n        var r = u.DistanceSquared(t, i);\n        if (0 === r) return u.Distance(e, t);\n        var n = i.subtract(t),\n            o = Math.max(0, Math.min(1, u.Dot(e.subtract(t), n) / r)),\n            s = t.add(n.multiplyByFloats(o, o));\n        return u.Distance(e, s);\n      }, u;\n    }();\n\n    f.Vector2 = p;\n\n    var _ = function () {\n      function d(e, t, i) {\n        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = 0), this.x = e, this.y = t, this.z = i;\n      }\n\n      return d.prototype.toString = function () {\n        return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \"}\";\n      }, d.prototype.getClassName = function () {\n        return \"Vector3\";\n      }, d.prototype.getHashCode = function () {\n        var e = this.x || 0;\n        return e = 397 * (e = 397 * e ^ (this.y || 0)) ^ (this.z || 0);\n      }, d.prototype.asArray = function () {\n        var e = [];\n        return this.toArray(e, 0), e;\n      }, d.prototype.toArray = function (e, t) {\n        return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, this;\n      }, d.prototype.toQuaternion = function () {\n        return f.Quaternion.RotationYawPitchRoll(this.x, this.y, this.z);\n      }, d.prototype.addInPlace = function (e) {\n        return this.x += e.x, this.y += e.y, this.z += e.z, this;\n      }, d.prototype.add = function (e) {\n        return new d(this.x + e.x, this.y + e.y, this.z + e.z);\n      }, d.prototype.addToRef = function (e, t) {\n        return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, this;\n      }, d.prototype.subtractInPlace = function (e) {\n        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;\n      }, d.prototype.subtract = function (e) {\n        return new d(this.x - e.x, this.y - e.y, this.z - e.z);\n      }, d.prototype.subtractToRef = function (e, t) {\n        return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, this;\n      }, d.prototype.subtractFromFloats = function (e, t, i) {\n        return new d(this.x - e, this.y - t, this.z - i);\n      }, d.prototype.subtractFromFloatsToRef = function (e, t, i, r) {\n        return r.x = this.x - e, r.y = this.y - t, r.z = this.z - i, this;\n      }, d.prototype.negate = function () {\n        return new d(-this.x, -this.y, -this.z);\n      }, d.prototype.scaleInPlace = function (e) {\n        return this.x *= e, this.y *= e, this.z *= e, this;\n      }, d.prototype.scale = function (e) {\n        return new d(this.x * e, this.y * e, this.z * e);\n      }, d.prototype.scaleToRef = function (e, t) {\n        return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, this;\n      }, d.prototype.scaleAndAddToRef = function (e, t) {\n        return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, this;\n      }, d.prototype.equals = function (e) {\n        return e && this.x === e.x && this.y === e.y && this.z === e.z;\n      }, d.prototype.equalsWithEpsilon = function (e, t) {\n        return void 0 === t && (t = f.Epsilon), e && f.Scalar.WithinEpsilon(this.x, e.x, t) && f.Scalar.WithinEpsilon(this.y, e.y, t) && f.Scalar.WithinEpsilon(this.z, e.z, t);\n      }, d.prototype.equalsToFloats = function (e, t, i) {\n        return this.x === e && this.y === t && this.z === i;\n      }, d.prototype.multiplyInPlace = function (e) {\n        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;\n      }, d.prototype.multiply = function (e) {\n        return new d(this.x * e.x, this.y * e.y, this.z * e.z);\n      }, d.prototype.multiplyToRef = function (e, t) {\n        return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, this;\n      }, d.prototype.multiplyByFloats = function (e, t, i) {\n        return new d(this.x * e, this.y * t, this.z * i);\n      }, d.prototype.divide = function (e) {\n        return new d(this.x / e.x, this.y / e.y, this.z / e.z);\n      }, d.prototype.divideToRef = function (e, t) {\n        return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, this;\n      }, d.prototype.divideInPlace = function (e) {\n        return this.divideToRef(e, this);\n      }, d.prototype.minimizeInPlace = function (e) {\n        return this.minimizeInPlaceFromFloats(e.x, e.y, e.z);\n      }, d.prototype.maximizeInPlace = function (e) {\n        return this.maximizeInPlaceFromFloats(e.x, e.y, e.z);\n      }, d.prototype.minimizeInPlaceFromFloats = function (e, t, i) {\n        return e < this.x && (this.x = e), t < this.y && (this.y = t), i < this.z && (this.z = i), this;\n      }, d.prototype.maximizeInPlaceFromFloats = function (e, t, i) {\n        return e > this.x && (this.x = e), t > this.y && (this.y = t), i > this.z && (this.z = i), this;\n      }, Object.defineProperty(d.prototype, \"isNonUniform\", {\n        get: function () {\n          var e = Math.abs(this.x),\n              t = Math.abs(this.y);\n          if (e !== t) return !0;\n          var i = Math.abs(this.z);\n          return e !== i || t !== i;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), d.prototype.floor = function () {\n        return new d(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\n      }, d.prototype.fract = function () {\n        return new d(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z));\n      }, d.prototype.length = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n      }, d.prototype.lengthSquared = function () {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n      }, d.prototype.normalize = function () {\n        var e = this.length();\n        if (0 === e || 1 === e) return this;\n        var t = 1 / e;\n        return this.x *= t, this.y *= t, this.z *= t, this;\n      }, d.prototype.normalizeToNew = function () {\n        var e = new d(0, 0, 0);\n        return this.normalizeToRef(e), e;\n      }, d.prototype.normalizeToRef = function (e) {\n        var t = this.length();\n        if (0 === t || 1 === t) return e.set(this.x, this.y, this.z), e;\n        var i = 1 / t;\n        return this.scaleToRef(i, e), e;\n      }, d.prototype.clone = function () {\n        return new d(this.x, this.y, this.z);\n      }, d.prototype.copyFrom = function (e) {\n        return this.x = e.x, this.y = e.y, this.z = e.z, this;\n      }, d.prototype.copyFromFloats = function (e, t, i) {\n        return this.x = e, this.y = t, this.z = i, this;\n      }, d.prototype.set = function (e, t, i) {\n        return this.copyFromFloats(e, t, i);\n      }, d.GetClipFactor = function (e, t, i, r) {\n        var n = d.Dot(e, i) - r;\n        return n / (n - (d.Dot(t, i) - r));\n      }, d.GetAngleBetweenVectors = function (e, t, i) {\n        var r = A.Vector3[1].copyFrom(e).normalize(),\n            n = A.Vector3[2].copyFrom(t).normalize(),\n            o = d.Dot(r, n),\n            s = A.Vector3[3];\n        return d.CrossToRef(r, n, s), 0 < d.Dot(s, i) ? Math.acos(o) : -Math.acos(o);\n      }, d.FromArray = function (e, t) {\n        return t || (t = 0), new d(e[t], e[t + 1], e[t + 2]);\n      }, d.FromFloatArray = function (e, t) {\n        return d.FromArray(e, t);\n      }, d.FromArrayToRef = function (e, t, i) {\n        i.x = e[t], i.y = e[t + 1], i.z = e[t + 2];\n      }, d.FromFloatArrayToRef = function (e, t, i) {\n        return d.FromArrayToRef(e, t, i);\n      }, d.FromFloatsToRef = function (e, t, i, r) {\n        r.x = e, r.y = t, r.z = i;\n      }, d.Zero = function () {\n        return new d(0, 0, 0);\n      }, d.One = function () {\n        return new d(1, 1, 1);\n      }, d.Up = function () {\n        return new d(0, 1, 0);\n      }, d.Down = function () {\n        return new d(0, -1, 0);\n      }, d.Forward = function () {\n        return new d(0, 0, 1);\n      }, d.Backward = function () {\n        return new d(0, 0, -1);\n      }, d.Right = function () {\n        return new d(1, 0, 0);\n      }, d.Left = function () {\n        return new d(-1, 0, 0);\n      }, d.TransformCoordinates = function (e, t) {\n        var i = d.Zero();\n        return d.TransformCoordinatesToRef(e, t, i), i;\n      }, d.TransformCoordinatesToRef = function (e, t, i) {\n        var r = e.x * t.m[0] + e.y * t.m[4] + e.z * t.m[8] + t.m[12],\n            n = e.x * t.m[1] + e.y * t.m[5] + e.z * t.m[9] + t.m[13],\n            o = e.x * t.m[2] + e.y * t.m[6] + e.z * t.m[10] + t.m[14],\n            s = e.x * t.m[3] + e.y * t.m[7] + e.z * t.m[11] + t.m[15];\n        i.x = r / s, i.y = n / s, i.z = o / s;\n      }, d.TransformCoordinatesFromFloatsToRef = function (e, t, i, r, n) {\n        var o = e * r.m[0] + t * r.m[4] + i * r.m[8] + r.m[12],\n            s = e * r.m[1] + t * r.m[5] + i * r.m[9] + r.m[13],\n            a = e * r.m[2] + t * r.m[6] + i * r.m[10] + r.m[14],\n            l = e * r.m[3] + t * r.m[7] + i * r.m[11] + r.m[15];\n        n.x = o / l, n.y = s / l, n.z = a / l;\n      }, d.TransformNormal = function (e, t) {\n        var i = d.Zero();\n        return d.TransformNormalToRef(e, t, i), i;\n      }, d.TransformNormalToRef = function (e, t, i) {\n        var r = e.x * t.m[0] + e.y * t.m[4] + e.z * t.m[8],\n            n = e.x * t.m[1] + e.y * t.m[5] + e.z * t.m[9],\n            o = e.x * t.m[2] + e.y * t.m[6] + e.z * t.m[10];\n        i.x = r, i.y = n, i.z = o;\n      }, d.TransformNormalFromFloatsToRef = function (e, t, i, r, n) {\n        n.x = e * r.m[0] + t * r.m[4] + i * r.m[8], n.y = e * r.m[1] + t * r.m[5] + i * r.m[9], n.z = e * r.m[2] + t * r.m[6] + i * r.m[10];\n      }, d.CatmullRom = function (e, t, i, r, n) {\n        var o = n * n,\n            s = n * o;\n        return new d(.5 * (2 * t.x + (-e.x + i.x) * n + (2 * e.x - 5 * t.x + 4 * i.x - r.x) * o + (-e.x + 3 * t.x - 3 * i.x + r.x) * s), .5 * (2 * t.y + (-e.y + i.y) * n + (2 * e.y - 5 * t.y + 4 * i.y - r.y) * o + (-e.y + 3 * t.y - 3 * i.y + r.y) * s), .5 * (2 * t.z + (-e.z + i.z) * n + (2 * e.z - 5 * t.z + 4 * i.z - r.z) * o + (-e.z + 3 * t.z - 3 * i.z + r.z) * s));\n      }, d.Clamp = function (e, t, i) {\n        var r = e.x;\n        r = (r = r > i.x ? i.x : r) < t.x ? t.x : r;\n        var n = e.y;\n        n = (n = n > i.y ? i.y : n) < t.y ? t.y : n;\n        var o = e.z;\n        return new d(r, n, o = (o = o > i.z ? i.z : o) < t.z ? t.z : o);\n      }, d.Hermite = function (e, t, i, r, n) {\n        var o = n * n,\n            s = n * o,\n            a = 2 * s - 3 * o + 1,\n            l = -2 * s + 3 * o,\n            c = s - 2 * o + n,\n            h = s - o;\n        return new d(e.x * a + i.x * l + t.x * c + r.x * h, e.y * a + i.y * l + t.y * c + r.y * h, e.z * a + i.z * l + t.z * c + r.z * h);\n      }, d.Lerp = function (e, t, i) {\n        var r = new d(0, 0, 0);\n        return d.LerpToRef(e, t, i, r), r;\n      }, d.LerpToRef = function (e, t, i, r) {\n        r.x = e.x + (t.x - e.x) * i, r.y = e.y + (t.y - e.y) * i, r.z = e.z + (t.z - e.z) * i;\n      }, d.Dot = function (e, t) {\n        return e.x * t.x + e.y * t.y + e.z * t.z;\n      }, d.Cross = function (e, t) {\n        var i = d.Zero();\n        return d.CrossToRef(e, t, i), i;\n      }, d.CrossToRef = function (e, t, i) {\n        A.Vector3[0].x = e.y * t.z - e.z * t.y, A.Vector3[0].y = e.z * t.x - e.x * t.z, A.Vector3[0].z = e.x * t.y - e.y * t.x, i.copyFrom(A.Vector3[0]);\n      }, d.Normalize = function (e) {\n        var t = d.Zero();\n        return d.NormalizeToRef(e, t), t;\n      }, d.NormalizeToRef = function (e, t) {\n        t.copyFrom(e), t.normalize();\n      }, d.Project = function (e, t, i, r) {\n        var n = r.width,\n            o = r.height,\n            s = r.x,\n            a = r.y,\n            l = d._viewportMatrixCache ? d._viewportMatrixCache : d._viewportMatrixCache = new h();\n        h.FromValuesToRef(n / 2, 0, 0, 0, 0, -o / 2, 0, 0, 0, 0, .5, 0, s + n / 2, o / 2 + a, .5, 1, l);\n        var c = A.Matrix[0];\n        return t.multiplyToRef(i, c), c.multiplyToRef(l, c), d.TransformCoordinates(e, c);\n      }, d.UnprojectFromTransform = function (e, t, i, r, n) {\n        var o = A.Matrix[0];\n        r.multiplyToRef(n, o), o.invert(), e.x = e.x / t * 2 - 1, e.y = -(e.y / i * 2 - 1);\n        var s = d.TransformCoordinates(e, o),\n            a = e.x * o.m[3] + e.y * o.m[7] + e.z * o.m[11] + o.m[15];\n        return f.Scalar.WithinEpsilon(a, 1) && (s = s.scale(1 / a)), s;\n      }, d.Unproject = function (e, t, i, r, n, o) {\n        var s = d.Zero();\n        return d.UnprojectToRef(e, t, i, r, n, o, s), s;\n      }, d.UnprojectToRef = function (e, t, i, r, n, o, s) {\n        d.UnprojectFloatsToRef(e.x, e.y, e.z, t, i, r, n, o, s);\n      }, d.UnprojectFloatsToRef = function (e, t, i, r, n, o, s, a, l) {\n        var c = A.Matrix[0];\n        o.multiplyToRef(s, c), c.multiplyToRef(a, c), c.invert();\n        var h = A.Vector3[0];\n        h.x = e / r * 2 - 1, h.y = -(t / n * 2 - 1), h.z = 2 * i - 1, d.TransformCoordinatesToRef(h, c, l);\n        var u = h.x * c.m[3] + h.y * c.m[7] + h.z * c.m[11] + c.m[15];\n        f.Scalar.WithinEpsilon(u, 1) && l.scaleInPlace(1 / u);\n      }, d.Minimize = function (e, t) {\n        var i = e.clone();\n        return i.minimizeInPlace(t), i;\n      }, d.Maximize = function (e, t) {\n        var i = e.clone();\n        return i.maximizeInPlace(t), i;\n      }, d.Distance = function (e, t) {\n        return Math.sqrt(d.DistanceSquared(e, t));\n      }, d.DistanceSquared = function (e, t) {\n        var i = e.x - t.x,\n            r = e.y - t.y,\n            n = e.z - t.z;\n        return i * i + r * r + n * n;\n      }, d.Center = function (e, t) {\n        var i = e.add(t);\n        return i.scaleInPlace(.5), i;\n      }, d.RotationFromAxis = function (e, t, i) {\n        var r = d.Zero();\n        return d.RotationFromAxisToRef(e, t, i, r), r;\n      }, d.RotationFromAxisToRef = function (e, t, i, r) {\n        var n = A.Quaternion[0];\n        m.RotationQuaternionFromAxisToRef(e, t, i, n), n.toEulerAnglesToRef(r);\n      }, d;\n    }();\n\n    f.Vector3 = _;\n\n    var r = function () {\n      function n(e, t, i, r) {\n        this.x = e, this.y = t, this.z = i, this.w = r;\n      }\n\n      return n.prototype.toString = function () {\n        return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\n      }, n.prototype.getClassName = function () {\n        return \"Vector4\";\n      }, n.prototype.getHashCode = function () {\n        var e = this.x || 0;\n        return e = 397 * (e = 397 * (e = 397 * e ^ (this.y || 0)) ^ (this.z || 0)) ^ (this.w || 0);\n      }, n.prototype.asArray = function () {\n        var e = new Array();\n        return this.toArray(e, 0), e;\n      }, n.prototype.toArray = function (e, t) {\n        return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this;\n      }, n.prototype.addInPlace = function (e) {\n        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;\n      }, n.prototype.add = function (e) {\n        return new n(this.x + e.x, this.y + e.y, this.z + e.z, this.w + e.w);\n      }, n.prototype.addToRef = function (e, t) {\n        return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, t.w = this.w + e.w, this;\n      }, n.prototype.subtractInPlace = function (e) {\n        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;\n      }, n.prototype.subtract = function (e) {\n        return new n(this.x - e.x, this.y - e.y, this.z - e.z, this.w - e.w);\n      }, n.prototype.subtractToRef = function (e, t) {\n        return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, t.w = this.w - e.w, this;\n      }, n.prototype.subtractFromFloats = function (e, t, i, r) {\n        return new n(this.x - e, this.y - t, this.z - i, this.w - r);\n      }, n.prototype.subtractFromFloatsToRef = function (e, t, i, r, n) {\n        return n.x = this.x - e, n.y = this.y - t, n.z = this.z - i, n.w = this.w - r, this;\n      }, n.prototype.negate = function () {\n        return new n(-this.x, -this.y, -this.z, -this.w);\n      }, n.prototype.scaleInPlace = function (e) {\n        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;\n      }, n.prototype.scale = function (e) {\n        return new n(this.x * e, this.y * e, this.z * e, this.w * e);\n      }, n.prototype.scaleToRef = function (e, t) {\n        return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e, this;\n      }, n.prototype.scaleAndAddToRef = function (e, t) {\n        return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, t.w += this.w * e, this;\n      }, n.prototype.equals = function (e) {\n        return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;\n      }, n.prototype.equalsWithEpsilon = function (e, t) {\n        return void 0 === t && (t = f.Epsilon), e && f.Scalar.WithinEpsilon(this.x, e.x, t) && f.Scalar.WithinEpsilon(this.y, e.y, t) && f.Scalar.WithinEpsilon(this.z, e.z, t) && f.Scalar.WithinEpsilon(this.w, e.w, t);\n      }, n.prototype.equalsToFloats = function (e, t, i, r) {\n        return this.x === e && this.y === t && this.z === i && this.w === r;\n      }, n.prototype.multiplyInPlace = function (e) {\n        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;\n      }, n.prototype.multiply = function (e) {\n        return new n(this.x * e.x, this.y * e.y, this.z * e.z, this.w * e.w);\n      }, n.prototype.multiplyToRef = function (e, t) {\n        return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, t.w = this.w * e.w, this;\n      }, n.prototype.multiplyByFloats = function (e, t, i, r) {\n        return new n(this.x * e, this.y * t, this.z * i, this.w * r);\n      }, n.prototype.divide = function (e) {\n        return new n(this.x / e.x, this.y / e.y, this.z / e.z, this.w / e.w);\n      }, n.prototype.divideToRef = function (e, t) {\n        return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, t.w = this.w / e.w, this;\n      }, n.prototype.divideInPlace = function (e) {\n        return this.divideToRef(e, this);\n      }, n.prototype.minimizeInPlace = function (e) {\n        return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this;\n      }, n.prototype.maximizeInPlace = function (e) {\n        return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this;\n      }, n.prototype.floor = function () {\n        return new n(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\n      }, n.prototype.fract = function () {\n        return new n(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\n      }, n.prototype.length = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n      }, n.prototype.lengthSquared = function () {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n      }, n.prototype.normalize = function () {\n        var e = this.length();\n        if (0 === e) return this;\n        var t = 1 / e;\n        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;\n      }, n.prototype.toVector3 = function () {\n        return new _(this.x, this.y, this.z);\n      }, n.prototype.clone = function () {\n        return new n(this.x, this.y, this.z, this.w);\n      }, n.prototype.copyFrom = function (e) {\n        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;\n      }, n.prototype.copyFromFloats = function (e, t, i, r) {\n        return this.x = e, this.y = t, this.z = i, this.w = r, this;\n      }, n.prototype.set = function (e, t, i, r) {\n        return this.copyFromFloats(e, t, i, r);\n      }, n.FromArray = function (e, t) {\n        return t || (t = 0), new n(e[t], e[t + 1], e[t + 2], e[t + 3]);\n      }, n.FromArrayToRef = function (e, t, i) {\n        i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3];\n      }, n.FromFloatArrayToRef = function (e, t, i) {\n        n.FromArrayToRef(e, t, i);\n      }, n.FromFloatsToRef = function (e, t, i, r, n) {\n        n.x = e, n.y = t, n.z = i, n.w = r;\n      }, n.Zero = function () {\n        return new n(0, 0, 0, 0);\n      }, n.One = function () {\n        return new n(1, 1, 1, 1);\n      }, n.Normalize = function (e) {\n        var t = n.Zero();\n        return n.NormalizeToRef(e, t), t;\n      }, n.NormalizeToRef = function (e, t) {\n        t.copyFrom(e), t.normalize();\n      }, n.Minimize = function (e, t) {\n        var i = e.clone();\n        return i.minimizeInPlace(t), i;\n      }, n.Maximize = function (e, t) {\n        var i = e.clone();\n        return i.maximizeInPlace(t), i;\n      }, n.Distance = function (e, t) {\n        return Math.sqrt(n.DistanceSquared(e, t));\n      }, n.DistanceSquared = function (e, t) {\n        var i = e.x - t.x,\n            r = e.y - t.y,\n            n = e.z - t.z,\n            o = e.w - t.w;\n        return i * i + r * r + n * n + o * o;\n      }, n.Center = function (e, t) {\n        var i = e.add(t);\n        return i.scaleInPlace(.5), i;\n      }, n.TransformNormal = function (e, t) {\n        var i = n.Zero();\n        return n.TransformNormalToRef(e, t, i), i;\n      }, n.TransformNormalToRef = function (e, t, i) {\n        var r = e.x * t.m[0] + e.y * t.m[4] + e.z * t.m[8],\n            n = e.x * t.m[1] + e.y * t.m[5] + e.z * t.m[9],\n            o = e.x * t.m[2] + e.y * t.m[6] + e.z * t.m[10];\n        i.x = r, i.y = n, i.z = o, i.w = e.w;\n      }, n.TransformNormalFromFloatsToRef = function (e, t, i, r, n, o) {\n        o.x = e * n.m[0] + t * n.m[4] + i * n.m[8], o.y = e * n.m[1] + t * n.m[5] + i * n.m[9], o.z = e * n.m[2] + t * n.m[6] + i * n.m[10], o.w = r;\n      }, n;\n    }();\n\n    f.Vector4 = r;\n\n    var e = function () {\n      function r(e, t) {\n        this.width = e, this.height = t;\n      }\n\n      return r.prototype.toString = function () {\n        return \"{W: \" + this.width + \", H: \" + this.height + \"}\";\n      }, r.prototype.getClassName = function () {\n        return \"Size\";\n      }, r.prototype.getHashCode = function () {\n        var e = this.width || 0;\n        return e = 397 * e ^ (this.height || 0);\n      }, r.prototype.copyFrom = function (e) {\n        this.width = e.width, this.height = e.height;\n      }, r.prototype.copyFromFloats = function (e, t) {\n        return this.width = e, this.height = t, this;\n      }, r.prototype.set = function (e, t) {\n        return this.copyFromFloats(e, t);\n      }, r.prototype.multiplyByFloats = function (e, t) {\n        return new r(this.width * e, this.height * t);\n      }, r.prototype.clone = function () {\n        return new r(this.width, this.height);\n      }, r.prototype.equals = function (e) {\n        return !!e && this.width === e.width && this.height === e.height;\n      }, Object.defineProperty(r.prototype, \"surface\", {\n        get: function () {\n          return this.width * this.height;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), r.Zero = function () {\n        return new r(0, 0);\n      }, r.prototype.add = function (e) {\n        return new r(this.width + e.width, this.height + e.height);\n      }, r.prototype.subtract = function (e) {\n        return new r(this.width - e.width, this.height - e.height);\n      }, r.Lerp = function (e, t, i) {\n        return new r(e.width + (t.width - e.width) * i, e.height + (t.height - e.height) * i);\n      }, r;\n    }();\n\n    f.Size = e;\n\n    var m = function () {\n      function u(e, t, i, r) {\n        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 1), this.x = e, this.y = t, this.z = i, this.w = r;\n      }\n\n      return u.prototype.toString = function () {\n        return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\n      }, u.prototype.getClassName = function () {\n        return \"Quaternion\";\n      }, u.prototype.getHashCode = function () {\n        var e = this.x || 0;\n        return e = 397 * (e = 397 * (e = 397 * e ^ (this.y || 0)) ^ (this.z || 0)) ^ (this.w || 0);\n      }, u.prototype.asArray = function () {\n        return [this.x, this.y, this.z, this.w];\n      }, u.prototype.equals = function (e) {\n        return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;\n      }, u.prototype.clone = function () {\n        return new u(this.x, this.y, this.z, this.w);\n      }, u.prototype.copyFrom = function (e) {\n        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;\n      }, u.prototype.copyFromFloats = function (e, t, i, r) {\n        return this.x = e, this.y = t, this.z = i, this.w = r, this;\n      }, u.prototype.set = function (e, t, i, r) {\n        return this.copyFromFloats(e, t, i, r);\n      }, u.prototype.add = function (e) {\n        return new u(this.x + e.x, this.y + e.y, this.z + e.z, this.w + e.w);\n      }, u.prototype.addInPlace = function (e) {\n        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;\n      }, u.prototype.subtract = function (e) {\n        return new u(this.x - e.x, this.y - e.y, this.z - e.z, this.w - e.w);\n      }, u.prototype.scale = function (e) {\n        return new u(this.x * e, this.y * e, this.z * e, this.w * e);\n      }, u.prototype.scaleToRef = function (e, t) {\n        return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e, this;\n      }, u.prototype.scaleInPlace = function (e) {\n        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;\n      }, u.prototype.scaleAndAddToRef = function (e, t) {\n        return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, t.w += this.w * e, this;\n      }, u.prototype.multiply = function (e) {\n        var t = new u(0, 0, 0, 1);\n        return this.multiplyToRef(e, t), t;\n      }, u.prototype.multiplyToRef = function (e, t) {\n        var i = this.x * e.w + this.y * e.z - this.z * e.y + this.w * e.x,\n            r = -this.x * e.z + this.y * e.w + this.z * e.x + this.w * e.y,\n            n = this.x * e.y - this.y * e.x + this.z * e.w + this.w * e.z,\n            o = -this.x * e.x - this.y * e.y - this.z * e.z + this.w * e.w;\n        return t.copyFromFloats(i, r, n, o), this;\n      }, u.prototype.multiplyInPlace = function (e) {\n        return this.multiplyToRef(e, this), this;\n      }, u.prototype.conjugateToRef = function (e) {\n        return e.copyFromFloats(-this.x, -this.y, -this.z, this.w), this;\n      }, u.prototype.conjugateInPlace = function () {\n        return this.x *= -1, this.y *= -1, this.z *= -1, this;\n      }, u.prototype.conjugate = function () {\n        return new u(-this.x, -this.y, -this.z, this.w);\n      }, u.prototype.length = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n      }, u.prototype.normalize = function () {\n        var e = 1 / this.length();\n        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;\n      }, u.prototype.toEulerAngles = function (e) {\n        void 0 === e && (e = \"YZX\");\n\n        var t = _.Zero();\n\n        return this.toEulerAnglesToRef(t, e), t;\n      }, u.prototype.toEulerAnglesToRef = function (e, t) {\n        void 0 === t && (t = \"YZX\");\n        var i = this.z,\n            r = this.x,\n            n = this.y,\n            o = this.w,\n            s = o * o,\n            a = i * i,\n            l = r * r,\n            c = n * n,\n            h = n * i - r * o;\n        return h < -.4999999 ? (e.y = 2 * Math.atan2(n, o), e.x = Math.PI / 2, e.z = 0) : .4999999 < h ? (e.y = 2 * Math.atan2(n, o), e.x = -Math.PI / 2, e.z = 0) : (e.z = Math.atan2(2 * (r * n + i * o), -a - l + c + s), e.x = Math.asin(-2 * (i * n - r * o)), e.y = Math.atan2(2 * (i * r + n * o), a - l - c + s)), this;\n      }, u.prototype.toRotationMatrix = function (e) {\n        var t = this.x * this.x,\n            i = this.y * this.y,\n            r = this.z * this.z,\n            n = this.x * this.y,\n            o = this.z * this.w,\n            s = this.z * this.x,\n            a = this.y * this.w,\n            l = this.y * this.z,\n            c = this.x * this.w;\n        return e.m[0] = 1 - 2 * (i + r), e.m[1] = 2 * (n + o), e.m[2] = 2 * (s - a), e.m[3] = 0, e.m[4] = 2 * (n - o), e.m[5] = 1 - 2 * (r + t), e.m[6] = 2 * (l + c), e.m[7] = 0, e.m[8] = 2 * (s + a), e.m[9] = 2 * (l - c), e.m[10] = 1 - 2 * (i + t), e.m[11] = 0, e.m[12] = 0, e.m[13] = 0, e.m[14] = 0, e.m[15] = 1, e._markAsUpdated(), this;\n      }, u.prototype.fromRotationMatrix = function (e) {\n        return u.FromRotationMatrixToRef(e, this), this;\n      }, u.FromRotationMatrix = function (e) {\n        var t = new u();\n        return u.FromRotationMatrixToRef(e, t), t;\n      }, u.FromRotationMatrixToRef = function (e, t) {\n        var i,\n            r = e.m,\n            n = r[0],\n            o = r[4],\n            s = r[8],\n            a = r[1],\n            l = r[5],\n            c = r[9],\n            h = r[2],\n            u = r[6],\n            d = r[10],\n            f = n + l + d;\n        0 < f ? (i = .5 / Math.sqrt(f + 1), t.w = .25 / i, t.x = (u - c) * i, t.y = (s - h) * i, t.z = (a - o) * i) : l < n && d < n ? (i = 2 * Math.sqrt(1 + n - l - d), t.w = (u - c) / i, t.x = .25 * i, t.y = (o + a) / i, t.z = (s + h) / i) : d < l ? (i = 2 * Math.sqrt(1 + l - n - d), t.w = (s - h) / i, t.x = (o + a) / i, t.y = .25 * i, t.z = (c + u) / i) : (i = 2 * Math.sqrt(1 + d - n - l), t.w = (a - o) / i, t.x = (s + h) / i, t.y = (c + u) / i, t.z = .25 * i);\n      }, u.Dot = function (e, t) {\n        return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;\n      }, u.AreClose = function (e, t) {\n        return 0 <= u.Dot(e, t);\n      }, u.Zero = function () {\n        return new u(0, 0, 0, 0);\n      }, u.Inverse = function (e) {\n        return new u(-e.x, -e.y, -e.z, e.w);\n      }, u.Identity = function () {\n        return new u(0, 0, 0, 1);\n      }, u.IsIdentity = function (e) {\n        return e && 0 === e.x && 0 === e.y && 0 === e.z && 1 === e.w;\n      }, u.RotationAxis = function (e, t) {\n        return u.RotationAxisToRef(e, t, new u());\n      }, u.RotationAxisToRef = function (e, t, i) {\n        var r = Math.sin(t / 2);\n        return e.normalize(), i.w = Math.cos(t / 2), i.x = e.x * r, i.y = e.y * r, i.z = e.z * r, i;\n      }, u.FromArray = function (e, t) {\n        return t || (t = 0), new u(e[t], e[t + 1], e[t + 2], e[t + 3]);\n      }, u.RotationYawPitchRoll = function (e, t, i) {\n        var r = new u();\n        return u.RotationYawPitchRollToRef(e, t, i, r), r;\n      }, u.RotationYawPitchRollToRef = function (e, t, i, r) {\n        var n = .5 * i,\n            o = .5 * t,\n            s = .5 * e,\n            a = Math.sin(n),\n            l = Math.cos(n),\n            c = Math.sin(o),\n            h = Math.cos(o),\n            u = Math.sin(s),\n            d = Math.cos(s);\n        r.x = d * c * l + u * h * a, r.y = u * h * l - d * c * a, r.z = d * h * a - u * c * l, r.w = d * h * l + u * c * a;\n      }, u.RotationAlphaBetaGamma = function (e, t, i) {\n        var r = new u();\n        return u.RotationAlphaBetaGammaToRef(e, t, i, r), r;\n      }, u.RotationAlphaBetaGammaToRef = function (e, t, i, r) {\n        var n = .5 * (i + e),\n            o = .5 * (i - e),\n            s = .5 * t;\n        r.x = Math.cos(o) * Math.sin(s), r.y = Math.sin(o) * Math.sin(s), r.z = Math.sin(n) * Math.cos(s), r.w = Math.cos(n) * Math.cos(s);\n      }, u.RotationQuaternionFromAxis = function (e, t, i) {\n        var r = new u(0, 0, 0, 0);\n        return u.RotationQuaternionFromAxisToRef(e, t, i, r), r;\n      }, u.RotationQuaternionFromAxisToRef = function (e, t, i, r) {\n        var n = A.Matrix[0];\n        h.FromXYZAxesToRef(e.normalize(), t.normalize(), i.normalize(), n), u.FromRotationMatrixToRef(n, r);\n      }, u.Slerp = function (e, t, i) {\n        var r = u.Identity();\n        return u.SlerpToRef(e, t, i, r), r;\n      }, u.SlerpToRef = function (e, t, i, r) {\n        var n,\n            o,\n            s = e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w,\n            a = !1;\n        if (s < 0 && (a = !0, s = -s), .999999 < s) o = 1 - i, n = a ? -i : i;else {\n          var l = Math.acos(s),\n              c = 1 / Math.sin(l);\n          o = Math.sin((1 - i) * l) * c, n = a ? -Math.sin(i * l) * c : Math.sin(i * l) * c;\n        }\n        r.x = o * e.x + n * t.x, r.y = o * e.y + n * t.y, r.z = o * e.z + n * t.z, r.w = o * e.w + n * t.w;\n      }, u.Hermite = function (e, t, i, r, n) {\n        var o = n * n,\n            s = n * o,\n            a = 2 * s - 3 * o + 1,\n            l = -2 * s + 3 * o,\n            c = s - 2 * o + n,\n            h = s - o;\n        return new u(e.x * a + i.x * l + t.x * c + r.x * h, e.y * a + i.y * l + t.y * c + r.y * h, e.z * a + i.z * l + t.z * c + r.z * h, e.w * a + i.w * l + t.w * c + r.w * h);\n      }, u;\n    }();\n\n    f.Quaternion = m;\n\n    var h = function () {\n      function g() {\n        this._isIdentity = !1, this._isIdentityDirty = !0, this.m = new Float32Array(16), this._markAsUpdated();\n      }\n\n      return g.prototype._markAsUpdated = function () {\n        this.updateFlag = g._updateFlagSeed++, this._isIdentityDirty = !0;\n      }, g.prototype.isIdentity = function (e) {\n        return void 0 === e && (e = !1), this._isIdentityDirty && (this._isIdentityDirty = !1, 1 !== this.m[0] || 1 !== this.m[5] || 1 !== this.m[15] ? this._isIdentity = !1 : 0 !== this.m[1] || 0 !== this.m[2] || 0 !== this.m[3] || 0 !== this.m[4] || 0 !== this.m[6] || 0 !== this.m[7] || 0 !== this.m[8] || 0 !== this.m[9] || 0 !== this.m[11] || 0 !== this.m[12] || 0 !== this.m[13] || 0 !== this.m[14] ? this._isIdentity = !1 : this._isIdentity = !0, e || 1 === this.m[10] || (this._isIdentity = !1)), this._isIdentity;\n      }, g.prototype.determinant = function () {\n        var e = this.m[10] * this.m[15] - this.m[11] * this.m[14],\n            t = this.m[9] * this.m[15] - this.m[11] * this.m[13],\n            i = this.m[9] * this.m[14] - this.m[10] * this.m[13],\n            r = this.m[8] * this.m[15] - this.m[11] * this.m[12],\n            n = this.m[8] * this.m[14] - this.m[10] * this.m[12],\n            o = this.m[8] * this.m[13] - this.m[9] * this.m[12];\n        return this.m[0] * (this.m[5] * e - this.m[6] * t + this.m[7] * i) - this.m[1] * (this.m[4] * e - this.m[6] * r + this.m[7] * n) + this.m[2] * (this.m[4] * t - this.m[5] * r + this.m[7] * o) - this.m[3] * (this.m[4] * i - this.m[5] * n + this.m[6] * o);\n      }, g.prototype.toArray = function () {\n        return this.m;\n      }, g.prototype.asArray = function () {\n        return this.toArray();\n      }, g.prototype.invert = function () {\n        return this.invertToRef(this), this;\n      }, g.prototype.reset = function () {\n        for (var e = 0; e < 16; e++) this.m[e] = 0;\n\n        return this._markAsUpdated(), this;\n      }, g.prototype.add = function (e) {\n        var t = new g();\n        return this.addToRef(e, t), t;\n      }, g.prototype.addToRef = function (e, t) {\n        for (var i = 0; i < 16; i++) t.m[i] = this.m[i] + e.m[i];\n\n        return t._markAsUpdated(), this;\n      }, g.prototype.addToSelf = function (e) {\n        for (var t = 0; t < 16; t++) this.m[t] += e.m[t];\n\n        return this._markAsUpdated(), this;\n      }, g.prototype.invertToRef = function (e) {\n        var t = this.m[0],\n            i = this.m[1],\n            r = this.m[2],\n            n = this.m[3],\n            o = this.m[4],\n            s = this.m[5],\n            a = this.m[6],\n            l = this.m[7],\n            c = this.m[8],\n            h = this.m[9],\n            u = this.m[10],\n            d = this.m[11],\n            f = this.m[12],\n            p = this.m[13],\n            _ = this.m[14],\n            m = this.m[15],\n            g = u * m - d * _,\n            v = h * m - d * p,\n            y = h * _ - u * p,\n            b = c * m - d * f,\n            T = c * _ - u * f,\n            E = c * p - h * f,\n            x = s * g - a * v + l * y,\n            P = -(o * g - a * b + l * T),\n            A = o * v - s * b + l * E,\n            S = -(o * y - s * T + a * E),\n            M = 1 / (t * x + i * P + r * A + n * S),\n            R = a * m - l * _,\n            C = s * m - l * p,\n            O = s * _ - a * p,\n            D = o * m - l * f,\n            I = o * _ - a * f,\n            w = o * p - s * f,\n            L = a * d - l * u,\n            F = s * d - l * h,\n            B = s * u - a * h,\n            N = o * d - l * c,\n            V = o * u - a * c,\n            U = o * h - s * c;\n        return e.m[0] = x * M, e.m[4] = P * M, e.m[8] = A * M, e.m[12] = S * M, e.m[1] = -(i * g - r * v + n * y) * M, e.m[5] = (t * g - r * b + n * T) * M, e.m[9] = -(t * v - i * b + n * E) * M, e.m[13] = (t * y - i * T + r * E) * M, e.m[2] = (i * R - r * C + n * O) * M, e.m[6] = -(t * R - r * D + n * I) * M, e.m[10] = (t * C - i * D + n * w) * M, e.m[14] = -(t * O - i * I + r * w) * M, e.m[3] = -(i * L - r * F + n * B) * M, e.m[7] = (t * L - r * N + n * V) * M, e.m[11] = -(t * F - i * N + n * U) * M, e.m[15] = (t * B - i * V + r * U) * M, e._markAsUpdated(), this;\n      }, g.prototype.setTranslationFromFloats = function (e, t, i) {\n        return this.m[12] = e, this.m[13] = t, this.m[14] = i, this._markAsUpdated(), this;\n      }, g.prototype.setTranslation = function (e) {\n        return this.m[12] = e.x, this.m[13] = e.y, this.m[14] = e.z, this._markAsUpdated(), this;\n      }, g.prototype.getTranslation = function () {\n        return new _(this.m[12], this.m[13], this.m[14]);\n      }, g.prototype.getTranslationToRef = function (e) {\n        return e.x = this.m[12], e.y = this.m[13], e.z = this.m[14], this;\n      }, g.prototype.removeRotationAndScaling = function () {\n        return this.setRowFromFloats(0, 1, 0, 0, 0), this.setRowFromFloats(1, 0, 1, 0, 0), this.setRowFromFloats(2, 0, 0, 1, 0), this;\n      }, g.prototype.multiply = function (e) {\n        var t = new g();\n        return this.multiplyToRef(e, t), t;\n      }, g.prototype.copyFrom = function (e) {\n        for (var t = 0; t < 16; t++) this.m[t] = e.m[t];\n\n        return this._markAsUpdated(), this;\n      }, g.prototype.copyToArray = function (e, t) {\n        void 0 === t && (t = 0);\n\n        for (var i = 0; i < 16; i++) e[t + i] = this.m[i];\n\n        return this;\n      }, g.prototype.multiplyToRef = function (e, t) {\n        return this.multiplyToArray(e, t.m, 0), t._markAsUpdated(), this;\n      }, g.prototype.multiplyToArray = function (e, t, i) {\n        var r = this.m[0],\n            n = this.m[1],\n            o = this.m[2],\n            s = this.m[3],\n            a = this.m[4],\n            l = this.m[5],\n            c = this.m[6],\n            h = this.m[7],\n            u = this.m[8],\n            d = this.m[9],\n            f = this.m[10],\n            p = this.m[11],\n            _ = this.m[12],\n            m = this.m[13],\n            g = this.m[14],\n            v = this.m[15],\n            y = e.m[0],\n            b = e.m[1],\n            T = e.m[2],\n            E = e.m[3],\n            x = e.m[4],\n            P = e.m[5],\n            A = e.m[6],\n            S = e.m[7],\n            M = e.m[8],\n            R = e.m[9],\n            C = e.m[10],\n            O = e.m[11],\n            D = e.m[12],\n            I = e.m[13],\n            w = e.m[14],\n            L = e.m[15];\n        return t[i] = r * y + n * x + o * M + s * D, t[i + 1] = r * b + n * P + o * R + s * I, t[i + 2] = r * T + n * A + o * C + s * w, t[i + 3] = r * E + n * S + o * O + s * L, t[i + 4] = a * y + l * x + c * M + h * D, t[i + 5] = a * b + l * P + c * R + h * I, t[i + 6] = a * T + l * A + c * C + h * w, t[i + 7] = a * E + l * S + c * O + h * L, t[i + 8] = u * y + d * x + f * M + p * D, t[i + 9] = u * b + d * P + f * R + p * I, t[i + 10] = u * T + d * A + f * C + p * w, t[i + 11] = u * E + d * S + f * O + p * L, t[i + 12] = _ * y + m * x + g * M + v * D, t[i + 13] = _ * b + m * P + g * R + v * I, t[i + 14] = _ * T + m * A + g * C + v * w, t[i + 15] = _ * E + m * S + g * O + v * L, this;\n      }, g.prototype.equals = function (e) {\n        return e && this.m[0] === e.m[0] && this.m[1] === e.m[1] && this.m[2] === e.m[2] && this.m[3] === e.m[3] && this.m[4] === e.m[4] && this.m[5] === e.m[5] && this.m[6] === e.m[6] && this.m[7] === e.m[7] && this.m[8] === e.m[8] && this.m[9] === e.m[9] && this.m[10] === e.m[10] && this.m[11] === e.m[11] && this.m[12] === e.m[12] && this.m[13] === e.m[13] && this.m[14] === e.m[14] && this.m[15] === e.m[15];\n      }, g.prototype.clone = function () {\n        return g.FromValues(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5], this.m[6], this.m[7], this.m[8], this.m[9], this.m[10], this.m[11], this.m[12], this.m[13], this.m[14], this.m[15]);\n      }, g.prototype.getClassName = function () {\n        return \"Matrix\";\n      }, g.prototype.getHashCode = function () {\n        for (var e = this.m[0] || 0, t = 1; t < 16; t++) e = 397 * e ^ (this.m[t] || 0);\n\n        return e;\n      }, g.prototype.decompose = function (e, t, i) {\n        return i && (i.x = this.m[12], i.y = this.m[13], i.z = this.m[14]), (e = e || A.Vector3[0]).x = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1] + this.m[2] * this.m[2]), e.y = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5] + this.m[6] * this.m[6]), e.z = Math.sqrt(this.m[8] * this.m[8] + this.m[9] * this.m[9] + this.m[10] * this.m[10]), this.determinant() <= 0 && (e.y *= -1), 0 === e.x || 0 === e.y || 0 === e.z ? (t && (t.x = 0, t.y = 0, t.z = 0, t.w = 1), !1) : (t && (g.FromValuesToRef(this.m[0] / e.x, this.m[1] / e.x, this.m[2] / e.x, 0, this.m[4] / e.y, this.m[5] / e.y, this.m[6] / e.y, 0, this.m[8] / e.z, this.m[9] / e.z, this.m[10] / e.z, 0, 0, 0, 0, 1, A.Matrix[0]), m.FromRotationMatrixToRef(A.Matrix[0], t)), !0);\n      }, g.prototype.getRow = function (e) {\n        if (e < 0 || 3 < e) return null;\n        var t = 4 * e;\n        return new r(this.m[t + 0], this.m[t + 1], this.m[t + 2], this.m[t + 3]);\n      }, g.prototype.setRow = function (e, t) {\n        if (e < 0 || 3 < e) return this;\n        var i = 4 * e;\n        return this.m[i + 0] = t.x, this.m[i + 1] = t.y, this.m[i + 2] = t.z, this.m[i + 3] = t.w, this._markAsUpdated(), this;\n      }, g.prototype.transpose = function () {\n        return g.Transpose(this);\n      }, g.prototype.transposeToRef = function (e) {\n        return g.TransposeToRef(this, e), this;\n      }, g.prototype.setRowFromFloats = function (e, t, i, r, n) {\n        if (e < 0 || 3 < e) return this;\n        var o = 4 * e;\n        return this.m[o + 0] = t, this.m[o + 1] = i, this.m[o + 2] = r, this.m[o + 3] = n, this._markAsUpdated(), this;\n      }, g.prototype.scale = function (e) {\n        var t = new g();\n        return this.scaleToRef(e, t), t;\n      }, g.prototype.scaleToRef = function (e, t) {\n        for (var i = 0; i < 16; i++) t.m[i] = this.m[i] * e;\n\n        return t._markAsUpdated(), this;\n      }, g.prototype.scaleAndAddToRef = function (e, t) {\n        for (var i = 0; i < 16; i++) t.m[i] += this.m[i] * e;\n\n        return t._markAsUpdated(), this;\n      }, g.prototype.toNormalMatrix = function (e) {\n        this.invertToRef(e), e.transpose();\n        var t = e.m;\n        g.FromValuesToRef(t[0], t[1], t[2], 0, t[4], t[5], t[6], 0, t[8], t[9], t[10], 0, 0, 0, 0, 1, e);\n      }, g.prototype.getRotationMatrix = function () {\n        var e = g.Identity();\n        return this.getRotationMatrixToRef(e), e;\n      }, g.prototype.getRotationMatrixToRef = function (e) {\n        var t = this.m,\n            i = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),\n            r = Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),\n            n = Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);\n        return this.determinant() <= 0 && (r *= -1), 0 === i || 0 === r || 0 === n ? g.IdentityToRef(e) : g.FromValuesToRef(t[0] / i, t[1] / i, t[2] / i, 0, t[4] / r, t[5] / r, t[6] / r, 0, t[8] / n, t[9] / n, t[10] / n, 0, 0, 0, 0, 1, e), this;\n      }, g.FromArray = function (e, t) {\n        var i = new g();\n        return t || (t = 0), g.FromArrayToRef(e, t, i), i;\n      }, g.FromArrayToRef = function (e, t, i) {\n        for (var r = 0; r < 16; r++) i.m[r] = e[r + t];\n\n        i._markAsUpdated();\n      }, g.FromFloat32ArrayToRefScaled = function (e, t, i, r) {\n        for (var n = 0; n < 16; n++) r.m[n] = e[n + t] * i;\n\n        r._markAsUpdated();\n      }, g.FromValuesToRef = function (e, t, i, r, n, o, s, a, l, c, h, u, d, f, p, _, m) {\n        m.m[0] = e, m.m[1] = t, m.m[2] = i, m.m[3] = r, m.m[4] = n, m.m[5] = o, m.m[6] = s, m.m[7] = a, m.m[8] = l, m.m[9] = c, m.m[10] = h, m.m[11] = u, m.m[12] = d, m.m[13] = f, m.m[14] = p, m.m[15] = _, m._markAsUpdated();\n      }, Object.defineProperty(g, \"IdentityReadOnly\", {\n        get: function () {\n          return g._identityReadOnly;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), g.FromValues = function (e, t, i, r, n, o, s, a, l, c, h, u, d, f, p, _) {\n        var m = new g();\n        return m.m[0] = e, m.m[1] = t, m.m[2] = i, m.m[3] = r, m.m[4] = n, m.m[5] = o, m.m[6] = s, m.m[7] = a, m.m[8] = l, m.m[9] = c, m.m[10] = h, m.m[11] = u, m.m[12] = d, m.m[13] = f, m.m[14] = p, m.m[15] = _, m;\n      }, g.Compose = function (e, t, i) {\n        var r = g.Identity();\n        return g.ComposeToRef(e, t, i, r), r;\n      }, g.ComposeToRef = function (e, t, i, r) {\n        g.FromValuesToRef(e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, e.z, 0, 0, 0, 0, 1, A.Matrix[1]), t.toRotationMatrix(A.Matrix[0]), A.Matrix[1].multiplyToRef(A.Matrix[0], r), r.setTranslation(i);\n      }, g.Identity = function () {\n        return g.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      }, g.IdentityToRef = function (e) {\n        g.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, e);\n      }, g.Zero = function () {\n        return g.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      }, g.RotationX = function (e) {\n        var t = new g();\n        return g.RotationXToRef(e, t), t;\n      }, g.Invert = function (e) {\n        var t = new g();\n        return e.invertToRef(t), t;\n      }, g.RotationXToRef = function (e, t) {\n        var i = Math.sin(e),\n            r = Math.cos(e);\n        t.m[0] = 1, t.m[15] = 1, t.m[5] = r, t.m[10] = r, t.m[9] = -i, t.m[6] = i, t.m[1] = 0, t.m[2] = 0, t.m[3] = 0, t.m[4] = 0, t.m[7] = 0, t.m[8] = 0, t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0, t._markAsUpdated();\n      }, g.RotationY = function (e) {\n        var t = new g();\n        return g.RotationYToRef(e, t), t;\n      }, g.RotationYToRef = function (e, t) {\n        var i = Math.sin(e),\n            r = Math.cos(e);\n        t.m[5] = 1, t.m[15] = 1, t.m[0] = r, t.m[2] = -i, t.m[8] = i, t.m[10] = r, t.m[1] = 0, t.m[3] = 0, t.m[4] = 0, t.m[6] = 0, t.m[7] = 0, t.m[9] = 0, t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0, t._markAsUpdated();\n      }, g.RotationZ = function (e) {\n        var t = new g();\n        return g.RotationZToRef(e, t), t;\n      }, g.RotationZToRef = function (e, t) {\n        var i = Math.sin(e),\n            r = Math.cos(e);\n        t.m[10] = 1, t.m[15] = 1, t.m[0] = r, t.m[1] = i, t.m[4] = -i, t.m[5] = r, t.m[2] = 0, t.m[3] = 0, t.m[6] = 0, t.m[7] = 0, t.m[8] = 0, t.m[9] = 0, t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0, t._markAsUpdated();\n      }, g.RotationAxis = function (e, t) {\n        var i = g.Zero();\n        return g.RotationAxisToRef(e, t, i), i;\n      }, g.RotationAxisToRef = function (e, t, i) {\n        var r = Math.sin(-t),\n            n = Math.cos(-t),\n            o = 1 - n;\n        e.normalize(), i.m[0] = e.x * e.x * o + n, i.m[1] = e.x * e.y * o - e.z * r, i.m[2] = e.x * e.z * o + e.y * r, i.m[3] = 0, i.m[4] = e.y * e.x * o + e.z * r, i.m[5] = e.y * e.y * o + n, i.m[6] = e.y * e.z * o - e.x * r, i.m[7] = 0, i.m[8] = e.z * e.x * o - e.y * r, i.m[9] = e.z * e.y * o + e.x * r, i.m[10] = e.z * e.z * o + n, i.m[11] = 0, i.m[15] = 1, i._markAsUpdated();\n      }, g.RotationYawPitchRoll = function (e, t, i) {\n        var r = new g();\n        return g.RotationYawPitchRollToRef(e, t, i, r), r;\n      }, g.RotationYawPitchRollToRef = function (e, t, i, r) {\n        m.RotationYawPitchRollToRef(e, t, i, this._tempQuaternion), this._tempQuaternion.toRotationMatrix(r);\n      }, g.Scaling = function (e, t, i) {\n        var r = g.Zero();\n        return g.ScalingToRef(e, t, i, r), r;\n      }, g.ScalingToRef = function (e, t, i, r) {\n        r.m[0] = e, r.m[1] = 0, r.m[2] = 0, r.m[3] = 0, r.m[4] = 0, r.m[5] = t, r.m[6] = 0, r.m[7] = 0, r.m[8] = 0, r.m[9] = 0, r.m[10] = i, r.m[11] = 0, r.m[12] = 0, r.m[13] = 0, r.m[14] = 0, r.m[15] = 1, r._markAsUpdated();\n      }, g.Translation = function (e, t, i) {\n        var r = g.Identity();\n        return g.TranslationToRef(e, t, i, r), r;\n      }, g.TranslationToRef = function (e, t, i, r) {\n        g.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1, r);\n      }, g.Lerp = function (e, t, i) {\n        var r = g.Zero();\n        return g.LerpToRef(e, t, i, r), r;\n      }, g.LerpToRef = function (e, t, i, r) {\n        for (var n = 0; n < 16; n++) r.m[n] = e.m[n] * (1 - i) + t.m[n] * i;\n\n        r._markAsUpdated();\n      }, g.DecomposeLerp = function (e, t, i) {\n        var r = g.Zero();\n        return g.DecomposeLerpToRef(e, t, i, r), r;\n      }, g.DecomposeLerpToRef = function (e, t, i, r) {\n        var n = A.Vector3[0],\n            o = A.Quaternion[0],\n            s = A.Vector3[1];\n        e.decompose(n, o, s);\n        var a = A.Vector3[2],\n            l = A.Quaternion[1],\n            c = A.Vector3[3];\n        t.decompose(a, l, c);\n        var h = A.Vector3[4];\n\n        _.LerpToRef(n, a, i, h);\n\n        var u = A.Quaternion[2];\n        m.SlerpToRef(o, l, i, u);\n        var d = A.Vector3[5];\n        _.LerpToRef(s, c, i, d), g.ComposeToRef(h, u, d, r);\n      }, g.LookAtLH = function (e, t, i) {\n        var r = g.Zero();\n        return g.LookAtLHToRef(e, t, i, r), r;\n      }, g.LookAtLHToRef = function (e, t, i, r) {\n        t.subtractToRef(e, this._zAxis), this._zAxis.normalize(), _.CrossToRef(i, this._zAxis, this._xAxis), 0 === this._xAxis.lengthSquared() ? this._xAxis.x = 1 : this._xAxis.normalize(), _.CrossToRef(this._zAxis, this._xAxis, this._yAxis), this._yAxis.normalize();\n        var n = -_.Dot(this._xAxis, e),\n            o = -_.Dot(this._yAxis, e),\n            s = -_.Dot(this._zAxis, e);\n        return g.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, n, o, s, 1, r);\n      }, g.LookAtRH = function (e, t, i) {\n        var r = g.Zero();\n        return g.LookAtRHToRef(e, t, i, r), r;\n      }, g.LookAtRHToRef = function (e, t, i, r) {\n        e.subtractToRef(t, this._zAxis), this._zAxis.normalize(), _.CrossToRef(i, this._zAxis, this._xAxis), 0 === this._xAxis.lengthSquared() ? this._xAxis.x = 1 : this._xAxis.normalize(), _.CrossToRef(this._zAxis, this._xAxis, this._yAxis), this._yAxis.normalize();\n        var n = -_.Dot(this._xAxis, e),\n            o = -_.Dot(this._yAxis, e),\n            s = -_.Dot(this._zAxis, e);\n        return g.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, n, o, s, 1, r);\n      }, g.OrthoLH = function (e, t, i, r) {\n        var n = g.Zero();\n        return g.OrthoLHToRef(e, t, i, r, n), n;\n      }, g.OrthoLHToRef = function (e, t, i, r, n) {\n        g.FromValuesToRef(2 / e, 0, 0, 0, 0, 2 / t, 0, 0, 0, 0, 2 / (r - i), 0, 0, 0, -(r + i) / (r - i), 1, n);\n      }, g.OrthoOffCenterLH = function (e, t, i, r, n, o) {\n        var s = g.Zero();\n        return g.OrthoOffCenterLHToRef(e, t, i, r, n, o, s), s;\n      }, g.OrthoOffCenterLHToRef = function (e, t, i, r, n, o, s) {\n        g.FromValuesToRef(2 / (t - e), 0, 0, 0, 0, 2 / (r - i), 0, 0, 0, 0, 2 / (o - n), 0, (e + t) / (e - t), (r + i) / (i - r), -(o + n) / (o - n), 1, s);\n      }, g.OrthoOffCenterRH = function (e, t, i, r, n, o) {\n        var s = g.Zero();\n        return g.OrthoOffCenterRHToRef(e, t, i, r, n, o, s), s;\n      }, g.OrthoOffCenterRHToRef = function (e, t, i, r, n, o, s) {\n        g.OrthoOffCenterLHToRef(e, t, i, r, n, o, s), s.m[10] *= -1;\n      }, g.PerspectiveLH = function (e, t, i, r) {\n        var n = g.Zero();\n        return g.FromValuesToRef(2 * i / e, 0, 0, 0, 0, 2 * i / t, 0, 0, 0, 0, (r + i) / (r - i), 1, 0, 0, -2 * r * i / (r - i), 0, n), n;\n      }, g.PerspectiveFovLH = function (e, t, i, r) {\n        var n = g.Zero();\n        return g.PerspectiveFovLHToRef(e, t, i, r, n), n;\n      }, g.PerspectiveFovLHToRef = function (e, t, i, r, n, o) {\n        void 0 === o && (o = !0);\n        var s = i,\n            a = r,\n            l = 1 / Math.tan(.5 * e);\n        g.FromValuesToRef(o ? l / t : l, 0, 0, 0, 0, o ? l : l * t, 0, 0, 0, 0, (a + s) / (a - s), 1, 0, 0, -2 * a * s / (a - s), 0, n);\n      }, g.PerspectiveFovRH = function (e, t, i, r) {\n        var n = g.Zero();\n        return g.PerspectiveFovRHToRef(e, t, i, r, n), n;\n      }, g.PerspectiveFovRHToRef = function (e, t, i, r, n, o) {\n        void 0 === o && (o = !0);\n        var s = i,\n            a = r,\n            l = 1 / Math.tan(.5 * e);\n        g.FromValuesToRef(o ? l / t : l, 0, 0, 0, 0, o ? l : l * t, 0, 0, 0, 0, -(a + s) / (a - s), -1, 0, 0, -2 * a * s / (a - s), 0, n);\n      }, g.PerspectiveFovWebVRToRef = function (e, t, i, r, n) {\n        void 0 === n && (n = !1);\n        var o = n ? -1 : 1,\n            s = Math.tan(e.upDegrees * Math.PI / 180),\n            a = Math.tan(e.downDegrees * Math.PI / 180),\n            l = Math.tan(e.leftDegrees * Math.PI / 180),\n            c = Math.tan(e.rightDegrees * Math.PI / 180),\n            h = 2 / (l + c),\n            u = 2 / (s + a);\n        r.m[0] = h, r.m[1] = r.m[2] = r.m[3] = r.m[4] = 0, r.m[5] = u, r.m[6] = r.m[7] = 0, r.m[8] = (l - c) * h * .5, r.m[9] = -(s - a) * u * .5, r.m[10] = -i / (t - i), r.m[11] = 1 * o, r.m[12] = r.m[13] = r.m[15] = 0, r.m[14] = -2 * i * t / (i - t), r._markAsUpdated();\n      }, g.GetFinalMatrix = function (e, t, i, r, n, o) {\n        var s = e.width,\n            a = e.height,\n            l = e.x,\n            c = e.y,\n            h = g.FromValues(s / 2, 0, 0, 0, 0, -a / 2, 0, 0, 0, 0, o - n, 0, l + s / 2, a / 2 + c, n, 1);\n        return t.multiply(i).multiply(r).multiply(h);\n      }, g.GetAsMatrix2x2 = function (e) {\n        return new Float32Array([e.m[0], e.m[1], e.m[4], e.m[5]]);\n      }, g.GetAsMatrix3x3 = function (e) {\n        return new Float32Array([e.m[0], e.m[1], e.m[2], e.m[4], e.m[5], e.m[6], e.m[8], e.m[9], e.m[10]]);\n      }, g.Transpose = function (e) {\n        var t = new g();\n        return g.TransposeToRef(e, t), t;\n      }, g.TransposeToRef = function (e, t) {\n        t.m[0] = e.m[0], t.m[1] = e.m[4], t.m[2] = e.m[8], t.m[3] = e.m[12], t.m[4] = e.m[1], t.m[5] = e.m[5], t.m[6] = e.m[9], t.m[7] = e.m[13], t.m[8] = e.m[2], t.m[9] = e.m[6], t.m[10] = e.m[10], t.m[11] = e.m[14], t.m[12] = e.m[3], t.m[13] = e.m[7], t.m[14] = e.m[11], t.m[15] = e.m[15];\n      }, g.Reflection = function (e) {\n        var t = new g();\n        return g.ReflectionToRef(e, t), t;\n      }, g.ReflectionToRef = function (e, t) {\n        e.normalize();\n        var i = e.normal.x,\n            r = e.normal.y,\n            n = e.normal.z,\n            o = -2 * i,\n            s = -2 * r,\n            a = -2 * n;\n        t.m[0] = o * i + 1, t.m[1] = s * i, t.m[2] = a * i, t.m[3] = 0, t.m[4] = o * r, t.m[5] = s * r + 1, t.m[6] = a * r, t.m[7] = 0, t.m[8] = o * n, t.m[9] = s * n, t.m[10] = a * n + 1, t.m[11] = 0, t.m[12] = o * e.d, t.m[13] = s * e.d, t.m[14] = a * e.d, t.m[15] = 1, t._markAsUpdated();\n      }, g.FromXYZAxesToRef = function (e, t, i, r) {\n        r.m[0] = e.x, r.m[1] = e.y, r.m[2] = e.z, r.m[3] = 0, r.m[4] = t.x, r.m[5] = t.y, r.m[6] = t.z, r.m[7] = 0, r.m[8] = i.x, r.m[9] = i.y, r.m[10] = i.z, r.m[11] = 0, r.m[12] = 0, r.m[13] = 0, r.m[14] = 0, r.m[15] = 1, r._markAsUpdated();\n      }, g.FromQuaternionToRef = function (e, t) {\n        var i = e.x * e.x,\n            r = e.y * e.y,\n            n = e.z * e.z,\n            o = e.x * e.y,\n            s = e.z * e.w,\n            a = e.z * e.x,\n            l = e.y * e.w,\n            c = e.y * e.z,\n            h = e.x * e.w;\n        t.m[0] = 1 - 2 * (r + n), t.m[1] = 2 * (o + s), t.m[2] = 2 * (a - l), t.m[3] = 0, t.m[4] = 2 * (o - s), t.m[5] = 1 - 2 * (n + i), t.m[6] = 2 * (c + h), t.m[7] = 0, t.m[8] = 2 * (a + l), t.m[9] = 2 * (c - h), t.m[10] = 1 - 2 * (r + i), t.m[11] = 0, t.m[12] = 0, t.m[13] = 0, t.m[14] = 0, t.m[15] = 1, t._markAsUpdated();\n      }, g._tempQuaternion = new m(), g._xAxis = _.Zero(), g._yAxis = _.Zero(), g._zAxis = _.Zero(), g._updateFlagSeed = 0, g._identityReadOnly = g.Identity(), g;\n    }();\n\n    f.Matrix = h;\n\n    var n = function () {\n      function s(e, t, i, r) {\n        this.normal = new _(e, t, i), this.d = r;\n      }\n\n      return s.prototype.asArray = function () {\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\n      }, s.prototype.clone = function () {\n        return new s(this.normal.x, this.normal.y, this.normal.z, this.d);\n      }, s.prototype.getClassName = function () {\n        return \"Plane\";\n      }, s.prototype.getHashCode = function () {\n        var e = this.normal.getHashCode();\n        return e = 397 * e ^ (this.d || 0);\n      }, s.prototype.normalize = function () {\n        var e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z),\n            t = 0;\n        return 0 !== e && (t = 1 / e), this.normal.x *= t, this.normal.y *= t, this.normal.z *= t, this.d *= t, this;\n      }, s.prototype.transform = function (e) {\n        var t = h.Transpose(e),\n            i = this.normal.x,\n            r = this.normal.y,\n            n = this.normal.z,\n            o = this.d;\n        return new s(i * t.m[0] + r * t.m[1] + n * t.m[2] + o * t.m[3], i * t.m[4] + r * t.m[5] + n * t.m[6] + o * t.m[7], i * t.m[8] + r * t.m[9] + n * t.m[10] + o * t.m[11], i * t.m[12] + r * t.m[13] + n * t.m[14] + o * t.m[15]);\n      }, s.prototype.dotCoordinate = function (e) {\n        return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d;\n      }, s.prototype.copyFromPoints = function (e, t, i) {\n        var r,\n            n = t.x - e.x,\n            o = t.y - e.y,\n            s = t.z - e.z,\n            a = i.x - e.x,\n            l = i.y - e.y,\n            c = i.z - e.z,\n            h = o * c - s * l,\n            u = s * a - n * c,\n            d = n * l - o * a,\n            f = Math.sqrt(h * h + u * u + d * d);\n        return r = 0 !== f ? 1 / f : 0, this.normal.x = h * r, this.normal.y = u * r, this.normal.z = d * r, this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z), this;\n      }, s.prototype.isFrontFacingTo = function (e, t) {\n        return _.Dot(this.normal, e) <= t;\n      }, s.prototype.signedDistanceTo = function (e) {\n        return _.Dot(e, this.normal) + this.d;\n      }, s.FromArray = function (e) {\n        return new s(e[0], e[1], e[2], e[3]);\n      }, s.FromPoints = function (e, t, i) {\n        var r = new s(0, 0, 0, 0);\n        return r.copyFromPoints(e, t, i), r;\n      }, s.FromPositionAndNormal = function (e, t) {\n        var i = new s(0, 0, 0, 0);\n        return t.normalize(), i.normal = t, i.d = -(t.x * e.x + t.y * e.y + t.z * e.z), i;\n      }, s.SignedDistanceToPlaneFromPositionAndNormal = function (e, t, i) {\n        var r = -(t.x * e.x + t.y * e.y + t.z * e.z);\n        return _.Dot(i, t) + r;\n      }, s;\n    }();\n\n    f.Plane = n;\n\n    var o = function () {\n      function n(e, t, i, r) {\n        this.x = e, this.y = t, this.width = i, this.height = r;\n      }\n\n      return n.prototype.toGlobal = function (e, t) {\n        if (e.getRenderWidth) {\n          var i = e;\n          return this.toGlobal(i.getRenderWidth(), i.getRenderHeight());\n        }\n\n        var r = e;\n        return new n(this.x * r, this.y * t, this.width * r, this.height * t);\n      }, n.prototype.clone = function () {\n        return new n(this.x, this.y, this.width, this.height);\n      }, n;\n    }();\n\n    f.Viewport = o;\n\n    var s,\n        a = function () {\n      function r() {}\n\n      return r.GetPlanes = function (e) {\n        for (var t = [], i = 0; i < 6; i++) t.push(new n(0, 0, 0, 0));\n\n        return r.GetPlanesToRef(e, t), t;\n      }, r.GetNearPlaneToRef = function (e, t) {\n        t.normal.x = e.m[3] + e.m[2], t.normal.y = e.m[7] + e.m[6], t.normal.z = e.m[11] + e.m[10], t.d = e.m[15] + e.m[14], t.normalize();\n      }, r.GetFarPlaneToRef = function (e, t) {\n        t.normal.x = e.m[3] - e.m[2], t.normal.y = e.m[7] - e.m[6], t.normal.z = e.m[11] - e.m[10], t.d = e.m[15] - e.m[14], t.normalize();\n      }, r.GetLeftPlaneToRef = function (e, t) {\n        t.normal.x = e.m[3] + e.m[0], t.normal.y = e.m[7] + e.m[4], t.normal.z = e.m[11] + e.m[8], t.d = e.m[15] + e.m[12], t.normalize();\n      }, r.GetRightPlaneToRef = function (e, t) {\n        t.normal.x = e.m[3] - e.m[0], t.normal.y = e.m[7] - e.m[4], t.normal.z = e.m[11] - e.m[8], t.d = e.m[15] - e.m[12], t.normalize();\n      }, r.GetTopPlaneToRef = function (e, t) {\n        t.normal.x = e.m[3] - e.m[1], t.normal.y = e.m[7] - e.m[5], t.normal.z = e.m[11] - e.m[9], t.d = e.m[15] - e.m[13], t.normalize();\n      }, r.GetBottomPlaneToRef = function (e, t) {\n        t.normal.x = e.m[3] + e.m[1], t.normal.y = e.m[7] + e.m[5], t.normal.z = e.m[11] + e.m[9], t.d = e.m[15] + e.m[13], t.normalize();\n      }, r.GetPlanesToRef = function (e, t) {\n        r.GetNearPlaneToRef(e, t[0]), r.GetFarPlaneToRef(e, t[1]), r.GetLeftPlaneToRef(e, t[2]), r.GetRightPlaneToRef(e, t[3]), r.GetTopPlaneToRef(e, t[4]), r.GetBottomPlaneToRef(e, t[5]);\n      }, r;\n    }();\n\n    f.Frustum = a, (s = f.Space || (f.Space = {}))[s.LOCAL = 0] = \"LOCAL\", s[s.WORLD = 1] = \"WORLD\", s[s.BONE = 2] = \"BONE\";\n\n    var l = function () {\n      function e() {}\n\n      return e.X = new _(1, 0, 0), e.Y = new _(0, 1, 0), e.Z = new _(0, 0, 1), e;\n    }();\n\n    f.Axis = l;\n\n    var g,\n        c,\n        u = function () {\n      function e() {}\n\n      return e.Interpolate = function (e, t, i, r, n) {\n        for (var o = 1 - 3 * r + 3 * t, s = 3 * r - 6 * t, a = 3 * t, l = e, c = 0; c < 5; c++) {\n          var h = l * l;\n          l -= (o * (h * l) + s * h + a * l - e) * (1 / (3 * o * h + 2 * s * l + a)), l = Math.min(1, Math.max(0, l));\n        }\n\n        return 3 * Math.pow(1 - l, 2) * l * i + 3 * (1 - l) * Math.pow(l, 2) * n + Math.pow(l, 3);\n      }, e;\n    }();\n\n    f.BezierCurve = u, (c = g = f.Orientation || (f.Orientation = {}))[c.CW = 0] = \"CW\", c[c.CCW = 1] = \"CCW\";\n\n    var d = function () {\n      function r(e) {\n        this._radians = e, this._radians < 0 && (this._radians += 2 * Math.PI);\n      }\n\n      return r.prototype.degrees = function () {\n        return 180 * this._radians / Math.PI;\n      }, r.prototype.radians = function () {\n        return this._radians;\n      }, r.BetweenTwoPoints = function (e, t) {\n        var i = t.subtract(e);\n        return new r(Math.atan2(i.y, i.x));\n      }, r.FromRadians = function (e) {\n        return new r(e);\n      }, r.FromDegrees = function (e) {\n        return new r(e * Math.PI / 180);\n      }, r;\n    }();\n\n    f.Angle = d;\n\n    var v = function (e, t, i) {\n      this.startPoint = e, this.midPoint = t, this.endPoint = i;\n      var r = Math.pow(t.x, 2) + Math.pow(t.y, 2),\n          n = (Math.pow(e.x, 2) + Math.pow(e.y, 2) - r) / 2,\n          o = (r - Math.pow(i.x, 2) - Math.pow(i.y, 2)) / 2,\n          s = (e.x - t.x) * (t.y - i.y) - (t.x - i.x) * (e.y - t.y);\n      this.centerPoint = new p((n * (t.y - i.y) - o * (e.y - t.y)) / s, ((e.x - t.x) * o - (t.x - i.x) * n) / s), this.radius = this.centerPoint.subtract(this.startPoint).length(), this.startAngle = d.BetweenTwoPoints(this.centerPoint, this.startPoint);\n      var a = this.startAngle.degrees(),\n          l = d.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees(),\n          c = d.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n      180 < l - a && (l -= 360), l - a < -180 && (l += 360), 180 < c - l && (c -= 360), c - l < -180 && (c += 360), this.orientation = l - a < 0 ? g.CW : g.CCW, this.angle = d.FromDegrees(this.orientation === g.CW ? a - c : c - a);\n    };\n\n    f.Arc2 = v;\n\n    var y = function () {\n      function i(e, t) {\n        this._points = new Array(), this._length = 0, this.closed = !1, this._points.push(new p(e, t));\n      }\n\n      return i.prototype.addLineTo = function (e, t) {\n        if (this.closed) return this;\n        var i = new p(e, t),\n            r = this._points[this._points.length - 1];\n        return this._points.push(i), this._length += i.subtract(r).length(), this;\n      }, i.prototype.addArcTo = function (e, t, i, r, n) {\n        if (void 0 === n && (n = 36), this.closed) return this;\n        var o = this._points[this._points.length - 1],\n            s = new p(e, t),\n            a = new p(i, r),\n            l = new v(o, s, a),\n            c = l.angle.radians() / n;\n        l.orientation === g.CW && (c *= -1);\n\n        for (var h = l.startAngle.radians() + c, u = 0; u < n; u++) {\n          var d = Math.cos(h) * l.radius + l.centerPoint.x,\n              f = Math.sin(h) * l.radius + l.centerPoint.y;\n          this.addLineTo(d, f), h += c;\n        }\n\n        return this;\n      }, i.prototype.close = function () {\n        return this.closed = !0, this;\n      }, i.prototype.length = function () {\n        var e = this._length;\n\n        if (!this.closed) {\n          var t = this._points[this._points.length - 1];\n          e += this._points[0].subtract(t).length();\n        }\n\n        return e;\n      }, i.prototype.getPoints = function () {\n        return this._points;\n      }, i.prototype.getPointAtLengthPosition = function (e) {\n        if (e < 0 || 1 < e) return p.Zero();\n\n        for (var t = e * this.length(), i = 0, r = 0; r < this._points.length; r++) {\n          var n = (r + 1) % this._points.length,\n              o = this._points[r],\n              s = this._points[n].subtract(o),\n              a = s.length() + i;\n\n          if (i <= t && t <= a) {\n            var l = s.normalize(),\n                c = t - i;\n            return new p(o.x + l.x * c, o.y + l.y * c);\n          }\n\n          i = a;\n        }\n\n        return p.Zero();\n      }, i.StartingAt = function (e, t) {\n        return new i(e, t);\n      }, i;\n    }();\n\n    f.Path2 = y;\n\n    var b = function () {\n      function e(e, t, i) {\n        void 0 === t && (t = null), this.path = e, this._curve = new Array(), this._distances = new Array(), this._tangents = new Array(), this._normals = new Array(), this._binormals = new Array();\n\n        for (var r = 0; r < e.length; r++) this._curve[r] = e[r].clone();\n\n        this._raw = i || !1, this._compute(t);\n      }\n\n      return e.prototype.getCurve = function () {\n        return this._curve;\n      }, e.prototype.getTangents = function () {\n        return this._tangents;\n      }, e.prototype.getNormals = function () {\n        return this._normals;\n      }, e.prototype.getBinormals = function () {\n        return this._binormals;\n      }, e.prototype.getDistances = function () {\n        return this._distances;\n      }, e.prototype.update = function (e, t) {\n        void 0 === t && (t = null);\n\n        for (var i = 0; i < e.length; i++) this._curve[i].x = e[i].x, this._curve[i].y = e[i].y, this._curve[i].z = e[i].z;\n\n        return this._compute(t), this;\n      }, e.prototype._compute = function (e) {\n        var t = this._curve.length;\n        this._tangents[0] = this._getFirstNonNullVector(0), this._raw || this._tangents[0].normalize(), this._tangents[t - 1] = this._curve[t - 1].subtract(this._curve[t - 2]), this._raw || this._tangents[t - 1].normalize();\n\n        var i,\n            r,\n            n,\n            o,\n            s = this._tangents[0],\n            a = this._normalVector(this._curve[0], s, e);\n\n        this._normals[0] = a, this._raw || this._normals[0].normalize(), this._binormals[0] = _.Cross(s, this._normals[0]), this._raw || this._binormals[0].normalize(), this._distances[0] = 0;\n\n        for (var l = 1; l < t; l++) i = this._getLastNonNullVector(l), l < t - 1 && (r = this._getFirstNonNullVector(l), this._tangents[l] = i.add(r), this._tangents[l].normalize()), this._distances[l] = this._distances[l - 1] + i.length(), n = this._tangents[l], o = this._binormals[l - 1], this._normals[l] = _.Cross(o, n), this._raw || this._normals[l].normalize(), this._binormals[l] = _.Cross(n, this._normals[l]), this._raw || this._binormals[l].normalize();\n      }, e.prototype._getFirstNonNullVector = function (e) {\n        for (var t = 1, i = this._curve[e + t].subtract(this._curve[e]); 0 === i.length() && e + t + 1 < this._curve.length;) t++, i = this._curve[e + t].subtract(this._curve[e]);\n\n        return i;\n      }, e.prototype._getLastNonNullVector = function (e) {\n        for (var t = 1, i = this._curve[e].subtract(this._curve[e - t]); 0 === i.length() && t + 1 < e;) t++, i = this._curve[e].subtract(this._curve[e - t]);\n\n        return i;\n      }, e.prototype._normalVector = function (e, t, i) {\n        var r,\n            n,\n            o = t.length();\n        (0 === o && (o = 1), null == i) ? (n = f.Scalar.WithinEpsilon(Math.abs(t.y) / o, 1, f.Epsilon) ? f.Scalar.WithinEpsilon(Math.abs(t.x) / o, 1, f.Epsilon) ? f.Scalar.WithinEpsilon(Math.abs(t.z) / o, 1, f.Epsilon) ? _.Zero() : new _(0, 0, 1) : new _(1, 0, 0) : new _(0, -1, 0), r = _.Cross(t, n)) : (r = _.Cross(t, i), _.CrossToRef(r, t, r));\n        return r.normalize(), r;\n      }, e;\n    }();\n\n    f.Path3D = b;\n\n    var T = function () {\n      function h(e) {\n        this._length = 0, this._points = e, this._length = this._computeLength(e);\n      }\n\n      return h.CreateQuadraticBezier = function (e, t, i, r) {\n        r = 2 < r ? r : 3;\n\n        for (var n = new Array(), o = function (e, t, i, r) {\n          return (1 - e) * (1 - e) * t + 2 * e * (1 - e) * i + e * e * r;\n        }, s = 0; s <= r; s++) n.push(new _(o(s / r, e.x, t.x, i.x), o(s / r, e.y, t.y, i.y), o(s / r, e.z, t.z, i.z)));\n\n        return new h(n);\n      }, h.CreateCubicBezier = function (e, t, i, r, n) {\n        n = 3 < n ? n : 4;\n\n        for (var o = new Array(), s = function (e, t, i, r, n) {\n          return (1 - e) * (1 - e) * (1 - e) * t + 3 * e * (1 - e) * (1 - e) * i + 3 * e * e * (1 - e) * r + e * e * e * n;\n        }, a = 0; a <= n; a++) o.push(new _(s(a / n, e.x, t.x, i.x, r.x), s(a / n, e.y, t.y, i.y, r.y), s(a / n, e.z, t.z, i.z, r.z)));\n\n        return new h(o);\n      }, h.CreateHermiteSpline = function (e, t, i, r, n) {\n        for (var o = new Array(), s = 1 / n, a = 0; a <= n; a++) o.push(_.Hermite(e, t, i, r, a * s));\n\n        return new h(o);\n      }, h.CreateCatmullRomSpline = function (e, t, i) {\n        var r = new Array(),\n            n = 1 / t,\n            o = 0;\n\n        if (i) {\n          for (var s = e.length, a = 0; a < s; a++) for (var l = o = 0; l < t; l++) r.push(_.CatmullRom(e[a % s], e[(a + 1) % s], e[(a + 2) % s], e[(a + 3) % s], o)), o += n;\n\n          r.push(r[0]);\n        } else {\n          var c = new Array();\n          c.push(e[0].clone()), Array.prototype.push.apply(c, e), c.push(e[e.length - 1].clone());\n\n          for (a = 0; a < c.length - 3; a++) for (l = o = 0; l < t; l++) r.push(_.CatmullRom(c[a], c[a + 1], c[a + 2], c[a + 3], o)), o += n;\n\n          a--, r.push(_.CatmullRom(c[a], c[a + 1], c[a + 2], c[a + 3], o));\n        }\n\n        return new h(r);\n      }, h.prototype.getPoints = function () {\n        return this._points;\n      }, h.prototype.length = function () {\n        return this._length;\n      }, h.prototype.continue = function (e) {\n        for (var t = this._points[this._points.length - 1], i = this._points.slice(), r = e.getPoints(), n = 1; n < r.length; n++) i.push(r[n].subtract(r[0]).add(t));\n\n        return new h(i);\n      }, h.prototype._computeLength = function (e) {\n        for (var t = 0, i = 1; i < e.length; i++) t += e[i].subtract(e[i - 1]).length();\n\n        return t;\n      }, h;\n    }();\n\n    f.Curve3 = T;\n\n    var E = function () {\n      function e(e, t) {\n        void 0 === e && (e = _.Zero()), void 0 === t && (t = _.Up()), this.position = e, this.normal = t;\n      }\n\n      return e.prototype.clone = function () {\n        return new e(this.position.clone(), this.normal.clone());\n      }, e;\n    }();\n\n    f.PositionNormalVertex = E;\n\n    var x = function () {\n      function e(e, t, i) {\n        void 0 === e && (e = _.Zero()), void 0 === t && (t = _.Up()), void 0 === i && (i = p.Zero()), this.position = e, this.normal = t, this.uv = i;\n      }\n\n      return e.prototype.clone = function () {\n        return new e(this.position.clone(), this.normal.clone(), this.uv.clone());\n      }, e;\n    }();\n\n    f.PositionNormalTextureVertex = x;\n\n    var P = function () {\n      function e() {}\n\n      return e.Color3 = [t.Black(), t.Black(), t.Black()], e.Color4 = [new i(0, 0, 0, 0), new i(0, 0, 0, 0)], e.Vector2 = [p.Zero(), p.Zero(), p.Zero()], e.Vector3 = [_.Zero(), _.Zero(), _.Zero(), _.Zero(), _.Zero(), _.Zero(), _.Zero(), _.Zero(), _.Zero()], e.Vector4 = [r.Zero(), r.Zero(), r.Zero()], e.Quaternion = [m.Zero(), m.Zero()], e.Matrix = [h.Zero(), h.Zero(), h.Zero(), h.Zero(), h.Zero(), h.Zero(), h.Zero(), h.Zero()], e;\n    }();\n\n    f.Tmp = P;\n\n    var A = function () {\n      function e() {}\n\n      return e.Vector3 = [_.Zero(), _.Zero(), _.Zero(), _.Zero(), _.Zero(), _.Zero()], e.Matrix = [h.Zero(), h.Zero()], e.Quaternion = [m.Zero(), m.Zero(), m.Zero()], e;\n    }();\n  }($a || ($a = {})), e = $a || ($a = {}), n = function () {\n    function n() {}\n\n    return n.WithinEpsilon = function (e, t, i) {\n      void 0 === i && (i = 1401298e-51);\n      var r = e - t;\n      return -i <= r && r <= i;\n    }, n.ToHex = function (e) {\n      var t = e.toString(16);\n      return e <= 15 ? (\"0\" + t).toUpperCase() : t.toUpperCase();\n    }, n.Sign = function (e) {\n      return 0 === (e = +e) || isNaN(e) ? e : 0 < e ? 1 : -1;\n    }, n.Clamp = function (e, t, i) {\n      return void 0 === t && (t = 0), void 0 === i && (i = 1), Math.min(i, Math.max(t, e));\n    }, n.Log2 = function (e) {\n      return Math.log(e) * Math.LOG2E;\n    }, n.Repeat = function (e, t) {\n      return e - Math.floor(e / t) * t;\n    }, n.Normalize = function (e, t, i) {\n      return (e - t) / (i - t);\n    }, n.Denormalize = function (e, t, i) {\n      return e * (i - t) + t;\n    }, n.DeltaAngle = function (e, t) {\n      var i = n.Repeat(t - e, 360);\n      return 180 < i && (i -= 360), i;\n    }, n.PingPong = function (e, t) {\n      var i = n.Repeat(e, 2 * t);\n      return t - Math.abs(i - t);\n    }, n.SmoothStep = function (e, t, i) {\n      var r = n.Clamp(i);\n      return t * (r = -2 * r * r * r + 3 * r * r) + e * (1 - r);\n    }, n.MoveTowards = function (e, t, i) {\n      return Math.abs(t - e) <= i ? t : e + n.Sign(t - e) * i;\n    }, n.MoveTowardsAngle = function (e, t, i) {\n      var r = n.DeltaAngle(e, t);\n      return -i < r && r < i ? t : n.MoveTowards(e, t = e + r, i);\n    }, n.Lerp = function (e, t, i) {\n      return e + (t - e) * i;\n    }, n.LerpAngle = function (e, t, i) {\n      var r = n.Repeat(t - e, 360);\n      return 180 < r && (r -= 360), e + r * n.Clamp(i);\n    }, n.InverseLerp = function (e, t, i) {\n      return e != t ? n.Clamp((i - e) / (t - e)) : 0;\n    }, n.Hermite = function (e, t, i, r, n) {\n      var o = n * n,\n          s = n * o;\n      return e * (2 * s - 3 * o + 1) + i * (-2 * s + 3 * o) + t * (s - 2 * o + n) + r * (s - o);\n    }, n.RandomRange = function (e, t) {\n      return e === t ? e : Math.random() * (t - e) + e;\n    }, n.RangeToPercent = function (e, t, i) {\n      return (e - t) / (i - t);\n    }, n.PercentToRange = function (e, t, i) {\n      return (i - t) * e + t;\n    }, n.NormalizeRadians = function (e) {\n      return e -= n.TwoPi * Math.floor((e + Math.PI) / n.TwoPi);\n    }, n.TwoPi = 2 * Math.PI, n;\n  }(), e.Scalar = n, function (u) {\n    var c = {},\n        h = {},\n        i = function (e, t, i) {\n      var r = e();\n      u.Tags && u.Tags.AddTagsTo(r, t.tags);\n      var n = d(r);\n\n      for (var o in n) {\n        var s = n[o],\n            a = t[o],\n            l = s.type;\n        if (null != a) switch (l) {\n          case 0:\n          case 6:\n          case 11:\n            r[o] = a;\n            break;\n\n          case 1:\n            r[o] = i || a.isRenderTarget ? a : a.clone();\n            break;\n\n          case 2:\n          case 3:\n          case 4:\n          case 5:\n          case 7:\n          case 10:\n            r[o] = i ? a : a.clone();\n        }\n      }\n\n      return r;\n    };\n\n    function d(e) {\n      var t = e.getClassName();\n      if (h[t]) return h[t];\n      h[t] = {};\n\n      for (var i = h[t], r = e, n = t; n;) {\n        var o = c[n];\n\n        for (var s in o) i[s] = o[s];\n\n        var a = void 0,\n            l = !1;\n\n        do {\n          if (!(a = Object.getPrototypeOf(r)).getClassName) {\n            l = !0;\n            break;\n          }\n\n          if (a.getClassName() !== n) break;\n          r = a;\n        } while (a);\n\n        if (l) break;\n        n = a.getClassName(), r = a;\n      }\n\n      return i;\n    }\n\n    function t(n, o) {\n      return function (e, t) {\n        var i,\n            r = (i = e.getClassName(), c[i] || (c[i] = {}), c[i]);\n        r[t] || (r[t] = {\n          type: n,\n          sourceName: o\n        });\n      };\n    }\n\n    u.expandToProperty = function (e, t) {\n      return void 0 === t && (t = null), r = e, void 0 === (n = t) && (n = null), function (t, e) {\n        var i = n || \"_\" + e;\n        Object.defineProperty(t, e, {\n          get: function () {\n            return this[i];\n          },\n          set: function (e) {\n            this[i] !== e && (this[i] = e, t[r].apply(this));\n          },\n          enumerable: !0,\n          configurable: !0\n        });\n      };\n      var r, n;\n    }, u.serialize = function (e) {\n      return t(0, e);\n    }, u.serializeAsTexture = function (e) {\n      return t(1, e);\n    }, u.serializeAsColor3 = function (e) {\n      return t(2, e);\n    }, u.serializeAsFresnelParameters = function (e) {\n      return t(3, e);\n    }, u.serializeAsVector2 = function (e) {\n      return t(4, e);\n    }, u.serializeAsVector3 = function (e) {\n      return t(5, e);\n    }, u.serializeAsMeshReference = function (e) {\n      return t(6, e);\n    }, u.serializeAsColorCurves = function (e) {\n      return t(7, e);\n    }, u.serializeAsColor4 = function (e) {\n      return t(8, e);\n    }, u.serializeAsImageProcessingConfiguration = function (e) {\n      return t(9, e);\n    }, u.serializeAsQuaternion = function (e) {\n      return t(10, e);\n    }, u.serializeAsCameraReference = function (e) {\n      return t(11, e);\n    };\n\n    var e = function () {\n      function e() {}\n\n      return e.Serialize = function (e, t) {\n        t || (t = {}), u.Tags && (t.tags = u.Tags.GetTags(e));\n        var i = d(e);\n\n        for (var r in i) {\n          var n = i[r],\n              o = n.sourceName || r,\n              s = n.type,\n              a = e[r];\n          if (null != a) switch (s) {\n            case 0:\n              t[o] = a;\n              break;\n\n            case 1:\n              t[o] = a.serialize();\n              break;\n\n            case 2:\n              t[o] = a.asArray();\n              break;\n\n            case 3:\n              t[o] = a.serialize();\n              break;\n\n            case 4:\n            case 5:\n              t[o] = a.asArray();\n              break;\n\n            case 6:\n              t[o] = a.id;\n              break;\n\n            case 7:\n              t[o] = a.serialize();\n              break;\n\n            case 8:\n              t[o] = a.asArray();\n              break;\n\n            case 9:\n              t[o] = a.serialize();\n              break;\n\n            case 10:\n              t[o] = a.asArray();\n              break;\n\n            case 11:\n              t[o] = a.id;\n          }\n        }\n\n        return t;\n      }, e.Parse = function (e, t, i, r) {\n        void 0 === r && (r = null);\n        var n = e();\n        r || (r = \"\"), u.Tags && u.Tags.AddTagsTo(n, t.tags);\n        var o = d(n);\n\n        for (var s in o) {\n          var a = o[s],\n              l = t[a.sourceName || s],\n              c = a.type;\n\n          if (null != l) {\n            var h = n;\n\n            switch (c) {\n              case 0:\n                h[s] = l;\n                break;\n\n              case 1:\n                i && (h[s] = u.Texture.Parse(l, i, r));\n                break;\n\n              case 2:\n                h[s] = u.Color3.FromArray(l);\n                break;\n\n              case 3:\n                h[s] = u.FresnelParameters.Parse(l);\n                break;\n\n              case 4:\n                h[s] = u.Vector2.FromArray(l);\n                break;\n\n              case 5:\n                h[s] = u.Vector3.FromArray(l);\n                break;\n\n              case 6:\n                i && (h[s] = i.getLastMeshByID(l));\n                break;\n\n              case 7:\n                h[s] = u.ColorCurves.Parse(l);\n                break;\n\n              case 8:\n                h[s] = u.Color4.FromArray(l);\n                break;\n\n              case 9:\n                h[s] = u.ImageProcessingConfiguration.Parse(l);\n                break;\n\n              case 10:\n                h[s] = u.Quaternion.FromArray(l);\n                break;\n\n              case 11:\n                i && (h[s] = i.getCameraByID(l));\n            }\n          }\n        }\n\n        return n;\n      }, e.Clone = function (e, t) {\n        return i(e, t, !1);\n      }, e.Instanciate = function (e, t) {\n        return i(e, t, !0);\n      }, e;\n    }();\n\n    u.SerializationHelper = e;\n  }($a || ($a = {})), o = $a || ($a = {}), s = function () {\n    function e() {\n      var i = this;\n      this.promise = new Promise(function (e, t) {\n        i._resolve = e, i._reject = t;\n      });\n    }\n\n    return Object.defineProperty(e.prototype, \"resolve\", {\n      get: function () {\n        return this._resolve;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"reject\", {\n      get: function () {\n        return this._reject;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e;\n  }(), o.Deferred = s, function (i) {\n    var r = function () {\n      function e(e, t, i, r) {\n        void 0 === t && (t = !1), this.initalize(e, t, i, r);\n      }\n\n      return e.prototype.initalize = function (e, t, i, r) {\n        return void 0 === t && (t = !1), this.mask = e, this.skipNextObservers = t, this.target = i, this.currentTarget = r, this;\n      }, e;\n    }();\n\n    i.EventState = r;\n\n    var s = function (e, t, i) {\n      void 0 === i && (i = null), this.callback = e, this.mask = t, this.scope = i, this._willBeUnregistered = !1, this.unregisterOnNextCall = !1;\n    };\n\n    i.Observer = s;\n\n    var e = function () {\n      function l() {}\n\n      return l.prototype.dispose = function () {\n        if (this._observers && this._observables) for (var e = 0; e < this._observers.length; e++) this._observables[e].remove(this._observers[e]);\n        this._observers = null, this._observables = null;\n      }, l.Watch = function (e, t, i, r) {\n        void 0 === i && (i = -1), void 0 === r && (r = null);\n        var n = new l();\n        n._observers = new Array();\n\n        for (var o = 0, s = n._observables = e; o < s.length; o++) {\n          var a = s[o].add(t, i, !1, r);\n          a && n._observers.push(a);\n        }\n\n        return n;\n      }, l;\n    }();\n\n    i.MultiObserver = e;\n\n    var t = function () {\n      function t(e) {\n        this._observers = new Array(), this._eventState = new r(0), e && (this._onObserverAdded = e);\n      }\n\n      return t.prototype.add = function (e, t, i, r, n) {\n        if (void 0 === t && (t = -1), void 0 === i && (i = !1), void 0 === r && (r = null), void 0 === n && (n = !1), !e) return null;\n        var o = new s(e, t, r);\n        return o.unregisterOnNextCall = n, i ? this._observers.unshift(o) : this._observers.push(o), this._onObserverAdded && this._onObserverAdded(o), o;\n      }, t.prototype.addOnce = function (e) {\n        return this.add(e, void 0, void 0, void 0, !0);\n      }, t.prototype.remove = function (e) {\n        return !!e && -1 !== this._observers.indexOf(e) && (this._deferUnregister(e), !0);\n      }, t.prototype.removeCallback = function (e, t) {\n        for (var i = 0; i < this._observers.length; i++) if (this._observers[i].callback === e && (!t || t === this._observers[i].scope)) return this._deferUnregister(this._observers[i]), !0;\n\n        return !1;\n      }, t.prototype._deferUnregister = function (e) {\n        var t = this;\n        e.unregisterOnNextCall = !1, e._willBeUnregistered = !0, i.Tools.SetImmediate(function () {\n          t._remove(e);\n        });\n      }, t.prototype._remove = function (e) {\n        if (!e) return !1;\n\n        var t = this._observers.indexOf(e);\n\n        return -1 !== t && (this._observers.splice(t, 1), !0);\n      }, t.prototype.notifyObservers = function (e, t, i, r) {\n        if (void 0 === t && (t = -1), !this._observers.length) return !0;\n        var n = this._eventState;\n        n.mask = t, n.target = i, n.currentTarget = r, n.skipNextObservers = !1, n.lastReturnValue = e;\n\n        for (var o = 0, s = this._observers; o < s.length; o++) {\n          var a = s[o];\n          if (!a._willBeUnregistered && (a.mask & t && (a.scope ? n.lastReturnValue = a.callback.apply(a.scope, [e, n]) : n.lastReturnValue = a.callback(e, n), a.unregisterOnNextCall && this._deferUnregister(a)), n.skipNextObservers)) return !1;\n        }\n\n        return !0;\n      }, t.prototype.notifyObserversWithPromise = function (i, e, t, r) {\n        var n = this;\n        void 0 === e && (e = -1);\n        var o = Promise.resolve(i);\n        if (!this._observers.length) return o;\n        var s = this._eventState;\n        return s.mask = e, s.target = t, s.currentTarget = r, s.skipNextObservers = !1, this._observers.forEach(function (t) {\n          s.skipNextObservers || t._willBeUnregistered || t.mask & e && (o = t.scope ? o.then(function (e) {\n            return s.lastReturnValue = e, t.callback.apply(t.scope, [i, s]);\n          }) : o.then(function (e) {\n            return s.lastReturnValue = e, t.callback(i, s);\n          }), t.unregisterOnNextCall && n._deferUnregister(t));\n        }), o.then(function () {\n          return i;\n        });\n      }, t.prototype.notifyObserver = function (e, t, i) {\n        void 0 === i && (i = -1);\n        var r = this._eventState;\n        r.mask = i, r.skipNextObservers = !1, e.callback(t, r);\n      }, t.prototype.hasObservers = function () {\n        return 0 < this._observers.length;\n      }, t.prototype.clear = function () {\n        this._observers = new Array(), this._onObserverAdded = null;\n      }, t.prototype.clone = function () {\n        var e = new t();\n        return e._observers = this._observers.slice(0), e;\n      }, t.prototype.hasSpecificMask = function (e) {\n        void 0 === e && (e = -1);\n\n        for (var t = 0, i = this._observers; t < i.length; t++) {\n          var r = i[t];\n          if (r.mask & e || r.mask === e) return !0;\n        }\n\n        return !1;\n      }, t;\n    }();\n\n    i.Observable = t;\n  }($a || ($a = {})), a = $a || ($a = {}), l = function () {\n    function t(e) {\n      this.length = 0, this.data = new Array(e), this._id = t._GlobalId++;\n    }\n\n    return t.prototype.push = function (e) {\n      this.data[this.length++] = e, this.length > this.data.length && (this.data.length *= 2);\n    }, t.prototype.forEach = function (e) {\n      for (var t = 0; t < this.length; t++) e(this.data[t]);\n    }, t.prototype.sort = function (e) {\n      this.data.sort(e);\n    }, t.prototype.reset = function () {\n      this.length = 0;\n    }, t.prototype.dispose = function () {\n      this.reset(), this.data && (this.data.length = 0, this.data = []);\n    }, t.prototype.concat = function (e) {\n      if (0 !== e.length) {\n        this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));\n\n        for (var t = 0; t < e.length; t++) this.data[this.length++] = (e.data || e)[t];\n      }\n    }, t.prototype.indexOf = function (e) {\n      var t = this.data.indexOf(e);\n      return t >= this.length ? -1 : t;\n    }, t.prototype.contains = function (e) {\n      return -1 !== this.indexOf(e);\n    }, t._GlobalId = 0, t;\n  }(), c = function (t) {\n    function e() {\n      var e = null !== t && t.apply(this, arguments) || this;\n      return e._duplicateId = 0, e;\n    }\n\n    return T(e, t), e.prototype.push = function (e) {\n      t.prototype.push.call(this, e), e.__smartArrayFlags || (e.__smartArrayFlags = {}), e.__smartArrayFlags[this._id] = this._duplicateId;\n    }, e.prototype.pushNoDuplicate = function (e) {\n      return (!e.__smartArrayFlags || e.__smartArrayFlags[this._id] !== this._duplicateId) && (this.push(e), !0);\n    }, e.prototype.reset = function () {\n      t.prototype.reset.call(this), this._duplicateId++;\n    }, e.prototype.concatWithNoDuplicate = function (e) {\n      if (0 !== e.length) {\n        this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));\n\n        for (var t = 0; t < e.length; t++) {\n          var i = (e.data || e)[t];\n          this.pushNoDuplicate(i);\n        }\n      }\n    }, e;\n  }(a.SmartArray = l), a.SmartArrayNoDuplicate = c, function (_) {\n    var e = function () {\n      function e() {}\n\n      return e.prototype.getColorToRef = function (e) {\n        this.color2 ? _.Color4.LerpToRef(this.color1, this.color2, Math.random(), e) : e.copyFrom(this.color1);\n      }, e;\n    }();\n\n    _.ColorGradient = e;\n\n    var t = function () {};\n\n    _.Color3Gradient = t;\n\n    var i = function () {\n      function e() {}\n\n      return e.prototype.getFactor = function () {\n        return void 0 === this.factor2 ? this.factor1 : _.Scalar.Lerp(this.factor1, this.factor2, Math.random());\n      }, e;\n    }();\n\n    _.FactorGradient = i;\n\n    var g = function (r) {\n      function n(e, t) {\n        var i = r.call(this, e) || this;\n        return i.request = t, i.name = \"LoadFileError\", n._setPrototypeOf(i, n.prototype), i;\n      }\n\n      return T(n, r), n._setPrototypeOf = Object.setPrototypeOf || function (e, t) {\n        return e.__proto__ = t, e;\n      }, n;\n    }(Error);\n\n    _.LoadFileError = g;\n\n    var v,\n        r = function () {\n      function e() {}\n\n      return e.ExponentialBackoff = function (r, n) {\n        return void 0 === r && (r = 3), void 0 === n && (n = 500), function (e, t, i) {\n          return 0 !== t.status || r <= i || -1 !== e.indexOf(\"file:\") ? -1 : Math.pow(2, i) * n;\n        };\n      }, e;\n    }();\n\n    _.RetryStrategy = r;\n\n    var c = function (e, t) {\n      return e ? e instanceof _.Mesh ? null : e instanceof _.SubMesh ? e.clone(t) : e.clone ? e.clone() : null : null;\n    },\n        n = function () {\n      function m() {}\n\n      return m.FetchToRef = function (e, t, i, r, n, o) {\n        var s = 4 * ((Math.abs(e) * i % i | 0) + (Math.abs(t) * r % r | 0) * i);\n        o.r = n[s] / 255, o.g = n[s + 1] / 255, o.b = n[s + 2] / 255, o.a = n[s + 3] / 255;\n      }, m.Mix = function (e, t, i) {\n        return e * (1 - i) + t * i;\n      }, m.Instantiate = function (e) {\n        if (m.RegisteredExternalClasses && m.RegisteredExternalClasses[e]) return m.RegisteredExternalClasses[e];\n\n        for (var t = e.split(\".\"), i = window || this, r = 0, n = t.length; r < n; r++) i = i[t[r]];\n\n        return \"function\" != typeof i ? null : i;\n      }, m.Slice = function (e, t, i) {\n        return e.slice ? e.slice(t, i) : Array.prototype.slice.call(e, t, i);\n      }, m.SetImmediate = function (e) {\n        m.IsWindowObjectExist() && window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1);\n      }, m.IsExponentOfTwo = function (e) {\n        for (var t = 1; (t *= 2) < e;);\n\n        return t === e;\n      }, m.FloatRound = function (e) {\n        return Math.fround ? Math.fround(e) : m._tmpFloatArray[0] = e;\n      }, m.CeilingPOT = function (e) {\n        return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e;\n      }, m.FloorPOT = function (e) {\n        return e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, (e |= e >> 16) - (e >> 1);\n      }, m.NearestPOT = function (e) {\n        var t = m.CeilingPOT(e),\n            i = m.FloorPOT(e);\n        return e - i < t - e ? i : t;\n      }, m.GetExponentOfTwo = function (e, t, i) {\n        var r;\n\n        switch (void 0 === i && (i = _.Engine.SCALEMODE_NEAREST), i) {\n          case _.Engine.SCALEMODE_FLOOR:\n            r = m.FloorPOT(e);\n            break;\n\n          case _.Engine.SCALEMODE_NEAREST:\n            r = m.NearestPOT(e);\n            break;\n\n          case _.Engine.SCALEMODE_CEILING:\n          default:\n            r = m.CeilingPOT(e);\n        }\n\n        return Math.min(r, t);\n      }, m.GetFilename = function (e) {\n        var t = e.lastIndexOf(\"/\");\n        return t < 0 ? e : e.substring(t + 1);\n      }, m.GetFolderPath = function (e, t) {\n        void 0 === t && (t = !1);\n        var i = e.lastIndexOf(\"/\");\n        return i < 0 ? t ? e : \"\" : e.substring(0, i + 1);\n      }, m.GetDOMTextContent = function (e) {\n        for (var t = \"\", i = e.firstChild; i;) 3 === i.nodeType && (t += i.textContent), i = i.nextSibling;\n\n        return t;\n      }, m.ToDegrees = function (e) {\n        return 180 * e / Math.PI;\n      }, m.ToRadians = function (e) {\n        return e * Math.PI / 180;\n      }, m.EncodeArrayBufferTobase64 = function (e) {\n        for (var t, i, r, n, o, s, a, l = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", c = \"\", h = 0, u = new Uint8Array(e); h < u.length;) n = (t = u[h++]) >> 2, o = (3 & t) << 4 | (i = h < u.length ? u[h++] : Number.NaN) >> 4, s = (15 & i) << 2 | (r = h < u.length ? u[h++] : Number.NaN) >> 6, a = 63 & r, isNaN(i) ? s = a = 64 : isNaN(r) && (a = 64), c += l.charAt(n) + l.charAt(o) + l.charAt(s) + l.charAt(a);\n\n        return \"data:image/png;base64,\" + c;\n      }, m.ExtractMinAndMaxIndexed = function (e, t, i, r, n) {\n        void 0 === n && (n = null);\n\n        for (var o = new _.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new _.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), a = i; a < i + r; a++) {\n          var l = 3 * t[a],\n              c = e[l],\n              h = e[l + 1],\n              u = e[l + 2];\n          o.minimizeInPlaceFromFloats(c, h, u), s.maximizeInPlaceFromFloats(c, h, u);\n        }\n\n        return n && (o.x -= o.x * n.x + n.y, o.y -= o.y * n.x + n.y, o.z -= o.z * n.x + n.y, s.x += s.x * n.x + n.y, s.y += s.y * n.x + n.y, s.z += s.z * n.x + n.y), {\n          minimum: o,\n          maximum: s\n        };\n      }, m.ExtractMinAndMax = function (e, t, i, r, n) {\n        void 0 === r && (r = null);\n        var o = new _.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),\n            s = new _.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        n || (n = 3);\n\n        for (var a = t, l = t * n; a < t + i; a++, l += n) {\n          var c = e[l],\n              h = e[l + 1],\n              u = e[l + 2];\n          o.minimizeInPlaceFromFloats(c, h, u), s.maximizeInPlaceFromFloats(c, h, u);\n        }\n\n        return r && (o.x -= o.x * r.x + r.y, o.y -= o.y * r.x + r.y, o.z -= o.z * r.x + r.y, s.x += s.x * r.x + r.y, s.y += s.y * r.x + r.y, s.z += s.z * r.x + r.y), {\n          minimum: o,\n          maximum: s\n        };\n      }, m.MakeArray = function (e, t) {\n        return !0 === t || void 0 !== e && null != e ? Array.isArray(e) ? e : [e] : null;\n      }, m.GetPointerPrefix = function () {\n        var e = \"pointer\";\n        return !m.IsWindowObjectExist() || window.PointerEvent || navigator.pointerEnabled || (e = \"mouse\"), e;\n      }, m.QueueNewFrame = function (e, t) {\n        return m.IsWindowObjectExist() ? (t || (t = window), t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.msRequestAnimationFrame ? t.msRequestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.mozRequestAnimationFrame ? t.mozRequestAnimationFrame(e) : t.oRequestAnimationFrame ? t.oRequestAnimationFrame(e) : window.setTimeout(e, 16)) : setTimeout(e, 16);\n      }, m.RequestFullscreen = function (e) {\n        var t = e.requestFullscreen || e.msRequestFullscreen || e.webkitRequestFullscreen || e.mozRequestFullScreen;\n        t && t.call(e);\n      }, m.ExitFullscreen = function () {\n        document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen ? document.webkitCancelFullScreen() : document.msCancelFullScreen && document.msCancelFullScreen();\n      }, m.SetCorsBehavior = function (e, t) {\n        if ((!e || 0 !== e.indexOf(\"data:\")) && m.CorsBehavior) if (\"string\" == typeof m.CorsBehavior || m.CorsBehavior instanceof String) t.crossOrigin = m.CorsBehavior;else {\n          var i = m.CorsBehavior(e);\n          i && (t.crossOrigin = i);\n        }\n      }, m.CleanUrl = function (e) {\n        return e = e.replace(/#/gm, \"%23\");\n      }, m.LoadImage = function (t, e, i, r) {\n        var n,\n            o = !1;\n        t instanceof ArrayBuffer ? (n = URL.createObjectURL(new Blob([t])), o = !0) : t instanceof Blob ? (n = URL.createObjectURL(t), o = !0) : (n = m.CleanUrl(t), n = m.PreprocessUrl(t));\n        var s = new Image();\n        m.SetCorsBehavior(n, s);\n\n        var a = function () {\n          o && s.src && URL.revokeObjectURL(s.src), s.removeEventListener(\"load\", a), s.removeEventListener(\"error\", l), e(s);\n        },\n            l = function (e) {\n          o && s.src && URL.revokeObjectURL(s.src), s.removeEventListener(\"load\", a), s.removeEventListener(\"error\", l), m.Error(\"Error while trying to load image: \" + t), i && i(\"Error while trying to load image: \" + t, e);\n        };\n\n        s.addEventListener(\"load\", a), s.addEventListener(\"error\", l);\n\n        var c = function () {\n          s.src = n;\n        };\n\n        if (\"data:\" !== n.substr(0, 5) && r && r.enableTexturesOffline && _.Database.IsUASupportingBlobStorage) r.openAsync(function () {\n          r && r.loadImageFromDB(n, s);\n        }, c);else {\n          if (-1 !== n.indexOf(\"file:\")) {\n            var h = decodeURIComponent(n.substring(5).toLowerCase());\n\n            if (_.FilesInput.FilesToLoad[h]) {\n              try {\n                var u;\n\n                try {\n                  u = URL.createObjectURL(_.FilesInput.FilesToLoad[h]);\n                } catch (e) {\n                  u = URL.createObjectURL(_.FilesInput.FilesToLoad[h]);\n                }\n\n                s.src = u, o = !0;\n              } catch (e) {\n                s.src = \"\";\n              }\n\n              return s;\n            }\n          }\n\n          c();\n        }\n        return s;\n      }, m.LoadFile = function (e, c, t, i, h, u) {\n        if (e = m.CleanUrl(e), -1 !== (e = m.PreprocessUrl(e)).indexOf(\"file:\")) {\n          var r = decodeURIComponent(e.substring(5).toLowerCase());\n          if (_.FilesInput.FilesToLoad[r]) return m.ReadFile(_.FilesInput.FilesToLoad[r], c, t, h);\n        }\n\n        var d = m.BaseUrl + e,\n            f = !1,\n            p = {\n          onCompleteObservable: new _.Observable(),\n          abort: function () {\n            return f = !0;\n          }\n        },\n            n = function () {\n          var s = new XMLHttpRequest(),\n              a = null;\n\n          p.abort = function () {\n            f = !0, s.readyState !== (XMLHttpRequest.DONE || 4) && s.abort(), null !== a && (clearTimeout(a), a = null);\n          };\n\n          var l = function (r) {\n            s.open(\"GET\", d, !0), h && (s.responseType = \"arraybuffer\"), t && s.addEventListener(\"progress\", t);\n\n            var n = function () {\n              s.removeEventListener(\"loadend\", n), p.onCompleteObservable.notifyObservers(p), p.onCompleteObservable.clear();\n            };\n\n            s.addEventListener(\"loadend\", n);\n\n            var o = function () {\n              if (!f && s.readyState === (XMLHttpRequest.DONE || 4)) {\n                if (s.removeEventListener(\"readystatechange\", o), 200 <= s.status && s.status < 300 || 0 === s.status && (!m.IsWindowObjectExist() || m.IsFileURL())) return void c(h ? s.response : s.responseText, s.responseURL);\n                var e = m.DefaultRetryStrategy;\n\n                if (e) {\n                  var t = e(d, s, r);\n                  if (-1 !== t) return s.removeEventListener(\"loadend\", n), s = new XMLHttpRequest(), void (a = setTimeout(function () {\n                    return l(r + 1);\n                  }, t));\n                }\n\n                var i = new g(\"Error status: \" + s.status + \" \" + s.statusText + \" - Unable to load \" + d, s);\n                if (!u) throw i;\n                u(s, i);\n              }\n            };\n\n            s.addEventListener(\"readystatechange\", o), s.send();\n          };\n\n          l(0);\n        };\n\n        if (i && i.enableSceneOffline) {\n          var o = function (e) {\n            e && 400 < e.status ? u && u(e) : f || n();\n          };\n\n          i.openAsync(function () {\n            f || i && i.loadFileFromDB(e, function (e) {\n              f || c(e), p.onCompleteObservable.notifyObservers(p);\n            }, t ? function (e) {\n              f || t(e);\n            } : void 0, o, h);\n          }, o);\n        } else n();\n\n        return p;\n      }, m.LoadScript = function (t, e, i) {\n        if (m.IsWindowObjectExist()) {\n          var r = document.getElementsByTagName(\"head\")[0],\n              n = document.createElement(\"script\");\n          n.type = \"text/javascript\", n.src = t, n.onload = function () {\n            e && e();\n          }, n.onerror = function (e) {\n            i && i(\"Unable to load script '\" + t + \"'\", e);\n          }, r.appendChild(n);\n        }\n      }, m.ReadFileAsDataURL = function (e, t, i) {\n        var r = new FileReader(),\n            n = {\n          onCompleteObservable: new _.Observable(),\n          abort: function () {\n            return r.abort();\n          }\n        };\n        return r.onloadend = function (e) {\n          n.onCompleteObservable.notifyObservers(n);\n        }, r.onload = function (e) {\n          t(e.target.result);\n        }, r.onprogress = i, r.readAsDataURL(e), n;\n      }, m.ReadFile = function (t, i, e, r) {\n        var n = new FileReader(),\n            o = {\n          onCompleteObservable: new _.Observable(),\n          abort: function () {\n            return n.abort();\n          }\n        };\n        return n.onloadend = function (e) {\n          return o.onCompleteObservable.notifyObservers(o);\n        }, n.onerror = function (e) {\n          m.Log(\"Error while reading file: \" + t.name), i(JSON.stringify({\n            autoClear: !0,\n            clearColor: [1, 0, 0],\n            ambientColor: [0, 0, 0],\n            gravity: [0, -9.807, 0],\n            meshes: [],\n            cameras: [],\n            lights: []\n          }));\n        }, n.onload = function (e) {\n          i(e.target.result);\n        }, e && (n.onprogress = e), r ? n.readAsArrayBuffer(t) : n.readAsText(t), o;\n      }, m.FileAsURL = function (e) {\n        var t = new Blob([e]);\n        return (window.URL || window.webkitURL).createObjectURL(t);\n      }, m.Format = function (e, t) {\n        return void 0 === t && (t = 2), e.toFixed(t);\n      }, m.CheckExtends = function (e, t, i) {\n        e.x < t.x && (t.x = e.x), e.y < t.y && (t.y = e.y), e.z < t.z && (t.z = e.z), e.x > i.x && (i.x = e.x), e.y > i.y && (i.y = e.y), e.z > i.z && (i.z = e.z);\n      }, m.DeepCopy = function (e, t, i, r) {\n        for (var n in e) if ((\"_\" !== n[0] || r && -1 !== r.indexOf(n)) && (!i || -1 === i.indexOf(n))) {\n          var o = e[n],\n              s = typeof o;\n          if (\"function\" !== s) try {\n            if (\"object\" === s) {\n              if (o instanceof Array) {\n                if (t[n] = [], 0 < o.length) if (\"object\" == typeof o[0]) for (var a = 0; a < o.length; a++) {\n                  var l = c(o[a], t);\n                  -1 === t[n].indexOf(l) && t[n].push(l);\n                } else t[n] = o.slice(0);\n              } else t[n] = c(o, t);\n            } else t[n] = o;\n          } catch (e) {}\n        }\n      }, m.IsEmpty = function (e) {\n        for (var t in e) if (e.hasOwnProperty(t)) return !1;\n\n        return !0;\n      }, m.RegisterTopRootEvents = function (e) {\n        for (var t = 0; t < e.length; t++) {\n          var i = e[t];\n          window.addEventListener(i.name, i.handler, !1);\n\n          try {\n            window.parent && window.parent.addEventListener(i.name, i.handler, !1);\n          } catch (e) {}\n        }\n      }, m.UnregisterTopRootEvents = function (e) {\n        for (var t = 0; t < e.length; t++) {\n          var i = e[t];\n          window.removeEventListener(i.name, i.handler);\n\n          try {\n            window.parent && window.parent.removeEventListener(i.name, i.handler);\n          } catch (e) {}\n        }\n      }, m.DumpFramebuffer = function (e, t, i, r, n, o) {\n        void 0 === n && (n = \"image/png\");\n\n        for (var s = 4 * e, a = t / 2, l = i.readPixels(0, 0, e, t), c = 0; c < a; c++) for (var h = 0; h < s; h++) {\n          var u = h + c * s,\n              d = h + (t - c - 1) * s,\n              f = l[u];\n          l[u] = l[d], l[d] = f;\n        }\n\n        v || (v = document.createElement(\"canvas\")), v.width = e, v.height = t;\n        var p = v.getContext(\"2d\");\n\n        if (p) {\n          var _ = p.createImageData(e, t);\n\n          _.data.set(l), p.putImageData(_, 0, 0), m.EncodeScreenshotCanvasData(r, n, o);\n        }\n      }, m.ToBlob = function (e, t, i) {\n        void 0 === i && (i = \"image/png\"), e.toBlob || (e.toBlob = function (n, o, s) {\n          var a = this;\n          setTimeout(function () {\n            for (var e = atob(a.toDataURL(o, s).split(\",\")[1]), t = e.length, i = new Uint8Array(t), r = 0; r < t; r++) i[r] = e.charCodeAt(r);\n\n            n(new Blob([i]));\n          });\n        }), e.toBlob(function (e) {\n          t(e);\n        }, i);\n      }, m.EncodeScreenshotCanvasData = function (e, t, s) {\n        (void 0 === t && (t = \"image/png\"), e) ? e(v.toDataURL(t)) : this.ToBlob(v, function (e) {\n          if (\"download\" in document.createElement(\"a\")) {\n            if (!s) {\n              var t = new Date(),\n                  i = (t.getFullYear() + \"-\" + (t.getMonth() + 1)).slice(2) + \"-\" + t.getDate() + \"_\" + t.getHours() + \"-\" + (\"0\" + t.getMinutes()).slice(-2);\n              s = \"screenshot_\" + i + \".png\";\n            }\n\n            m.Download(e, s);\n          } else {\n            var r = URL.createObjectURL(e),\n                n = window.open(\"\");\n            if (!n) return;\n            var o = n.document.createElement(\"img\");\n            o.onload = function () {\n              URL.revokeObjectURL(r);\n            }, o.src = r, n.document.body.appendChild(o);\n          }\n        }, t);\n      }, m.Download = function (e, t) {\n        if (navigator && navigator.msSaveBlob) navigator.msSaveBlob(e, t);else {\n          var i = window.URL.createObjectURL(e),\n              r = document.createElement(\"a\");\n          document.body.appendChild(r), r.style.display = \"none\", r.href = i, r.download = t, r.addEventListener(\"click\", function () {\n            r.parentElement && r.parentElement.removeChild(r);\n          }), r.click(), window.URL.revokeObjectURL(i);\n        }\n      }, m.CreateScreenshot = function (e, t, i, r, n) {\n        var o, s;\n        if (void 0 === n && (n = \"image/png\"), i.precision) o = Math.round(e.getRenderWidth() * i.precision), s = Math.round(o / e.getAspectRatio(t));else if (i.width && i.height) o = i.width, s = i.height;else if (i.width && !i.height) o = i.width, s = Math.round(o / e.getAspectRatio(t));else if (i.height && !i.width) s = i.height, o = Math.round(s * e.getAspectRatio(t));else {\n          if (isNaN(i)) return void m.Error(\"Invalid 'size' parameter !\");\n          o = s = i;\n        }\n        v || (v = document.createElement(\"canvas\")), v.width = o, v.height = s;\n        var a = v.getContext(\"2d\"),\n            l = e.getRenderWidth() / e.getRenderHeight(),\n            c = o,\n            h = c / l;\n        s < h && (c = (h = s) * l);\n        var u = Math.max(0, o - c) / 2,\n            d = Math.max(0, s - h) / 2,\n            f = e.getRenderingCanvas();\n        a && f && a.drawImage(f, u, d, c, h), m.EncodeScreenshotCanvasData(r, n);\n      }, m.CreateScreenshotUsingRenderTarget = function (e, t, i, r, n, o, s, a) {\n        var l, c;\n        if (void 0 === n && (n = \"image/png\"), void 0 === o && (o = 1), void 0 === s && (s = !1), i.precision) l = Math.round(e.getRenderWidth() * i.precision), c = Math.round(l / e.getAspectRatio(t)), i = {\n          width: l,\n          height: c\n        };else if (i.width && i.height) l = i.width, c = i.height;else if (i.width && !i.height) l = i.width, c = Math.round(l / e.getAspectRatio(t)), i = {\n          width: l,\n          height: c\n        };else if (i.height && !i.width) c = i.height, i = {\n          width: l = Math.round(c * e.getAspectRatio(t)),\n          height: c\n        };else {\n          if (isNaN(i)) return void m.Error(\"Invalid 'size' parameter !\");\n          l = c = i;\n        }\n        var h = t.getScene(),\n            u = null;\n        h.activeCamera !== t && (u = h.activeCamera, h.activeCamera = t);\n        var d = new _.RenderTargetTexture(\"screenShot\", i, h, !1, !1, _.Engine.TEXTURETYPE_UNSIGNED_INT, !1, _.Texture.NEAREST_SAMPLINGMODE);\n        d.renderList = null, d.samples = o, s && d.addPostProcess(new _.FxaaPostProcess(\"antialiasing\", 1, h.activeCamera)), d.onAfterRenderObservable.add(function () {\n          m.DumpFramebuffer(l, c, e, r, n, a);\n        }), h.incrementRenderId(), h.resetCachedMaterial(), d.render(!0), d.dispose(), u && (h.activeCamera = u), t.getProjectionMatrix(!0);\n      }, m.ValidateXHRData = function (e, t) {\n        void 0 === t && (t = 7);\n\n        try {\n          if (1 & t) {\n            if (e.responseText && 0 < e.responseText.length) return !0;\n            if (1 === t) return !1;\n          }\n\n          if (2 & t) {\n            var i = _.TGATools.GetTGAHeader(e.response);\n\n            if (i.width && i.height && 0 < i.width && 0 < i.height) return !0;\n            if (2 === t) return !1;\n          }\n\n          if (4 & t) {\n            var r = new Uint8Array(e.response, 0, 3);\n            return 68 === r[0] && 68 === r[1] && 83 === r[2];\n          }\n        } catch (e) {}\n\n        return !1;\n      }, m.RandomId = function () {\n        return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (e) {\n          var t = 16 * Math.random() | 0;\n          return (\"x\" === e ? t : 3 & t | 8).toString(16);\n        });\n      }, m.IsBase64 = function (e) {\n        return !(e.length < 5) && \"data:\" === e.substr(0, 5);\n      }, m.DecodeBase64 = function (e) {\n        for (var t = atob(e.split(\",\")[1]), i = t.length, r = new Uint8Array(new ArrayBuffer(i)), n = 0; n < i; n++) r[n] = t.charCodeAt(n);\n\n        return r.buffer;\n      }, m._AddLogEntry = function (e) {\n        m._LogCache = e + m._LogCache, m.OnNewCacheEntry && m.OnNewCacheEntry(e);\n      }, m._FormatMessage = function (e) {\n        var t = function (e) {\n          return e < 10 ? \"0\" + e : \"\" + e;\n        },\n            i = new Date();\n\n        return \"[\" + t(i.getHours()) + \":\" + t(i.getMinutes()) + \":\" + t(i.getSeconds()) + \"]: \" + e;\n      }, m._LogDisabled = function (e) {}, m._LogEnabled = function (e) {\n        var t = m._FormatMessage(e);\n\n        console.log(\"BJS - \" + t), m._AddLogEntry(\"<div style='color:white'>\" + t + \"</div><br>\");\n      }, m._WarnDisabled = function (e) {}, m._WarnEnabled = function (e) {\n        var t = m._FormatMessage(e);\n\n        console.warn(\"BJS - \" + t), m._AddLogEntry(\"<div style='color:orange'>\" + t + \"</div><br>\");\n      }, m._ErrorDisabled = function (e) {}, m._ErrorEnabled = function (e) {\n        m.errorsCount++;\n\n        var t = m._FormatMessage(e);\n\n        console.error(\"BJS - \" + t), m._AddLogEntry(\"<div style='color:red'>\" + t + \"</div><br>\");\n      }, Object.defineProperty(m, \"LogCache\", {\n        get: function () {\n          return m._LogCache;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), m.ClearLogCache = function () {\n        m._LogCache = \"\", m.errorsCount = 0;\n      }, Object.defineProperty(m, \"LogLevels\", {\n        set: function (e) {\n          m.Log = (e & m.MessageLogLevel) === m.MessageLogLevel ? m._LogEnabled : m._LogDisabled, m.Warn = (e & m.WarningLogLevel) === m.WarningLogLevel ? m._WarnEnabled : m._WarnDisabled, m.Error = (e & m.ErrorLogLevel) === m.ErrorLogLevel ? m._ErrorEnabled : m._ErrorDisabled;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), m.IsFileURL = function () {\n        return \"file:\" === location.protocol;\n      }, m.IsWindowObjectExist = function () {\n        return \"undefined\" != typeof window;\n      }, Object.defineProperty(m, \"PerformanceLogLevel\", {\n        set: function (e) {\n          return (e & m.PerformanceUserMarkLogLevel) === m.PerformanceUserMarkLogLevel ? (m.StartPerformanceCounter = m._StartUserMark, void (m.EndPerformanceCounter = m._EndUserMark)) : (e & m.PerformanceConsoleLogLevel) === m.PerformanceConsoleLogLevel ? (m.StartPerformanceCounter = m._StartPerformanceConsole, void (m.EndPerformanceCounter = m._EndPerformanceConsole)) : (m.StartPerformanceCounter = m._StartPerformanceCounterDisabled, void (m.EndPerformanceCounter = m._EndPerformanceCounterDisabled));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), m._StartPerformanceCounterDisabled = function (e, t) {}, m._EndPerformanceCounterDisabled = function (e, t) {}, m._StartUserMark = function (e, t) {\n        if (void 0 === t && (t = !0), !m._performance) {\n          if (!m.IsWindowObjectExist()) return;\n          m._performance = window.performance;\n        }\n\n        t && m._performance.mark && m._performance.mark(e + \"-Begin\");\n      }, m._EndUserMark = function (e, t) {\n        void 0 === t && (t = !0), t && m._performance.mark && (m._performance.mark(e + \"-End\"), m._performance.measure(e, e + \"-Begin\", e + \"-End\"));\n      }, m._StartPerformanceConsole = function (e, t) {\n        void 0 === t && (t = !0), t && (m._StartUserMark(e, t), console.time && console.time(e));\n      }, m._EndPerformanceConsole = function (e, t) {\n        void 0 === t && (t = !0), t && (m._EndUserMark(e, t), console.time && console.timeEnd(e));\n      }, Object.defineProperty(m, \"Now\", {\n        get: function () {\n          return m.IsWindowObjectExist() && window.performance && window.performance.now ? window.performance.now() : Date.now();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), m.GetClassName = function (e, t) {\n        void 0 === t && (t = !1);\n        var i = null;\n        if (!t && e.getClassName) i = e.getClassName();else {\n          if (e instanceof Object) i = (t ? e : Object.getPrototypeOf(e)).constructor.__bjsclassName__;\n          i || (i = typeof e);\n        }\n        return i;\n      }, m.First = function (e, t) {\n        for (var i = 0, r = e; i < r.length; i++) {\n          var n = r[i];\n          if (t(n)) return n;\n        }\n\n        return null;\n      }, m.getFullClassName = function (e, t) {\n        void 0 === t && (t = !1);\n        var i = null,\n            r = null;\n        if (!t && e.getClassName) i = e.getClassName();else {\n          if (e instanceof Object) {\n            var n = t ? e : Object.getPrototypeOf(e);\n            i = n.constructor.__bjsclassName__, r = n.constructor.__bjsmoduleName__;\n          }\n\n          i || (i = typeof e);\n        }\n        return i ? (null != r ? r + \".\" : \"\") + i : null;\n      }, m.DelayAsync = function (t) {\n        return new Promise(function (e) {\n          setTimeout(function () {\n            e();\n          }, t);\n        });\n      }, m.GetCurrentGradient = function (e, t, i) {\n        for (var r = 0; r < t.length - 1; r++) {\n          var n = t[r],\n              o = t[r + 1];\n          if (e >= n.gradient && e <= o.gradient) return void i(n, o, (e - n.gradient) / (o.gradient - n.gradient));\n        }\n\n        var s = t.length - 1;\n        i(t[s], t[s], 1);\n      }, m.BaseUrl = \"\", m.DefaultRetryStrategy = r.ExponentialBackoff(), m.CorsBehavior = \"anonymous\", m.UseFallbackTexture = !0, m.RegisteredExternalClasses = {}, m.fallbackTexture = \"data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z\", m._tmpFloatArray = new Float32Array(1), m.PreprocessUrl = function (e) {\n        return e;\n      }, m.NoneLogLevel = 0, m.MessageLogLevel = 1, m.WarningLogLevel = 2, m.ErrorLogLevel = 4, m.AllLogLevel = 7, m._LogCache = \"\", m.errorsCount = 0, m.Log = m._LogEnabled, m.Warn = m._WarnEnabled, m.Error = m._ErrorEnabled, m.PerformanceNoneLogLevel = 0, m.PerformanceUserMarkLogLevel = 1, m.PerformanceConsoleLogLevel = 2, m.StartPerformanceCounter = m._StartPerformanceCounterDisabled, m.EndPerformanceCounter = m._EndPerformanceCounterDisabled, m;\n    }();\n\n    _.Tools = n;\n\n    var o = function () {\n      function i() {\n        this._startMonitoringTime = 0, this._min = 0, this._max = 0, this._average = 0, this._lastSecAverage = 0, this._current = 0, this._totalValueCount = 0, this._totalAccumulated = 0, this._lastSecAccumulated = 0, this._lastSecTime = 0, this._lastSecValueCount = 0;\n      }\n\n      return Object.defineProperty(i.prototype, \"min\", {\n        get: function () {\n          return this._min;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"max\", {\n        get: function () {\n          return this._max;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"average\", {\n        get: function () {\n          return this._average;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"lastSecAverage\", {\n        get: function () {\n          return this._lastSecAverage;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"current\", {\n        get: function () {\n          return this._current;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"total\", {\n        get: function () {\n          return this._totalAccumulated;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"count\", {\n        get: function () {\n          return this._totalValueCount;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), i.prototype.fetchNewFrame = function () {\n        this._totalValueCount++, this._current = 0, this._lastSecValueCount++;\n      }, i.prototype.addCount = function (e, t) {\n        i.Enabled && (this._current += e, t && this._fetchResult());\n      }, i.prototype.beginMonitoring = function () {\n        i.Enabled && (this._startMonitoringTime = n.Now);\n      }, i.prototype.endMonitoring = function (e) {\n        if (void 0 === e && (e = !0), i.Enabled) {\n          e && this.fetchNewFrame();\n          var t = n.Now;\n          this._current = t - this._startMonitoringTime, e && this._fetchResult();\n        }\n      }, i.prototype._fetchResult = function () {\n        this._totalAccumulated += this._current, this._lastSecAccumulated += this._current, this._min = Math.min(this._min, this._current), this._max = Math.max(this._max, this._current), this._average = this._totalAccumulated / this._totalValueCount;\n        var e = n.Now;\n        1e3 < e - this._lastSecTime && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount, this._lastSecTime = e, this._lastSecAccumulated = 0, this._lastSecValueCount = 0);\n      }, i.Enabled = !0, i;\n    }();\n\n    _.PerfCounter = o, _.className = function (t, i) {\n      return function (e) {\n        e.__bjsclassName__ = t, e.__bjsmoduleName__ = null != i ? i : null;\n      };\n    };\n\n    var s = function () {\n      function a(e, t, i, r) {\n        void 0 === r && (r = 0), this.iterations = e, this.index = r - 1, this._done = !1, this._fn = t, this._successCallback = i;\n      }\n\n      return a.prototype.executeNext = function () {\n        this._done || (this.index + 1 < this.iterations ? (++this.index, this._fn(this)) : this.breakLoop());\n      }, a.prototype.breakLoop = function () {\n        this._done = !0, this._successCallback();\n      }, a.Run = function (e, t, i, r) {\n        void 0 === r && (r = 0);\n        var n = new a(e, t, i, r);\n        return n.executeNext(), n;\n      }, a.SyncAsyncForLoop = function (r, n, o, e, s, t) {\n        return void 0 === t && (t = 0), a.Run(Math.ceil(r / n), function (i) {\n          s && s() ? i.breakLoop() : setTimeout(function () {\n            for (var e = 0; e < n; ++e) {\n              var t = i.index * n + e;\n              if (r <= t) break;\n\n              if (o(t), s && s()) {\n                i.breakLoop();\n                break;\n              }\n            }\n\n            i.executeNext();\n          }, t);\n        }, e);\n      }, a;\n    }();\n\n    _.AsyncLoop = s;\n  }($a || ($a = {})), function (o) {\n    var a, e;\n    (e = a || (a = {}))[e.Pending = 0] = \"Pending\", e[e.Fulfilled = 1] = \"Fulfilled\", e[e.Rejected = 2] = \"Rejected\";\n\n    var s = function () {\n      this.count = 0, this.target = 0, this.results = [];\n    },\n        t = function () {\n      function n(e) {\n        var t = this;\n        if (this._state = a.Pending, this._children = new Array(), this._rejectWasConsumed = !1, e) try {\n          e(function (e) {\n            t._resolve(e);\n          }, function (e) {\n            t._reject(e);\n          });\n        } catch (e) {\n          this._reject(e);\n        }\n      }\n\n      return Object.defineProperty(n.prototype, \"_result\", {\n        get: function () {\n          return this._resultValue;\n        },\n        set: function (e) {\n          this._resultValue = e, this._parent && void 0 === this._parent._result && (this._parent._result = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), n.prototype.catch = function (e) {\n        return this.then(void 0, e);\n      }, n.prototype.then = function (e, t) {\n        var i = this,\n            r = new n();\n        return r._onFulfilled = e, r._onRejected = t, this._children.push(r), (r._parent = this)._state !== a.Pending && o.Tools.SetImmediate(function () {\n          if (i._state === a.Fulfilled || i._rejectWasConsumed) {\n            var e = r._resolve(i._result);\n\n            if (null != e) if (void 0 !== e._state) {\n              var t = e;\n              r._children.push(t), t._parent = r, r = t;\n            } else r._result = e;\n          } else r._reject(i._reason);\n        }), r;\n      }, n.prototype._moveChildren = function (e) {\n        var t,\n            i = this;\n        if ((t = this._children).push.apply(t, e.splice(0, e.length)), this._children.forEach(function (e) {\n          e._parent = i;\n        }), this._state === a.Fulfilled) for (var r = 0, n = this._children; r < n.length; r++) {\n          n[r]._resolve(this._result);\n        } else if (this._state === a.Rejected) for (var o = 0, s = this._children; o < s.length; o++) {\n          s[o]._reject(this._reason);\n        }\n      }, n.prototype._resolve = function (e) {\n        try {\n          this._state = a.Fulfilled;\n          var t = null;\n          if (this._onFulfilled && (t = this._onFulfilled(e)), null != t) if (void 0 !== t._state) {\n            var i = t;\n            i._parent = this, i._moveChildren(this._children), e = i._result;\n          } else e = t;\n          this._result = e;\n\n          for (var r = 0, n = this._children; r < n.length; r++) {\n            n[r]._resolve(e);\n          }\n\n          this._children.length = 0, delete this._onFulfilled, delete this._onRejected;\n        } catch (e) {\n          this._reject(e, !0);\n        }\n      }, n.prototype._reject = function (t, e) {\n        if (void 0 === e && (e = !1), this._state = a.Rejected, this._reason = t, this._onRejected && !e) try {\n          this._onRejected(t), this._rejectWasConsumed = !0;\n        } catch (e) {\n          t = e;\n        }\n\n        for (var i = 0, r = this._children; i < r.length; i++) {\n          var n = r[i];\n          this._rejectWasConsumed ? n._resolve(null) : n._reject(t);\n        }\n\n        this._children.length = 0, delete this._onFulfilled, delete this._onRejected;\n      }, n.resolve = function (e) {\n        var t = new n();\n        return t._resolve(e), t;\n      }, n._RegisterForFulfillment = function (e, t, i) {\n        e.then(function (e) {\n          return t.results[i] = e, t.count++, t.count === t.target && t.rootPromise._resolve(t.results), null;\n        }, function (e) {\n          t.rootPromise._state !== a.Rejected && t.rootPromise._reject(e);\n        });\n      }, n.all = function (e) {\n        var t = new n(),\n            i = new s();\n        if (i.target = e.length, i.rootPromise = t, e.length) for (var r = 0; r < e.length; r++) n._RegisterForFulfillment(e[r], i, r);else t._resolve([]);\n        return t;\n      }, n.race = function (e) {\n        var t = new n();\n        if (e.length) for (var i = 0, r = e; i < r.length; i++) {\n          r[i].then(function (e) {\n            return t && (t._resolve(e), t = null), null;\n          }, function (e) {\n            t && (t._reject(e), t = null);\n          });\n        }\n        return t;\n      }, n;\n    }(),\n        i = function () {\n      function e() {}\n\n      return e.Apply = function (e) {\n        (void 0 === e && (e = !1), e || \"undefined\" == typeof Promise) && (window.Promise = t);\n      }, e;\n    }();\n\n    o.PromisePolyfill = i;\n  }($a || ($a = {})), h = $a || ($a = {}), u = function () {\n    function e(e) {\n      this._pendingActions = new Array(), this._workerInfos = e.map(function (e) {\n        return {\n          worker: e,\n          active: !1\n        };\n      });\n    }\n\n    return e.prototype.dispose = function () {\n      for (var e = 0, t = this._workerInfos; e < t.length; e++) {\n        t[e].worker.terminate();\n      }\n\n      delete this._workerInfos, delete this._pendingActions;\n    }, e.prototype.push = function (e) {\n      for (var t = 0, i = this._workerInfos; t < i.length; t++) {\n        var r = i[t];\n        if (!r.active) return void this._execute(r, e);\n      }\n\n      this._pendingActions.push(e);\n    }, e.prototype._execute = function (t, e) {\n      var i = this;\n      t.active = !0, e(t.worker, function () {\n        t.active = !1;\n\n        var e = i._pendingActions.shift();\n\n        e && i._execute(t, e);\n      });\n    }, e;\n  }(), h.WorkerPool = u, d = $a || ($a = {}), f = function () {\n    function e() {\n      this._isAlphaBlendDirty = !1, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this._isBlendConstantsDirty = !1, this._alphaBlend = !1, this._blendFunctionParameters = new Array(4), this._blendEquationParameters = new Array(2), this._blendConstants = new Array(4), this.reset();\n    }\n\n    return Object.defineProperty(e.prototype, \"isDirty\", {\n      get: function () {\n        return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"alphaBlend\", {\n      get: function () {\n        return this._alphaBlend;\n      },\n      set: function (e) {\n        this._alphaBlend !== e && (this._alphaBlend = e, this._isAlphaBlendDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.setAlphaBlendConstants = function (e, t, i, r) {\n      this._blendConstants[0] === e && this._blendConstants[1] === t && this._blendConstants[2] === i && this._blendConstants[3] === r || (this._blendConstants[0] = e, this._blendConstants[1] = t, this._blendConstants[2] = i, this._blendConstants[3] = r, this._isBlendConstantsDirty = !0);\n    }, e.prototype.setAlphaBlendFunctionParameters = function (e, t, i, r) {\n      this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === i && this._blendFunctionParameters[3] === r || (this._blendFunctionParameters[0] = e, this._blendFunctionParameters[1] = t, this._blendFunctionParameters[2] = i, this._blendFunctionParameters[3] = r, this._isBlendFunctionParametersDirty = !0);\n    }, e.prototype.setAlphaEquationParameters = function (e, t) {\n      this._blendEquationParameters[0] === e && this._blendEquationParameters[1] === t || (this._blendEquationParameters[0] = e, this._blendEquationParameters[1] = t, this._isBlendEquationParametersDirty = !0);\n    }, e.prototype.reset = function () {\n      this._alphaBlend = !1, this._blendFunctionParameters[0] = null, this._blendFunctionParameters[1] = null, this._blendFunctionParameters[2] = null, this._blendFunctionParameters[3] = null, this._blendEquationParameters[0] = null, this._blendEquationParameters[1] = null, this._blendConstants[0] = null, this._blendConstants[1] = null, this._blendConstants[2] = null, this._blendConstants[3] = null, this._isAlphaBlendDirty = !0, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this._isBlendConstantsDirty = !1;\n    }, e.prototype.apply = function (e) {\n      this.isDirty && (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND), this._isAlphaBlendDirty = !1), this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]), this._isBlendFunctionParametersDirty = !1), this._isBlendEquationParametersDirty && (e.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]), this._isBlendEquationParametersDirty = !1), this._isBlendConstantsDirty && (e.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]), this._isBlendConstantsDirty = !1));\n    }, e;\n  }(), d._AlphaState = f, p = $a || ($a = {}), _ = function () {\n    function e() {\n      this._isDepthTestDirty = !1, this._isDepthMaskDirty = !1, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this._isFrontFaceDirty = !1, this.reset();\n    }\n\n    return Object.defineProperty(e.prototype, \"isDirty\", {\n      get: function () {\n        return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"zOffset\", {\n      get: function () {\n        return this._zOffset;\n      },\n      set: function (e) {\n        this._zOffset !== e && (this._zOffset = e, this._isZOffsetDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"cullFace\", {\n      get: function () {\n        return this._cullFace;\n      },\n      set: function (e) {\n        this._cullFace !== e && (this._cullFace = e, this._isCullFaceDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"cull\", {\n      get: function () {\n        return this._cull;\n      },\n      set: function (e) {\n        this._cull !== e && (this._cull = e, this._isCullDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"depthFunc\", {\n      get: function () {\n        return this._depthFunc;\n      },\n      set: function (e) {\n        this._depthFunc !== e && (this._depthFunc = e, this._isDepthFuncDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"depthMask\", {\n      get: function () {\n        return this._depthMask;\n      },\n      set: function (e) {\n        this._depthMask !== e && (this._depthMask = e, this._isDepthMaskDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"depthTest\", {\n      get: function () {\n        return this._depthTest;\n      },\n      set: function (e) {\n        this._depthTest !== e && (this._depthTest = e, this._isDepthTestDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"frontFace\", {\n      get: function () {\n        return this._frontFace;\n      },\n      set: function (e) {\n        this._frontFace !== e && (this._frontFace = e, this._isFrontFaceDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.reset = function () {\n      this._depthMask = !0, this._depthTest = !0, this._depthFunc = null, this._cullFace = null, this._cull = null, this._zOffset = 0, this._frontFace = null, this._isDepthTestDirty = !0, this._isDepthMaskDirty = !0, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this._isFrontFaceDirty = !1;\n    }, e.prototype.apply = function (e) {\n      this.isDirty && (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this._isCullDirty = !1), this._isCullFaceDirty && (e.cullFace(this.cullFace), this._isCullFaceDirty = !1), this._isDepthMaskDirty && (e.depthMask(this.depthMask), this._isDepthMaskDirty = !1), this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this._isDepthTestDirty = !1), this._isDepthFuncDirty && (e.depthFunc(this.depthFunc), this._isDepthFuncDirty = !1), this._isZOffsetDirty && (this.zOffset ? (e.enable(e.POLYGON_OFFSET_FILL), e.polygonOffset(this.zOffset, 0)) : e.disable(e.POLYGON_OFFSET_FILL), this._isZOffsetDirty = !1), this._isFrontFaceDirty && (e.frontFace(this.frontFace), this._isFrontFaceDirty = !1));\n    }, e;\n  }(), p._DepthCullingState = _, g = $a || ($a = {}), v = function () {\n    function e() {\n      this._isStencilTestDirty = !1, this._isStencilMaskDirty = !1, this._isStencilFuncDirty = !1, this._isStencilOpDirty = !1, this.reset();\n    }\n\n    return Object.defineProperty(e.prototype, \"isDirty\", {\n      get: function () {\n        return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilFunc\", {\n      get: function () {\n        return this._stencilFunc;\n      },\n      set: function (e) {\n        this._stencilFunc !== e && (this._stencilFunc = e, this._isStencilFuncDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilFuncRef\", {\n      get: function () {\n        return this._stencilFuncRef;\n      },\n      set: function (e) {\n        this._stencilFuncRef !== e && (this._stencilFuncRef = e, this._isStencilFuncDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilFuncMask\", {\n      get: function () {\n        return this._stencilFuncMask;\n      },\n      set: function (e) {\n        this._stencilFuncMask !== e && (this._stencilFuncMask = e, this._isStencilFuncDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilOpStencilFail\", {\n      get: function () {\n        return this._stencilOpStencilFail;\n      },\n      set: function (e) {\n        this._stencilOpStencilFail !== e && (this._stencilOpStencilFail = e, this._isStencilOpDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilOpDepthFail\", {\n      get: function () {\n        return this._stencilOpDepthFail;\n      },\n      set: function (e) {\n        this._stencilOpDepthFail !== e && (this._stencilOpDepthFail = e, this._isStencilOpDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilOpStencilDepthPass\", {\n      get: function () {\n        return this._stencilOpStencilDepthPass;\n      },\n      set: function (e) {\n        this._stencilOpStencilDepthPass !== e && (this._stencilOpStencilDepthPass = e, this._isStencilOpDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilMask\", {\n      get: function () {\n        return this._stencilMask;\n      },\n      set: function (e) {\n        this._stencilMask !== e && (this._stencilMask = e, this._isStencilMaskDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"stencilTest\", {\n      get: function () {\n        return this._stencilTest;\n      },\n      set: function (e) {\n        this._stencilTest !== e && (this._stencilTest = e, this._isStencilTestDirty = !0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.reset = function () {\n      this._stencilTest = !1, this._stencilMask = 255, this._stencilFunc = g.Engine.ALWAYS, this._stencilFuncRef = 1, this._stencilFuncMask = 255, this._stencilOpStencilFail = g.Engine.KEEP, this._stencilOpDepthFail = g.Engine.KEEP, this._stencilOpStencilDepthPass = g.Engine.REPLACE, this._isStencilTestDirty = !0, this._isStencilMaskDirty = !0, this._isStencilFuncDirty = !0, this._isStencilOpDirty = !0;\n    }, e.prototype.apply = function (e) {\n      this.isDirty && (this._isStencilTestDirty && (this.stencilTest ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this._isStencilTestDirty = !1), this._isStencilMaskDirty && (e.stencilMask(this.stencilMask), this._isStencilMaskDirty = !1), this._isStencilFuncDirty && (e.stencilFunc(this.stencilFunc, this.stencilFuncRef, this.stencilFuncMask), this._isStencilFuncDirty = !1), this._isStencilOpDirty && (e.stencilOp(this.stencilOpStencilFail, this.stencilOpDepthFail, this.stencilOpStencilDepthPass), this._isStencilOpDirty = !1));\n    }, e;\n  }(), g._StencilState = v;\n\n  var y,\n      E,\n      x,\n      P,\n      A,\n      S,\n      M,\n      R,\n      C,\n      O,\n      D,\n      I,\n      w,\n      L,\n      F,\n      B,\n      N,\n      V,\n      U,\n      z,\n      G,\n      k,\n      W,\n      H,\n      X,\n      j,\n      Y,\n      K,\n      Q,\n      Z,\n      q,\n      J,\n      $,\n      ee,\n      te,\n      ie,\n      re,\n      ne,\n      oe,\n      se,\n      ae = this && this.__assign || function () {\n    return (ae = Object.assign || function (e) {\n      for (var t, i = 1, r = arguments.length; i < r; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n      return e;\n    }).apply(this, arguments);\n  };\n\n  !function (R) {\n    var b = function () {},\n        e = function () {};\n\n    R.InstancingAttributeInfo = e;\n\n    var h = function () {};\n\n    R.RenderTargetCreationOptions = h;\n\n    var t = function () {};\n\n    R.DepthTextureCreationOptions = t;\n\n    var l = function () {};\n\n    R.EngineCapabilities = l;\n\n    var i = function () {\n      function M(e, t, i, r) {\n        void 0 === r && (r = !1);\n        var n = this;\n        this.forcePOTTextures = !1, this.isFullscreen = !1, this.isPointerLock = !1, this.cullBackFaces = !0, this.renderEvenInBackground = !0, this.preventCacheWipeBetweenFrames = !1, this.enableOfflineSupport = !1, this.disableManifestCheck = !1, this.scenes = new Array(), this.postProcesses = new Array(), this.validateShaderPrograms = !1, this.onResizeObservable = new R.Observable(), this.onCanvasBlurObservable = new R.Observable(), this.onCanvasFocusObservable = new R.Observable(), this.onCanvasPointerOutObservable = new R.Observable(), this.onBeforeTextureInitObservable = new R.Observable(), this._vrDisplay = void 0, this._vrSupported = !1, this._vrExclusivePointerMode = !1, this.disableUniformBuffers = !1, this._uniformBuffers = new Array(), this.onBeginFrameObservable = new R.Observable(), this.onEndFrameObservable = new R.Observable(), this.onBeforeShaderCompilationObservable = new R.Observable(), this.onAfterShaderCompilationObservable = new R.Observable(), this._windowIsBackground = !1, this._webGLVersion = 1, this._badOS = !1, this._badDesktopOS = !1, this.disableTextureBindingOptimization = !1, this.onVRDisplayChangedObservable = new R.Observable(), this.onVRRequestPresentComplete = new R.Observable(), this.onVRRequestPresentStart = new R.Observable(), this._colorWrite = !0, this._drawCalls = new R.PerfCounter(), this._textureCollisions = new R.PerfCounter(), this._renderingQueueLaunched = !1, this._activeRenderLoops = new Array(), this._deterministicLockstep = !1, this._lockstepMaxSteps = 4, this.onContextLostObservable = new R.Observable(), this.onContextRestoredObservable = new R.Observable(), this._contextWasLost = !1, this._doNotHandleContextLost = !1, this._performanceMonitor = new R.PerformanceMonitor(), this._fps = 60, this._deltaTime = 0, this.disablePerformanceMonitorInBackground = !1, this._depthCullingState = new R._DepthCullingState(), this._stencilState = new R._StencilState(), this._alphaState = new R._AlphaState(), this._alphaMode = M.ALPHA_DISABLE, this._internalTexturesCache = new Array(), this._activeChannel = 0, this._currentTextureChannel = -1, this._boundTexturesCache = {}, this._compiledEffects = {}, this._vertexAttribArraysEnabled = [], this._uintIndicesCurrentlySet = !1, this._currentBoundBuffer = new Array(), this._currentFramebuffer = null, this._currentBufferPointers = new Array(), this._currentInstanceLocations = new Array(), this._currentInstanceBuffers = new Array(), this._firstBoundInternalTextureTracker = new R.DummyInternalTextureTracker(), this._lastBoundInternalTextureTracker = new R.DummyInternalTextureTracker(), this._vaoRecordInProgress = !1, this._mustWipeVertexAttributes = !1, this._nextFreeTextureSlots = new Array(), this._maxSimultaneousTextures = 0, this._activeRequests = new Array(), this._texturesSupported = new Array(), this.premultipliedAlpha = !0, this._viewportCached = new R.Vector4(0, 0, 0, 0), this._onVRFullScreenTriggered = function () {\n          if (n._vrDisplay && n._vrDisplay.isPresenting) {\n            n._oldSize = new R.Size(n.getRenderWidth(), n.getRenderHeight()), n._oldHardwareScaleFactor = n.getHardwareScalingLevel();\n\n            var e = n._vrDisplay.getEyeParameters(\"left\");\n\n            n.setHardwareScalingLevel(1), n.setSize(2 * e.renderWidth, e.renderHeight);\n          } else n.setHardwareScalingLevel(n._oldHardwareScaleFactor), n.setSize(n._oldSize.width, n._oldSize.height);\n        }, this._unpackFlipYCached = null, this.enableUnpackFlipYCached = !0, this._boundUniforms = {}, R.PromisePolyfill.Apply();\n        var o = null;\n\n        if (M.Instances.push(this), e) {\n          if (i = i || {}, e.getContext) {\n            if (o = e, this._renderingCanvas = o, null != t && (i.antialias = t), void 0 === i.deterministicLockstep && (i.deterministicLockstep = !1), void 0 === i.lockstepMaxSteps && (i.lockstepMaxSteps = 4), void 0 === i.preserveDrawingBuffer && (i.preserveDrawingBuffer = !1), void 0 === i.audioEngine && (i.audioEngine = !0), void 0 === i.stencil && (i.stencil = !0), !1 === i.premultipliedAlpha && (this.premultipliedAlpha = !1), this._deterministicLockstep = i.deterministicLockstep, this._lockstepMaxSteps = i.lockstepMaxSteps, this._doNotHandleContextLost = !!i.doNotHandleContextLost, navigator && navigator.userAgent) for (var s = navigator.userAgent, a = 0, l = M.ExceptionList; a < l.length; a++) {\n              var c = l[a],\n                  h = c.key,\n                  u = c.targets;\n\n              if (-1 < s.indexOf(h)) {\n                if (c.capture && c.captureConstraint) {\n                  var d = c.capture,\n                      f = c.captureConstraint,\n                      p = new RegExp(d).exec(s);\n                  if (p && 0 < p.length) if (f <= parseInt(p[p.length - 1])) continue;\n                }\n\n                for (var _ = 0, m = u; _ < m.length; _++) {\n                  switch (m[_]) {\n                    case \"uniformBuffer\":\n                      this.disableUniformBuffers = !0;\n                      break;\n\n                    case \"textureBindingOptimization\":\n                      this.disableTextureBindingOptimization = !0;\n                  }\n                }\n              }\n            }\n            if (!i.disableWebGL2Support) try {\n              this._gl = o.getContext(\"webgl2\", i) || o.getContext(\"experimental-webgl2\", i), this._gl && (this._webGLVersion = 2, this._gl.deleteQuery || (this._webGLVersion = 1));\n            } catch (e) {}\n\n            if (!this._gl) {\n              if (!o) throw new Error(\"The provided canvas is null or undefined.\");\n\n              try {\n                this._gl = o.getContext(\"webgl\", i) || o.getContext(\"experimental-webgl\", i);\n              } catch (e) {\n                throw new Error(\"WebGL not supported\");\n              }\n            }\n\n            if (!this._gl) throw new Error(\"WebGL not supported\");\n            this._onCanvasFocus = function () {\n              n.onCanvasFocusObservable.notifyObservers(n);\n            }, this._onCanvasBlur = function () {\n              n.onCanvasBlurObservable.notifyObservers(n);\n            }, o.addEventListener(\"focus\", this._onCanvasFocus), o.addEventListener(\"blur\", this._onCanvasBlur), this._onBlur = function () {\n              n.disablePerformanceMonitorInBackground && n._performanceMonitor.disable(), n._windowIsBackground = !0;\n            }, this._onFocus = function () {\n              n.disablePerformanceMonitorInBackground && n._performanceMonitor.enable(), n._windowIsBackground = !1;\n            }, this._onCanvasPointerOut = function (e) {\n              n.onCanvasPointerOutObservable.notifyObservers(e);\n            }, window.addEventListener(\"blur\", this._onBlur), window.addEventListener(\"focus\", this._onFocus), o.addEventListener(\"pointerout\", this._onCanvasPointerOut), this._doNotHandleContextLost || (this._onContextLost = function (e) {\n              e.preventDefault(), n._contextWasLost = !0, R.Tools.Warn(\"WebGL context lost.\"), n.onContextLostObservable.notifyObservers(n);\n            }, this._onContextRestored = function (e) {\n              setTimeout(function () {\n                n._initGLContext(), n._rebuildEffects(), n._rebuildInternalTextures(), n._rebuildBuffers(), n.wipeCaches(!0), R.Tools.Warn(\"WebGL context successfully restored.\"), n.onContextRestoredObservable.notifyObservers(n), n._contextWasLost = !1;\n              }, 0);\n            }, o.addEventListener(\"webglcontextlost\", this._onContextLost, !1), o.addEventListener(\"webglcontextrestored\", this._onContextRestored, !1));\n          } else {\n            this._gl = e, this._renderingCanvas = this._gl.canvas, this._gl.renderbufferStorageMultisample && (this._webGLVersion = 2);\n\n            var g = this._gl.getContextAttributes();\n\n            g && (i.stencil = g.stencil);\n          }\n\n          var v = i.limitDeviceRatio || window.devicePixelRatio || 1;\n          this._hardwareScalingLevel = r ? 1 / Math.min(v, window.devicePixelRatio || 1) : 1, this.resize(), this._isStencilEnable = !!i.stencil, this._initGLContext(), o && (this._onFullscreenChange = function () {\n            void 0 !== document.fullscreen ? n.isFullscreen = document.fullscreen : void 0 !== document.mozFullScreen ? n.isFullscreen = document.mozFullScreen : void 0 !== document.webkitIsFullScreen ? n.isFullscreen = document.webkitIsFullScreen : void 0 !== document.msIsFullScreen && (n.isFullscreen = document.msIsFullScreen), n.isFullscreen && n._pointerLockRequested && o && (o.requestPointerLock = o.requestPointerLock || o.msRequestPointerLock || o.mozRequestPointerLock || o.webkitRequestPointerLock, o.requestPointerLock && o.requestPointerLock());\n          }, document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, !1), document.addEventListener(\"mozfullscreenchange\", this._onFullscreenChange, !1), document.addEventListener(\"webkitfullscreenchange\", this._onFullscreenChange, !1), document.addEventListener(\"msfullscreenchange\", this._onFullscreenChange, !1), this._onPointerLockChange = function () {\n            n.isPointerLock = document.mozPointerLockElement === o || document.webkitPointerLockElement === o || document.msPointerLockElement === o || document.pointerLockElement === o;\n          }, document.addEventListener(\"pointerlockchange\", this._onPointerLockChange, !1), document.addEventListener(\"mspointerlockchange\", this._onPointerLockChange, !1), document.addEventListener(\"mozpointerlockchange\", this._onPointerLockChange, !1), document.addEventListener(\"webkitpointerlockchange\", this._onPointerLockChange, !1), this._onVRDisplayPointerRestricted = function () {\n            o && o.requestPointerLock();\n          }, this._onVRDisplayPointerUnrestricted = function () {\n            document.exitPointerLock();\n          }, window.addEventListener(\"vrdisplaypointerrestricted\", this._onVRDisplayPointerRestricted, !1), window.addEventListener(\"vrdisplaypointerunrestricted\", this._onVRDisplayPointerUnrestricted, !1)), !M.audioEngine && i.audioEngine && M.AudioEngineFactory && (M.audioEngine = M.AudioEngineFactory(this.getRenderingCanvas()));\n\n          for (var y = 0; y < this._caps.maxVertexAttribs; y++) this._currentBufferPointers[y] = new b();\n\n          this._linkTrackers(this._firstBoundInternalTextureTracker, this._lastBoundInternalTextureTracker), i.autoEnableWebVR && this.initWebVR(), this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent), this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), console.log(\"Babylon.js engine (v\" + M.Version + \") launched\"), this.enableOfflineSupport = void 0 !== R.Database;\n        }\n      }\n\n      return Object.defineProperty(M, \"LastCreatedEngine\", {\n        get: function () {\n          return 0 === M.Instances.length ? null : M.Instances[M.Instances.length - 1];\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M, \"LastCreatedScene\", {\n        get: function () {\n          var e = M.LastCreatedEngine;\n          return e ? 0 === e.scenes.length ? null : e.scenes[e.scenes.length - 1] : null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), M.MarkAllMaterialsAsDirty = function (e, t) {\n        for (var i = 0; i < M.Instances.length; i++) for (var r = M.Instances[i], n = 0; n < r.scenes.length; n++) r.scenes[n].markAllMaterialsAsDirty(e, t);\n      }, Object.defineProperty(M, \"Version\", {\n        get: function () {\n          return \"3.3.0\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"isInVRExclusivePointerMode\", {\n        get: function () {\n          return this._vrExclusivePointerMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"supportsUniformBuffers\", {\n        get: function () {\n          return 1 < this.webGLVersion && !this.disableUniformBuffers;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"needPOTTextures\", {\n        get: function () {\n          return this._webGLVersion < 2 || this.forcePOTTextures;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"doNotHandleContextLost\", {\n        get: function () {\n          return this._doNotHandleContextLost;\n        },\n        set: function (e) {\n          this._doNotHandleContextLost = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"performanceMonitor\", {\n        get: function () {\n          return this._performanceMonitor;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"texturesSupported\", {\n        get: function () {\n          return this._texturesSupported;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"textureFormatInUse\", {\n        get: function () {\n          return this._textureFormatInUse;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"currentViewport\", {\n        get: function () {\n          return this._cachedViewport;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"emptyTexture\", {\n        get: function () {\n          return this._emptyTexture || (this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, M.TEXTUREFORMAT_RGBA, !1, !1, M.TEXTURE_NEAREST_SAMPLINGMODE)), this._emptyTexture;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"emptyTexture3D\", {\n        get: function () {\n          return this._emptyTexture3D || (this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, M.TEXTUREFORMAT_RGBA, !1, !1, M.TEXTURE_NEAREST_SAMPLINGMODE)), this._emptyTexture3D;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"emptyCubeTexture\", {\n        get: function () {\n          if (!this._emptyCubeTexture) {\n            var e = new Uint8Array(4),\n                t = [e, e, e, e, e, e];\n            this._emptyCubeTexture = this.createRawCubeTexture(t, 1, M.TEXTUREFORMAT_RGBA, M.TEXTURETYPE_UNSIGNED_INT, !1, !1, M.TEXTURE_NEAREST_SAMPLINGMODE);\n          }\n\n          return this._emptyCubeTexture;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), M.prototype._rebuildInternalTextures = function () {\n        for (var e = 0, t = this._internalTexturesCache.slice(); e < t.length; e++) {\n          t[e]._rebuild();\n        }\n      }, M.prototype._rebuildEffects = function () {\n        for (var e in this._compiledEffects) {\n          this._compiledEffects[e]._prepareEffect();\n        }\n\n        R.Effect.ResetCache();\n      }, M.prototype._rebuildBuffers = function () {\n        for (var e = 0, t = this.scenes; e < t.length; e++) {\n          var i = t[e];\n          i.resetCachedMaterial(), i._rebuildGeometries(), i._rebuildTextures();\n        }\n\n        for (var r = 0, n = this._uniformBuffers; r < n.length; r++) {\n          n[r]._rebuild();\n        }\n      }, M.prototype._initGLContext = function () {\n        this._caps = new l(), this._caps.maxTexturesImageUnits = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS), this._caps.maxCombinedTexturesImageUnits = this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS), this._caps.maxVertexTextureImageUnits = this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this._caps.maxTextureSize = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE), this._caps.maxCubemapTextureSize = this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE), this._caps.maxRenderTextureSize = this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE), this._caps.maxVertexAttribs = this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS), this._caps.maxVaryingVectors = this._gl.getParameter(this._gl.MAX_VARYING_VECTORS), this._caps.maxFragmentUniformVectors = this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS), this._caps.maxVertexUniformVectors = this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS), this._glVersion = this._gl.getParameter(this._gl.VERSION);\n\n        var e = this._gl.getExtension(\"WEBGL_debug_renderer_info\");\n\n        if (null != e && (this._glRenderer = this._gl.getParameter(e.UNMASKED_RENDERER_WEBGL), this._glVendor = this._gl.getParameter(e.UNMASKED_VENDOR_WEBGL)), this._glVendor || (this._glVendor = \"Unknown vendor\"), this._glRenderer || (this._glRenderer = \"Unknown renderer\"), this._gl.HALF_FLOAT_OES = 36193, 34842 !== this._gl.RGBA16F && (this._gl.RGBA16F = 34842), 34836 !== this._gl.RGBA32F && (this._gl.RGBA32F = 34836), 35056 !== this._gl.DEPTH24_STENCIL8 && (this._gl.DEPTH24_STENCIL8 = 35056), this._caps.standardDerivatives = 1 < this._webGLVersion || null !== this._gl.getExtension(\"OES_standard_derivatives\"), this._caps.astc = this._gl.getExtension(\"WEBGL_compressed_texture_astc\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_astc\"), this._caps.s3tc = this._gl.getExtension(\"WEBGL_compressed_texture_s3tc\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\"), this._caps.pvrtc = this._gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"), this._caps.etc1 = this._gl.getExtension(\"WEBGL_compressed_texture_etc1\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_etc1\"), this._caps.etc2 = this._gl.getExtension(\"WEBGL_compressed_texture_etc\") || this._gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_etc\") || this._gl.getExtension(\"WEBGL_compressed_texture_es3_0\"), this._caps.textureAnisotropicFilterExtension = this._gl.getExtension(\"EXT_texture_filter_anisotropic\") || this._gl.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\") || this._gl.getExtension(\"MOZ_EXT_texture_filter_anisotropic\"), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this._caps.uintIndices = 1 < this._webGLVersion || null !== this._gl.getExtension(\"OES_element_index_uint\"), this._caps.fragmentDepthSupported = 1 < this._webGLVersion || null !== this._gl.getExtension(\"EXT_frag_depth\"), this._caps.highPrecisionShaderSupported = !0, this._caps.timerQuery = this._gl.getExtension(\"EXT_disjoint_timer_query_webgl2\") || this._gl.getExtension(\"EXT_disjoint_timer_query\"), this._caps.timerQuery && (1 === this._webGLVersion && (this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)), this._caps.canUseTimestampForTimerQuery = 0 < this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)), this._caps.colorBufferFloat = 1 < this._webGLVersion && this._gl.getExtension(\"EXT_color_buffer_float\"), this._caps.textureFloat = !!(1 < this._webGLVersion || this._gl.getExtension(\"OES_texture_float\")), this._caps.textureFloatLinearFiltering = !(!this._caps.textureFloat || !this._gl.getExtension(\"OES_texture_float_linear\")), this._caps.textureFloatRender = !(!this._caps.textureFloat || !this._canRenderToFloatFramebuffer()), this._caps.textureHalfFloat = !!(1 < this._webGLVersion || this._gl.getExtension(\"OES_texture_half_float\")), this._caps.textureHalfFloatLinearFiltering = !!(1 < this._webGLVersion || this._caps.textureHalfFloat && this._gl.getExtension(\"OES_texture_half_float_linear\")), 1 < this._webGLVersion && (this._gl.HALF_FLOAT_OES = 5131), this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(), this._caps.textureLOD = !!(1 < this._webGLVersion || this._gl.getExtension(\"EXT_shader_texture_lod\")), 1 < this._webGLVersion) this._caps.drawBuffersExtension = !0;else {\n          var t = this._gl.getExtension(\"WEBGL_draw_buffers\");\n\n          if (null !== t) {\n            this._caps.drawBuffersExtension = !0, this._gl.drawBuffers = t.drawBuffersWEBGL.bind(t), this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;\n\n            for (var i = 0; i < 16; i++) this._gl[\"COLOR_ATTACHMENT\" + i + \"_WEBGL\"] = t[\"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n          } else this._caps.drawBuffersExtension = !1;\n        }\n        if (1 < this._webGLVersion) this._caps.depthTextureExtension = !0;else {\n          var r = this._gl.getExtension(\"WEBGL_depth_texture\");\n\n          null != r && (this._caps.depthTextureExtension = !0, this._gl.UNSIGNED_INT_24_8 = r.UNSIGNED_INT_24_8_WEBGL);\n        }\n        if (1 < this._webGLVersion) this._caps.vertexArrayObject = !0;else {\n          var n = this._gl.getExtension(\"OES_vertex_array_object\");\n\n          null != n ? (this._caps.vertexArrayObject = !0, this._gl.createVertexArray = n.createVertexArrayOES.bind(n), this._gl.bindVertexArray = n.bindVertexArrayOES.bind(n), this._gl.deleteVertexArray = n.deleteVertexArrayOES.bind(n)) : this._caps.vertexArrayObject = !1;\n        }\n        if (1 < this._webGLVersion) this._caps.instancedArrays = !0;else {\n          var o = this._gl.getExtension(\"ANGLE_instanced_arrays\");\n\n          null != o ? (this._caps.instancedArrays = !0, this._gl.drawArraysInstanced = o.drawArraysInstancedANGLE.bind(o), this._gl.drawElementsInstanced = o.drawElementsInstancedANGLE.bind(o), this._gl.vertexAttribDivisor = o.vertexAttribDivisorANGLE.bind(o)) : this._caps.instancedArrays = !1;\n        }\n\n        if (this._caps.astc && this.texturesSupported.push(\"-astc.ktx\"), this._caps.s3tc && this.texturesSupported.push(\"-dxt.ktx\"), this._caps.pvrtc && this.texturesSupported.push(\"-pvrtc.ktx\"), this._caps.etc2 && this.texturesSupported.push(\"-etc2.ktx\"), this._caps.etc1 && this.texturesSupported.push(\"-etc1.ktx\"), this._gl.getShaderPrecisionFormat) {\n          var s = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);\n\n          s && (this._caps.highPrecisionShaderSupported = 0 !== s.precision);\n        }\n\n        this.setDepthBuffer(!0), this.setDepthFunctionToLessOrEqual(), this.setDepthWrite(!0), this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;\n\n        for (var a = 0; a < this._maxSimultaneousTextures; a++) this._nextFreeTextureSlots.push(a);\n      }, Object.defineProperty(M.prototype, \"webGLVersion\", {\n        get: function () {\n          return this._webGLVersion;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"isStencilEnable\", {\n        get: function () {\n          return this._isStencilEnable;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), M.prototype._prepareWorkingCanvas = function () {\n        if (!this._workingCanvas) {\n          this._workingCanvas = document.createElement(\"canvas\");\n\n          var e = this._workingCanvas.getContext(\"2d\");\n\n          e && (this._workingContext = e);\n        }\n      }, M.prototype.resetTextureCache = function () {\n        for (var e in this._boundTexturesCache) if (this._boundTexturesCache.hasOwnProperty(e)) {\n          var t = this._boundTexturesCache[e];\n          t && this._removeDesignatedSlot(t), this._boundTexturesCache[e] = null;\n        }\n\n        if (!this.disableTextureBindingOptimization) {\n          this._nextFreeTextureSlots = [];\n\n          for (var i = 0; i < this._maxSimultaneousTextures; i++) this._nextFreeTextureSlots.push(i);\n        }\n\n        this._currentTextureChannel = -1;\n      }, M.prototype.isDeterministicLockStep = function () {\n        return this._deterministicLockstep;\n      }, M.prototype.getLockstepMaxSteps = function () {\n        return this._lockstepMaxSteps;\n      }, M.prototype.getGlInfo = function () {\n        return {\n          vendor: this._glVendor,\n          renderer: this._glRenderer,\n          version: this._glVersion\n        };\n      }, M.prototype.getAspectRatio = function (e, t) {\n        void 0 === t && (t = !1);\n        var i = e.viewport;\n        return this.getRenderWidth(t) * i.width / (this.getRenderHeight(t) * i.height);\n      }, M.prototype.getScreenAspectRatio = function () {\n        return this.getRenderWidth(!0) / this.getRenderHeight(!0);\n      }, M.prototype.getRenderWidth = function (e) {\n        return void 0 === e && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._gl.drawingBufferWidth;\n      }, M.prototype.getRenderHeight = function (e) {\n        return void 0 === e && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._gl.drawingBufferHeight;\n      }, M.prototype.getRenderingCanvas = function () {\n        return this._renderingCanvas;\n      }, M.prototype.getRenderingCanvasClientRect = function () {\n        return this._renderingCanvas ? this._renderingCanvas.getBoundingClientRect() : null;\n      }, M.prototype.setHardwareScalingLevel = function (e) {\n        this._hardwareScalingLevel = e, this.resize();\n      }, M.prototype.getHardwareScalingLevel = function () {\n        return this._hardwareScalingLevel;\n      }, M.prototype.getLoadedTexturesCache = function () {\n        return this._internalTexturesCache;\n      }, M.prototype.getCaps = function () {\n        return this._caps;\n      }, Object.defineProperty(M.prototype, \"drawCalls\", {\n        get: function () {\n          return R.Tools.Warn(\"drawCalls is deprecated. Please use SceneInstrumentation class\"), 0;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"drawCallsPerfCounter\", {\n        get: function () {\n          return R.Tools.Warn(\"drawCallsPerfCounter is deprecated. Please use SceneInstrumentation class\"), null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), M.prototype.getDepthFunction = function () {\n        return this._depthCullingState.depthFunc;\n      }, M.prototype.setDepthFunction = function (e) {\n        this._depthCullingState.depthFunc = e;\n      }, M.prototype.setDepthFunctionToGreater = function () {\n        this._depthCullingState.depthFunc = this._gl.GREATER;\n      }, M.prototype.setDepthFunctionToGreaterOrEqual = function () {\n        this._depthCullingState.depthFunc = this._gl.GEQUAL;\n      }, M.prototype.setDepthFunctionToLess = function () {\n        this._depthCullingState.depthFunc = this._gl.LESS;\n      }, M.prototype.setDepthFunctionToLessOrEqual = function () {\n        this._depthCullingState.depthFunc = this._gl.LEQUAL;\n      }, M.prototype.getStencilBuffer = function () {\n        return this._stencilState.stencilTest;\n      }, M.prototype.setStencilBuffer = function (e) {\n        this._stencilState.stencilTest = e;\n      }, M.prototype.getStencilMask = function () {\n        return this._stencilState.stencilMask;\n      }, M.prototype.setStencilMask = function (e) {\n        this._stencilState.stencilMask = e;\n      }, M.prototype.getStencilFunction = function () {\n        return this._stencilState.stencilFunc;\n      }, M.prototype.getStencilFunctionReference = function () {\n        return this._stencilState.stencilFuncRef;\n      }, M.prototype.getStencilFunctionMask = function () {\n        return this._stencilState.stencilFuncMask;\n      }, M.prototype.setStencilFunction = function (e) {\n        this._stencilState.stencilFunc = e;\n      }, M.prototype.setStencilFunctionReference = function (e) {\n        this._stencilState.stencilFuncRef = e;\n      }, M.prototype.setStencilFunctionMask = function (e) {\n        this._stencilState.stencilFuncMask = e;\n      }, M.prototype.getStencilOperationFail = function () {\n        return this._stencilState.stencilOpStencilFail;\n      }, M.prototype.getStencilOperationDepthFail = function () {\n        return this._stencilState.stencilOpDepthFail;\n      }, M.prototype.getStencilOperationPass = function () {\n        return this._stencilState.stencilOpStencilDepthPass;\n      }, M.prototype.setStencilOperationFail = function (e) {\n        this._stencilState.stencilOpStencilFail = e;\n      }, M.prototype.setStencilOperationDepthFail = function (e) {\n        this._stencilState.stencilOpDepthFail = e;\n      }, M.prototype.setStencilOperationPass = function (e) {\n        this._stencilState.stencilOpStencilDepthPass = e;\n      }, M.prototype.setDitheringState = function (e) {\n        e ? this._gl.enable(this._gl.DITHER) : this._gl.disable(this._gl.DITHER);\n      }, M.prototype.setRasterizerState = function (e) {\n        e ? this._gl.disable(this._gl.RASTERIZER_DISCARD) : this._gl.enable(this._gl.RASTERIZER_DISCARD);\n      }, M.prototype.stopRenderLoop = function (e) {\n        if (e) {\n          var t = this._activeRenderLoops.indexOf(e);\n\n          0 <= t && this._activeRenderLoops.splice(t, 1);\n        } else this._activeRenderLoops = [];\n      }, M.prototype._renderLoop = function () {\n        if (!this._contextWasLost) {\n          var e = !0;\n\n          if (!this.renderEvenInBackground && this._windowIsBackground && (e = !1), e) {\n            this.beginFrame();\n\n            for (var t = 0; t < this._activeRenderLoops.length; t++) {\n              (0, this._activeRenderLoops[t])();\n            }\n\n            this.endFrame();\n          }\n        }\n\n        if (0 < this._activeRenderLoops.length) {\n          var i = null;\n          this._vrDisplay && this._vrDisplay.isPresenting && (i = this._vrDisplay), this._frameHandler = R.Tools.QueueNewFrame(this._bindedRenderFunction, i);\n        } else this._renderingQueueLaunched = !1;\n      }, M.prototype.runRenderLoop = function (e) {\n        -1 === this._activeRenderLoops.indexOf(e) && (this._activeRenderLoops.push(e), this._renderingQueueLaunched || (this._renderingQueueLaunched = !0, this._bindedRenderFunction = this._renderLoop.bind(this), this._frameHandler = R.Tools.QueueNewFrame(this._bindedRenderFunction)));\n      }, M.prototype.switchFullscreen = function (e) {\n        this.isFullscreen ? R.Tools.ExitFullscreen() : (this._pointerLockRequested = e, this._renderingCanvas && R.Tools.RequestFullscreen(this._renderingCanvas));\n      }, M.prototype.clear = function (e, t, i, r) {\n        void 0 === r && (r = !1), this.applyStates();\n        var n = 0;\n        t && e && (this._gl.clearColor(e.r, e.g, e.b, void 0 !== e.a ? e.a : 1), n |= this._gl.COLOR_BUFFER_BIT), i && (this._gl.clearDepth(1), n |= this._gl.DEPTH_BUFFER_BIT), r && (this._gl.clearStencil(0), n |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(n);\n      }, M.prototype.scissorClear = function (e, t, i, r, n) {\n        var o = this._gl,\n            s = o.getParameter(o.SCISSOR_TEST),\n            a = o.getParameter(o.SCISSOR_BOX);\n        o.enable(o.SCISSOR_TEST), o.scissor(e, t, i, r), this.clear(n, !0, !0, !0), o.scissor(a[0], a[1], a[2], a[3]), !0 === s ? o.enable(o.SCISSOR_TEST) : o.disable(o.SCISSOR_TEST);\n      }, M.prototype._viewport = function (e, t, i, r) {\n        e === this._viewportCached.x && t === this._viewportCached.y && i === this._viewportCached.z && r === this._viewportCached.w || (this._viewportCached.x = e, this._viewportCached.y = t, this._viewportCached.z = i, this._viewportCached.w = r, this._gl.viewport(e, t, i, r));\n      }, M.prototype.setViewport = function (e, t, i) {\n        var r = t || this.getRenderWidth(),\n            n = i || this.getRenderHeight(),\n            o = e.x || 0,\n            s = e.y || 0;\n        this._cachedViewport = e, this._viewport(o * r, s * n, r * e.width, n * e.height);\n      }, M.prototype.setDirectViewport = function (e, t, i, r) {\n        var n = this._cachedViewport;\n        return this._cachedViewport = null, this._viewport(e, t, i, r), n;\n      }, M.prototype.beginFrame = function () {\n        this.onBeginFrameObservable.notifyObservers(this), this._measureFps();\n      }, M.prototype.endFrame = function () {\n        this._badOS && this.flushFramebuffer(), this._vrDisplay && this._vrDisplay.isPresenting && this._vrDisplay.submitFrame(), this.onEndFrameObservable.notifyObservers(this);\n      }, M.prototype.resize = function () {\n        if (!this._vrDisplay || !this._vrDisplay.isPresenting) {\n          var e = this._renderingCanvas ? this._renderingCanvas.clientWidth : window.innerWidth,\n              t = this._renderingCanvas ? this._renderingCanvas.clientHeight : window.innerHeight;\n          this.setSize(e / this._hardwareScalingLevel, t / this._hardwareScalingLevel);\n        }\n      }, M.prototype.setSize = function (e, t) {\n        if (this._renderingCanvas && (this._renderingCanvas.width !== e || this._renderingCanvas.height !== t)) {\n          this._renderingCanvas.width = e, this._renderingCanvas.height = t;\n\n          for (var i = 0; i < this.scenes.length; i++) for (var r = this.scenes[i], n = 0; n < r.cameras.length; n++) {\n            r.cameras[n]._currentRenderId = 0;\n          }\n\n          this.onResizeObservable.hasObservers && this.onResizeObservable.notifyObservers(this);\n        }\n      }, M.prototype.isVRDevicePresent = function () {\n        return !!this._vrDisplay;\n      }, M.prototype.getVRDevice = function () {\n        return this._vrDisplay;\n      }, M.prototype.initWebVR = function () {\n        return this.initWebVRAsync(), this.onVRDisplayChangedObservable;\n      }, M.prototype.initWebVRAsync = function () {\n        var i = this,\n            t = function () {\n          var t = {\n            vrDisplay: i._vrDisplay,\n            vrSupported: i._vrSupported\n          };\n          i.onVRDisplayChangedObservable.notifyObservers(t), i._webVRInitPromise = new Promise(function (e) {\n            e(t);\n          });\n        };\n\n        return this._onVrDisplayConnect || (this._onVrDisplayConnect = function (e) {\n          i._vrDisplay = e.display, t();\n        }, this._onVrDisplayDisconnect = function () {\n          i._vrDisplay.cancelAnimationFrame(i._frameHandler), i._vrDisplay = void 0, i._frameHandler = R.Tools.QueueNewFrame(i._bindedRenderFunction), t();\n        }, this._onVrDisplayPresentChange = function () {\n          i._vrExclusivePointerMode = i._vrDisplay && i._vrDisplay.isPresenting;\n        }, window.addEventListener(\"vrdisplayconnect\", this._onVrDisplayConnect), window.addEventListener(\"vrdisplaydisconnect\", this._onVrDisplayDisconnect), window.addEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChange)), this._webVRInitPromise = this._webVRInitPromise || this._getVRDisplaysAsync(), this._webVRInitPromise.then(t), this._webVRInitPromise;\n      }, M.prototype.enableVR = function () {\n        var e = this;\n\n        if (this._vrDisplay && !this._vrDisplay.isPresenting) {\n          this.onVRRequestPresentStart.notifyObservers(this), this._vrDisplay.requestPresent([{\n            source: this.getRenderingCanvas()\n          }]).then(function () {\n            e.onVRRequestPresentComplete.notifyObservers(!0), e._onVRFullScreenTriggered();\n          }).catch(function () {\n            e.onVRRequestPresentComplete.notifyObservers(!1);\n          });\n        }\n      }, M.prototype.disableVR = function () {\n        this._vrDisplay && this._vrDisplay.isPresenting && this._vrDisplay.exitPresent().then(this._onVRFullScreenTriggered).catch(this._onVRFullScreenTriggered);\n      }, M.prototype._getVRDisplaysAsync = function () {\n        var i = this;\n        return new Promise(function (t, e) {\n          navigator.getVRDisplays ? navigator.getVRDisplays().then(function (e) {\n            i._vrSupported = !0, i._vrDisplay = e[0], t({\n              vrDisplay: i._vrDisplay,\n              vrSupported: i._vrSupported\n            });\n          }) : (i._vrDisplay = void 0, i._vrSupported = !1, t({\n            vrDisplay: i._vrDisplay,\n            vrSupported: i._vrSupported\n          }));\n        });\n      }, M.prototype.bindFramebuffer = function (e, t, i, r, n, o, s) {\n        void 0 === s && (s = 0), this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget), this._currentRenderTarget = e, this.bindUnboundFramebuffer(e._MSAAFramebuffer ? e._MSAAFramebuffer : e._framebuffer);\n        var a = this._gl;\n        e.isCube && (void 0 === t && (t = 0), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + t, e._webGLTexture, s), o && (o._generateStencilBuffer ? a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_CUBE_MAP_POSITIVE_X + t, o._webGLTexture, s) : a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.TEXTURE_CUBE_MAP_POSITIVE_X + t, o._webGLTexture, s))), this._cachedViewport && !n ? this.setViewport(this._cachedViewport, i, r) : (i || (i = e.width, s && (i /= Math.pow(2, s))), r || (r = e.height, s && (r /= Math.pow(2, s))), this._viewport(0, 0, i, r)), this.wipeCaches();\n      }, M.prototype.bindUnboundFramebuffer = function (e) {\n        this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._currentFramebuffer = e);\n      }, M.prototype.unBindFramebuffer = function (e, t, i) {\n        void 0 === t && (t = !1), this._currentRenderTarget = null;\n        var r = this._gl;\n        e._MSAAFramebuffer && (r.bindFramebuffer(r.READ_FRAMEBUFFER, e._MSAAFramebuffer), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, e._framebuffer), r.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, r.COLOR_BUFFER_BIT, r.NEAREST)), !e.generateMipMaps || t || e.isCube || (this._bindTextureDirectly(r.TEXTURE_2D, e, !0), r.generateMipmap(r.TEXTURE_2D), this._bindTextureDirectly(r.TEXTURE_2D, null)), i && (e._MSAAFramebuffer && this.bindUnboundFramebuffer(e._framebuffer), i()), this.bindUnboundFramebuffer(null);\n      }, M.prototype.unBindMultiColorAttachmentFramebuffer = function (e, t, i) {\n        void 0 === t && (t = !1), this._currentRenderTarget = null;\n        var r = this._gl;\n\n        if (e[0]._MSAAFramebuffer) {\n          r.bindFramebuffer(r.READ_FRAMEBUFFER, e[0]._MSAAFramebuffer), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, e[0]._framebuffer);\n          var n = e[0]._attachments;\n          n || (n = new Array(e.length), e[0]._attachments = n);\n\n          for (var o = 0; o < e.length; o++) {\n            for (var s = e[o], a = 0; a < n.length; a++) n[a] = r.NONE;\n\n            n[o] = r[1 < this.webGLVersion ? \"COLOR_ATTACHMENT\" + o : \"COLOR_ATTACHMENT\" + o + \"_WEBGL\"], r.readBuffer(n[o]), r.drawBuffers(n), r.blitFramebuffer(0, 0, s.width, s.height, 0, 0, s.width, s.height, r.COLOR_BUFFER_BIT, r.NEAREST);\n          }\n\n          for (o = 0; o < n.length; o++) n[o] = r[1 < this.webGLVersion ? \"COLOR_ATTACHMENT\" + o : \"COLOR_ATTACHMENT\" + o + \"_WEBGL\"];\n\n          r.drawBuffers(n);\n        }\n\n        for (o = 0; o < e.length; o++) {\n          !(s = e[o]).generateMipMaps || t || s.isCube || (this._bindTextureDirectly(r.TEXTURE_2D, s), r.generateMipmap(r.TEXTURE_2D), this._bindTextureDirectly(r.TEXTURE_2D, null));\n        }\n\n        i && (e[0]._MSAAFramebuffer && this.bindUnboundFramebuffer(e[0]._framebuffer), i()), this.bindUnboundFramebuffer(null);\n      }, M.prototype.generateMipMapsForCubemap = function (e) {\n        if (e.generateMipMaps) {\n          var t = this._gl;\n          this._bindTextureDirectly(t.TEXTURE_CUBE_MAP, e, !0), t.generateMipmap(t.TEXTURE_CUBE_MAP), this._bindTextureDirectly(t.TEXTURE_CUBE_MAP, null);\n        }\n      }, M.prototype.flushFramebuffer = function () {\n        this._gl.flush();\n      }, M.prototype.restoreDefaultFramebuffer = function () {\n        this._currentRenderTarget ? this.unBindFramebuffer(this._currentRenderTarget) : this.bindUnboundFramebuffer(null), this._cachedViewport && this.setViewport(this._cachedViewport), this.wipeCaches();\n      }, M.prototype.createUniformBuffer = function (e) {\n        var t = this._gl.createBuffer();\n\n        if (!t) throw new Error(\"Unable to create uniform buffer\");\n        return this.bindUniformBuffer(t), e instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, e, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(e), this._gl.STATIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;\n      }, M.prototype.createDynamicUniformBuffer = function (e) {\n        var t = this._gl.createBuffer();\n\n        if (!t) throw new Error(\"Unable to create dynamic uniform buffer\");\n        return this.bindUniformBuffer(t), e instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, e, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(e), this._gl.DYNAMIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;\n      }, M.prototype.updateUniformBuffer = function (e, t, i, r) {\n        this.bindUniformBuffer(e), void 0 === i && (i = 0), void 0 === r ? t instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, i, t) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, i, new Float32Array(t)) : t instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, t.subarray(i, i + r)) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(t).subarray(i, i + r)), this.bindUniformBuffer(null);\n      }, M.prototype._resetVertexBufferBinding = function () {\n        this.bindArrayBuffer(null), this._cachedVertexBuffers = null;\n      }, M.prototype.createVertexBuffer = function (e) {\n        var t = this._gl.createBuffer();\n\n        if (!t) throw new Error(\"Unable to create vertex buffer\");\n        return this.bindArrayBuffer(t), e instanceof Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.STATIC_DRAW), this._resetVertexBufferBinding(), t.references = 1, t;\n      }, M.prototype.createDynamicVertexBuffer = function (e) {\n        var t = this._gl.createBuffer();\n\n        if (!t) throw new Error(\"Unable to create dynamic vertex buffer\");\n        return this.bindArrayBuffer(t), e instanceof Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW), this._resetVertexBufferBinding(), t.references = 1, t;\n      }, M.prototype.updateDynamicIndexBuffer = function (e, t, i) {\n        var r;\n        void 0 === i && (i = 0), this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null, this.bindIndexBuffer(e), r = t instanceof Uint16Array || t instanceof Uint32Array ? t : e.is32Bits ? new Uint32Array(t) : new Uint16Array(t), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, r, this._gl.DYNAMIC_DRAW), this._resetIndexBufferBinding();\n      }, M.prototype.updateDynamicVertexBuffer = function (e, t, i, r) {\n        this.bindArrayBuffer(e), void 0 === i && (i = 0), void 0 === r ? t instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, new Float32Array(t)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, t) : t instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(t).subarray(i, i + r)) : (t = t instanceof ArrayBuffer ? new Uint8Array(t, i, r) : new Uint8Array(t.buffer, t.byteOffset + i, r), this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t)), this._resetVertexBufferBinding();\n      }, M.prototype._resetIndexBufferBinding = function () {\n        this.bindIndexBuffer(null), this._cachedIndexBuffer = null;\n      }, M.prototype.createIndexBuffer = function (e, t) {\n        var i,\n            r = this._gl.createBuffer();\n\n        if (!r) throw new Error(\"Unable to create index buffer\");\n        this.bindIndexBuffer(r);\n        var n = !1;\n        if (e instanceof Uint16Array) i = e;else if (this._caps.uintIndices) {\n          if (e instanceof Uint32Array) i = e, n = !0;else {\n            for (var o = 0; o < e.length; o++) if (65535 < e[o]) {\n              n = !0;\n              break;\n            }\n\n            i = n ? new Uint32Array(e) : new Uint16Array(e);\n          }\n        } else i = new Uint16Array(e);\n        return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, i, t ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), r.references = 1, r.is32Bits = n, r;\n      }, M.prototype.bindArrayBuffer = function (e) {\n        this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.bindBuffer(e, this._gl.ARRAY_BUFFER);\n      }, M.prototype.bindUniformBuffer = function (e) {\n        this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, e);\n      }, M.prototype.bindUniformBufferBase = function (e, t) {\n        this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, t, e);\n      }, M.prototype.bindUniformBlock = function (e, t, i) {\n        var r = this._gl.getUniformBlockIndex(e, t);\n\n        this._gl.uniformBlockBinding(e, r, i);\n      }, M.prototype.bindIndexBuffer = function (e) {\n        this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER);\n      }, M.prototype.bindBuffer = function (e, t) {\n        (this._vaoRecordInProgress || this._currentBoundBuffer[t] !== e) && (this._gl.bindBuffer(t, e), this._currentBoundBuffer[t] = e);\n      }, M.prototype.updateArrayBuffer = function (e) {\n        this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e);\n      }, M.prototype._vertexAttribPointer = function (e, t, i, r, n, o, s) {\n        var a = this._currentBufferPointers[t],\n            l = !1;\n        a.active ? (a.buffer !== e && (a.buffer = e, l = !0), a.size !== i && (a.size = i, l = !0), a.type !== r && (a.type = r, l = !0), a.normalized !== n && (a.normalized = n, l = !0), a.stride !== o && (a.stride = o, l = !0), a.offset !== s && (a.offset = s, l = !0)) : (l = !0, a.active = !0, a.index = t, a.size = i, a.type = r, a.normalized = n, a.stride = o, a.offset = s, a.buffer = e), (l || this._vaoRecordInProgress) && (this.bindArrayBuffer(e), this._gl.vertexAttribPointer(t, i, r, n, o, s));\n      }, M.prototype._bindIndexBufferWithCache = function (e) {\n        null != e && this._cachedIndexBuffer !== e && (this._cachedIndexBuffer = e, this.bindIndexBuffer(e), this._uintIndicesCurrentlySet = e.is32Bits);\n      }, M.prototype._bindVertexBuffersAttributes = function (e, t) {\n        var i = t.getAttributesNames();\n        this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.unbindAllAttributes();\n\n        for (var r = 0; r < i.length; r++) {\n          var n = t.getAttributeLocation(r);\n\n          if (0 <= n) {\n            var o = e[i[r]];\n            if (!o) continue;\n            this._gl.enableVertexAttribArray(n), this._vaoRecordInProgress || (this._vertexAttribArraysEnabled[n] = !0);\n            var s = o.getBuffer();\n            s && (this._vertexAttribPointer(s, n, o.getSize(), o.type, o.normalized, o.byteStride, o.byteOffset), o.getIsInstanced() && (this._gl.vertexAttribDivisor(n, o.getInstanceDivisor()), this._vaoRecordInProgress || (this._currentInstanceLocations.push(n), this._currentInstanceBuffers.push(s))));\n          }\n        }\n      }, M.prototype.recordVertexArrayObject = function (e, t, i) {\n        var r = this._gl.createVertexArray();\n\n        return this._vaoRecordInProgress = !0, this._gl.bindVertexArray(r), this._mustWipeVertexAttributes = !0, this._bindVertexBuffersAttributes(e, i), this.bindIndexBuffer(t), this._vaoRecordInProgress = !1, this._gl.bindVertexArray(null), r;\n      }, M.prototype.bindVertexArrayObject = function (e, t) {\n        this._cachedVertexArrayObject !== e && (this._cachedVertexArrayObject = e, this._gl.bindVertexArray(e), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._uintIndicesCurrentlySet = null != t && t.is32Bits, this._mustWipeVertexAttributes = !0);\n      }, M.prototype.bindBuffersDirectly = function (e, t, i, r, n) {\n        if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== n) {\n          this._cachedVertexBuffers = e;\n          var o = (this._cachedEffectForVertexBuffers = n).getAttributesCount();\n          this._unbindVertexArrayObject(), this.unbindAllAttributes();\n\n          for (var s = 0, a = 0; a < o; a++) if (a < i.length) {\n            var l = n.getAttributeLocation(a);\n            0 <= l && (this._gl.enableVertexAttribArray(l), this._vertexAttribArraysEnabled[l] = !0, this._vertexAttribPointer(e, l, i[a], this._gl.FLOAT, !1, r, s)), s += 4 * i[a];\n          }\n        }\n\n        this._bindIndexBufferWithCache(t);\n      }, M.prototype._unbindVertexArrayObject = function () {\n        this._cachedVertexArrayObject && (this._cachedVertexArrayObject = null, this._gl.bindVertexArray(null));\n      }, M.prototype.bindBuffers = function (e, t, i) {\n        this._cachedVertexBuffers === e && this._cachedEffectForVertexBuffers === i || (this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = i, this._bindVertexBuffersAttributes(e, i)), this._bindIndexBufferWithCache(t);\n      }, M.prototype.unbindInstanceAttributes = function () {\n        for (var e, t = 0, i = this._currentInstanceLocations.length; t < i; t++) {\n          var r = this._currentInstanceBuffers[t];\n          e != r && r.references && (e = r, this.bindArrayBuffer(r));\n          var n = this._currentInstanceLocations[t];\n\n          this._gl.vertexAttribDivisor(n, 0);\n        }\n\n        this._currentInstanceBuffers.length = 0, this._currentInstanceLocations.length = 0;\n      }, M.prototype.releaseVertexArrayObject = function (e) {\n        this._gl.deleteVertexArray(e);\n      }, M.prototype._releaseBuffer = function (e) {\n        return e.references--, 0 === e.references && (this._gl.deleteBuffer(e), !0);\n      }, M.prototype.createInstancesBuffer = function (e) {\n        var t = this._gl.createBuffer();\n\n        if (!t) throw new Error(\"Unable to create instance buffer\");\n        return t.capacity = e, this.bindArrayBuffer(t), this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW), t;\n      }, M.prototype.deleteInstancesBuffer = function (e) {\n        this._gl.deleteBuffer(e);\n      }, M.prototype.updateAndBindInstancesBuffer = function (e, t, i) {\n        if (this.bindArrayBuffer(e), t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t), void 0 !== i[0].index) {\n          for (var r = 0, n = 0; n < i.length; n++) {\n            r += 4 * (o = i[n]).attributeSize;\n          }\n\n          for (n = 0; n < i.length; n++) {\n            var o = i[n];\n            this._vertexAttribArraysEnabled[o.index] || (this._gl.enableVertexAttribArray(o.index), this._vertexAttribArraysEnabled[o.index] = !0), this._vertexAttribPointer(e, o.index, o.attributeSize, o.attribyteType || this._gl.FLOAT, o.normalized || !1, r, o.offset), this._gl.vertexAttribDivisor(o.index, 1), this._currentInstanceLocations.push(o.index), this._currentInstanceBuffers.push(e);\n          }\n        } else for (var s = 0; s < 4; s++) {\n          var a = i[s];\n          this._vertexAttribArraysEnabled[a] || (this._gl.enableVertexAttribArray(a), this._vertexAttribArraysEnabled[a] = !0), this._vertexAttribPointer(e, a, 4, this._gl.FLOAT, !1, 64, 16 * s), this._gl.vertexAttribDivisor(a, 1), this._currentInstanceLocations.push(a), this._currentInstanceBuffers.push(e);\n        }\n      }, M.prototype.applyStates = function () {\n        this._depthCullingState.apply(this._gl), this._stencilState.apply(this._gl), this._alphaState.apply(this._gl);\n      }, M.prototype.draw = function (e, t, i, r) {\n        this.drawElementsType(e ? R.Material.TriangleFillMode : R.Material.WireFrameFillMode, t, i, r);\n      }, M.prototype.drawPointClouds = function (e, t, i) {\n        this.drawArraysType(R.Material.PointFillMode, e, t, i);\n      }, M.prototype.drawUnIndexed = function (e, t, i, r) {\n        this.drawArraysType(e ? R.Material.TriangleFillMode : R.Material.WireFrameFillMode, t, i, r);\n      }, M.prototype.drawElementsType = function (e, t, i, r) {\n        this.applyStates(), this._drawCalls.addCount(1, !1);\n\n        var n = this._drawMode(e),\n            o = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT,\n            s = this._uintIndicesCurrentlySet ? 4 : 2;\n\n        r ? this._gl.drawElementsInstanced(n, i, o, t * s, r) : this._gl.drawElements(n, i, o, t * s);\n      }, M.prototype.drawArraysType = function (e, t, i, r) {\n        this.applyStates(), this._drawCalls.addCount(1, !1);\n\n        var n = this._drawMode(e);\n\n        r ? this._gl.drawArraysInstanced(n, t, i, r) : this._gl.drawArrays(n, t, i);\n      }, M.prototype._drawMode = function (e) {\n        switch (e) {\n          case R.Material.TriangleFillMode:\n            return this._gl.TRIANGLES;\n\n          case R.Material.PointFillMode:\n            return this._gl.POINTS;\n\n          case R.Material.WireFrameFillMode:\n            return this._gl.LINES;\n\n          case R.Material.PointListDrawMode:\n            return this._gl.POINTS;\n\n          case R.Material.LineListDrawMode:\n            return this._gl.LINES;\n\n          case R.Material.LineLoopDrawMode:\n            return this._gl.LINE_LOOP;\n\n          case R.Material.LineStripDrawMode:\n            return this._gl.LINE_STRIP;\n\n          case R.Material.TriangleStripDrawMode:\n            return this._gl.TRIANGLE_STRIP;\n\n          case R.Material.TriangleFanDrawMode:\n            return this._gl.TRIANGLE_FAN;\n\n          default:\n            return this._gl.TRIANGLES;\n        }\n      }, M.prototype._releaseEffect = function (e) {\n        this._compiledEffects[e._key] && (delete this._compiledEffects[e._key], this._deleteProgram(e.getProgram()));\n      }, M.prototype._deleteProgram = function (e) {\n        e && (e.__SPECTOR_rebuildProgram = null, e.transformFeedback && (this.deleteTransformFeedback(e.transformFeedback), e.transformFeedback = null), this._gl.deleteProgram(e));\n      }, M.prototype.createEffect = function (e, t, i, r, n, o, s, a, l) {\n        var c = (e.vertexElement || e.vertex || e) + \"+\" + (e.fragmentElement || e.fragment || e) + \"@\" + (n || t.defines);\n\n        if (this._compiledEffects[c]) {\n          var h = this._compiledEffects[c];\n          return s && h.isReady() && s(h), h;\n        }\n\n        var u = new R.Effect(e, t, i, r, this, n, o, s, a, l);\n        return u._key = c, this._compiledEffects[c] = u;\n      }, M.prototype._compileShader = function (e, t, i, r) {\n        return this._compileRawShader(r + (i ? i + \"\\n\" : \"\") + e, t);\n      }, M.prototype._compileRawShader = function (e, t) {\n        var i = this._gl,\n            r = i.createShader(\"vertex\" === t ? i.VERTEX_SHADER : i.FRAGMENT_SHADER);\n        if (!r) throw new Error(\"Something went wrong while compile the shader.\");\n\n        if (i.shaderSource(r, e), i.compileShader(r), !i.getShaderParameter(r, i.COMPILE_STATUS)) {\n          var n = i.getShaderInfoLog(r);\n          if (n) throw new Error(n);\n        }\n\n        return r;\n      }, M.prototype.createRawShaderProgram = function (e, t, i, r) {\n        void 0 === r && (r = null), i = i || this._gl;\n\n        var n = this._compileRawShader(e, \"vertex\"),\n            o = this._compileRawShader(t, \"fragment\");\n\n        return this._createShaderProgram(n, o, i, r);\n      }, M.prototype.createShaderProgram = function (e, t, i, r, n) {\n        void 0 === n && (n = null), r = r || this._gl, this.onBeforeShaderCompilationObservable.notifyObservers(this);\n\n        var o = 1 < this._webGLVersion ? \"#version 300 es\\n#define WEBGL2 \\n\" : \"\",\n            s = this._compileShader(e, \"vertex\", i, o),\n            a = this._compileShader(t, \"fragment\", i, o),\n            l = this._createShaderProgram(s, a, r, n);\n\n        return this.onAfterShaderCompilationObservable.notifyObservers(this), l;\n      }, M.prototype._createShaderProgram = function (e, t, i, r) {\n        void 0 === r && (r = null);\n        var n,\n            o = i.createProgram();\n        if (!o) throw new Error(\"Unable to create program\");\n\n        if (i.attachShader(o, e), i.attachShader(o, t), 1 < this.webGLVersion && r) {\n          var s = this.createTransformFeedback();\n          this.bindTransformFeedback(s), this.setTranformFeedbackVaryings(o, r), o.transformFeedback = s;\n        }\n\n        if ((i.linkProgram(o), 1 < this.webGLVersion && r && this.bindTransformFeedback(null), !i.getProgramParameter(o, i.LINK_STATUS)) && (n = i.getProgramInfoLog(o))) throw new Error(n);\n        if (this.validateShaderPrograms && (i.validateProgram(o), !i.getProgramParameter(o, i.VALIDATE_STATUS) && (n = i.getProgramInfoLog(o)))) throw new Error(n);\n        return i.deleteShader(e), i.deleteShader(t), o;\n      }, M.prototype.getUniforms = function (e, t) {\n        for (var i = new Array(), r = 0; r < t.length; r++) i.push(this._gl.getUniformLocation(e, t[r]));\n\n        return i;\n      }, M.prototype.getAttributes = function (e, t) {\n        for (var i = [], r = 0; r < t.length; r++) try {\n          i.push(this._gl.getAttribLocation(e, t[r]));\n        } catch (e) {\n          i.push(-1);\n        }\n\n        return i;\n      }, M.prototype.enableEffect = function (e) {\n        e && e !== this._currentEffect && (this.bindSamplers(e), (this._currentEffect = e).onBind && e.onBind(e), e._onBindObservable && e._onBindObservable.notifyObservers(e));\n      }, M.prototype.setIntArray = function (e, t) {\n        e && this._gl.uniform1iv(e, t);\n      }, M.prototype.setIntArray2 = function (e, t) {\n        e && t.length % 2 == 0 && this._gl.uniform2iv(e, t);\n      }, M.prototype.setIntArray3 = function (e, t) {\n        e && t.length % 3 == 0 && this._gl.uniform3iv(e, t);\n      }, M.prototype.setIntArray4 = function (e, t) {\n        e && t.length % 4 == 0 && this._gl.uniform4iv(e, t);\n      }, M.prototype.setFloatArray = function (e, t) {\n        e && this._gl.uniform1fv(e, t);\n      }, M.prototype.setFloatArray2 = function (e, t) {\n        e && t.length % 2 == 0 && this._gl.uniform2fv(e, t);\n      }, M.prototype.setFloatArray3 = function (e, t) {\n        e && t.length % 3 == 0 && this._gl.uniform3fv(e, t);\n      }, M.prototype.setFloatArray4 = function (e, t) {\n        e && t.length % 4 == 0 && this._gl.uniform4fv(e, t);\n      }, M.prototype.setArray = function (e, t) {\n        e && this._gl.uniform1fv(e, t);\n      }, M.prototype.setArray2 = function (e, t) {\n        e && t.length % 2 == 0 && this._gl.uniform2fv(e, t);\n      }, M.prototype.setArray3 = function (e, t) {\n        e && t.length % 3 == 0 && this._gl.uniform3fv(e, t);\n      }, M.prototype.setArray4 = function (e, t) {\n        e && t.length % 4 == 0 && this._gl.uniform4fv(e, t);\n      }, M.prototype.setMatrices = function (e, t) {\n        e && this._gl.uniformMatrix4fv(e, !1, t);\n      }, M.prototype.setMatrix = function (e, t) {\n        e && this._gl.uniformMatrix4fv(e, !1, t.toArray());\n      }, M.prototype.setMatrix3x3 = function (e, t) {\n        e && this._gl.uniformMatrix3fv(e, !1, t);\n      }, M.prototype.setMatrix2x2 = function (e, t) {\n        e && this._gl.uniformMatrix2fv(e, !1, t);\n      }, M.prototype.setInt = function (e, t) {\n        e && this._gl.uniform1i(e, t);\n      }, M.prototype.setFloat = function (e, t) {\n        e && this._gl.uniform1f(e, t);\n      }, M.prototype.setFloat2 = function (e, t, i) {\n        e && this._gl.uniform2f(e, t, i);\n      }, M.prototype.setFloat3 = function (e, t, i, r) {\n        e && this._gl.uniform3f(e, t, i, r);\n      }, M.prototype.setBool = function (e, t) {\n        e && this._gl.uniform1i(e, t);\n      }, M.prototype.setFloat4 = function (e, t, i, r, n) {\n        e && this._gl.uniform4f(e, t, i, r, n);\n      }, M.prototype.setColor3 = function (e, t) {\n        e && this._gl.uniform3f(e, t.r, t.g, t.b);\n      }, M.prototype.setColor4 = function (e, t, i) {\n        e && this._gl.uniform4f(e, t.r, t.g, t.b, i);\n      }, M.prototype.setDirectColor4 = function (e, t) {\n        e && this._gl.uniform4f(e, t.r, t.g, t.b, t.a);\n      }, M.prototype.setState = function (e, t, i, r) {\n        void 0 === t && (t = 0), void 0 === r && (r = !1), (this._depthCullingState.cull !== e || i) && (this._depthCullingState.cull = e);\n        var n = this.cullBackFaces ? this._gl.BACK : this._gl.FRONT;\n        (this._depthCullingState.cullFace !== n || i) && (this._depthCullingState.cullFace = n), this.setZOffset(t);\n        var o = r ? this._gl.CW : this._gl.CCW;\n        (this._depthCullingState.frontFace !== o || i) && (this._depthCullingState.frontFace = o);\n      }, M.prototype.setZOffset = function (e) {\n        this._depthCullingState.zOffset = e;\n      }, M.prototype.getZOffset = function () {\n        return this._depthCullingState.zOffset;\n      }, M.prototype.setDepthBuffer = function (e) {\n        this._depthCullingState.depthTest = e;\n      }, M.prototype.getDepthWrite = function () {\n        return this._depthCullingState.depthMask;\n      }, M.prototype.setDepthWrite = function (e) {\n        this._depthCullingState.depthMask = e;\n      }, M.prototype.setColorWrite = function (e) {\n        this._gl.colorMask(e, e, e, e), this._colorWrite = e;\n      }, M.prototype.getColorWrite = function () {\n        return this._colorWrite;\n      }, M.prototype.setAlphaConstants = function (e, t, i, r) {\n        this._alphaState.setAlphaBlendConstants(e, t, i, r);\n      }, M.prototype.setAlphaMode = function (e, t) {\n        if (void 0 === t && (t = !1), this._alphaMode !== e) {\n          switch (e) {\n            case M.ALPHA_DISABLE:\n              this._alphaState.alphaBlend = !1;\n              break;\n\n            case M.ALPHA_PREMULTIPLIED:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_PREMULTIPLIED_PORTERDUFF:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_COMBINE:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_ONEONE:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_ADD:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_SUBTRACT:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_MULTIPLY:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_MAXIMIZED:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_INTERPOLATE:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA), this._alphaState.alphaBlend = !0;\n              break;\n\n            case M.ALPHA_SCREENMODE:\n              this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;\n          }\n\n          t || this.setDepthWrite(e === M.ALPHA_DISABLE), this._alphaMode = e;\n        }\n      }, M.prototype.getAlphaMode = function () {\n        return this._alphaMode;\n      }, M.prototype.clearInternalTexturesCache = function () {\n        this._internalTexturesCache = [];\n      }, M.prototype.wipeCaches = function (e) {\n        this.preventCacheWipeBetweenFrames && !e || (this._currentEffect = null, this._viewportCached.x = 0, this._viewportCached.y = 0, this._viewportCached.z = 0, this._viewportCached.w = 0, e && (this.resetTextureCache(), this._currentProgram = null, this._stencilState.reset(), this._depthCullingState.reset(), this.setDepthFunctionToLessOrEqual(), this._alphaState.reset(), this._unpackFlipYCached = null), this._resetVertexBufferBinding(), this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null, this._unbindVertexArrayObject(), this.bindIndexBuffer(null));\n      }, M.prototype.setTextureFormatToUse = function (e) {\n        for (var t = 0, i = this.texturesSupported.length; t < i; t++) for (var r = 0, n = e.length; r < n; r++) if (this._texturesSupported[t] === e[r].toLowerCase()) return this._textureFormatInUse = this._texturesSupported[t];\n\n        return this._textureFormatInUse = null;\n      }, M.prototype._getSamplingParameters = function (e, t) {\n        var i = this._gl,\n            r = i.NEAREST,\n            n = i.NEAREST;\n\n        switch (e) {\n          case M.TEXTURE_BILINEAR_SAMPLINGMODE:\n            r = i.LINEAR, n = t ? i.LINEAR_MIPMAP_NEAREST : i.LINEAR;\n            break;\n\n          case M.TEXTURE_TRILINEAR_SAMPLINGMODE:\n            r = i.LINEAR, n = t ? i.LINEAR_MIPMAP_LINEAR : i.LINEAR;\n            break;\n\n          case M.TEXTURE_NEAREST_SAMPLINGMODE:\n            r = i.NEAREST, n = t ? i.NEAREST_MIPMAP_LINEAR : i.NEAREST;\n            break;\n\n          case M.TEXTURE_NEAREST_NEAREST_MIPNEAREST:\n            r = i.NEAREST, n = t ? i.NEAREST_MIPMAP_NEAREST : i.NEAREST;\n            break;\n\n          case M.TEXTURE_NEAREST_LINEAR_MIPNEAREST:\n            r = i.NEAREST, n = t ? i.LINEAR_MIPMAP_NEAREST : i.LINEAR;\n            break;\n\n          case M.TEXTURE_NEAREST_LINEAR_MIPLINEAR:\n            r = i.NEAREST, n = t ? i.LINEAR_MIPMAP_LINEAR : i.LINEAR;\n            break;\n\n          case M.TEXTURE_NEAREST_LINEAR:\n            r = i.NEAREST, n = i.LINEAR;\n            break;\n\n          case M.TEXTURE_NEAREST_NEAREST:\n            r = i.NEAREST, n = i.NEAREST;\n            break;\n\n          case M.TEXTURE_LINEAR_NEAREST_MIPNEAREST:\n            r = i.LINEAR, n = t ? i.NEAREST_MIPMAP_NEAREST : i.NEAREST;\n            break;\n\n          case M.TEXTURE_LINEAR_NEAREST_MIPLINEAR:\n            r = i.LINEAR, n = t ? i.NEAREST_MIPMAP_LINEAR : i.NEAREST;\n            break;\n\n          case M.TEXTURE_LINEAR_LINEAR:\n            r = i.LINEAR, n = i.LINEAR;\n            break;\n\n          case M.TEXTURE_LINEAR_NEAREST:\n            r = i.LINEAR, n = i.NEAREST;\n        }\n\n        return {\n          min: n,\n          mag: r\n        };\n      }, M.prototype._partialLoadImg = function (e, t, i, r, n, o) {\n        var s;\n        void 0 === o && (o = null);\n        s = R.Tools.LoadImage(e, function () {\n          i[t] = s, i._internalCount++, r && r._removePendingData(s), 6 === i._internalCount && n(i);\n        }, function (e, t) {\n          r && r._removePendingData(s), o && o(e, t);\n        }, r ? r.database : null), r && r._addPendingData(s);\n      }, M.prototype._cascadeLoadImgs = function (e, t, i, r, n) {\n        void 0 === n && (n = null);\n\n        for (var o = [], s = o._internalCount = 0; s < 6; s++) this._partialLoadImg(r[s], s, o, t, i, n);\n      }, M.prototype._createTexture = function () {\n        var e = this._gl.createTexture();\n\n        if (!e) throw new Error(\"Unable to create texture\");\n        return e;\n      }, M.prototype.createTexture = function (r, n, o, c, s, e, a, l, t, h, i) {\n        var u = this;\n        void 0 === s && (s = M.TEXTURE_TRILINEAR_SAMPLINGMODE), void 0 === e && (e = null), void 0 === a && (a = null), void 0 === l && (l = null), void 0 === t && (t = null), void 0 === h && (h = null), void 0 === i && (i = null);\n\n        for (var d = String(r), f = \"data:\" === d.substr(0, 5), p = \"blob:\" === d.substr(0, 5), _ = f && -1 !== d.indexOf(\";base64,\"), m = t || new R.InternalTexture(this, R.InternalTexture.DATASOURCE_URL), g = d.lastIndexOf(\".\"), v = i || (-1 < g ? d.substring(g).toLowerCase() : \"\"), y = null, b = 0, T = M._TextureLoaders; b < T.length; b++) {\n          var E = T[b];\n\n          if (E.canLoad(v, this._textureFormatInUse, t, _, !!l)) {\n            y = E;\n            break;\n          }\n        }\n\n        y && (d = y.transformUrl(d, this._textureFormatInUse)), c && c._addPendingData(m), m.url = d, m.generateMipMaps = !n, m.samplingMode = s, m.invertY = o, this._doNotHandleContextLost || (m._buffer = l);\n        var x = null;\n        e && !t && (x = m.onLoadedObservable.add(e)), t || this._internalTexturesCache.push(m);\n\n        var P = function (e, t) {\n          c && c._removePendingData(m);\n          var i = !1;\n          y && y.getFallbackTextureUrl(d, u._textureFormatInUse) && (i = !0, u.createTexture(r, n, o, c, s, null, a, l, m));\n          i || (x && m.onLoadedObservable.remove(x), R.Tools.UseFallbackTexture && u.createTexture(R.Tools.fallbackTexture, n, o, c, s, null, a, l, m)), a && a(e || \"Unknown error\", t);\n        };\n\n        if (y) {\n          var A = function (e) {\n            y.loadData(e, m, function (e, t, i, r, n) {\n              u._prepareWebGLTexture(m, c, e, t, o, !i, r, function () {\n                return n(), !1;\n              }, s);\n            });\n          };\n\n          l ? A(l) : this._loadFile(d, A, void 0, c ? c.database : void 0, !0, function (e, t) {\n            P(\"Unable to load \" + (e && e.responseURL, t));\n          });\n        } else {\n          var S = function (l) {\n            p && !u._doNotHandleContextLost && (m._buffer = l), u._prepareWebGLTexture(m, c, l.width, l.height, o, n, !1, function (e, t, i) {\n              var r = u._gl,\n                  n = l.width === e && l.height === t,\n                  o = h ? u._getInternalFormat(h) : \".jpg\" === v ? r.RGB : r.RGBA;\n              if (n) return r.texImage2D(r.TEXTURE_2D, 0, o, o, r.UNSIGNED_BYTE, l), !1;\n              var s = u._caps.maxTextureSize;\n              if (l.width > s || l.height > s) return u._prepareWorkingCanvas(), u._workingCanvas && u._workingContext && (u._workingCanvas.width = e, u._workingCanvas.height = t, u._workingContext.drawImage(l, 0, 0, l.width, l.height, 0, 0, e, t), r.texImage2D(r.TEXTURE_2D, 0, o, o, r.UNSIGNED_BYTE, u._workingCanvas), m.width = e, m.height = t), !1;\n              var a = new R.InternalTexture(u, R.InternalTexture.DATASOURCE_TEMP);\n              return u._bindTextureDirectly(r.TEXTURE_2D, a, !0), r.texImage2D(r.TEXTURE_2D, 0, o, o, r.UNSIGNED_BYTE, l), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), u._rescaleTexture(a, m, c, o, function () {\n                u._releaseTexture(a), u._bindTextureDirectly(r.TEXTURE_2D, m, !0), i();\n              }), !0;\n            }, s);\n          };\n\n          !f || _ ? l instanceof HTMLImageElement ? S(l) : R.Tools.LoadImage(d, S, P, c ? c.database : null) : \"string\" == typeof l || l instanceof ArrayBuffer || l instanceof Blob ? R.Tools.LoadImage(l, S, P, c ? c.database : null) : S(l);\n        }\n\n        return m;\n      }, M.prototype._rescaleTexture = function (t, i, r, n, o) {\n        var s = this,\n            a = this.createRenderTargetTexture({\n          width: i.width,\n          height: i.height\n        }, {\n          generateMipMaps: !1,\n          type: M.TEXTURETYPE_UNSIGNED_INT,\n          samplingMode: M.TEXTURE_BILINEAR_SAMPLINGMODE,\n          generateDepthBuffer: !1,\n          generateStencilBuffer: !1\n        });\n        this._rescalePostProcess || (this._rescalePostProcess = new R.PassPostProcess(\"rescale\", 1, null, M.TEXTURE_BILINEAR_SAMPLINGMODE, this, !1, M.TEXTURETYPE_UNSIGNED_INT)), this._rescalePostProcess.getEffect().executeWhenCompiled(function () {\n          s._rescalePostProcess.onApply = function (e) {\n            e._bindTexture(\"textureSampler\", t);\n          };\n\n          var e = r;\n          e || (e = s.scenes[s.scenes.length - 1]), e.postProcessManager.directRender([s._rescalePostProcess], a, !0), s._bindTextureDirectly(s._gl.TEXTURE_2D, i, !0), s._gl.copyTexImage2D(s._gl.TEXTURE_2D, 0, n, 0, 0, i.width, i.height, 0), s.unBindFramebuffer(a), s._releaseTexture(a), o && o();\n        });\n      }, M.prototype.updateRawTexture = function (e, t, i, r, n, o) {\n        if (void 0 === n && (n = null), void 0 === o && (o = M.TEXTURETYPE_UNSIGNED_INT), e) {\n          var s = this._getRGBABufferInternalSizedFormat(o, i),\n              a = this._getInternalFormat(i),\n              l = this._getWebGLTextureType(o);\n\n          this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), this._unpackFlipY(void 0 === r || !!r), this._doNotHandleContextLost || (e._bufferView = t, e.format = i, e.type = o, e.invertY = r, e._compression = n), e.width % 4 != 0 && this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1), n && t ? this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[n], e.width, e.height, 0, t) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, s, e.width, e.height, 0, a, l, t), e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), e.isReady = !0;\n        }\n      }, M.prototype.createRawTexture = function (e, t, i, r, n, o, s, a, l) {\n        void 0 === a && (a = null), void 0 === l && (l = M.TEXTURETYPE_UNSIGNED_INT);\n        var c = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_RAW);\n        c.baseWidth = t, c.baseHeight = i, c.width = t, c.height = i, c.format = r, c.generateMipMaps = n, c.samplingMode = s, c.invertY = o, c._compression = a, c.type = l, this._doNotHandleContextLost || (c._bufferView = e), this.updateRawTexture(c, e, r, o, a, l), this._bindTextureDirectly(this._gl.TEXTURE_2D, c, !0);\n\n        var h = this._getSamplingParameters(s, n);\n\n        return this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, h.mag), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, h.min), n && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._internalTexturesCache.push(c), c;\n      }, M.prototype._unpackFlipY = function (e) {\n        this._unpackFlipYCached !== e && (this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e ? 1 : 0), this.enableUnpackFlipYCached && (this._unpackFlipYCached = e));\n      }, M.prototype._getUnpackAlignement = function () {\n        return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);\n      }, M.prototype.createDynamicTexture = function (e, t, i, r) {\n        var n = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_DYNAMIC);\n        return n.baseWidth = e, n.baseHeight = t, i && (e = this.needPOTTextures ? R.Tools.GetExponentOfTwo(e, this._caps.maxTextureSize) : e, t = this.needPOTTextures ? R.Tools.GetExponentOfTwo(t, this._caps.maxTextureSize) : t), n.width = e, n.height = t, n.isReady = !1, n.generateMipMaps = i, n.samplingMode = r, this.updateTextureSamplingMode(r, n), this._internalTexturesCache.push(n), n;\n      }, M.prototype.updateTextureSamplingMode = function (e, t) {\n        var i = this._getSamplingParameters(e, t.generateMipMaps);\n\n        t.isCube ? (this._setTextureParameterInteger(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MAG_FILTER, i.mag, t), this._setTextureParameterInteger(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MIN_FILTER, i.min), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : t.is3D ? (this._setTextureParameterInteger(this._gl.TEXTURE_3D, this._gl.TEXTURE_MAG_FILTER, i.mag, t), this._setTextureParameterInteger(this._gl.TEXTURE_3D, this._gl.TEXTURE_MIN_FILTER, i.min), this._bindTextureDirectly(this._gl.TEXTURE_3D, null)) : (this._setTextureParameterInteger(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, i.mag, t), this._setTextureParameterInteger(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, i.min), this._bindTextureDirectly(this._gl.TEXTURE_2D, null)), t.samplingMode = e;\n      }, M.prototype.updateDynamicTexture = function (e, t, i, r, n) {\n        if (void 0 === r && (r = !1), e) {\n          this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), this._unpackFlipY(i), r && this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n          var o = n ? this._getInternalFormat(n) : this._gl.RGBA;\n          this._gl.texImage2D(this._gl.TEXTURE_2D, 0, o, o, this._gl.UNSIGNED_BYTE, t), e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null), r && this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), e.isReady = !0;\n        }\n      }, M.prototype.updateVideoTexture = function (t, e, i) {\n        if (t && !t._isDisabled) {\n          var r = this._bindTextureDirectly(this._gl.TEXTURE_2D, t, !0);\n\n          this._unpackFlipY(!i);\n\n          try {\n            if (void 0 === this._videoTextureSupported && (this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, e), 0 !== this._gl.getError() ? this._videoTextureSupported = !1 : this._videoTextureSupported = !0), this._videoTextureSupported) this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, e);else {\n              if (!t._workingCanvas) {\n                t._workingCanvas = document.createElement(\"canvas\");\n\n                var n = t._workingCanvas.getContext(\"2d\");\n\n                if (!n) throw new Error(\"Unable to get 2d context\");\n                t._workingContext = n, t._workingCanvas.width = t.width, t._workingCanvas.height = t.height;\n              }\n\n              t._workingContext.drawImage(e, 0, 0, e.videoWidth, e.videoHeight, 0, 0, t.width, t.height), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, t._workingCanvas);\n            }\n            t.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), r || this._bindTextureDirectly(this._gl.TEXTURE_2D, null), t.isReady = !0;\n          } catch (e) {\n            t._isDisabled = !0;\n          }\n        }\n      }, M.prototype.updateTextureComparisonFunction = function (e, t) {\n        if (1 !== this.webGLVersion) {\n          var i = this._gl;\n          e.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, e, !0), 0 === t ? (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, M.LEQUAL), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), 0 === t ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, M.LEQUAL), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_2D, null)), e._comparisonFunction = t;\n        } else R.Tools.Error(\"WebGL 1 does not support texture comparison.\");\n      }, M.prototype._setupDepthStencilTexture = function (e, t, i, r, n) {\n        var o = t.width || t,\n            s = t.height || t;\n        e.baseWidth = o, e.baseHeight = s, e.width = o, e.height = s, e.isReady = !0, e.samples = 1, e.generateMipMaps = !1, e._generateDepthBuffer = !0, e._generateStencilBuffer = i, e.samplingMode = r ? M.TEXTURE_BILINEAR_SAMPLINGMODE : M.TEXTURE_NEAREST_SAMPLINGMODE, e.type = M.TEXTURETYPE_UNSIGNED_INT, e._comparisonFunction = n;\n\n        var a = this._gl,\n            l = e.isCube ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D,\n            c = this._getSamplingParameters(e.samplingMode, !1);\n\n        a.texParameteri(l, a.TEXTURE_MAG_FILTER, c.mag), a.texParameteri(l, a.TEXTURE_MIN_FILTER, c.min), a.texParameteri(l, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(l, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), 0 === n ? (a.texParameteri(l, a.TEXTURE_COMPARE_FUNC, M.LEQUAL), a.texParameteri(l, a.TEXTURE_COMPARE_MODE, a.NONE)) : (a.texParameteri(l, a.TEXTURE_COMPARE_FUNC, n), a.texParameteri(l, a.TEXTURE_COMPARE_MODE, a.COMPARE_REF_TO_TEXTURE));\n      }, M.prototype.createDepthStencilTexture = function (e, t) {\n        if (t.isCube) {\n          var i = e.width || e;\n          return this._createDepthStencilCubeTexture(i, t);\n        }\n\n        return this._createDepthStencilTexture(e, t);\n      }, M.prototype._createDepthStencilTexture = function (e, t) {\n        var i = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_DEPTHTEXTURE);\n        if (!this._caps.depthTextureExtension) return R.Tools.Error(\"Depth texture is not supported by your browser or hardware.\"), i;\n        var r = ae({\n          bilinearFiltering: !1,\n          comparisonFunction: 0,\n          generateStencil: !1\n        }, t),\n            n = this._gl;\n        return this._bindTextureDirectly(n.TEXTURE_2D, i, !0), this._setupDepthStencilTexture(i, e, r.generateStencil, r.bilinearFiltering, r.comparisonFunction), 1 < this.webGLVersion ? r.generateStencil ? n.texImage2D(n.TEXTURE_2D, 0, n.DEPTH24_STENCIL8, i.width, i.height, 0, n.DEPTH_STENCIL, n.UNSIGNED_INT_24_8, null) : n.texImage2D(n.TEXTURE_2D, 0, n.DEPTH_COMPONENT24, i.width, i.height, 0, n.DEPTH_COMPONENT, n.UNSIGNED_INT, null) : r.generateStencil ? n.texImage2D(n.TEXTURE_2D, 0, n.DEPTH_STENCIL, i.width, i.height, 0, n.DEPTH_STENCIL, n.UNSIGNED_INT_24_8, null) : n.texImage2D(n.TEXTURE_2D, 0, n.DEPTH_COMPONENT, i.width, i.height, 0, n.DEPTH_COMPONENT, n.UNSIGNED_INT, null), this._bindTextureDirectly(n.TEXTURE_2D, null), i;\n      }, M.prototype._createDepthStencilCubeTexture = function (e, t) {\n        var i = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_UNKNOWN);\n        if (i.isCube = !0, 1 === this.webGLVersion) return R.Tools.Error(\"Depth cube texture is not supported by WebGL 1.\"), i;\n        var r = ae({\n          bilinearFiltering: !1,\n          comparisonFunction: 0,\n          generateStencil: !1\n        }, t),\n            n = this._gl;\n        this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, i, !0), this._setupDepthStencilTexture(i, e, r.generateStencil, r.bilinearFiltering, r.comparisonFunction);\n\n        for (var o = 0; o < 6; o++) r.generateStencil ? n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, n.DEPTH24_STENCIL8, e, e, 0, n.DEPTH_STENCIL, n.UNSIGNED_INT_24_8, null) : n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, n.DEPTH_COMPONENT24, e, e, 0, n.DEPTH_COMPONENT, n.UNSIGNED_INT, null);\n\n        return this._bindTextureDirectly(n.TEXTURE_CUBE_MAP, null), i;\n      }, M.prototype.setFrameBufferDepthStencilTexture = function (e) {\n        var t = e.getInternalTexture();\n\n        if (t && t._framebuffer && e.depthStencilTexture) {\n          var i = this._gl,\n              r = e.depthStencilTexture;\n          this.bindUnboundFramebuffer(t._framebuffer), r.isCube ? r._generateStencilBuffer ? i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_CUBE_MAP_POSITIVE_X, r._webGLTexture, 0) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_CUBE_MAP_POSITIVE_X, r._webGLTexture, 0) : r._generateStencilBuffer ? i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, r._webGLTexture, 0) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, r._webGLTexture, 0), this.bindUnboundFramebuffer(null);\n        }\n      }, M.prototype.createRenderTargetTexture = function (e, t) {\n        var i = new h();\n        void 0 !== t && \"object\" == typeof t ? (i.generateMipMaps = t.generateMipMaps, i.generateDepthBuffer = void 0 === t.generateDepthBuffer || t.generateDepthBuffer, i.generateStencilBuffer = i.generateDepthBuffer && t.generateStencilBuffer, i.type = void 0 === t.type ? M.TEXTURETYPE_UNSIGNED_INT : t.type, i.samplingMode = void 0 === t.samplingMode ? M.TEXTURE_TRILINEAR_SAMPLINGMODE : t.samplingMode, i.format = void 0 === t.format ? M.TEXTUREFORMAT_RGBA : t.format) : (i.generateMipMaps = t, i.generateDepthBuffer = !0, i.generateStencilBuffer = !1, i.type = M.TEXTURETYPE_UNSIGNED_INT, i.samplingMode = M.TEXTURE_TRILINEAR_SAMPLINGMODE, i.format = M.TEXTUREFORMAT_RGBA), (i.type !== M.TEXTURETYPE_FLOAT || this._caps.textureFloatLinearFiltering) && (i.type !== M.TEXTURETYPE_HALF_FLOAT || this._caps.textureHalfFloatLinearFiltering) || (i.samplingMode = M.TEXTURE_NEAREST_SAMPLINGMODE);\n        var r = this._gl,\n            n = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_RENDERTARGET);\n\n        this._bindTextureDirectly(r.TEXTURE_2D, n, !0);\n\n        var o = e.width || e,\n            s = e.height || e,\n            a = this._getSamplingParameters(i.samplingMode, !!i.generateMipMaps);\n\n        i.type !== M.TEXTURETYPE_FLOAT || this._caps.textureFloat || (i.type = M.TEXTURETYPE_UNSIGNED_INT, R.Tools.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\")), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, a.mag), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, a.min), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(r.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(i.type, i.format), o, s, 0, this._getInternalFormat(i.format), this._getWebGLTextureType(i.type), null);\n        var l = this._currentFramebuffer,\n            c = r.createFramebuffer();\n        return this.bindUnboundFramebuffer(c), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, n._webGLTexture, 0), n._depthStencilBuffer = this._setupFramebufferDepthAttachments(!!i.generateStencilBuffer, i.generateDepthBuffer, o, s), i.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(r.TEXTURE_2D, null), r.bindRenderbuffer(r.RENDERBUFFER, null), this.bindUnboundFramebuffer(l), n._framebuffer = c, n.baseWidth = o, n.baseHeight = s, n.width = o, n.height = s, n.isReady = !0, n.samples = 1, n.generateMipMaps = !!i.generateMipMaps, n.samplingMode = i.samplingMode, n.type = i.type, n.format = i.format, n._generateDepthBuffer = i.generateDepthBuffer, n._generateStencilBuffer = !!i.generateStencilBuffer, this._internalTexturesCache.push(n), n;\n      }, M.prototype.createMultipleRenderTarget = function (e, t) {\n        var i = !1,\n            r = !0,\n            n = !1,\n            o = !1,\n            s = 1,\n            a = M.TEXTURETYPE_UNSIGNED_INT,\n            l = M.TEXTURE_TRILINEAR_SAMPLINGMODE,\n            c = new Array(),\n            h = new Array();\n        void 0 !== t && (i = void 0 !== t.generateMipMaps && t.generateMipMaps, r = void 0 === t.generateDepthBuffer || t.generateDepthBuffer, n = void 0 !== t.generateStencilBuffer && t.generateStencilBuffer, o = void 0 !== t.generateDepthTexture && t.generateDepthTexture, s = t.textureCount || 1, t.types && (c = t.types), t.samplingModes && (h = t.samplingModes));\n        var u = this._gl,\n            d = u.createFramebuffer();\n        this.bindUnboundFramebuffer(d);\n\n        for (var f = e.width || e, p = e.height || e, _ = [], m = [], g = this._setupFramebufferDepthAttachments(n, r, f, p), v = 0; v < s; v++) {\n          var y = h[v] || l,\n              b = c[v] || a;\n          (b !== M.TEXTURETYPE_FLOAT || this._caps.textureFloatLinearFiltering) && (b !== M.TEXTURETYPE_HALF_FLOAT || this._caps.textureHalfFloatLinearFiltering) || (y = M.TEXTURE_NEAREST_SAMPLINGMODE);\n\n          var T = this._getSamplingParameters(y, i);\n\n          b !== M.TEXTURETYPE_FLOAT || this._caps.textureFloat || (b = M.TEXTURETYPE_UNSIGNED_INT, R.Tools.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\"));\n          var E = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_MULTIRENDERTARGET),\n              x = u[1 < this.webGLVersion ? \"COLOR_ATTACHMENT\" + v : \"COLOR_ATTACHMENT\" + v + \"_WEBGL\"];\n          _.push(E), m.push(x), u.activeTexture(u[\"TEXTURE\" + v]), u.bindTexture(u.TEXTURE_2D, E._webGLTexture), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, T.mag), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, T.min), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texImage2D(u.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(b), f, p, 0, u.RGBA, this._getWebGLTextureType(b), null), u.framebufferTexture2D(u.DRAW_FRAMEBUFFER, x, u.TEXTURE_2D, E._webGLTexture, 0), i && this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(u.TEXTURE_2D, null), E._framebuffer = d, E._depthStencilBuffer = g, E.baseWidth = f, E.baseHeight = p, E.width = f, E.height = p, E.isReady = !0, E.samples = 1, E.generateMipMaps = i, E.samplingMode = y, E.type = b, E._generateDepthBuffer = r, E._generateStencilBuffer = n, E._attachments = m, this._internalTexturesCache.push(E);\n        }\n\n        if (o && this._caps.depthTextureExtension) {\n          var P = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_MULTIRENDERTARGET);\n          u.activeTexture(u.TEXTURE0), u.bindTexture(u.TEXTURE_2D, P._webGLTexture), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texImage2D(u.TEXTURE_2D, 0, this.webGLVersion < 2 ? u.DEPTH_COMPONENT : u.DEPTH_COMPONENT16, f, p, 0, u.DEPTH_COMPONENT, u.UNSIGNED_SHORT, null), u.framebufferTexture2D(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.TEXTURE_2D, P._webGLTexture, 0), P._framebuffer = d, P.baseWidth = f, P.baseHeight = p, P.width = f, P.height = p, P.isReady = !0, P.samples = 1, P.generateMipMaps = i, P.samplingMode = u.NEAREST, P._generateDepthBuffer = r, P._generateStencilBuffer = n, _.push(P), this._internalTexturesCache.push(P);\n        }\n\n        return u.drawBuffers(m), u.bindRenderbuffer(u.RENDERBUFFER, null), this.bindUnboundFramebuffer(null), this.resetTextureCache(), _;\n      }, M.prototype._setupFramebufferDepthAttachments = function (e, t, i, r, n) {\n        void 0 === n && (n = 1);\n        var o = null,\n            s = this._gl;\n        return e ? (o = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, o), 1 < n ? s.renderbufferStorageMultisample(s.RENDERBUFFER, n, s.DEPTH24_STENCIL8, i, r) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, i, r), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, o)) : t && (o = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, o), 1 < n ? s.renderbufferStorageMultisample(s.RENDERBUFFER, n, s.DEPTH_COMPONENT16, i, r) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_COMPONENT16, i, r), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, o)), o;\n      }, M.prototype.updateRenderTargetTextureSampleCount = function (e, t) {\n        if (this.webGLVersion < 2 || !e) return 1;\n        if (e.samples === t) return t;\n        var i = this._gl;\n\n        if (t = Math.min(t, i.getParameter(i.MAX_SAMPLES)), e._depthStencilBuffer && (i.deleteRenderbuffer(e._depthStencilBuffer), e._depthStencilBuffer = null), e._MSAAFramebuffer && (i.deleteFramebuffer(e._MSAAFramebuffer), e._MSAAFramebuffer = null), e._MSAARenderBuffer && (i.deleteRenderbuffer(e._MSAARenderBuffer), e._MSAARenderBuffer = null), 1 < t) {\n          var r = i.createFramebuffer();\n          if (!r) throw new Error(\"Unable to create multi sampled framebuffer\");\n          e._MSAAFramebuffer = r, this.bindUnboundFramebuffer(e._MSAAFramebuffer);\n          var n = i.createRenderbuffer();\n          if (!n) throw new Error(\"Unable to create multi sampled framebuffer\");\n          i.bindRenderbuffer(i.RENDERBUFFER, n), i.renderbufferStorageMultisample(i.RENDERBUFFER, t, this._getRGBAMultiSampleBufferFormat(e.type), e.width, e.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, n), e._MSAARenderBuffer = n;\n        } else this.bindUnboundFramebuffer(e._framebuffer);\n\n        return e.samples = t, e._depthStencilBuffer = this._setupFramebufferDepthAttachments(e._generateStencilBuffer, e._generateDepthBuffer, e.width, e.height, t), i.bindRenderbuffer(i.RENDERBUFFER, null), this.bindUnboundFramebuffer(null), t;\n      }, M.prototype.updateMultipleRenderTargetTextureSampleCount = function (e, t) {\n        if (this.webGLVersion < 2 || !e || 0 == e.length) return 1;\n        if (e[0].samples === t) return t;\n        var i = this._gl;\n        t = Math.min(t, i.getParameter(i.MAX_SAMPLES)), e[0]._depthStencilBuffer && (i.deleteRenderbuffer(e[0]._depthStencilBuffer), e[0]._depthStencilBuffer = null), e[0]._MSAAFramebuffer && (i.deleteFramebuffer(e[0]._MSAAFramebuffer), e[0]._MSAAFramebuffer = null);\n\n        for (var r = 0; r < e.length; r++) e[r]._MSAARenderBuffer && (i.deleteRenderbuffer(e[r]._MSAARenderBuffer), e[r]._MSAARenderBuffer = null);\n\n        if (1 < t) {\n          var n = i.createFramebuffer();\n          if (!n) throw new Error(\"Unable to create multi sampled framebuffer\");\n          this.bindUnboundFramebuffer(n);\n\n          var o = this._setupFramebufferDepthAttachments(e[0]._generateStencilBuffer, e[0]._generateDepthBuffer, e[0].width, e[0].height, t),\n              s = [];\n\n          for (r = 0; r < e.length; r++) {\n            var a = e[r],\n                l = i[1 < this.webGLVersion ? \"COLOR_ATTACHMENT\" + r : \"COLOR_ATTACHMENT\" + r + \"_WEBGL\"],\n                c = i.createRenderbuffer();\n            if (!c) throw new Error(\"Unable to create multi sampled framebuffer\");\n            i.bindRenderbuffer(i.RENDERBUFFER, c), i.renderbufferStorageMultisample(i.RENDERBUFFER, t, this._getRGBAMultiSampleBufferFormat(a.type), a.width, a.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, l, i.RENDERBUFFER, c), a._MSAAFramebuffer = n, a._MSAARenderBuffer = c, a.samples = t, a._depthStencilBuffer = o, i.bindRenderbuffer(i.RENDERBUFFER, null), s.push(l);\n          }\n\n          i.drawBuffers(s);\n        } else this.bindUnboundFramebuffer(e[0]._framebuffer);\n\n        return this.bindUnboundFramebuffer(null), t;\n      }, M.prototype._uploadCompressedDataToTextureDirectly = function (e, t, i, r, n, o, s) {\n        void 0 === o && (o = 0), void 0 === s && (s = 0);\n        var a = this._gl,\n            l = a.TEXTURE_2D;\n        e.isCube && (l = a.TEXTURE_CUBE_MAP_POSITIVE_X + o), this._gl.compressedTexImage2D(l, s, t, i, r, 0, n);\n      }, M.prototype._uploadDataToTextureDirectly = function (e, t, i, r) {\n        void 0 === i && (i = 0), void 0 === r && (r = 0);\n\n        var n = this._gl,\n            o = this._getWebGLTextureType(e.type),\n            s = this._getInternalFormat(e.format),\n            a = this._getRGBABufferInternalSizedFormat(e.type, s);\n\n        this._unpackFlipY(e.invertY);\n\n        var l = n.TEXTURE_2D;\n        e.isCube && (l = n.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n        var c = Math.round(R.Scalar.Log2(e.width)),\n            h = Math.round(R.Scalar.Log2(e.height)),\n            u = Math.pow(2, Math.max(c - r, 0)),\n            d = Math.pow(2, Math.max(h - r, 0));\n        n.texImage2D(l, r, a, u, d, 0, s, o, t);\n      }, M.prototype._uploadArrayBufferViewToTexture = function (e, t, i, r) {\n        void 0 === i && (i = 0), void 0 === r && (r = 0);\n        var n = this._gl,\n            o = e.isCube ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D;\n        this._bindTextureDirectly(o, e, !0), this._uploadDataToTextureDirectly(e, t, i, r), this._bindTextureDirectly(o, null, !0);\n      }, M.prototype._uploadImageToTexture = function (e, t, i, r) {\n        void 0 === i && (i = 0), void 0 === r && (r = 0);\n\n        var n = this._gl,\n            o = this._getWebGLTextureType(e.type),\n            s = this._getInternalFormat(e.format),\n            a = this._getRGBABufferInternalSizedFormat(e.type, s),\n            l = e.isCube ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D;\n\n        this._bindTextureDirectly(l, e, !0), this._unpackFlipY(e.invertY);\n        var c = n.TEXTURE_2D;\n        e.isCube && (c = n.TEXTURE_CUBE_MAP_POSITIVE_X + i), n.texImage2D(c, r, a, s, o, t), this._bindTextureDirectly(l, null, !0);\n      }, M.prototype.createRenderTargetCubeTexture = function (e, t) {\n        var i = ae({\n          generateMipMaps: !0,\n          generateDepthBuffer: !0,\n          generateStencilBuffer: !1,\n          type: M.TEXTURETYPE_UNSIGNED_INT,\n          samplingMode: M.TEXTURE_TRILINEAR_SAMPLINGMODE,\n          format: M.TEXTUREFORMAT_RGBA\n        }, t);\n        i.generateStencilBuffer = i.generateDepthBuffer && i.generateStencilBuffer, (i.type !== M.TEXTURETYPE_FLOAT || this._caps.textureFloatLinearFiltering) && (i.type !== M.TEXTURETYPE_HALF_FLOAT || this._caps.textureHalfFloatLinearFiltering) || (i.samplingMode = M.TEXTURE_NEAREST_SAMPLINGMODE);\n        var r = this._gl,\n            n = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_RENDERTARGET);\n\n        this._bindTextureDirectly(r.TEXTURE_CUBE_MAP, n, !0);\n\n        var o = this._getSamplingParameters(i.samplingMode, i.generateMipMaps);\n\n        i.type !== M.TEXTURETYPE_FLOAT || this._caps.textureFloat || (i.type = M.TEXTURETYPE_UNSIGNED_INT, R.Tools.Warn(\"Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type\")), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, o.mag), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, o.min), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE);\n\n        for (var s = 0; s < 6; s++) r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + s, 0, this._getRGBABufferInternalSizedFormat(i.type, i.format), e, e, 0, this._getInternalFormat(i.format), this._getWebGLTextureType(i.type), null);\n\n        var a = r.createFramebuffer();\n        return this.bindUnboundFramebuffer(a), n._depthStencilBuffer = this._setupFramebufferDepthAttachments(i.generateStencilBuffer, i.generateDepthBuffer, e, e), i.generateMipMaps && r.generateMipmap(r.TEXTURE_CUBE_MAP), this._bindTextureDirectly(r.TEXTURE_CUBE_MAP, null), r.bindRenderbuffer(r.RENDERBUFFER, null), this.bindUnboundFramebuffer(null), n._framebuffer = a, n.width = e, n.height = e, n.isReady = !0, n.isCube = !0, n.samples = 1, n.generateMipMaps = i.generateMipMaps, n.samplingMode = i.samplingMode, n.type = i.type, n.format = i.format, n._generateDepthBuffer = i.generateDepthBuffer, n._generateStencilBuffer = i.generateStencilBuffer, this._internalTexturesCache.push(n), n;\n      }, M.prototype.createPrefilteredCubeTexture = function (e, _, m, g, v, t, i, r, y) {\n        var b = this;\n        void 0 === v && (v = null), void 0 === t && (t = null), void 0 === r && (r = null), void 0 === y && (y = !0);\n        return this.createCubeTexture(e, _, null, !1, function (e) {\n          if (e) {\n            var t = e.texture;\n            if (y ? e.info.sphericalPolynomial && (t._sphericalPolynomial = e.info.sphericalPolynomial) : t._sphericalPolynomial = new R.SphericalPolynomial(), t._dataSource = R.InternalTexture.DATASOURCE_CUBEPREFILTERED, b._caps.textureLOD) v && v(t);else {\n              var i = b._gl,\n                  r = e.width;\n\n              if (r) {\n                for (var n = [], o = 0; o < 3; o++) {\n                  var s = 1 - o / 2,\n                      a = g,\n                      l = R.Scalar.Log2(r) * m + g,\n                      c = a + (l - a) * s,\n                      h = Math.round(Math.min(Math.max(c, 0), l)),\n                      u = new R.InternalTexture(b, R.InternalTexture.DATASOURCE_TEMP);\n\n                  if (u.type = t.type, u.format = t.format, u.width = Math.pow(2, Math.max(R.Scalar.Log2(r) - h, 0)), u.height = u.width, u.isCube = !0, b._bindTextureDirectly(i.TEXTURE_CUBE_MAP, u, !0), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), e.isDDS) {\n                    var d = e.info,\n                        f = e.data;\n                    b._unpackFlipY(d.isCompressed), R.DDSTools.UploadDDSLevels(b, u, f, d, !0, 6, h);\n                  } else R.Tools.Warn(\"DDS is the only prefiltered cube map supported so far.\");\n\n                  b._bindTextureDirectly(i.TEXTURE_CUBE_MAP, null);\n\n                  var p = new R.BaseTexture(_);\n                  p.isCube = !0, (p._texture = u).isReady = !0, n.push(p);\n                }\n\n                t._lodTextureHigh = n[2], t._lodTextureMid = n[1], t._lodTextureLow = n[0], v && v(t);\n              }\n            }\n          } else v && v(null);\n        }, t, i, r, y, m, g);\n      }, M.prototype.createCubeTexture = function (r, n, o, s, a, l, c, e, h, u, d, t) {\n        var f = this;\n        void 0 === a && (a = null), void 0 === l && (l = null), void 0 === e && (e = null), void 0 === h && (h = !1), void 0 === u && (u = 0), void 0 === d && (d = 0), void 0 === t && (t = null);\n\n        var p = this._gl,\n            _ = t || new R.InternalTexture(this, R.InternalTexture.DATASOURCE_CUBE);\n\n        _.isCube = !0, _.url = r, _.generateMipMaps = !s, _._lodGenerationScale = u, _._lodGenerationOffset = d, this._doNotHandleContextLost || (_._extension = e, _._files = o);\n\n        for (var i = r.lastIndexOf(\".\"), m = e || (-1 < i ? r.substring(i).toLowerCase() : \"\"), g = null, v = 0, y = M._TextureLoaders; v < y.length; v++) {\n          var b = y[v];\n\n          if (b.canLoad(m, this._textureFormatInUse, t, !1, !1)) {\n            g = b;\n            break;\n          }\n        }\n\n        if (g) {\n          r = g.transformUrl(r, this._textureFormatInUse);\n\n          var T = function (e) {\n            f._bindTextureDirectly(p.TEXTURE_CUBE_MAP, _, !0), g.loadCubeData(e, _, h, a, l);\n          };\n\n          o && 6 === o.length ? g.supportCascades ? this._cascadeLoadFiles(n, T, o, l) : l && l(\"Textures type does not support cascades.\") : this._loadFile(r, T, void 0, void 0, !0, function (e, t) {\n            if (g) {\n              var i = g.getFallbackTextureUrl(r, f._textureFormatInUse);\n              i && f.createCubeTexture(i, n, o, s, a, l, c, m, h, u, d, _);\n            }\n\n            l && e && l(e.status + \" \" + e.statusText, t);\n          });\n        } else {\n          if (!o) throw new Error(\"Cannot load cubemap because files were not defined\");\n\n          this._cascadeLoadImgs(r, n, function (e) {\n            var t = f.needPOTTextures ? R.Tools.GetExponentOfTwo(e[0].width, f._caps.maxCubemapTextureSize) : e[0].width,\n                i = t;\n\n            if (f._prepareWorkingCanvas(), f._workingCanvas && f._workingContext) {\n              f._workingCanvas.width = t, f._workingCanvas.height = i;\n              var r = [p.TEXTURE_CUBE_MAP_POSITIVE_X, p.TEXTURE_CUBE_MAP_POSITIVE_Y, p.TEXTURE_CUBE_MAP_POSITIVE_Z, p.TEXTURE_CUBE_MAP_NEGATIVE_X, p.TEXTURE_CUBE_MAP_NEGATIVE_Y, p.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n              f._bindTextureDirectly(p.TEXTURE_CUBE_MAP, _, !0), f._unpackFlipY(!1);\n\n              for (var n = c ? f._getInternalFormat(c) : f._gl.RGBA, o = 0; o < r.length; o++) f._workingContext.drawImage(e[o], 0, 0, e[o].width, e[o].height, 0, 0, t, i), p.texImage2D(r[o], 0, n, n, p.UNSIGNED_BYTE, f._workingCanvas);\n\n              s || p.generateMipmap(p.TEXTURE_CUBE_MAP), f._setCubeMapTextureParams(!s), _.width = t, _.height = i, _.isReady = !0, c && (_.format = c), _.onLoadedObservable.notifyObservers(_), _.onLoadedObservable.clear(), a && a();\n            }\n          }, o, l);\n        }\n\n        return this._internalTexturesCache.push(_), _;\n      }, M.prototype._setCubeMapTextureParams = function (e) {\n        var t = this._gl;\n        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, e ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), this._bindTextureDirectly(t.TEXTURE_CUBE_MAP, null);\n      }, M.prototype.updateRawCubeTexture = function (e, t, i, r, n, o, s) {\n        void 0 === o && (o = null), void 0 === s && (s = 0), e._bufferViewArray = t, e.format = i, e.type = r, e.invertY = n, e._compression = o;\n\n        var a = this._gl,\n            l = this._getWebGLTextureType(r),\n            c = this._getInternalFormat(i),\n            h = this._getRGBABufferInternalSizedFormat(r),\n            u = !1;\n\n        c === a.RGB && (c = a.RGBA, u = !0), this._bindTextureDirectly(a.TEXTURE_CUBE_MAP, e, !0), this._unpackFlipY(void 0 === n || !!n), e.width % 4 != 0 && a.pixelStorei(a.UNPACK_ALIGNMENT, 1);\n\n        for (var d = 0; d < 6; d++) {\n          var f = t[d];\n          o ? a.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + d, s, this.getCaps().s3tc[o], e.width, e.height, 0, f) : (u && (f = this._convertRGBtoRGBATextureData(f, e.width, e.height, r)), a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + d, s, h, e.width, e.height, 0, c, l, f));\n        }\n\n        (!this.needPOTTextures || R.Tools.IsExponentOfTwo(e.width) && R.Tools.IsExponentOfTwo(e.height)) && e.generateMipMaps && 0 === s && this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), e.isReady = !0;\n      }, M.prototype.createRawCubeTexture = function (e, t, i, r, n, o, s, a) {\n        void 0 === a && (a = null);\n        var l = this._gl,\n            c = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_CUBERAW);\n        c.isCube = !0, c.format = i, c.type = r, this._doNotHandleContextLost || (c._bufferViewArray = e);\n\n        var h = this._getWebGLTextureType(r),\n            u = this._getInternalFormat(i);\n\n        u === l.RGB && (u = l.RGBA), h !== l.FLOAT || this._caps.textureFloatLinearFiltering ? h !== this._gl.HALF_FLOAT_OES || this._caps.textureHalfFloatLinearFiltering ? h !== l.FLOAT || this._caps.textureFloatRender ? h !== l.HALF_FLOAT || this._caps.colorBufferFloat || (n = !1, R.Tools.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\")) : (n = !1, R.Tools.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\")) : (n = !1, s = M.TEXTURE_NEAREST_SAMPLINGMODE, R.Tools.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\")) : (n = !1, s = M.TEXTURE_NEAREST_SAMPLINGMODE, R.Tools.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\"));\n        var d = t,\n            f = d;\n        c.width = d, c.height = f, !this.needPOTTextures || R.Tools.IsExponentOfTwo(c.width) && R.Tools.IsExponentOfTwo(c.height) || (n = !1), e && this.updateRawCubeTexture(c, e, i, r, o, a), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, c, !0), e && n && this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n\n        var p = this._getSamplingParameters(s, n);\n\n        return l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_MAG_FILTER, p.mag), l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_MIN_FILTER, p.min), l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_CUBE_MAP, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), this._bindTextureDirectly(l.TEXTURE_CUBE_MAP, null), c.generateMipMaps = n, c;\n      }, M.prototype.createRawCubeTextureFromUrl = function (e, d, t, f, p, i, _, m, g, r, n, v) {\n        var y = this;\n        void 0 === g && (g = null), void 0 === r && (r = null), void 0 === n && (n = M.TEXTURE_TRILINEAR_SAMPLINGMODE), void 0 === v && (v = !1);\n        var b = this._gl,\n            T = this.createRawCubeTexture(null, t, f, p, !i, v, n);\n        d._addPendingData(T), T.url = e, this._internalTexturesCache.push(T);\n        return this._loadFile(e, function (e) {\n          !function (e) {\n            var t = T.width,\n                i = _(e);\n\n            if (i) {\n              if (m) {\n                var r = y._getWebGLTextureType(p),\n                    n = y._getInternalFormat(f),\n                    o = y._getRGBABufferInternalSizedFormat(p),\n                    s = !1;\n\n                n === b.RGB && (n = b.RGBA, s = !0), y._bindTextureDirectly(b.TEXTURE_CUBE_MAP, T, !0), y._unpackFlipY(!1);\n\n                for (var a = m(i), l = 0; l < a.length; l++) for (var c = t >> l, h = 0; h < 6; h++) {\n                  var u = a[l][h];\n                  s && (u = y._convertRGBtoRGBATextureData(u, c, c, p)), b.texImage2D(h, l, o, c, c, 0, n, r, u);\n                }\n\n                y._bindTextureDirectly(b.TEXTURE_CUBE_MAP, null);\n              } else y.updateRawCubeTexture(T, i, f, p, v);\n\n              T.isReady = !0, d._removePendingData(T), g && g();\n            }\n          }(e);\n        }, void 0, d.database, !0, function (e, t) {\n          d._removePendingData(T), r && e && r(e.status + \" \" + e.statusText, t);\n        }), T;\n      }, M.prototype.updateRawTexture3D = function (e, t, i, r, n, o) {\n        void 0 === n && (n = null), void 0 === o && (o = M.TEXTURETYPE_UNSIGNED_INT);\n\n        var s = this._getWebGLTextureType(o),\n            a = this._getInternalFormat(i),\n            l = this._getRGBABufferInternalSizedFormat(o, i);\n\n        this._bindTextureDirectly(this._gl.TEXTURE_3D, e, !0), this._unpackFlipY(void 0 === r || !!r), this._doNotHandleContextLost || (e._bufferView = t, e.format = i, e.invertY = r, e._compression = n), e.width % 4 != 0 && this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1), n && t ? this._gl.compressedTexImage3D(this._gl.TEXTURE_3D, 0, this.getCaps().s3tc[n], e.width, e.height, e.depth, 0, t) : this._gl.texImage3D(this._gl.TEXTURE_3D, 0, l, e.width, e.height, e.depth, 0, a, s, t), e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_3D), this._bindTextureDirectly(this._gl.TEXTURE_3D, null), e.isReady = !0;\n      }, M.prototype.createRawTexture3D = function (e, t, i, r, n, o, s, a, l, c) {\n        void 0 === l && (l = null), void 0 === c && (c = M.TEXTURETYPE_UNSIGNED_INT);\n        var h = new R.InternalTexture(this, R.InternalTexture.DATASOURCE_RAW3D);\n        h.baseWidth = t, h.baseHeight = i, h.baseDepth = r, h.width = t, h.height = i, h.depth = r, h.format = n, h.type = c, h.generateMipMaps = o, h.samplingMode = a, h.is3D = !0, this._doNotHandleContextLost || (h._bufferView = e), this.updateRawTexture3D(h, e, n, s, l, c), this._bindTextureDirectly(this._gl.TEXTURE_3D, h, !0);\n\n        var u = this._getSamplingParameters(a, o);\n\n        return this._gl.texParameteri(this._gl.TEXTURE_3D, this._gl.TEXTURE_MAG_FILTER, u.mag), this._gl.texParameteri(this._gl.TEXTURE_3D, this._gl.TEXTURE_MIN_FILTER, u.min), o && this._gl.generateMipmap(this._gl.TEXTURE_3D), this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._internalTexturesCache.push(h), h;\n      }, M.prototype._prepareWebGLTextureContinuation = function (e, t, i, r, n) {\n        var o = this._gl;\n\n        if (o) {\n          var s = this._getSamplingParameters(n, !i);\n\n          o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, s.mag), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, s.min), i || r || o.generateMipmap(o.TEXTURE_2D), this._bindTextureDirectly(o.TEXTURE_2D, null), t && t._removePendingData(e), e.onLoadedObservable.notifyObservers(e), e.onLoadedObservable.clear();\n        }\n      }, M.prototype._prepareWebGLTexture = function (e, t, i, r, n, o, s, a, l) {\n        var c = this;\n        void 0 === l && (l = M.TEXTURE_TRILINEAR_SAMPLINGMODE);\n        var h = this.getCaps().maxTextureSize,\n            u = Math.min(h, this.needPOTTextures ? R.Tools.GetExponentOfTwo(i, h) : i),\n            d = Math.min(h, this.needPOTTextures ? R.Tools.GetExponentOfTwo(r, h) : r),\n            f = this._gl;\n        f && (e._webGLTexture ? (this._bindTextureDirectly(f.TEXTURE_2D, e, !0), this._unpackFlipY(void 0 === n || !!n), e.baseWidth = i, e.baseHeight = r, e.width = u, e.height = d, e.isReady = !0, a(u, d, function () {\n          c._prepareWebGLTextureContinuation(e, t, o, s, l);\n        }) || this._prepareWebGLTextureContinuation(e, t, o, s, l)) : t && t._removePendingData(e));\n      }, M.prototype._convertRGBtoRGBATextureData = function (e, t, i, r) {\n        var n;\n        n = r === M.TEXTURETYPE_FLOAT ? new Float32Array(t * i * 4) : new Uint32Array(t * i * 4);\n\n        for (var o = 0; o < t; o++) for (var s = 0; s < i; s++) {\n          var a = 3 * (s * t + o),\n              l = 4 * (s * t + o);\n          n[l + 0] = e[a + 0], n[l + 1] = e[a + 1], n[l + 2] = e[a + 2], n[l + 3] = 1;\n        }\n\n        return n;\n      }, M.prototype._releaseFramebufferObjects = function (e) {\n        var t = this._gl;\n        e._framebuffer && (t.deleteFramebuffer(e._framebuffer), e._framebuffer = null), e._depthStencilBuffer && (t.deleteRenderbuffer(e._depthStencilBuffer), e._depthStencilBuffer = null), e._MSAAFramebuffer && (t.deleteFramebuffer(e._MSAAFramebuffer), e._MSAAFramebuffer = null), e._MSAARenderBuffer && (t.deleteRenderbuffer(e._MSAARenderBuffer), e._MSAARenderBuffer = null);\n      }, M.prototype._releaseTexture = function (t) {\n        var e = this._gl;\n        this._releaseFramebufferObjects(t), e.deleteTexture(t._webGLTexture), this.unbindAllTextures();\n\n        var i = this._internalTexturesCache.indexOf(t);\n\n        -1 !== i && this._internalTexturesCache.splice(i, 1), t._lodTextureHigh && t._lodTextureHigh.dispose(), t._lodTextureMid && t._lodTextureMid.dispose(), t._lodTextureLow && t._lodTextureLow.dispose(), this.scenes.forEach(function (e) {\n          e.postProcesses.forEach(function (e) {\n            e._outputTexture == t && (e._outputTexture = null);\n          }), e.cameras.forEach(function (e) {\n            e._postProcesses.forEach(function (e) {\n              e && e._outputTexture == t && (e._outputTexture = null);\n            });\n          });\n        });\n      }, M.prototype.setProgram = function (e) {\n        this._currentProgram !== e && (this._gl.useProgram(e), this._currentProgram = e);\n      }, M.prototype.bindSamplers = function (e) {\n        this.setProgram(e.getProgram());\n\n        for (var t = e.getSamplers(), i = 0; i < t.length; i++) {\n          var r = e.getUniform(t[i]);\n          r && (this._boundUniforms[i] = r);\n        }\n\n        this._currentEffect = null;\n      }, M.prototype._moveBoundTextureOnTop = function (e) {\n        this.disableTextureBindingOptimization || this._lastBoundInternalTextureTracker.previous === e || (this._linkTrackers(e.previous, e.next), this._linkTrackers(this._lastBoundInternalTextureTracker.previous, e), this._linkTrackers(e, this._lastBoundInternalTextureTracker));\n      }, M.prototype._getCorrectTextureChannel = function (e, t) {\n        if (!t) return -1;\n        if (t._initialSlot = e, this.disableTextureBindingOptimization) e !== t._designatedSlot && this._textureCollisions.addCount(1, !1);else if (e !== t._designatedSlot) return -1 < t._designatedSlot ? t._designatedSlot : this._nextFreeTextureSlots.length ? this._nextFreeTextureSlots[0] : (this._textureCollisions.addCount(1, !1), this._removeDesignatedSlot(this._firstBoundInternalTextureTracker.next));\n        return e;\n      }, M.prototype._linkTrackers = function (e, t) {\n        (e.next = t).previous = e;\n      }, M.prototype._removeDesignatedSlot = function (e) {\n        var t = e._designatedSlot;\n        return -1 === t ? -1 : (e._designatedSlot = -1, this.disableTextureBindingOptimization ? -1 : (this._linkTrackers(e.previous, e.next), this._boundTexturesCache[t] = null, this._nextFreeTextureSlots.push(t), t));\n      }, M.prototype._activateCurrentTexture = function () {\n        this._currentTextureChannel !== this._activeChannel && (this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel), this._currentTextureChannel = this._activeChannel);\n      }, M.prototype._bindTextureDirectly = function (e, t, i, r) {\n        void 0 === i && (i = !1), void 0 === r && (r = !1);\n        var n = !1;\n        i && t && -1 < t._designatedSlot && (this._activeChannel = t._designatedSlot);\n        var o = this._boundTexturesCache[this._activeChannel],\n            s = t && -1 < t._initialSlot;\n\n        if (o !== t || r) {\n          if (o && this._removeDesignatedSlot(o), this._activateCurrentTexture(), this._gl.bindTexture(e, t ? t._webGLTexture : null), this._boundTexturesCache[this._activeChannel] = t) {\n            if (!this.disableTextureBindingOptimization) {\n              var a = this._nextFreeTextureSlots.indexOf(this._activeChannel);\n\n              -1 < a && this._nextFreeTextureSlots.splice(a, 1), this._linkTrackers(this._lastBoundInternalTextureTracker.previous, t), this._linkTrackers(t, this._lastBoundInternalTextureTracker);\n            }\n\n            t._designatedSlot = this._activeChannel;\n          }\n        } else i && (n = !0, this._activateCurrentTexture());\n\n        return s && !i && this._bindSamplerUniformToChannel(t._initialSlot, this._activeChannel), n;\n      }, M.prototype._bindTexture = function (e, t) {\n        e < 0 || (t && (e = this._getCorrectTextureChannel(e, t)), this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, t));\n      }, M.prototype.setTextureFromPostProcess = function (e, t) {\n        this._bindTexture(e, t ? t._textures.data[t._currentRenderTextureInd] : null);\n      }, M.prototype.setTextureFromPostProcessOutput = function (e, t) {\n        this._bindTexture(e, t ? t._outputTexture : null);\n      }, M.prototype.unbindAllTextures = function () {\n        for (var e = 0; e < this._maxSimultaneousTextures; e++) this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), 1 < this.webGLVersion && this._bindTextureDirectly(this._gl.TEXTURE_3D, null);\n      }, M.prototype.setTexture = function (e, t, i) {\n        e < 0 || (t && (this._boundUniforms[e] = t), this._setTexture(e, i));\n      }, M.prototype.setDepthStencilTexture = function (e, t, i) {\n        e < 0 || (t && (this._boundUniforms[e] = t), i && i.depthStencilTexture ? this._setTexture(e, i, !1, !0) : this._setTexture(e, null));\n      }, M.prototype._bindSamplerUniformToChannel = function (e, t) {\n        var i = this._boundUniforms[e];\n        i._currentState !== t && (this._gl.uniform1i(i, t), i._currentState = t);\n      }, M.prototype._getTextureWrapMode = function (e) {\n        switch (e) {\n          case M.TEXTURE_WRAP_ADDRESSMODE:\n            return this._gl.REPEAT;\n\n          case M.TEXTURE_CLAMP_ADDRESSMODE:\n            return this._gl.CLAMP_TO_EDGE;\n\n          case M.TEXTURE_MIRROR_ADDRESSMODE:\n            return this._gl.MIRRORED_REPEAT;\n        }\n\n        return this._gl.REPEAT;\n      }, M.prototype._setTexture = function (e, t, i, r) {\n        if (void 0 === i && (i = !1), void 0 === r && (r = !1), !t) return null != this._boundTexturesCache[e] && (this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), 1 < this.webGLVersion && this._bindTextureDirectly(this._gl.TEXTURE_3D, null)), !1;\n        if (t.video) this._activeChannel = e, t.update();else if (t.delayLoadState === M.DELAYLOADSTATE_NOTLOADED) return t.delayLoad(), !1;\n        var n;\n        n = r ? t.depthStencilTexture : t.isReady() ? t.getInternalTexture() : t.isCube ? this.emptyCubeTexture : t.is3D ? this.emptyTexture3D : this.emptyTexture, i || (e = this._getCorrectTextureChannel(e, n));\n        var o = !0;\n        if (this._boundTexturesCache[e] === n && (this._moveBoundTextureOnTop(n), i || this._bindSamplerUniformToChannel(n._initialSlot, e), o = !1), this._activeChannel = e, n && n.is3D) o && this._bindTextureDirectly(this._gl.TEXTURE_3D, n, i), n && n._cachedWrapU !== t.wrapU && (n._cachedWrapU = t.wrapU, this._setTextureParameterInteger(this._gl.TEXTURE_3D, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), n)), n && n._cachedWrapV !== t.wrapV && (n._cachedWrapV = t.wrapV, this._setTextureParameterInteger(this._gl.TEXTURE_3D, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), n)), n && n._cachedWrapR !== t.wrapR && (n._cachedWrapR = t.wrapR, this._setTextureParameterInteger(this._gl.TEXTURE_3D, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(t.wrapR), n)), this._setAnisotropicLevel(this._gl.TEXTURE_3D, t);else if (n && n.isCube) {\n          if (o && this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, n, i), n._cachedCoordinatesMode !== t.coordinatesMode) {\n            n._cachedCoordinatesMode = t.coordinatesMode;\n            var s = t.coordinatesMode !== M.TEXTURE_CUBIC_MODE && t.coordinatesMode !== M.TEXTURE_SKYBOX_MODE ? this._gl.REPEAT : this._gl.CLAMP_TO_EDGE;\n            this._setTextureParameterInteger(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_S, s, n), this._setTextureParameterInteger(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_T, s);\n          }\n\n          this._setAnisotropicLevel(this._gl.TEXTURE_CUBE_MAP, t);\n        } else o && this._bindTextureDirectly(this._gl.TEXTURE_2D, n, i), n && n._cachedWrapU !== t.wrapU && (n._cachedWrapU = t.wrapU, this._setTextureParameterInteger(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), n)), n && n._cachedWrapV !== t.wrapV && (n._cachedWrapV = t.wrapV, this._setTextureParameterInteger(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), n)), this._setAnisotropicLevel(this._gl.TEXTURE_2D, t);\n        return !0;\n      }, M.prototype.setTextureArray = function (e, t, i) {\n        if (!(e < 0) && t) {\n          this._textureUnits && this._textureUnits.length === i.length || (this._textureUnits = new Int32Array(i.length));\n\n          for (var r = 0; r < i.length; r++) this._textureUnits[r] = this._getCorrectTextureChannel(e + r, i[r].getInternalTexture());\n\n          this._gl.uniform1iv(t, this._textureUnits);\n\n          for (var n = 0; n < i.length; n++) this._setTexture(this._textureUnits[n], i[n], !0);\n        }\n      }, M.prototype._setAnisotropicLevel = function (e, t) {\n        var i = t.getInternalTexture();\n\n        if (i) {\n          var r = this._caps.textureAnisotropicFilterExtension,\n              n = t.anisotropicFilteringLevel;\n          i.samplingMode !== M.TEXTURE_LINEAR_LINEAR_MIPNEAREST && i.samplingMode !== M.TEXTURE_LINEAR_LINEAR_MIPLINEAR && i.samplingMode !== M.TEXTURE_LINEAR_LINEAR && (n = 1), r && i._cachedAnisotropicFilteringLevel !== n && (this._setTextureParameterFloat(e, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(n, this._caps.maxAnisotropy), i), i._cachedAnisotropicFilteringLevel = n);\n        }\n      }, M.prototype._setTextureParameterFloat = function (e, t, i, r) {\n        this._bindTextureDirectly(e, r, !0, !0), this._gl.texParameterf(e, t, i);\n      }, M.prototype._setTextureParameterInteger = function (e, t, i, r) {\n        r && this._bindTextureDirectly(e, r, !0, !0), this._gl.texParameteri(e, t, i);\n      }, M.prototype.readPixels = function (e, t, i, r) {\n        var n = new Uint8Array(r * i * 4);\n        return this._gl.readPixels(e, t, i, r, this._gl.RGBA, this._gl.UNSIGNED_BYTE, n), n;\n      }, M.prototype.addExternalData = function (e, t) {\n        return this._externalData || (this._externalData = new R.StringDictionary()), this._externalData.add(e, t);\n      }, M.prototype.getExternalData = function (e) {\n        return this._externalData || (this._externalData = new R.StringDictionary()), this._externalData.get(e);\n      }, M.prototype.getOrAddExternalDataWithFactory = function (e, t) {\n        return this._externalData || (this._externalData = new R.StringDictionary()), this._externalData.getOrAddWithFactory(e, t);\n      }, M.prototype.removeExternalData = function (e) {\n        return this._externalData || (this._externalData = new R.StringDictionary()), this._externalData.remove(e);\n      }, M.prototype.unbindAllAttributes = function () {\n        if (this._mustWipeVertexAttributes) {\n          this._mustWipeVertexAttributes = !1;\n\n          for (var e = 0; e < this._caps.maxVertexAttribs; e++) this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1, this._currentBufferPointers[e].active = !1;\n        } else {\n          e = 0;\n\n          for (var t = this._vertexAttribArraysEnabled.length; e < t; e++) e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || (this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1, this._currentBufferPointers[e].active = !1);\n        }\n      }, M.prototype.releaseEffects = function () {\n        for (var e in this._compiledEffects) this._deleteProgram(this._compiledEffects[e]._program);\n\n        this._compiledEffects = {};\n      }, M.prototype.dispose = function () {\n        for (this.hideLoadingUI(), this.stopRenderLoop(); this.postProcesses.length;) this.postProcesses[0].dispose();\n\n        for (this._emptyTexture && (this._releaseTexture(this._emptyTexture), this._emptyTexture = null), this._emptyCubeTexture && (this._releaseTexture(this._emptyCubeTexture), this._emptyCubeTexture = null), this._rescalePostProcess && this._rescalePostProcess.dispose(); this.scenes.length;) this.scenes[0].dispose();\n\n        1 === M.Instances.length && M.audioEngine && M.audioEngine.dispose(), this.releaseEffects(), this.unbindAllAttributes(), this._boundUniforms = [], this._dummyFramebuffer && this._gl.deleteFramebuffer(this._dummyFramebuffer), this.disableVR(), R.Tools.IsWindowObjectExist() && (window.removeEventListener(\"blur\", this._onBlur), window.removeEventListener(\"focus\", this._onFocus), window.removeEventListener(\"vrdisplaypointerrestricted\", this._onVRDisplayPointerRestricted), window.removeEventListener(\"vrdisplaypointerunrestricted\", this._onVRDisplayPointerUnrestricted), this._renderingCanvas && (this._renderingCanvas.removeEventListener(\"focus\", this._onCanvasFocus), this._renderingCanvas.removeEventListener(\"blur\", this._onCanvasBlur), this._renderingCanvas.removeEventListener(\"pointerout\", this._onCanvasPointerOut), this._doNotHandleContextLost || (this._renderingCanvas.removeEventListener(\"webglcontextlost\", this._onContextLost), this._renderingCanvas.removeEventListener(\"webglcontextrestored\", this._onContextRestored))), document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange), document.removeEventListener(\"mozfullscreenchange\", this._onFullscreenChange), document.removeEventListener(\"webkitfullscreenchange\", this._onFullscreenChange), document.removeEventListener(\"msfullscreenchange\", this._onFullscreenChange), document.removeEventListener(\"pointerlockchange\", this._onPointerLockChange), document.removeEventListener(\"mspointerlockchange\", this._onPointerLockChange), document.removeEventListener(\"mozpointerlockchange\", this._onPointerLockChange), document.removeEventListener(\"webkitpointerlockchange\", this._onPointerLockChange), this._onVrDisplayConnect && (window.removeEventListener(\"vrdisplayconnect\", this._onVrDisplayConnect), this._onVrDisplayDisconnect && window.removeEventListener(\"vrdisplaydisconnect\", this._onVrDisplayDisconnect), this._onVrDisplayPresentChange && window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChange), this._onVrDisplayConnect = null, this._onVrDisplayDisconnect = null));\n        var e = M.Instances.indexOf(this);\n        0 <= e && M.Instances.splice(e, 1), this._workingCanvas = null, this._workingContext = null, this._currentBufferPointers = [], this._renderingCanvas = null, this._currentProgram = null, this._bindedRenderFunction = null, this.onResizeObservable.clear(), this.onCanvasBlurObservable.clear(), this.onCanvasFocusObservable.clear(), this.onCanvasPointerOutObservable.clear(), this.onBeginFrameObservable.clear(), this.onEndFrameObservable.clear(), R.Effect.ResetCache();\n\n        for (var t = 0, i = this._activeRequests; t < i.length; t++) {\n          i[t].abort();\n        }\n      }, M.prototype.displayLoadingUI = function () {\n        if (R.Tools.IsWindowObjectExist()) {\n          var e = this.loadingScreen;\n          e && e.displayLoadingUI();\n        }\n      }, M.prototype.hideLoadingUI = function () {\n        if (R.Tools.IsWindowObjectExist()) {\n          var e = this.loadingScreen;\n          e && e.hideLoadingUI();\n        }\n      }, Object.defineProperty(M.prototype, \"loadingScreen\", {\n        get: function () {\n          return !this._loadingScreen && R.DefaultLoadingScreen && this._renderingCanvas && (this._loadingScreen = new R.DefaultLoadingScreen(this._renderingCanvas)), this._loadingScreen;\n        },\n        set: function (e) {\n          this._loadingScreen = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"loadingUIText\", {\n        set: function (e) {\n          this.loadingScreen.loadingUIText = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(M.prototype, \"loadingUIBackgroundColor\", {\n        set: function (e) {\n          this.loadingScreen.loadingUIBackgroundColor = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), M.prototype.attachContextLostEvent = function (e) {\n        this._renderingCanvas && this._renderingCanvas.addEventListener(\"webglcontextlost\", e, !1);\n      }, M.prototype.attachContextRestoredEvent = function (e) {\n        this._renderingCanvas && this._renderingCanvas.addEventListener(\"webglcontextrestored\", e, !1);\n      }, M.prototype.getVertexShaderSource = function (e) {\n        var t = this._gl.getAttachedShaders(e);\n\n        return t ? this._gl.getShaderSource(t[0]) : null;\n      }, M.prototype.getFragmentShaderSource = function (e) {\n        var t = this._gl.getAttachedShaders(e);\n\n        return t ? this._gl.getShaderSource(t[1]) : null;\n      }, M.prototype.getError = function () {\n        return this._gl.getError();\n      }, M.prototype.getFps = function () {\n        return this._fps;\n      }, M.prototype.getDeltaTime = function () {\n        return this._deltaTime;\n      }, M.prototype._measureFps = function () {\n        this._performanceMonitor.sampleFrame(), this._fps = this._performanceMonitor.averageFPS, this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;\n      }, M.prototype._readTexturePixels = function (e, t, i, r, n, o) {\n        void 0 === r && (r = -1), void 0 === n && (n = 0), void 0 === o && (o = null);\n        var s = this._gl;\n\n        if (!this._dummyFramebuffer) {\n          var a = s.createFramebuffer();\n          if (!a) throw new Error(\"Unable to create dummy framebuffer\");\n          this._dummyFramebuffer = a;\n        }\n\n        s.bindFramebuffer(s.FRAMEBUFFER, this._dummyFramebuffer), -1 < r ? s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + r, e._webGLTexture, n) : s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e._webGLTexture, n);\n        var l = void 0 !== e.type ? this._getWebGLTextureType(e.type) : s.UNSIGNED_BYTE;\n\n        switch (l) {\n          case s.UNSIGNED_BYTE:\n            o || (o = new Uint8Array(4 * t * i)), l = s.UNSIGNED_BYTE;\n            break;\n\n          default:\n            o || (o = new Float32Array(4 * t * i)), l = s.FLOAT;\n        }\n\n        return s.readPixels(0, 0, t, i, s.RGBA, l, o), s.bindFramebuffer(s.FRAMEBUFFER, this._currentFramebuffer), o;\n      }, M.prototype._canRenderToFloatFramebuffer = function () {\n        return 1 < this._webGLVersion ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(M.TEXTURETYPE_FLOAT);\n      }, M.prototype._canRenderToHalfFloatFramebuffer = function () {\n        return 1 < this._webGLVersion ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(M.TEXTURETYPE_HALF_FLOAT);\n      }, M.prototype._canRenderToFramebuffer = function (e) {\n        for (var t = this._gl; t.getError() !== t.NO_ERROR;);\n\n        var i = !0,\n            r = t.createTexture();\n        t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(e), 1, 1, 0, t.RGBA, this._getWebGLTextureType(e), null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);\n        var n = t.createFramebuffer();\n        t.bindFramebuffer(t.FRAMEBUFFER, n), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);\n        var o = t.checkFramebufferStatus(t.FRAMEBUFFER);\n\n        if ((i = (i = i && o === t.FRAMEBUFFER_COMPLETE) && t.getError() === t.NO_ERROR) && (t.clear(t.COLOR_BUFFER_BIT), i = i && t.getError() === t.NO_ERROR), i) {\n          t.bindFramebuffer(t.FRAMEBUFFER, null);\n          var s = t.RGBA,\n              a = t.UNSIGNED_BYTE,\n              l = new Uint8Array(4);\n          t.readPixels(0, 0, 1, 1, s, a, l), i = i && t.getError() === t.NO_ERROR;\n        }\n\n        for (t.deleteTexture(r), t.deleteFramebuffer(n), t.bindFramebuffer(t.FRAMEBUFFER, null); !i && t.getError() !== t.NO_ERROR;);\n\n        return i;\n      }, M.prototype._getWebGLTextureType = function (e) {\n        if (1 === this._webGLVersion) {\n          switch (e) {\n            case M.TEXTURETYPE_FLOAT:\n              return this._gl.FLOAT;\n\n            case M.TEXTURETYPE_HALF_FLOAT:\n              return this._gl.HALF_FLOAT_OES;\n\n            case M.TEXTURETYPE_UNSIGNED_BYTE:\n              return this._gl.UNSIGNED_BYTE;\n          }\n\n          return this._gl.UNSIGNED_BYTE;\n        }\n\n        switch (e) {\n          case M.TEXTURETYPE_BYTE:\n            return this._gl.BYTE;\n\n          case M.TEXTURETYPE_UNSIGNED_BYTE:\n            return this._gl.UNSIGNED_BYTE;\n\n          case M.TEXTURETYPE_SHORT:\n            return this._gl.SHORT;\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT:\n            return this._gl.UNSIGNED_SHORT;\n\n          case M.TEXTURETYPE_INT:\n            return this._gl.INT;\n\n          case M.TEXTURETYPE_UNSIGNED_INTEGER:\n            return this._gl.UNSIGNED_INT;\n\n          case M.TEXTURETYPE_FLOAT:\n            return this._gl.FLOAT;\n\n          case M.TEXTURETYPE_HALF_FLOAT:\n            return this._gl.HALF_FLOAT;\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\n            return this._gl.UNSIGNED_SHORT_4_4_4_4;\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\n            return this._gl.UNSIGNED_SHORT_5_5_5_1;\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\n            return this._gl.UNSIGNED_SHORT_5_6_5;\n\n          case M.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\n            return this._gl.UNSIGNED_INT_2_10_10_10_REV;\n\n          case M.TEXTURETYPE_UNSIGNED_INT_24_8:\n            return this._gl.UNSIGNED_INT_24_8;\n\n          case M.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\n            return this._gl.UNSIGNED_INT_10F_11F_11F_REV;\n\n          case M.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\n            return this._gl.UNSIGNED_INT_5_9_9_9_REV;\n\n          case M.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV:\n            return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n        }\n\n        return this._gl.UNSIGNED_BYTE;\n      }, M.prototype._getInternalFormat = function (e) {\n        var t = this._gl.RGBA;\n\n        switch (e) {\n          case M.TEXTUREFORMAT_ALPHA:\n            t = this._gl.ALPHA;\n            break;\n\n          case M.TEXTUREFORMAT_LUMINANCE:\n            t = this._gl.LUMINANCE;\n            break;\n\n          case M.TEXTUREFORMAT_LUMINANCE_ALPHA:\n            t = this._gl.LUMINANCE_ALPHA;\n            break;\n\n          case M.TEXTUREFORMAT_RED:\n            t = this._gl.RED;\n            break;\n\n          case M.TEXTUREFORMAT_RG:\n            t = this._gl.RG;\n            break;\n\n          case M.TEXTUREFORMAT_RGB:\n            t = this._gl.RGB;\n            break;\n\n          case M.TEXTUREFORMAT_RGBA:\n            t = this._gl.RGBA;\n        }\n\n        if (1 < this._webGLVersion) switch (e) {\n          case M.TEXTUREFORMAT_RED_INTEGER:\n            t = this._gl.RED_INTEGER;\n            break;\n\n          case M.TEXTUREFORMAT_RG_INTEGER:\n            t = this._gl.RG_INTEGER;\n            break;\n\n          case M.TEXTUREFORMAT_RGB_INTEGER:\n            t = this._gl.RGB_INTEGER;\n            break;\n\n          case M.TEXTUREFORMAT_RGBA_INTEGER:\n            t = this._gl.RGBA_INTEGER;\n        }\n        return t;\n      }, M.prototype._getRGBABufferInternalSizedFormat = function (e, t) {\n        if (1 === this._webGLVersion) {\n          if (void 0 !== t) switch (t) {\n            case M.TEXTUREFORMAT_ALPHA:\n              return this._gl.ALPHA;\n\n            case M.TEXTUREFORMAT_LUMINANCE:\n              return this._gl.LUMINANCE;\n\n            case M.TEXTUREFORMAT_LUMINANCE_ALPHA:\n              return this._gl.LUMINANCE_ALPHA;\n          }\n          return this._gl.RGBA;\n        }\n\n        switch (e) {\n          case M.TEXTURETYPE_BYTE:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED:\n                return this._gl.R8_SNORM;\n\n              case M.TEXTUREFORMAT_RG:\n                return this._gl.RG8_SNORM;\n\n              case M.TEXTUREFORMAT_RGB:\n                return this._gl.RGB8_SNORM;\n\n              case M.TEXTUREFORMAT_RED_INTEGER:\n                return this._gl.R8I;\n\n              case M.TEXTUREFORMAT_RG_INTEGER:\n                return this._gl.RG8I;\n\n              case M.TEXTUREFORMAT_RGB_INTEGER:\n                return this._gl.RGB8I;\n\n              case M.TEXTUREFORMAT_RGBA_INTEGER:\n                return this._gl.RGBA8I;\n\n              default:\n                return this._gl.RGBA8_SNORM;\n            }\n\n          case M.TEXTURETYPE_UNSIGNED_BYTE:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED:\n                return this._gl.R8;\n\n              case M.TEXTUREFORMAT_RG:\n                return this._gl.RG8;\n\n              case M.TEXTUREFORMAT_RGB:\n                return this._gl.RGB8;\n\n              case M.TEXTUREFORMAT_RGBA:\n                return this._gl.RGBA8;\n\n              case M.TEXTUREFORMAT_RED_INTEGER:\n                return this._gl.R8UI;\n\n              case M.TEXTUREFORMAT_RG_INTEGER:\n                return this._gl.RG8UI;\n\n              case M.TEXTUREFORMAT_RGB_INTEGER:\n                return this._gl.RGB8UI;\n\n              case M.TEXTUREFORMAT_RGBA_INTEGER:\n                return this._gl.RGBA8UI;\n\n              default:\n                return this._gl.RGBA8;\n            }\n\n          case M.TEXTURETYPE_SHORT:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED_INTEGER:\n                return this._gl.R16I;\n\n              case M.TEXTUREFORMAT_RG_INTEGER:\n                return this._gl.RG16I;\n\n              case M.TEXTUREFORMAT_RGB_INTEGER:\n                return this._gl.RGB16I;\n\n              case M.TEXTUREFORMAT_RGBA_INTEGER:\n              default:\n                return this._gl.RGBA16I;\n            }\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED_INTEGER:\n                return this._gl.R16UI;\n\n              case M.TEXTUREFORMAT_RG_INTEGER:\n                return this._gl.RG16UI;\n\n              case M.TEXTUREFORMAT_RGB_INTEGER:\n                return this._gl.RGB16UI;\n\n              case M.TEXTUREFORMAT_RGBA_INTEGER:\n              default:\n                return this._gl.RGBA16UI;\n            }\n\n          case M.TEXTURETYPE_INT:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED_INTEGER:\n                return this._gl.R32I;\n\n              case M.TEXTUREFORMAT_RG_INTEGER:\n                return this._gl.RG32I;\n\n              case M.TEXTUREFORMAT_RGB_INTEGER:\n                return this._gl.RGB32I;\n\n              case M.TEXTUREFORMAT_RGBA_INTEGER:\n              default:\n                return this._gl.RGBA32I;\n            }\n\n          case M.TEXTURETYPE_UNSIGNED_INTEGER:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED_INTEGER:\n                return this._gl.R32UI;\n\n              case M.TEXTUREFORMAT_RG_INTEGER:\n                return this._gl.RG32UI;\n\n              case M.TEXTUREFORMAT_RGB_INTEGER:\n                return this._gl.RGB32UI;\n\n              case M.TEXTUREFORMAT_RGBA_INTEGER:\n              default:\n                return this._gl.RGBA32UI;\n            }\n\n          case M.TEXTURETYPE_FLOAT:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED:\n                return this._gl.R32F;\n\n              case M.TEXTUREFORMAT_RG:\n                return this._gl.RG32F;\n\n              case M.TEXTUREFORMAT_RGB:\n                return this._gl.RGB32F;\n\n              case M.TEXTUREFORMAT_RGBA:\n              default:\n                return this._gl.RGBA32F;\n            }\n\n          case M.TEXTURETYPE_HALF_FLOAT:\n            switch (t) {\n              case M.TEXTUREFORMAT_RED:\n                return this._gl.R16F;\n\n              case M.TEXTUREFORMAT_RG:\n                return this._gl.RG16F;\n\n              case M.TEXTUREFORMAT_RGB:\n                return this._gl.RGB16F;\n\n              case M.TEXTUREFORMAT_RGBA:\n              default:\n                return this._gl.RGBA16F;\n            }\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\n            return this._gl.RGB565;\n\n          case M.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\n            return this._gl.R11F_G11F_B10F;\n\n          case M.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\n            return this._gl.RGB9_E5;\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\n            return this._gl.RGBA4;\n\n          case M.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\n            return this._gl.RGB5_A1;\n\n          case M.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\n            switch (t) {\n              case M.TEXTUREFORMAT_RGBA:\n                return this._gl.RGB10_A2;\n\n              case M.TEXTUREFORMAT_RGBA_INTEGER:\n                return this._gl.RGB10_A2UI;\n\n              default:\n                return this._gl.RGB10_A2;\n            }\n\n        }\n\n        return this._gl.RGBA8;\n      }, M.prototype._getRGBAMultiSampleBufferFormat = function (e) {\n        return e === M.TEXTURETYPE_FLOAT ? this._gl.RGBA32F : e === M.TEXTURETYPE_HALF_FLOAT ? this._gl.RGBA16F : this._gl.RGBA8;\n      }, M.prototype._loadFile = function (e, t, i, r, n, o) {\n        var s = this,\n            a = R.Tools.LoadFile(e, t, i, r, n, o);\n        return this._activeRequests.push(a), a.onCompleteObservable.add(function (e) {\n          s._activeRequests.splice(s._activeRequests.indexOf(e), 1);\n        }), a;\n      }, M.prototype._loadFileAsync = function (e, r, n) {\n        var o = this;\n        return new Promise(function (t, i) {\n          o._loadFile(e, function (e) {\n            t(e);\n          }, void 0, r, n, function (e, t) {\n            i(t);\n          });\n        });\n      }, M.prototype._partialLoadFile = function (e, t, i, r, n, o) {\n        void 0 === o && (o = null);\n\n        this._loadFile(e, function (e) {\n          i[t] = e, i._internalCount++, 6 === i._internalCount && n(i);\n        }, void 0, void 0, !0, function (e, t) {\n          o && e && o(e.status + \" \" + e.statusText, t);\n        });\n      }, M.prototype._cascadeLoadFiles = function (e, t, i, r) {\n        void 0 === r && (r = null);\n\n        for (var n = [], o = n._internalCount = 0; o < 6; o++) this._partialLoadFile(i[o], o, n, e, t, r);\n      }, M.isSupported = function () {\n        try {\n          var e = document.createElement(\"canvas\");\n          return null != (e.getContext(\"webgl\") || e.getContext(\"experimental-webgl\")) && !!window.WebGLRenderingContext;\n        } catch (e) {\n          return !1;\n        }\n      }, M.ExceptionList = [{\n        key: \"Chrome/63.0\",\n        capture: \"63\\\\.0\\\\.3239\\\\.(\\\\d+)\",\n        captureConstraint: 108,\n        targets: [\"uniformBuffer\"]\n      }, {\n        key: \"Firefox/58\",\n        capture: null,\n        captureConstraint: null,\n        targets: [\"uniformBuffer\"]\n      }, {\n        key: \"Firefox/59\",\n        capture: null,\n        captureConstraint: null,\n        targets: [\"uniformBuffer\"]\n      }, {\n        key: \"Macintosh\",\n        capture: null,\n        captureConstraint: null,\n        targets: [\"textureBindingOptimization\"]\n      }, {\n        key: \"iPhone\",\n        capture: null,\n        captureConstraint: null,\n        targets: [\"textureBindingOptimization\"]\n      }, {\n        key: \"iPad\",\n        capture: null,\n        captureConstraint: null,\n        targets: [\"textureBindingOptimization\"]\n      }], M.Instances = new Array(), M._TextureLoaders = [], M.ALPHA_DISABLE = 0, M.ALPHA_ADD = 1, M.ALPHA_COMBINE = 2, M.ALPHA_SUBTRACT = 3, M.ALPHA_MULTIPLY = 4, M.ALPHA_MAXIMIZED = 5, M.ALPHA_ONEONE = 6, M.ALPHA_PREMULTIPLIED = 7, M.ALPHA_PREMULTIPLIED_PORTERDUFF = 8, M.ALPHA_INTERPOLATE = 9, M.ALPHA_SCREENMODE = 10, M.DELAYLOADSTATE_NONE = 0, M.DELAYLOADSTATE_LOADED = 1, M.DELAYLOADSTATE_LOADING = 2, M.DELAYLOADSTATE_NOTLOADED = 4, M.NEVER = 512, M.ALWAYS = 519, M.LESS = 513, M.EQUAL = 514, M.LEQUAL = 515, M.GREATER = 516, M.GEQUAL = 518, M.NOTEQUAL = 517, M.KEEP = 7680, M.REPLACE = 7681, M.INCR = 7682, M.DECR = 7683, M.INVERT = 5386, M.INCR_WRAP = 34055, M.DECR_WRAP = 34056, M.TEXTURE_CLAMP_ADDRESSMODE = 0, M.TEXTURE_WRAP_ADDRESSMODE = 1, M.TEXTURE_MIRROR_ADDRESSMODE = 2, M.TEXTUREFORMAT_ALPHA = 0, M.TEXTUREFORMAT_LUMINANCE = 1, M.TEXTUREFORMAT_LUMINANCE_ALPHA = 2, M.TEXTUREFORMAT_RGB = 4, M.TEXTUREFORMAT_RGBA = 5, M.TEXTUREFORMAT_RED = 6, M.TEXTUREFORMAT_R = 6, M.TEXTUREFORMAT_RG = 7, M.TEXTUREFORMAT_RED_INTEGER = 8, M.TEXTUREFORMAT_R_INTEGER = 8, M.TEXTUREFORMAT_RG_INTEGER = 9, M.TEXTUREFORMAT_RGB_INTEGER = 10, M.TEXTUREFORMAT_RGBA_INTEGER = 11, M.TEXTURETYPE_UNSIGNED_BYTE = 0, M.TEXTURETYPE_UNSIGNED_INT = 0, M.TEXTURETYPE_FLOAT = 1, M.TEXTURETYPE_HALF_FLOAT = 2, M.TEXTURETYPE_BYTE = 3, M.TEXTURETYPE_SHORT = 4, M.TEXTURETYPE_UNSIGNED_SHORT = 5, M.TEXTURETYPE_INT = 6, M.TEXTURETYPE_UNSIGNED_INTEGER = 7, M.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8, M.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9, M.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10, M.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11, M.TEXTURETYPE_UNSIGNED_INT_24_8 = 12, M.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13, M.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14, M.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15, M.TEXTURE_NEAREST_SAMPLINGMODE = 1, M.TEXTURE_BILINEAR_SAMPLINGMODE = 2, M.TEXTURE_TRILINEAR_SAMPLINGMODE = 3, M.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 1, M.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 2, M.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3, M.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4, M.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5, M.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6, M.TEXTURE_NEAREST_LINEAR = 7, M.TEXTURE_NEAREST_NEAREST = 8, M.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9, M.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10, M.TEXTURE_LINEAR_LINEAR = 11, M.TEXTURE_LINEAR_NEAREST = 12, M.TEXTURE_EXPLICIT_MODE = 0, M.TEXTURE_SPHERICAL_MODE = 1, M.TEXTURE_PLANAR_MODE = 2, M.TEXTURE_CUBIC_MODE = 3, M.TEXTURE_PROJECTION_MODE = 4, M.TEXTURE_SKYBOX_MODE = 5, M.TEXTURE_INVCUBIC_MODE = 6, M.TEXTURE_EQUIRECTANGULAR_MODE = 7, M.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8, M.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9, M.SCALEMODE_FLOOR = 1, M.SCALEMODE_NEAREST = 2, M.SCALEMODE_CEILING = 3, M.CollisionsEpsilon = .001, M.CodeRepository = \"src/\", M.ShadersRepository = \"src/Shaders/\", M;\n    }();\n\n    R.Engine = i;\n  }($a || ($a = {})), y = $a || ($a = {}), E = function () {\n    function e(e, t) {\n      void 0 === t && (t = null), this.state = \"\", this.metadata = null, this.doNotSerialize = !1, this._isDisposed = !1, this.animations = new Array(), this._ranges = {}, this._isEnabled = !0, this._isParentEnabled = !0, this._isReady = !0, this._currentRenderId = -1, this._parentRenderId = -1, this._childRenderId = -1, this._worldMatrix = y.Matrix.Identity(), this._worldMatrixDeterminant = 0, this._sceneRootNodesIndex = -1, this._animationPropertiesOverride = null, this.onDisposeObservable = new y.Observable(), this._behaviors = new Array(), this.name = e, this.id = e, this._scene = t || y.Engine.LastCreatedScene, this.uniqueId = this._scene.getUniqueId(), this._initCache(), this.addToSceneRootNodes();\n    }\n\n    return e.AddNodeConstructor = function (e, t) {\n      this._NodeConstructors[e] = t;\n    }, e.Construct = function (e, t, i, r) {\n      var n = this._NodeConstructors[e];\n      return n ? n(t, i, r) : null;\n    }, e.prototype.isDisposed = function () {\n      return this._isDisposed;\n    }, Object.defineProperty(e.prototype, \"parent\", {\n      get: function () {\n        return this._parentNode;\n      },\n      set: function (e) {\n        if (this._parentNode !== e) {\n          var t = this._parentNode;\n\n          if (this._parentNode && void 0 !== this._parentNode._children && null !== this._parentNode._children) {\n            var i = this._parentNode._children.indexOf(this);\n\n            -1 !== i && this._parentNode._children.splice(i, 1), e || this.addToSceneRootNodes();\n          }\n\n          this._parentNode = e, this._parentNode && (void 0 !== this._parentNode._children && null !== this._parentNode._children || (this._parentNode._children = new Array()), this._parentNode._children.push(this), t || this.removeFromSceneRootNodes()), this._syncParentEnabledState();\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.addToSceneRootNodes = function () {\n      -1 === this._sceneRootNodesIndex && (this._sceneRootNodesIndex = this._scene.rootNodes.length, this._scene.rootNodes.push(this));\n    }, e.prototype.removeFromSceneRootNodes = function () {\n      if (-1 !== this._sceneRootNodesIndex) {\n        var e = this._scene.rootNodes,\n            t = e.length - 1;\n        e[this._sceneRootNodesIndex] = e[t], e[this._sceneRootNodesIndex]._sceneRootNodesIndex = this._sceneRootNodesIndex, this._scene.rootNodes.pop(), this._sceneRootNodesIndex = -1;\n      }\n    }, Object.defineProperty(e.prototype, \"animationPropertiesOverride\", {\n      get: function () {\n        return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride;\n      },\n      set: function (e) {\n        this._animationPropertiesOverride = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getClassName = function () {\n      return \"Node\";\n    }, Object.defineProperty(e.prototype, \"onDispose\", {\n      set: function (e) {\n        this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getScene = function () {\n      return this._scene;\n    }, e.prototype.getEngine = function () {\n      return this._scene.getEngine();\n    }, e.prototype.addBehavior = function (e, t) {\n      var i = this;\n      return void 0 === t && (t = !1), -1 !== this._behaviors.indexOf(e) || (e.init(), this._scene.isLoading && !t ? this._scene.onDataLoadedObservable.addOnce(function () {\n        e.attach(i);\n      }) : e.attach(this), this._behaviors.push(e)), this;\n    }, e.prototype.removeBehavior = function (e) {\n      var t = this._behaviors.indexOf(e);\n\n      return -1 === t || (this._behaviors[t].detach(), this._behaviors.splice(t, 1)), this;\n    }, Object.defineProperty(e.prototype, \"behaviors\", {\n      get: function () {\n        return this._behaviors;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getBehaviorByName = function (e) {\n      for (var t = 0, i = this._behaviors; t < i.length; t++) {\n        var r = i[t];\n        if (r.name === e) return r;\n      }\n\n      return null;\n    }, e.prototype.getWorldMatrix = function () {\n      return this._currentRenderId !== this._scene.getRenderId() && this.computeWorldMatrix(), this._worldMatrix;\n    }, e.prototype._getWorldMatrixDeterminant = function () {\n      return this._worldMatrixDeterminant;\n    }, Object.defineProperty(e.prototype, \"worldMatrixFromCache\", {\n      get: function () {\n        return this._worldMatrix;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._initCache = function () {\n      this._cache = {}, this._cache.parent = void 0;\n    }, e.prototype.updateCache = function (e) {\n      !e && this.isSynchronized() || (this._cache.parent = this.parent, this._updateCache());\n    }, e.prototype._updateCache = function (e) {}, e.prototype._isSynchronized = function () {\n      return !0;\n    }, e.prototype._markSyncedWithParent = function () {\n      this._parentNode && (this._parentRenderId = this._parentNode._childRenderId);\n    }, e.prototype.isSynchronizedWithParent = function () {\n      return !this._parentNode || this._parentRenderId === this._parentNode._childRenderId && this._parentNode.isSynchronized();\n    }, e.prototype.isSynchronized = function () {\n      return this._cache.parent != this._parentNode ? (this._cache.parent = this._parentNode, !1) : !(this._parentNode && !this.isSynchronizedWithParent()) && this._isSynchronized();\n    }, e.prototype.isReady = function (e) {\n      return void 0 === e && (e = !1), this._isReady;\n    }, e.prototype.isEnabled = function (e) {\n      return void 0 === e && (e = !0), !1 === e ? this._isEnabled : !!this._isEnabled && this._isParentEnabled;\n    }, e.prototype._syncParentEnabledState = function () {\n      this._isParentEnabled = !this._parentNode || this._parentNode.isEnabled(), this._children && this._children.forEach(function (e) {\n        e._syncParentEnabledState();\n      });\n    }, e.prototype.setEnabled = function (e) {\n      this._isEnabled = e, this._syncParentEnabledState();\n    }, e.prototype.isDescendantOf = function (e) {\n      return !!this.parent && (this.parent === e || this.parent.isDescendantOf(e));\n    }, e.prototype._getDescendants = function (e, t, i) {\n      if (void 0 === t && (t = !1), this._children) for (var r = 0; r < this._children.length; r++) {\n        var n = this._children[r];\n        i && !i(n) || e.push(n), t || n._getDescendants(e, !1, i);\n      }\n    }, e.prototype.getDescendants = function (e, t) {\n      var i = new Array();\n      return this._getDescendants(i, e, t), i;\n    }, e.prototype.getChildMeshes = function (e, t) {\n      var i = [];\n      return this._getDescendants(i, e, function (e) {\n        return (!t || t(e)) && e instanceof y.AbstractMesh;\n      }), i;\n    }, e.prototype.getChildTransformNodes = function (e, t) {\n      var i = [];\n      return this._getDescendants(i, e, function (e) {\n        return (!t || t(e)) && e instanceof y.TransformNode;\n      }), i;\n    }, e.prototype.getChildren = function (e) {\n      return this.getDescendants(!0, e);\n    }, e.prototype._setReady = function (e) {\n      e !== this._isReady && (e ? (this.onReady && this.onReady(this), this._isReady = !0) : this._isReady = !1);\n    }, e.prototype.getAnimationByName = function (e) {\n      for (var t = 0; t < this.animations.length; t++) {\n        var i = this.animations[t];\n        if (i.name === e) return i;\n      }\n\n      return null;\n    }, e.prototype.createAnimationRange = function (e, t, i) {\n      if (!this._ranges[e]) {\n        this._ranges[e] = new y.AnimationRange(e, t, i);\n\n        for (var r = 0, n = this.animations.length; r < n; r++) this.animations[r] && this.animations[r].createRange(e, t, i);\n      }\n    }, e.prototype.deleteAnimationRange = function (e, t) {\n      void 0 === t && (t = !0);\n\n      for (var i = 0, r = this.animations.length; i < r; i++) this.animations[i] && this.animations[i].deleteRange(e, t);\n\n      this._ranges[e] = null;\n    }, e.prototype.getAnimationRange = function (e) {\n      return this._ranges[e];\n    }, e.prototype.beginAnimation = function (e, t, i, r) {\n      var n = this.getAnimationRange(e);\n      return n ? this._scene.beginAnimation(this, n.from, n.to, t, i, r) : null;\n    }, e.prototype.serializeAnimationRanges = function () {\n      var e = [];\n\n      for (var t in this._ranges) {\n        var i = this._ranges[t];\n\n        if (i) {\n          var r = {};\n          r.name = t, r.from = i.from, r.to = i.to, e.push(r);\n        }\n      }\n\n      return e;\n    }, e.prototype.computeWorldMatrix = function (e) {\n      return this._worldMatrix || (this._worldMatrix = y.Matrix.Identity()), this._worldMatrix;\n    }, e.prototype.dispose = function (e, t) {\n      if (void 0 === t && (t = !1), e) for (var i = 0, r = this.getChildTransformNodes(!0); i < r.length; i++) {\n        var n = r[i];\n        n.parent = null, n.computeWorldMatrix(!0);\n      } else for (var o = 0, s = this.getDescendants(!0); o < s.length; o++) {\n        s[o].dispose(e, t);\n      }\n      this.parent ? this.parent = null : this.removeFromSceneRootNodes(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear();\n\n      for (var a = 0, l = this._behaviors; a < l.length; a++) {\n        l[a].detach();\n      }\n\n      this._behaviors = [], this._isDisposed = !0;\n    }, e.ParseAnimationRanges = function (e, t, i) {\n      if (t.ranges) for (var r = 0; r < t.ranges.length; r++) {\n        var n = t.ranges[r];\n        e.createAnimationRange(n.name, n.from, n.to);\n      }\n    }, e._NodeConstructors = {}, b([y.serialize()], e.prototype, \"name\", void 0), b([y.serialize()], e.prototype, \"id\", void 0), b([y.serialize()], e.prototype, \"uniqueId\", void 0), b([y.serialize()], e.prototype, \"state\", void 0), b([y.serialize()], e.prototype, \"metadata\", void 0), e;\n  }(), y.Node = E, x = $a || ($a = {}), P = x.Matrix.Identity(), A = function () {\n    function e(e, t) {\n      this.center = x.Vector3.Zero(), this.centerWorld = x.Vector3.Zero(), this.minimum = x.Vector3.Zero(), this.maximum = x.Vector3.Zero(), this.reConstruct(e, t);\n    }\n\n    return e.prototype.reConstruct = function (e, t) {\n      this.minimum.copyFrom(e), this.maximum.copyFrom(t);\n      var i = x.Vector3.Distance(e, t);\n      x.Vector3.LerpToRef(e, t, .5, this.center), this.radius = .5 * i, this.centerWorld.set(0, 0, 0), this._update(P);\n    }, e.prototype.scale = function (e) {\n      var t = this.radius * e,\n          i = x.Tmp.Vector3[0].set(t, t, t),\n          r = x.Tmp.Vector3[1].copyFrom(this.center).subtractInPlace(i),\n          n = x.Tmp.Vector3[2].copyFrom(this.center).addInPlace(i);\n      return this.reConstruct(r, n), this;\n    }, e.prototype._update = function (e) {\n      x.Vector3.TransformCoordinatesToRef(this.center, e, this.centerWorld);\n      var t = x.Tmp.Vector3[0];\n      x.Vector3.TransformNormalFromFloatsToRef(1, 1, 1, e, t), this.radiusWorld = Math.max(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)) * this.radius;\n    }, e.prototype.isInFrustum = function (e) {\n      for (var t = 0; t < 6; t++) if (e[t].dotCoordinate(this.centerWorld) <= -this.radiusWorld) return !1;\n\n      return !0;\n    }, e.prototype.intersectsPoint = function (e) {\n      var t = this.centerWorld.x - e.x,\n          i = this.centerWorld.y - e.y,\n          r = this.centerWorld.z - e.z,\n          n = Math.sqrt(t * t + i * i + r * r);\n      return !(this.radiusWorld < n);\n    }, e.Intersects = function (e, t) {\n      var i = e.centerWorld.x - t.centerWorld.x,\n          r = e.centerWorld.y - t.centerWorld.y,\n          n = e.centerWorld.z - t.centerWorld.z,\n          o = Math.sqrt(i * i + r * r + n * n);\n      return !(e.radiusWorld + t.radiusWorld < o);\n    }, e;\n  }(), x.BoundingSphere = A, S = $a || ($a = {}), M = function () {\n    function t(e, t) {\n      this.vectors = [S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero()], this.center = S.Vector3.Zero(), this.centerWorld = S.Vector3.Zero(), this.extendSize = S.Vector3.Zero(), this.extendSizeWorld = S.Vector3.Zero(), this.directions = [S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero()], this.vectorsWorld = [S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero(), S.Vector3.Zero()], this.minimumWorld = S.Vector3.Zero(), this.maximumWorld = S.Vector3.Zero(), this.minimum = S.Vector3.Zero(), this.maximum = S.Vector3.Zero(), this.reConstruct(e, t);\n    }\n\n    return t.prototype.reConstruct = function (e, t) {\n      this.minimum.copyFrom(e), this.maximum.copyFrom(t), this.vectors[0].copyFrom(this.minimum), this.vectors[1].copyFrom(this.maximum), this.vectors[2].copyFrom(this.minimum), this.vectors[3].copyFrom(this.minimum), this.vectors[4].copyFrom(this.minimum), this.vectors[5].copyFrom(this.maximum), this.vectors[6].copyFrom(this.maximum), this.vectors[7].copyFrom(this.maximum), this.vectors[2].x = this.maximum.x, this.vectors[3].y = this.maximum.y, this.vectors[4].z = this.maximum.z, this.vectors[5].z = this.minimum.z, this.vectors[6].x = this.minimum.x, this.vectors[7].y = this.minimum.y, this.center.copyFrom(this.maximum).addInPlace(this.minimum).scaleInPlace(.5), this.extendSize.copyFrom(this.maximum).subtractInPlace(this.minimum).scaleInPlace(.5);\n\n      for (var i = 0; i < 3; i++) this.directions[i].copyFromFloats(0, 0, 0);\n\n      for (i = 0; i < 8; i++) this.vectorsWorld[i].copyFromFloats(0, 0, 0);\n\n      this.minimumWorld.copyFromFloats(0, 0, 0), this.maximumWorld.copyFromFloats(0, 0, 0), this.centerWorld.copyFromFloats(0, 0, 0), this.extendSizeWorld.copyFromFloats(0, 0, 0), this._update(this._worldMatrix || S.Matrix.Identity());\n    }, t.prototype.scale = function (e) {\n      var t = S.Tmp.Vector3[0].copyFrom(this.maximum).subtractInPlace(this.minimum),\n          i = t.length() * e;\n      t.normalize();\n      var r = t.scaleInPlace(.5 * i),\n          n = S.Tmp.Vector3[1].copyFrom(this.center).subtractInPlace(r),\n          o = S.Tmp.Vector3[2].copyFrom(this.center).addInPlace(r);\n      return this.reConstruct(n, o), this;\n    }, t.prototype.getWorldMatrix = function () {\n      return this._worldMatrix;\n    }, t.prototype.setWorldMatrix = function (e) {\n      return this._worldMatrix.copyFrom(e), this;\n    }, t.prototype._update = function (e) {\n      S.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimumWorld), S.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximumWorld);\n\n      for (var t = 0; t < 8; t++) {\n        var i = this.vectorsWorld[t];\n        S.Vector3.TransformCoordinatesToRef(this.vectors[t], e, i), this.minimumWorld.minimizeInPlace(i), this.maximumWorld.maximizeInPlace(i);\n      }\n\n      this.maximumWorld.subtractToRef(this.minimumWorld, this.extendSizeWorld), this.extendSizeWorld.scaleInPlace(.5), this.maximumWorld.addToRef(this.minimumWorld, this.centerWorld), this.centerWorld.scaleInPlace(.5), S.Vector3.FromFloatArrayToRef(e.m, 0, this.directions[0]), S.Vector3.FromFloatArrayToRef(e.m, 4, this.directions[1]), S.Vector3.FromFloatArrayToRef(e.m, 8, this.directions[2]), this._worldMatrix = e;\n    }, t.prototype.isInFrustum = function (e) {\n      return t.IsInFrustum(this.vectorsWorld, e);\n    }, t.prototype.isCompletelyInFrustum = function (e) {\n      return t.IsCompletelyInFrustum(this.vectorsWorld, e);\n    }, t.prototype.intersectsPoint = function (e) {\n      var t = -S.Epsilon;\n      return !(this.maximumWorld.x - e.x < t || t > e.x - this.minimumWorld.x) && !(this.maximumWorld.y - e.y < t || t > e.y - this.minimumWorld.y) && !(this.maximumWorld.z - e.z < t || t > e.z - this.minimumWorld.z);\n    }, t.prototype.intersectsSphere = function (e) {\n      return t.IntersectsSphere(this.minimumWorld, this.maximumWorld, e.centerWorld, e.radiusWorld);\n    }, t.prototype.intersectsMinMax = function (e, t) {\n      return !(this.maximumWorld.x < e.x || this.minimumWorld.x > t.x) && !(this.maximumWorld.y < e.y || this.minimumWorld.y > t.y) && !(this.maximumWorld.z < e.z || this.minimumWorld.z > t.z);\n    }, t.Intersects = function (e, t) {\n      return !(e.maximumWorld.x < t.minimumWorld.x || e.minimumWorld.x > t.maximumWorld.x) && !(e.maximumWorld.y < t.minimumWorld.y || e.minimumWorld.y > t.maximumWorld.y) && !(e.maximumWorld.z < t.minimumWorld.z || e.minimumWorld.z > t.maximumWorld.z);\n    }, t.IntersectsSphere = function (e, t, i, r) {\n      var n = S.Vector3.Clamp(i, e, t);\n      return S.Vector3.DistanceSquared(i, n) <= r * r;\n    }, t.IsCompletelyInFrustum = function (e, t) {\n      for (var i = 0; i < 6; i++) for (var r = 0; r < 8; r++) if (t[i].dotCoordinate(e[r]) < 0) return !1;\n\n      return !0;\n    }, t.IsInFrustum = function (e, t) {\n      for (var i = 0; i < 6; i++) {\n        for (var r = 8, n = 0; n < 8 && t[i].dotCoordinate(e[n]) < 0; n++) --r;\n\n        if (0 === r) return !1;\n      }\n\n      return !0;\n    }, t;\n  }(), S.BoundingBox = M, R = $a || ($a = {}), C = function (e, t) {\n    var i = R.Vector3.Dot(t.centerWorld, e),\n        r = Math.abs(R.Vector3.Dot(t.directions[0], e)) * t.extendSize.x + Math.abs(R.Vector3.Dot(t.directions[1], e)) * t.extendSize.y + Math.abs(R.Vector3.Dot(t.directions[2], e)) * t.extendSize.z;\n    return {\n      min: i - r,\n      max: i + r\n    };\n  }, O = function (e, t, i) {\n    var r,\n        n,\n        o,\n        s = C(e, t),\n        a = C(e, i);\n    return r = s.min, n = s.max, o = a.min, !(a.max < r || n < o);\n  }, D = function () {\n    function e(e, t) {\n      this._isLocked = !1, this.boundingBox = new R.BoundingBox(e, t), this.boundingSphere = new R.BoundingSphere(e, t);\n    }\n\n    return Object.defineProperty(e.prototype, \"minimum\", {\n      get: function () {\n        return this.boundingBox.minimum;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"maximum\", {\n      get: function () {\n        return this.boundingBox.maximum;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isLocked\", {\n      get: function () {\n        return this._isLocked;\n      },\n      set: function (e) {\n        this._isLocked = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.update = function (e) {\n      this._isLocked || (this.boundingBox._update(e), this.boundingSphere._update(e));\n    }, e.prototype.centerOn = function (e, t) {\n      var i = R.Tmp.Vector3[0].copyFrom(e).subtractInPlace(t),\n          r = R.Tmp.Vector3[1].copyFrom(e).addInPlace(t);\n      return this.boundingBox.reConstruct(i, r), this.boundingSphere.reConstruct(i, r), this;\n    }, e.prototype.scale = function (e) {\n      return this.boundingBox.scale(e), this.boundingSphere.scale(e), this;\n    }, e.prototype.isInFrustum = function (e, t) {\n      return void 0 === t && (t = R.AbstractMesh.CULLINGSTRATEGY_STANDARD), !!this.boundingSphere.isInFrustum(e) && (t === R.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || this.boundingBox.isInFrustum(e));\n    }, Object.defineProperty(e.prototype, \"diagonalLength\", {\n      get: function () {\n        var e = this.boundingBox;\n        return e.maximumWorld.subtract(e.minimumWorld).length();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.isCompletelyInFrustum = function (e) {\n      return this.boundingBox.isCompletelyInFrustum(e);\n    }, e.prototype._checkCollision = function (e) {\n      return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n    }, e.prototype.intersectsPoint = function (e) {\n      return !!this.boundingSphere.centerWorld && !!this.boundingSphere.intersectsPoint(e) && !!this.boundingBox.intersectsPoint(e);\n    }, e.prototype.intersects = function (e, t) {\n      if (!this.boundingSphere.centerWorld || !e.boundingSphere.centerWorld) return !1;\n      if (!R.BoundingSphere.Intersects(this.boundingSphere, e.boundingSphere)) return !1;\n      if (!R.BoundingBox.Intersects(this.boundingBox, e.boundingBox)) return !1;\n      if (!t) return !0;\n      var i = this.boundingBox,\n          r = e.boundingBox;\n      return !!O(i.directions[0], i, r) && !!O(i.directions[1], i, r) && !!O(i.directions[2], i, r) && !!O(r.directions[0], i, r) && !!O(r.directions[1], i, r) && !!O(r.directions[2], i, r) && !!O(R.Vector3.Cross(i.directions[0], r.directions[0]), i, r) && !!O(R.Vector3.Cross(i.directions[0], r.directions[1]), i, r) && !!O(R.Vector3.Cross(i.directions[0], r.directions[2]), i, r) && !!O(R.Vector3.Cross(i.directions[1], r.directions[0]), i, r) && !!O(R.Vector3.Cross(i.directions[1], r.directions[1]), i, r) && !!O(R.Vector3.Cross(i.directions[1], r.directions[2]), i, r) && !!O(R.Vector3.Cross(i.directions[2], r.directions[0]), i, r) && !!O(R.Vector3.Cross(i.directions[2], r.directions[1]), i, r) && !!O(R.Vector3.Cross(i.directions[2], r.directions[2]), i, r);\n    }, e;\n  }(), R.BoundingInfo = D, I = $a || ($a = {}), w = function (n) {\n    function h(e, t, i) {\n      void 0 === t && (t = null), void 0 === i && (i = !0);\n      var r = n.call(this, e, t) || this;\n      return r._forward = new I.Vector3(0, 0, 1), r._forwardInverted = new I.Vector3(0, 0, -1), r._up = new I.Vector3(0, 1, 0), r._right = new I.Vector3(1, 0, 0), r._rightInverted = new I.Vector3(-1, 0, 0), r._position = I.Vector3.Zero(), r._rotation = I.Vector3.Zero(), r._scaling = I.Vector3.One(), r._isDirty = !1, r.billboardMode = h.BILLBOARDMODE_NONE, r.scalingDeterminant = 1, r.infiniteDistance = !1, r.ignoreNonUniformScaling = !1, r._localWorld = I.Matrix.Zero(), r._absolutePosition = I.Vector3.Zero(), r._pivotMatrix = I.Matrix.Identity(), r._postMultiplyPivotMatrix = !1, r._isWorldMatrixFrozen = !1, r.onAfterWorldMatrixUpdateObservable = new I.Observable(), r._nonUniformScaling = !1, i && r.getScene().addTransformNode(r), r;\n    }\n\n    return T(h, n), h.prototype.getClassName = function () {\n      return \"TransformNode\";\n    }, Object.defineProperty(h.prototype, \"position\", {\n      get: function () {\n        return this._position;\n      },\n      set: function (e) {\n        this._position = e, this._isDirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"rotation\", {\n      get: function () {\n        return this._rotation;\n      },\n      set: function (e) {\n        this._rotation = e, this._isDirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"scaling\", {\n      get: function () {\n        return this._scaling;\n      },\n      set: function (e) {\n        this._scaling = e, this._isDirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"rotationQuaternion\", {\n      get: function () {\n        return this._rotationQuaternion;\n      },\n      set: function (e) {\n        (this._rotationQuaternion = e) && this.rotation.length() && this.rotation.copyFromFloats(0, 0, 0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"forward\", {\n      get: function () {\n        return I.Vector3.Normalize(I.Vector3.TransformNormal(this.getScene().useRightHandedSystem ? this._forwardInverted : this._forward, this.getWorldMatrix()));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"up\", {\n      get: function () {\n        return I.Vector3.Normalize(I.Vector3.TransformNormal(this._up, this.getWorldMatrix()));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"right\", {\n      get: function () {\n        return I.Vector3.Normalize(I.Vector3.TransformNormal(this.getScene().useRightHandedSystem ? this._rightInverted : this._right, this.getWorldMatrix()));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), h.prototype.updatePoseMatrix = function (e) {\n      return this._poseMatrix.copyFrom(e), this;\n    }, h.prototype.getPoseMatrix = function () {\n      return this._poseMatrix;\n    }, h.prototype._isSynchronized = function () {\n      return !this._isDirty && this.billboardMode === this._cache.billboardMode && this.billboardMode === h.BILLBOARDMODE_NONE && !this._cache.pivotMatrixUpdated && !this.infiniteDistance && !!this._cache.position.equals(this._position) && !(this._rotationQuaternion && !this._cache.rotationQuaternion.equals(this._rotationQuaternion)) && !!this._cache.rotation.equals(this._rotation) && !!this._cache.scaling.equals(this._scaling);\n    }, h.prototype._initCache = function () {\n      n.prototype._initCache.call(this), this._cache.localMatrixUpdated = !1, this._cache.position = I.Vector3.Zero(), this._cache.scaling = I.Vector3.Zero(), this._cache.rotation = I.Vector3.Zero(), this._cache.rotationQuaternion = new I.Quaternion(0, 0, 0, 0), this._cache.billboardMode = -1;\n    }, h.prototype.markAsDirty = function (e) {\n      return \"rotation\" === e && (this.rotationQuaternion = null), this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this;\n    }, Object.defineProperty(h.prototype, \"absolutePosition\", {\n      get: function () {\n        return this._absolutePosition;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), h.prototype.setPreTransformMatrix = function (e) {\n      return this.setPivotMatrix(e, !1);\n    }, h.prototype.setPivotMatrix = function (e, t) {\n      return void 0 === t && (t = !0), this._pivotMatrix = e.clone(), this._cache.pivotMatrixUpdated = !0, this._postMultiplyPivotMatrix = t, this._postMultiplyPivotMatrix && (this._pivotMatrixInverse ? this._pivotMatrix.invertToRef(this._pivotMatrixInverse) : this._pivotMatrixInverse = I.Matrix.Invert(this._pivotMatrix)), this;\n    }, h.prototype.getPivotMatrix = function () {\n      return this._pivotMatrix;\n    }, h.prototype.freezeWorldMatrix = function () {\n      return this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this._isWorldMatrixFrozen = !0, this;\n    }, h.prototype.unfreezeWorldMatrix = function () {\n      return this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this;\n    }, Object.defineProperty(h.prototype, \"isWorldMatrixFrozen\", {\n      get: function () {\n        return this._isWorldMatrixFrozen;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), h.prototype.getAbsolutePosition = function () {\n      return this.computeWorldMatrix(), this._absolutePosition;\n    }, h.prototype.setAbsolutePosition = function (e) {\n      if (!e) return this;\n      var t, i, r;\n\n      if (void 0 === e.x) {\n        if (arguments.length < 3) return this;\n        t = e, i = arguments[1], r = arguments[2];\n      } else t = e.x, i = e.y, r = e.z;\n\n      if (this.parent) {\n        var n = this.parent.getWorldMatrix().clone();\n        n.invert();\n        var o = new I.Vector3(t, i, r);\n        this.position = I.Vector3.TransformCoordinates(o, n);\n      } else this.position.x = t, this.position.y = i, this.position.z = r;\n\n      return this;\n    }, h.prototype.setPositionWithLocalVector = function (e) {\n      return this.computeWorldMatrix(), this.position = I.Vector3.TransformNormal(e, this._localWorld), this;\n    }, h.prototype.getPositionExpressedInLocalSpace = function () {\n      this.computeWorldMatrix();\n\n      var e = this._localWorld.clone();\n\n      return e.invert(), I.Vector3.TransformNormal(this.position, e);\n    }, h.prototype.locallyTranslate = function (e) {\n      return this.computeWorldMatrix(!0), this.position = I.Vector3.TransformCoordinates(e, this._localWorld), this;\n    }, h.prototype.lookAt = function (e, t, i, r, n) {\n      void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === n && (n = I.Space.LOCAL);\n      var o = h._lookAtVectorCache,\n          s = n === I.Space.LOCAL ? this.position : this.getAbsolutePosition();\n      e.subtractToRef(s, o);\n      var a = -Math.atan2(o.z, o.x) - Math.PI / 2,\n          l = Math.sqrt(o.x * o.x + o.z * o.z),\n          c = Math.atan2(o.y, l);\n      return this.rotationQuaternion ? I.Quaternion.RotationYawPitchRollToRef(a + t, c + i, r, this.rotationQuaternion) : (this.rotation.x = c + i, this.rotation.y = a + t, this.rotation.z = r), this;\n    }, h.prototype.getDirection = function (e) {\n      var t = I.Vector3.Zero();\n      return this.getDirectionToRef(e, t), t;\n    }, h.prototype.getDirectionToRef = function (e, t) {\n      return I.Vector3.TransformNormalToRef(e, this.getWorldMatrix(), t), this;\n    }, h.prototype.setPivotPoint = function (e, t) {\n      void 0 === t && (t = I.Space.LOCAL), 0 == this.getScene().getRenderId() && this.computeWorldMatrix(!0);\n      var i = this.getWorldMatrix();\n\n      if (t == I.Space.WORLD) {\n        var r = I.Tmp.Matrix[0];\n        i.invertToRef(r), e = I.Vector3.TransformCoordinates(e, r);\n      }\n\n      return this.setPivotMatrix(I.Matrix.Translation(-e.x, -e.y, -e.z), !0);\n    }, h.prototype.getPivotPoint = function () {\n      var e = I.Vector3.Zero();\n      return this.getPivotPointToRef(e), e;\n    }, h.prototype.getPivotPointToRef = function (e) {\n      return e.x = -this._pivotMatrix.m[12], e.y = -this._pivotMatrix.m[13], e.z = -this._pivotMatrix.m[14], this;\n    }, h.prototype.getAbsolutePivotPoint = function () {\n      var e = I.Vector3.Zero();\n      return this.getAbsolutePivotPointToRef(e), e;\n    }, h.prototype.getAbsolutePivotPointToRef = function (e) {\n      return e.x = this._pivotMatrix.m[12], e.y = this._pivotMatrix.m[13], e.z = this._pivotMatrix.m[14], this.getPivotPointToRef(e), I.Vector3.TransformCoordinatesToRef(e, this.getWorldMatrix(), e), this;\n    }, h.prototype.setParent = function (e) {\n      if (!e && !this.parent) return this;\n\n      if (e) {\n        r = I.Tmp.Quaternion[0], n = I.Tmp.Vector3[0], o = I.Tmp.Vector3[1];\n        var t = I.Tmp.Matrix[0],\n            i = I.Tmp.Matrix[1];\n        this.computeWorldMatrix(!0), e.computeWorldMatrix(!0), e.getWorldMatrix().invertToRef(i), this.getWorldMatrix().multiplyToRef(i, t), t.decompose(o, r, n), this.rotationQuaternion ? this.rotationQuaternion.copyFrom(r) : r.toEulerAnglesToRef(this.rotation), this.position.x = n.x, this.position.y = n.y, this.position.z = n.z, this.scaling.x = o.x, this.scaling.y = o.y, this.scaling.z = o.z;\n      } else {\n        var r = I.Tmp.Quaternion[0],\n            n = I.Tmp.Vector3[0],\n            o = I.Tmp.Vector3[1];\n        this.parent && this.parent.computeWorldMatrix && this.parent.computeWorldMatrix(!0), this.computeWorldMatrix(!0), this.getWorldMatrix().decompose(o, r, n), this.rotationQuaternion ? this.rotationQuaternion.copyFrom(r) : r.toEulerAnglesToRef(this.rotation), this.scaling.x = o.x, this.scaling.y = o.y, this.scaling.z = o.z, this.position.x = n.x, this.position.y = n.y, this.position.z = n.z;\n      }\n\n      return this.parent = e, this;\n    }, Object.defineProperty(h.prototype, \"nonUniformScaling\", {\n      get: function () {\n        return this._nonUniformScaling;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), h.prototype._updateNonUniformScalingState = function (e) {\n      return this._nonUniformScaling !== e && (this._nonUniformScaling = e, !0);\n    }, h.prototype.attachToBone = function (e, t) {\n      return this._transformToBoneReferal = t, (this.parent = e).getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this;\n    }, h.prototype.detachFromBone = function () {\n      return this.parent && (this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this._transformToBoneReferal = null, this.parent = null), this;\n    }, h.prototype.rotate = function (e, t, i) {\n      var r;\n\n      if (e.normalize(), this.rotationQuaternion || (this.rotationQuaternion = I.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation = I.Vector3.Zero()), i && i !== I.Space.LOCAL) {\n        if (this.parent) {\n          var n = this.parent.getWorldMatrix().clone();\n          n.invert(), e = I.Vector3.TransformNormal(e, n);\n        }\n\n        (r = I.Quaternion.RotationAxisToRef(e, t, h._rotationAxisCache)).multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n      } else r = I.Quaternion.RotationAxisToRef(e, t, h._rotationAxisCache), this.rotationQuaternion.multiplyToRef(r, this.rotationQuaternion);\n\n      return this;\n    }, h.prototype.rotateAround = function (e, t, i) {\n      return t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = I.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation.copyFromFloats(0, 0, 0)), e.subtractToRef(this.position, I.Tmp.Vector3[0]), I.Matrix.TranslationToRef(I.Tmp.Vector3[0].x, I.Tmp.Vector3[0].y, I.Tmp.Vector3[0].z, I.Tmp.Matrix[0]), I.Tmp.Matrix[0].invertToRef(I.Tmp.Matrix[2]), I.Matrix.RotationAxisToRef(t, i, I.Tmp.Matrix[1]), I.Tmp.Matrix[2].multiplyToRef(I.Tmp.Matrix[1], I.Tmp.Matrix[2]), I.Tmp.Matrix[2].multiplyToRef(I.Tmp.Matrix[0], I.Tmp.Matrix[2]), I.Tmp.Matrix[2].decompose(I.Tmp.Vector3[0], I.Tmp.Quaternion[0], I.Tmp.Vector3[1]), this.position.addInPlace(I.Tmp.Vector3[1]), I.Tmp.Quaternion[0].multiplyToRef(this.rotationQuaternion, this.rotationQuaternion), this;\n    }, h.prototype.translate = function (e, t, i) {\n      var r = e.scale(t);\n      if (i && i !== I.Space.LOCAL) this.setAbsolutePosition(this.getAbsolutePosition().add(r));else {\n        var n = this.getPositionExpressedInLocalSpace().add(r);\n        this.setPositionWithLocalVector(n);\n      }\n      return this;\n    }, h.prototype.addRotation = function (e, t, i) {\n      var r;\n      this.rotationQuaternion ? r = this.rotationQuaternion : (r = I.Tmp.Quaternion[1], I.Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, r));\n      var n = I.Tmp.Quaternion[0];\n      return I.Quaternion.RotationYawPitchRollToRef(t, e, i, n), r.multiplyInPlace(n), this.rotationQuaternion || r.toEulerAnglesToRef(this.rotation), this;\n    }, h.prototype.computeWorldMatrix = function (e) {\n      if (this._isWorldMatrixFrozen) return this._worldMatrix;\n      if (!e && this.isSynchronized()) return this._currentRenderId = this.getScene().getRenderId(), this._worldMatrix;\n      (this._updateCache(), this._cache.position.copyFrom(this.position), this._cache.scaling.copyFrom(this.scaling), this._cache.pivotMatrixUpdated = !1, this._cache.billboardMode = this.billboardMode, this._currentRenderId = this.getScene().getRenderId(), this._childRenderId = this.getScene().getRenderId(), this._isDirty = !1, I.Matrix.ScalingToRef(this.scaling.x * this.scalingDeterminant, this.scaling.y * this.scalingDeterminant, this.scaling.z * this.scalingDeterminant, I.Tmp.Matrix[1]), this.rotationQuaternion) && this.rotation.length() && (this.rotationQuaternion.multiplyInPlace(I.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z)), this.rotation.copyFromFloats(0, 0, 0));\n      this.rotationQuaternion ? (this.rotationQuaternion.toRotationMatrix(I.Tmp.Matrix[0]), this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (I.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, I.Tmp.Matrix[0]), this._cache.rotation.copyFrom(this.rotation));\n      var t = this.getScene().activeCamera;\n\n      if (this.infiniteDistance && !this.parent && t) {\n        var i = t.getWorldMatrix(),\n            r = new I.Vector3(i.m[12], i.m[13], i.m[14]);\n        I.Matrix.TranslationToRef(this.position.x + r.x, this.position.y + r.y, this.position.z + r.z, I.Tmp.Matrix[2]);\n      } else I.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, I.Tmp.Matrix[2]);\n\n      if (this._pivotMatrix.multiplyToRef(I.Tmp.Matrix[1], I.Tmp.Matrix[4]), I.Tmp.Matrix[4].multiplyToRef(I.Tmp.Matrix[0], I.Tmp.Matrix[5]), this.billboardMode !== h.BILLBOARDMODE_NONE && t) {\n        if ((this.billboardMode & h.BILLBOARDMODE_ALL) !== h.BILLBOARDMODE_ALL) {\n          var n = I.Tmp.Vector3[3];\n          this.parent && this.parent.getWorldMatrix ? this._transformToBoneReferal ? (this.parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), I.Tmp.Matrix[6]), I.Vector3.TransformCoordinatesToRef(this.position, I.Tmp.Matrix[6], n)) : I.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), n) : n.copyFrom(this.position), n.subtractInPlace(t.globalPosition);\n          var o = I.Tmp.Vector3[4].copyFromFloats(0, 0, 0);\n          (this.billboardMode & h.BILLBOARDMODE_X) === h.BILLBOARDMODE_X && (o.x = Math.atan2(-n.y, n.z)), (this.billboardMode & h.BILLBOARDMODE_Y) === h.BILLBOARDMODE_Y && (o.y = Math.atan2(n.x, n.z)), (this.billboardMode & h.BILLBOARDMODE_Z) === h.BILLBOARDMODE_Z && (o.z = Math.atan2(n.y, n.x)), I.Matrix.RotationYawPitchRollToRef(o.y, o.x, o.z, I.Tmp.Matrix[0]);\n        } else I.Tmp.Matrix[1].copyFrom(t.getViewMatrix()), I.Tmp.Matrix[1].setTranslationFromFloats(0, 0, 0), I.Tmp.Matrix[1].invertToRef(I.Tmp.Matrix[0]);\n\n        I.Tmp.Matrix[1].copyFrom(I.Tmp.Matrix[5]), I.Tmp.Matrix[1].multiplyToRef(I.Tmp.Matrix[0], I.Tmp.Matrix[5]);\n      }\n\n      return this._postMultiplyPivotMatrix && I.Tmp.Matrix[5].multiplyToRef(this._pivotMatrixInverse, I.Tmp.Matrix[5]), I.Tmp.Matrix[5].multiplyToRef(I.Tmp.Matrix[2], this._localWorld), this.parent && this.parent.getWorldMatrix ? (this.billboardMode !== h.BILLBOARDMODE_NONE ? (this._transformToBoneReferal ? (this.parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), I.Tmp.Matrix[6]), I.Tmp.Matrix[5].copyFrom(I.Tmp.Matrix[6])) : I.Tmp.Matrix[5].copyFrom(this.parent.getWorldMatrix()), this._localWorld.getTranslationToRef(I.Tmp.Vector3[5]), I.Vector3.TransformCoordinatesToRef(I.Tmp.Vector3[5], I.Tmp.Matrix[5], I.Tmp.Vector3[5]), this._worldMatrix.copyFrom(this._localWorld), this._worldMatrix.setTranslation(I.Tmp.Vector3[5])) : this._transformToBoneReferal ? (this._localWorld.multiplyToRef(this.parent.getWorldMatrix(), I.Tmp.Matrix[6]), I.Tmp.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix)) : this._localWorld.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix), this._markSyncedWithParent()) : this._worldMatrix.copyFrom(this._localWorld), this.ignoreNonUniformScaling ? this._updateNonUniformScalingState(!1) : this.scaling.isNonUniform ? this._updateNonUniformScalingState(!0) : this.parent && this.parent._nonUniformScaling ? this._updateNonUniformScalingState(this.parent._nonUniformScaling) : this._updateNonUniformScalingState(!1), this._afterComputeWorldMatrix(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this.onAfterWorldMatrixUpdateObservable.notifyObservers(this), this._poseMatrix || (this._poseMatrix = I.Matrix.Invert(this._worldMatrix)), this._worldMatrixDeterminant = this._worldMatrix.determinant(), this._worldMatrix;\n    }, h.prototype._afterComputeWorldMatrix = function () {}, h.prototype.registerAfterWorldMatrixUpdate = function (e) {\n      return this.onAfterWorldMatrixUpdateObservable.add(e), this;\n    }, h.prototype.unregisterAfterWorldMatrixUpdate = function (e) {\n      return this.onAfterWorldMatrixUpdateObservable.removeCallback(e), this;\n    }, h.prototype.clone = function (e, t, i) {\n      var r = this,\n          n = I.SerializationHelper.Clone(function () {\n        return new h(e, r.getScene());\n      }, this);\n      if (n.name = e, n.id = e, t && (n.parent = t), !i) for (var o = this.getDescendants(!0), s = 0; s < o.length; s++) {\n        var a = o[s];\n        a.clone && a.clone(e + \".\" + a.name, n);\n      }\n      return n;\n    }, h.prototype.serialize = function (e) {\n      var t = I.SerializationHelper.Serialize(this, e);\n      return t.type = this.getClassName(), this.parent && (t.parentId = this.parent.id), I.Tags && I.Tags.HasTags(this) && (t.tags = I.Tags.GetTags(this)), t.localMatrix = this.getPivotMatrix().asArray(), t.isEnabled = this.isEnabled(), this.parent && (t.parentId = this.parent.id), t;\n    }, h.Parse = function (e, t, i) {\n      var r = I.SerializationHelper.Parse(function () {\n        return new h(e.name, t);\n      }, e, t, i);\n      return I.Tags && I.Tags.AddTagsTo(r, e.tags), e.localMatrix ? r.setPreTransformMatrix(I.Matrix.FromArray(e.localMatrix)) : e.pivotMatrix && r.setPivotMatrix(I.Matrix.FromArray(e.pivotMatrix)), r.setEnabled(e.isEnabled), e.parentId && (r._waitingParentId = e.parentId), r;\n    }, h.prototype.dispose = function (e, t) {\n      void 0 === t && (t = !1), this.getScene().stopAnimation(this), this.getScene().removeTransformNode(this), this.onAfterWorldMatrixUpdateObservable.clear(), n.prototype.dispose.call(this, e, t);\n    }, h.BILLBOARDMODE_NONE = 0, h.BILLBOARDMODE_X = 1, h.BILLBOARDMODE_Y = 2, h.BILLBOARDMODE_Z = 4, h.BILLBOARDMODE_ALL = 7, h._lookAtVectorCache = new I.Vector3(0, 0, 0), h._rotationAxisCache = new I.Quaternion(), b([I.serializeAsVector3(\"position\")], h.prototype, \"_position\", void 0), b([I.serializeAsVector3(\"rotation\")], h.prototype, \"_rotation\", void 0), b([I.serializeAsQuaternion(\"rotationQuaternion\")], h.prototype, \"_rotationQuaternion\", void 0), b([I.serializeAsVector3(\"scaling\")], h.prototype, \"_scaling\", void 0), b([I.serialize()], h.prototype, \"billboardMode\", void 0), b([I.serialize()], h.prototype, \"scalingDeterminant\", void 0), b([I.serialize()], h.prototype, \"infiniteDistance\", void 0), b([I.serialize()], h.prototype, \"ignoreNonUniformScaling\", void 0), h;\n  }(I.Node), I.TransformNode = w, L = $a || ($a = {}), F = function () {\n    this.facetNb = 0, this.partitioningSubdivisions = 10, this.partitioningBBoxRatio = 1.01, this.facetDataEnabled = !1, this.facetParameters = {}, this.bbSize = L.Vector3.Zero(), this.subDiv = {\n      max: 1,\n      X: 1,\n      Y: 1,\n      Z: 1\n    }, this.facetDepthSort = !1, this.facetDepthSortEnabled = !1;\n  }, B = function (a) {\n    function i(e, t) {\n      void 0 === t && (t = null);\n      var r = a.call(this, e, t, !1) || this;\n      return r._facetData = new F(), r.cullingStrategy = i.CULLINGSTRATEGY_STANDARD, r.onCollideObservable = new L.Observable(), r.onCollisionPositionChangeObservable = new L.Observable(), r.onMaterialChangedObservable = new L.Observable(), r.definedFacingForward = !0, r._visibility = 1, r.alphaIndex = Number.MAX_VALUE, r.isVisible = !0, r.isPickable = !0, r.showSubMeshesBoundingBox = !1, r.isBlocker = !1, r.enablePointerMoveEvents = !1, r.renderingGroupId = 0, r._receiveShadows = !1, r.outlineColor = L.Color3.Red(), r.outlineWidth = .02, r.overlayColor = L.Color3.Red(), r.overlayAlpha = .5, r._hasVertexAlpha = !1, r._useVertexColors = !0, r._computeBonesUsingShaders = !0, r._numBoneInfluencers = 4, r._applyFog = !0, r.useOctreeForRenderingSelection = !0, r.useOctreeForPicking = !0, r.useOctreeForCollisions = !0, r._layerMask = 268435455, r.alwaysSelectAsActiveMesh = !1, r.actionManager = null, r._checkCollisions = !1, r._collisionMask = -1, r._collisionGroup = -1, r.ellipsoid = new L.Vector3(.5, 1, .5), r.ellipsoidOffset = new L.Vector3(0, 0, 0), r._oldPositionForCollisions = new L.Vector3(0, 0, 0), r._diffPositionForCollisions = new L.Vector3(0, 0, 0), r.edgesWidth = 1, r.edgesColor = new L.Color4(1, 0, 0, 1), r._renderId = 0, r._intersectionsInProgress = new Array(), r._unIndexed = !1, r._lightSources = new Array(), r.onRebuildObservable = new L.Observable(), r._onCollisionPositionChange = function (e, t, i) {\n        void 0 === i && (i = null), r.getScene().workerCollisions && t.multiplyInPlace(r._collider._radius), t.subtractToRef(r._oldPositionForCollisions, r._diffPositionForCollisions), r._diffPositionForCollisions.length() > L.Engine.CollisionsEpsilon && r.position.addInPlace(r._diffPositionForCollisions), i && r.onCollideObservable.notifyObservers(i), r.onCollisionPositionChangeObservable.notifyObservers(r.position);\n      }, r.getScene().addMesh(r), r._resyncLightSources(), r;\n    }\n\n    return T(i, a), Object.defineProperty(i, \"BILLBOARDMODE_NONE\", {\n      get: function () {\n        return L.TransformNode.BILLBOARDMODE_NONE;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i, \"BILLBOARDMODE_X\", {\n      get: function () {\n        return L.TransformNode.BILLBOARDMODE_X;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i, \"BILLBOARDMODE_Y\", {\n      get: function () {\n        return L.TransformNode.BILLBOARDMODE_Y;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i, \"BILLBOARDMODE_Z\", {\n      get: function () {\n        return L.TransformNode.BILLBOARDMODE_Z;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i, \"BILLBOARDMODE_ALL\", {\n      get: function () {\n        return L.TransformNode.BILLBOARDMODE_ALL;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"facetNb\", {\n      get: function () {\n        return this._facetData.facetNb;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"partitioningSubdivisions\", {\n      get: function () {\n        return this._facetData.partitioningSubdivisions;\n      },\n      set: function (e) {\n        this._facetData.partitioningSubdivisions = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"partitioningBBoxRatio\", {\n      get: function () {\n        return this._facetData.partitioningBBoxRatio;\n      },\n      set: function (e) {\n        this._facetData.partitioningBBoxRatio = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"mustDepthSortFacets\", {\n      get: function () {\n        return this._facetData.facetDepthSort;\n      },\n      set: function (e) {\n        this._facetData.facetDepthSort = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"facetDepthSortFrom\", {\n      get: function () {\n        return this._facetData.facetDepthSortFrom;\n      },\n      set: function (e) {\n        this._facetData.facetDepthSortFrom = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"isFacetDataEnabled\", {\n      get: function () {\n        return this._facetData.facetDataEnabled;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype._updateNonUniformScalingState = function (e) {\n      return !!a.prototype._updateNonUniformScalingState.call(this, e) && (this._markSubMeshesAsMiscDirty(), !0);\n    }, Object.defineProperty(i.prototype, \"onCollide\", {\n      set: function (e) {\n        this._onCollideObserver && this.onCollideObservable.remove(this._onCollideObserver), this._onCollideObserver = this.onCollideObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"onCollisionPositionChange\", {\n      set: function (e) {\n        this._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._onCollisionPositionChangeObserver), this._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"visibility\", {\n      get: function () {\n        return this._visibility;\n      },\n      set: function (e) {\n        this._visibility !== e && (this._visibility = e, this._markSubMeshesAsMiscDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"material\", {\n      get: function () {\n        return this._material;\n      },\n      set: function (e) {\n        this._material !== e && (this._material = e, this.onMaterialChangedObservable.hasObservers && this.onMaterialChangedObservable.notifyObservers(this), this.subMeshes && this._unBindEffect());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"receiveShadows\", {\n      get: function () {\n        return this._receiveShadows;\n      },\n      set: function (e) {\n        this._receiveShadows !== e && (this._receiveShadows = e, this._markSubMeshesAsLightDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"hasVertexAlpha\", {\n      get: function () {\n        return this._hasVertexAlpha;\n      },\n      set: function (e) {\n        this._hasVertexAlpha !== e && (this._hasVertexAlpha = e, this._markSubMeshesAsAttributesDirty(), this._markSubMeshesAsMiscDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"useVertexColors\", {\n      get: function () {\n        return this._useVertexColors;\n      },\n      set: function (e) {\n        this._useVertexColors !== e && (this._useVertexColors = e, this._markSubMeshesAsAttributesDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"computeBonesUsingShaders\", {\n      get: function () {\n        return this._computeBonesUsingShaders;\n      },\n      set: function (e) {\n        this._computeBonesUsingShaders !== e && (this._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"numBoneInfluencers\", {\n      get: function () {\n        return this._numBoneInfluencers;\n      },\n      set: function (e) {\n        this._numBoneInfluencers !== e && (this._numBoneInfluencers = e, this._markSubMeshesAsAttributesDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"applyFog\", {\n      get: function () {\n        return this._applyFog;\n      },\n      set: function (e) {\n        this._applyFog !== e && (this._applyFog = e, this._markSubMeshesAsMiscDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"layerMask\", {\n      get: function () {\n        return this._layerMask;\n      },\n      set: function (e) {\n        e !== this._layerMask && (this._layerMask = e, this._resyncLightSources());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"collisionMask\", {\n      get: function () {\n        return this._collisionMask;\n      },\n      set: function (e) {\n        this._collisionMask = isNaN(e) ? -1 : e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"collisionGroup\", {\n      get: function () {\n        return this._collisionGroup;\n      },\n      set: function (e) {\n        this._collisionGroup = isNaN(e) ? -1 : e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"_positions\", {\n      get: function () {\n        return null;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"skeleton\", {\n      get: function () {\n        return this._skeleton;\n      },\n      set: function (e) {\n        this._skeleton && this._skeleton.needInitialSkinMatrix && this._skeleton._unregisterMeshWithPoseMatrix(this), e && e.needInitialSkinMatrix && e._registerMeshWithPoseMatrix(this), this._skeleton = e, this._skeleton || (this._bonesTransformMatrices = null), this._markSubMeshesAsAttributesDirty();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.getClassName = function () {\n      return \"AbstractMesh\";\n    }, i.prototype.toString = function (e) {\n      var t = \"Name: \" + this.name + \", isInstance: \" + (this instanceof L.InstancedMesh ? \"YES\" : \"NO\");\n      return t += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0), this._skeleton && (t += \", skeleton: \" + this._skeleton.name), e && (t += \", billboard mode: \" + [\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"][this.billboardMode], t += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingFreezeWorldMatrix ? \"YES\" : \"NO\")), t;\n    }, i.prototype._rebuild = function () {\n      if (this.onRebuildObservable.notifyObservers(this), this._occlusionQuery && (this._occlusionQuery = null), this.subMeshes) for (var e = 0, t = this.subMeshes; e < t.length; e++) {\n        t[e]._rebuild();\n      }\n    }, i.prototype._resyncLightSources = function () {\n      for (var e = this._lightSources.length = 0, t = this.getScene().lights; e < t.length; e++) {\n        var i = t[e];\n        i.isEnabled() && i.canAffectMesh(this) && this._lightSources.push(i);\n      }\n\n      this._markSubMeshesAsLightDirty();\n    }, i.prototype._resyncLighSource = function (e) {\n      var t = e.isEnabled() && e.canAffectMesh(this),\n          i = this._lightSources.indexOf(e);\n\n      if (-1 === i) {\n        if (!t) return;\n\n        this._lightSources.push(e);\n      } else {\n        if (t) return;\n\n        this._lightSources.splice(i, 1);\n      }\n\n      this._markSubMeshesAsLightDirty();\n    }, i.prototype._unBindEffect = function () {\n      for (var e = 0, t = this.subMeshes; e < t.length; e++) {\n        t[e].setEffect(null);\n      }\n    }, i.prototype._removeLightSource = function (e) {\n      var t = this._lightSources.indexOf(e);\n\n      -1 !== t && (this._lightSources.splice(t, 1), this._markSubMeshesAsLightDirty());\n    }, i.prototype._markSubMeshesAsDirty = function (e) {\n      if (this.subMeshes) for (var t = 0, i = this.subMeshes; t < i.length; t++) {\n        var r = i[t];\n        r._materialDefines && e(r._materialDefines);\n      }\n    }, i.prototype._markSubMeshesAsLightDirty = function () {\n      this._markSubMeshesAsDirty(function (e) {\n        return e.markAsLightDirty();\n      });\n    }, i.prototype._markSubMeshesAsAttributesDirty = function () {\n      this._markSubMeshesAsDirty(function (e) {\n        return e.markAsAttributesDirty();\n      });\n    }, i.prototype._markSubMeshesAsMiscDirty = function () {\n      if (this.subMeshes) for (var e = 0, t = this.subMeshes; e < t.length; e++) {\n        var i = t[e].getMaterial();\n        i && i.markAsDirty(L.Material.MiscDirtyFlag);\n      }\n    }, Object.defineProperty(i.prototype, \"scaling\", {\n      get: function () {\n        return this._scaling;\n      },\n      set: function (e) {\n        this._scaling = e, this.physicsImpostor && this.physicsImpostor.forceUpdate();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"isBlocked\", {\n      get: function () {\n        return !1;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.getLOD = function (e) {\n      return this;\n    }, i.prototype.getTotalVertices = function () {\n      return 0;\n    }, i.prototype.getIndices = function () {\n      return null;\n    }, i.prototype.getVerticesData = function (e) {\n      return null;\n    }, i.prototype.setVerticesData = function (e, t, i, r) {\n      return this;\n    }, i.prototype.updateVerticesData = function (e, t, i, r) {\n      return this;\n    }, i.prototype.setIndices = function (e, t) {\n      return this;\n    }, i.prototype.isVerticesDataPresent = function (e) {\n      return !1;\n    }, i.prototype.getBoundingInfo = function () {\n      return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfo || this._updateBoundingInfo(), this._boundingInfo);\n    }, i.prototype.normalizeToUnitCube = function (e) {\n      void 0 === e && (e = !0);\n      var t = this.getHierarchyBoundingVectors(e),\n          i = t.max.subtract(t.min),\n          r = Math.max(i.x, i.y, i.z);\n      if (0 === r) return this;\n      var n = 1 / r;\n      return this.scaling.scaleInPlace(n), this;\n    }, i.prototype.setBoundingInfo = function (e) {\n      return this._boundingInfo = e, this;\n    }, Object.defineProperty(i.prototype, \"useBones\", {\n      get: function () {\n        return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(L.VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(L.VertexBuffer.MatricesWeightsKind);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype._preActivate = function () {}, i.prototype._preActivateForIntermediateRendering = function (e) {}, i.prototype._activate = function (e) {\n      this._renderId = e;\n    }, i.prototype.getWorldMatrix = function () {\n      return this._masterMesh ? this._masterMesh.getWorldMatrix() : a.prototype.getWorldMatrix.call(this);\n    }, i.prototype._getWorldMatrixDeterminant = function () {\n      return this._masterMesh ? this._masterMesh._getWorldMatrixDeterminant() : a.prototype._getWorldMatrixDeterminant.call(this);\n    }, i.prototype.movePOV = function (e, t, i) {\n      return this.position.addInPlace(this.calcMovePOV(e, t, i)), this;\n    }, i.prototype.calcMovePOV = function (e, t, i) {\n      var r = new L.Matrix();\n      (this.rotationQuaternion ? this.rotationQuaternion : L.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z)).toRotationMatrix(r);\n      var n = L.Vector3.Zero(),\n          o = this.definedFacingForward ? -1 : 1;\n      return L.Vector3.TransformCoordinatesFromFloatsToRef(e * o, t, i * o, r, n), n;\n    }, i.prototype.rotatePOV = function (e, t, i) {\n      return this.rotation.addInPlace(this.calcRotatePOV(e, t, i)), this;\n    }, i.prototype.calcRotatePOV = function (e, t, i) {\n      var r = this.definedFacingForward ? 1 : -1;\n      return new L.Vector3(e * r, t, i * r);\n    }, i.prototype.getHierarchyBoundingVectors = function (e, t) {\n      var i, r;\n      void 0 === e && (e = !0), void 0 === t && (t = null), this.getScene().incrementRenderId(), this.computeWorldMatrix(!0);\n      var n = this.getBoundingInfo();\n      if (this.subMeshes ? (i = n.boundingBox.minimumWorld, r = n.boundingBox.maximumWorld) : (i = new L.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), r = new L.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE)), e) for (var o = 0, s = this.getDescendants(!1); o < s.length; o++) {\n        var a = s[o];\n\n        if (a.computeWorldMatrix(!0), (!t || t(a)) && a.getBoundingInfo && 0 !== a.getTotalVertices()) {\n          var l = a.getBoundingInfo().boundingBox,\n              c = l.minimumWorld,\n              h = l.maximumWorld;\n          L.Tools.CheckExtends(c, i, r), L.Tools.CheckExtends(h, i, r);\n        }\n      }\n      return {\n        min: i,\n        max: r\n      };\n    }, i.prototype._updateBoundingInfo = function () {\n      return this._boundingInfo = this._boundingInfo || new L.BoundingInfo(this.absolutePosition, this.absolutePosition), this._boundingInfo.update(this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this;\n    }, i.prototype._updateSubMeshesBoundingInfo = function (e) {\n      if (!this.subMeshes) return this;\n\n      for (var t = this.subMeshes.length, i = 0; i < t; i++) {\n        var r = this.subMeshes[i];\n        (1 < t || !r.IsGlobal) && r.updateBoundingInfo(e);\n      }\n\n      return this;\n    }, i.prototype._afterComputeWorldMatrix = function () {\n      this._updateBoundingInfo();\n    }, i.prototype.isInFrustum = function (e) {\n      return null !== this._boundingInfo && this._boundingInfo.isInFrustum(e, this.cullingStrategy);\n    }, i.prototype.isCompletelyInFrustum = function (e) {\n      return null !== this._boundingInfo && this._boundingInfo.isCompletelyInFrustum(e);\n    }, i.prototype.intersectsMesh = function (e, t, i) {\n      if (void 0 === t && (t = !1), !this._boundingInfo || !e._boundingInfo) return !1;\n      if (this._boundingInfo.intersects(e._boundingInfo, t)) return !0;\n      if (i) for (var r = 0, n = this.getChildMeshes(); r < n.length; r++) {\n        if (n[r].intersectsMesh(e, t, !0)) return !0;\n      }\n      return !1;\n    }, i.prototype.intersectsPoint = function (e) {\n      return !!this._boundingInfo && this._boundingInfo.intersectsPoint(e);\n    }, i.prototype.getPositionInCameraSpace = function (e) {\n      return void 0 === e && (e = null), e || (e = this.getScene().activeCamera), L.Vector3.TransformCoordinates(this.absolutePosition, e.getViewMatrix());\n    }, i.prototype.getDistanceToCamera = function (e) {\n      return void 0 === e && (e = null), e || (e = this.getScene().activeCamera), this.absolutePosition.subtract(e.position).length();\n    }, Object.defineProperty(i.prototype, \"checkCollisions\", {\n      get: function () {\n        return this._checkCollisions;\n      },\n      set: function (e) {\n        this._checkCollisions = e, this.getScene().workerCollisions && this.getScene().collisionCoordinator.onMeshUpdated(this);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"collider\", {\n      get: function () {\n        return this._collider;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.moveWithCollisions = function (e) {\n      return this.getAbsolutePosition().addToRef(this.ellipsoidOffset, this._oldPositionForCollisions), this._collider || (this._collider = new L.Collider()), this._collider._radius = this.ellipsoid, this.getScene().collisionCoordinator.getNewPosition(this._oldPositionForCollisions, e, this._collider, 3, this, this._onCollisionPositionChange, this.uniqueId), this;\n    }, i.prototype._collideForSubMesh = function (e, t, i) {\n      if (this._generatePointsArray(), !this._positions) return this;\n\n      if (!e._lastColliderWorldVertices || !e._lastColliderTransformMatrix.equals(t)) {\n        e._lastColliderTransformMatrix = t.clone(), e._lastColliderWorldVertices = [], e._trianglePlanes = [];\n\n        for (var r = e.verticesStart, n = e.verticesStart + e.verticesCount, o = r; o < n; o++) e._lastColliderWorldVertices.push(L.Vector3.TransformCoordinates(this._positions[o], t));\n      }\n\n      return i._collide(e._trianglePlanes, e._lastColliderWorldVertices, this.getIndices(), e.indexStart, e.indexStart + e.indexCount, e.verticesStart, !!e.getMaterial()), i.collisionFound && (i.collidedMesh = this), this;\n    }, i.prototype._processCollisionsForSubMeshes = function (e, t) {\n      for (var i = this._scene.getCollidingSubMeshCandidates(this, e), r = i.length, n = 0; n < r; n++) {\n        var o = i.data[n];\n        1 < r && !o._checkCollision(e) || this._collideForSubMesh(o, t, e);\n      }\n\n      return this;\n    }, i.prototype._checkCollision = function (e) {\n      if (!this._boundingInfo || !this._boundingInfo._checkCollision(e)) return this;\n      var t = L.Tmp.Matrix[0],\n          i = L.Tmp.Matrix[1];\n      return L.Matrix.ScalingToRef(1 / e._radius.x, 1 / e._radius.y, 1 / e._radius.z, t), this.worldMatrixFromCache.multiplyToRef(t, i), this._processCollisionsForSubMeshes(e, i), this;\n    }, i.prototype._generatePointsArray = function () {\n      return !1;\n    }, i.prototype.intersects = function (e, t) {\n      var i = new L.PickingInfo();\n      if (!(this.subMeshes && this._boundingInfo && e.intersectsSphere(this._boundingInfo.boundingSphere) && e.intersectsBox(this._boundingInfo.boundingBox))) return i;\n      if (!this._generatePointsArray()) return i;\n\n      for (var r = null, n = this._scene.getIntersectingSubMeshCandidates(this, e), o = n.length, s = 0; s < o; s++) {\n        var a = n.data[s];\n\n        if (!(1 < o) || a.canIntersects(e)) {\n          var l = a.intersects(e, this._positions, this.getIndices(), t);\n          if (l && (t || !r || l.distance < r.distance) && ((r = l).subMeshId = s, t)) break;\n        }\n      }\n\n      if (r) {\n        var c = this.getWorldMatrix(),\n            h = L.Vector3.TransformCoordinates(e.origin, c),\n            u = e.direction.clone();\n        u = u.scale(r.distance);\n        var d = L.Vector3.TransformNormal(u, c),\n            f = h.add(d);\n        return i.hit = !0, i.distance = L.Vector3.Distance(h, f), i.pickedPoint = f, i.pickedMesh = this, i.bu = r.bu || 0, i.bv = r.bv || 0, i.faceId = r.faceId, i.subMeshId = r.subMeshId, i;\n      }\n\n      return i;\n    }, i.prototype.clone = function (e, t, i) {\n      return null;\n    }, i.prototype.releaseSubMeshes = function () {\n      if (this.subMeshes) for (; this.subMeshes.length;) this.subMeshes[0].dispose();else this.subMeshes = new Array();\n      return this;\n    }, i.prototype.dispose = function (e, t) {\n      var i,\n          n = this;\n\n      for (void 0 === t && (t = !1), this.getScene().freeActiveMeshes(), this.getScene().freeRenderingGroups(), void 0 !== this.actionManager && null !== this.actionManager && (this.actionManager.dispose(), this.actionManager = null), this._skeleton = null, i = 0; i < this._intersectionsInProgress.length; i++) {\n        var r = this._intersectionsInProgress[i],\n            o = r._intersectionsInProgress.indexOf(this);\n\n        r._intersectionsInProgress.splice(o, 1);\n      }\n\n      this._intersectionsInProgress = [], this.getScene().lights.forEach(function (e) {\n        var t = e.includedOnlyMeshes.indexOf(n);\n        -1 !== t && e.includedOnlyMeshes.splice(t, 1), -1 !== (t = e.excludedMeshes.indexOf(n)) && e.excludedMeshes.splice(t, 1);\n        var i = e.getShadowGenerator();\n\n        if (i) {\n          var r = i.getShadowMap();\n          r && r.renderList && -1 !== (t = r.renderList.indexOf(n)) && r.renderList.splice(t, 1);\n        }\n      }), \"InstancedMesh\" !== this.getClassName() && this.releaseSubMeshes();\n      var s = this.getScene().getEngine();\n      if (this._occlusionQuery && (this.isOcclusionQueryInProgress = !1, s.deleteQuery(this._occlusionQuery), this._occlusionQuery = null), s.wipeCaches(), this.getScene().removeMesh(this), t && this.material && this.material.dispose(!1, !0), !e) for (i = 0; i < this.getScene().particleSystems.length; i++) this.getScene().particleSystems[i].emitter === this && (this.getScene().particleSystems[i].dispose(), i--);\n      this._facetData.facetDataEnabled && this.disableFacetData(), this.onAfterWorldMatrixUpdateObservable.clear(), this.onCollideObservable.clear(), this.onCollisionPositionChangeObservable.clear(), this.onRebuildObservable.clear(), a.prototype.dispose.call(this, e, t);\n    }, i.prototype.addChild = function (e) {\n      return e.setParent(this), this;\n    }, i.prototype.removeChild = function (e) {\n      return e.setParent(null), this;\n    }, i.prototype._initFacetData = function () {\n      var e = this._facetData;\n      e.facetNormals || (e.facetNormals = new Array()), e.facetPositions || (e.facetPositions = new Array()), e.facetPartitioning || (e.facetPartitioning = new Array()), e.facetNb = this.getIndices().length / 3 | 0, e.partitioningSubdivisions = e.partitioningSubdivisions ? e.partitioningSubdivisions : 10, e.partitioningBBoxRatio = e.partitioningBBoxRatio ? e.partitioningBBoxRatio : 1.01;\n\n      for (var t = 0; t < e.facetNb; t++) e.facetNormals[t] = L.Vector3.Zero(), e.facetPositions[t] = L.Vector3.Zero();\n\n      return e.facetDataEnabled = !0, this;\n    }, i.prototype.updateFacetData = function () {\n      var e = this._facetData;\n      e.facetDataEnabled || this._initFacetData();\n      var t = this.getVerticesData(L.VertexBuffer.PositionKind),\n          i = this.getIndices(),\n          r = this.getVerticesData(L.VertexBuffer.NormalKind),\n          n = this.getBoundingInfo();\n\n      if (e.facetDepthSort && !e.facetDepthSortEnabled) {\n        if (e.facetDepthSortEnabled = !0, i instanceof Uint16Array) e.depthSortedIndices = new Uint16Array(i);else if (i instanceof Uint32Array) e.depthSortedIndices = new Uint32Array(i);else {\n          for (var o = !1, s = 0; s < i.length; s++) if (65535 < i[s]) {\n            o = !0;\n            break;\n          }\n\n          e.depthSortedIndices = o ? new Uint32Array(i) : new Uint16Array(i);\n        }\n\n        if (e.facetDepthSortFunction = function (e, t) {\n          return t.sqDistance - e.sqDistance;\n        }, !e.facetDepthSortFrom) {\n          var a = this.getScene().activeCamera;\n          e.facetDepthSortFrom = a ? a.position : L.Vector3.Zero();\n        }\n\n        e.depthSortedFacets = [];\n\n        for (var l = 0; l < e.facetNb; l++) {\n          var c = {\n            ind: 3 * l,\n            sqDistance: 0\n          };\n          e.depthSortedFacets.push(c);\n        }\n\n        e.invertedMatrix = L.Matrix.Identity(), e.facetDepthSortOrigin = L.Vector3.Zero();\n      }\n\n      e.bbSize.x = n.maximum.x - n.minimum.x > L.Epsilon ? n.maximum.x - n.minimum.x : L.Epsilon, e.bbSize.y = n.maximum.y - n.minimum.y > L.Epsilon ? n.maximum.y - n.minimum.y : L.Epsilon, e.bbSize.z = n.maximum.z - n.minimum.z > L.Epsilon ? n.maximum.z - n.minimum.z : L.Epsilon;\n      var h = e.bbSize.x > e.bbSize.y ? e.bbSize.x : e.bbSize.y;\n\n      if (h = h > e.bbSize.z ? h : e.bbSize.z, e.subDiv.max = e.partitioningSubdivisions, e.subDiv.X = Math.floor(e.subDiv.max * e.bbSize.x / h), e.subDiv.Y = Math.floor(e.subDiv.max * e.bbSize.y / h), e.subDiv.Z = Math.floor(e.subDiv.max * e.bbSize.z / h), e.subDiv.X = e.subDiv.X < 1 ? 1 : e.subDiv.X, e.subDiv.Y = e.subDiv.Y < 1 ? 1 : e.subDiv.Y, e.subDiv.Z = e.subDiv.Z < 1 ? 1 : e.subDiv.Z, e.facetParameters.facetNormals = this.getFacetLocalNormals(), e.facetParameters.facetPositions = this.getFacetLocalPositions(), e.facetParameters.facetPartitioning = this.getFacetLocalPartitioning(), e.facetParameters.bInfo = n, e.facetParameters.bbSize = e.bbSize, e.facetParameters.subDiv = e.subDiv, e.facetParameters.ratio = this.partitioningBBoxRatio, e.facetParameters.depthSort = e.facetDepthSort, e.facetDepthSort && e.facetDepthSortEnabled && (this.computeWorldMatrix(!0), this._worldMatrix.invertToRef(e.invertedMatrix), L.Vector3.TransformCoordinatesToRef(e.facetDepthSortFrom, e.invertedMatrix, e.facetDepthSortOrigin), e.facetParameters.distanceTo = e.facetDepthSortOrigin), e.facetParameters.depthSortedFacets = e.depthSortedFacets, L.VertexData.ComputeNormals(t, i, r, e.facetParameters), e.facetDepthSort && e.facetDepthSortEnabled) {\n        e.depthSortedFacets.sort(e.facetDepthSortFunction);\n        var u = e.depthSortedIndices.length / 3 | 0;\n\n        for (l = 0; l < u; l++) {\n          var d = e.depthSortedFacets[l].ind;\n          e.depthSortedIndices[3 * l] = i[d], e.depthSortedIndices[3 * l + 1] = i[d + 1], e.depthSortedIndices[3 * l + 2] = i[d + 2];\n        }\n\n        this.updateIndices(e.depthSortedIndices);\n      }\n\n      return this;\n    }, i.prototype.getFacetLocalNormals = function () {\n      return this._facetData.facetNormals || this.updateFacetData(), this._facetData.facetNormals;\n    }, i.prototype.getFacetLocalPositions = function () {\n      return this._facetData.facetPositions || this.updateFacetData(), this._facetData.facetPositions;\n    }, i.prototype.getFacetLocalPartitioning = function () {\n      return this._facetData.facetPartitioning || this.updateFacetData(), this._facetData.facetPartitioning;\n    }, i.prototype.getFacetPosition = function (e) {\n      var t = L.Vector3.Zero();\n      return this.getFacetPositionToRef(e, t), t;\n    }, i.prototype.getFacetPositionToRef = function (e, t) {\n      var i = this.getFacetLocalPositions()[e],\n          r = this.getWorldMatrix();\n      return L.Vector3.TransformCoordinatesToRef(i, r, t), this;\n    }, i.prototype.getFacetNormal = function (e) {\n      var t = L.Vector3.Zero();\n      return this.getFacetNormalToRef(e, t), t;\n    }, i.prototype.getFacetNormalToRef = function (e, t) {\n      var i = this.getFacetLocalNormals()[e];\n      return L.Vector3.TransformNormalToRef(i, this.getWorldMatrix(), t), this;\n    }, i.prototype.getFacetsAtLocalCoordinates = function (e, t, i) {\n      var r = this.getBoundingInfo(),\n          n = this._facetData,\n          o = Math.floor((e - r.minimum.x * n.partitioningBBoxRatio) * n.subDiv.X * n.partitioningBBoxRatio / n.bbSize.x),\n          s = Math.floor((t - r.minimum.y * n.partitioningBBoxRatio) * n.subDiv.Y * n.partitioningBBoxRatio / n.bbSize.y),\n          a = Math.floor((i - r.minimum.z * n.partitioningBBoxRatio) * n.subDiv.Z * n.partitioningBBoxRatio / n.bbSize.z);\n      return o < 0 || o > n.subDiv.max || s < 0 || s > n.subDiv.max || a < 0 || a > n.subDiv.max ? null : n.facetPartitioning[o + n.subDiv.max * s + n.subDiv.max * n.subDiv.max * a];\n    }, i.prototype.getClosestFacetAtCoordinates = function (e, t, i, r, n, o) {\n      void 0 === n && (n = !1), void 0 === o && (o = !0);\n      var s = this.getWorldMatrix(),\n          a = L.Tmp.Matrix[5];\n      s.invertToRef(a);\n      var l = L.Tmp.Vector3[8];\n      L.Vector3.TransformCoordinatesFromFloatsToRef(e, t, i, a, l);\n      var c = this.getClosestFacetAtLocalCoordinates(l.x, l.y, l.z, r, n, o);\n      return r && L.Vector3.TransformCoordinatesFromFloatsToRef(r.x, r.y, r.z, s, r), c;\n    }, i.prototype.getClosestFacetAtLocalCoordinates = function (e, t, i, r, n, o) {\n      void 0 === n && (n = !1), void 0 === o && (o = !0);\n\n      var s = null,\n          a = 0,\n          l = 0,\n          c = 0,\n          h = 0,\n          u = 0,\n          d = 0,\n          f = 0,\n          p = 0,\n          _ = this.getFacetLocalPositions(),\n          m = this.getFacetLocalNormals(),\n          g = this.getFacetsAtLocalCoordinates(e, t, i);\n\n      if (!g) return null;\n\n      for (var v, y, b, T = Number.MAX_VALUE, E = T, x = 0; x < g.length; x++) y = m[v = g[x]], h = (e - (b = _[v]).x) * y.x + (t - b.y) * y.y + (i - b.z) * y.z, (!n || n && o && 0 <= h || n && !o && h <= 0) && (h = y.x * b.x + y.y * b.y + y.z * b.z, u = -(y.x * e + y.y * t + y.z * i - h) / (y.x * y.x + y.y * y.y + y.z * y.z), (E = (a = (d = e + y.x * u) - e) * a + (l = (f = t + y.y * u) - t) * l + (c = (p = i + y.z * u) - i) * c) < T && (T = E, s = v, r && (r.x = d, r.y = f, r.z = p)));\n\n      return s;\n    }, i.prototype.getFacetDataParameters = function () {\n      return this._facetData.facetParameters;\n    }, i.prototype.disableFacetData = function () {\n      return this._facetData.facetDataEnabled && (this._facetData.facetDataEnabled = !1, this._facetData.facetPositions = new Array(), this._facetData.facetNormals = new Array(), this._facetData.facetPartitioning = new Array(), this._facetData.facetParameters = null, this._facetData.depthSortedIndices = new Uint32Array(0)), this;\n    }, i.prototype.updateIndices = function (e) {\n      return this;\n    }, i.prototype.createNormals = function (e) {\n      var t,\n          i = this.getVerticesData(L.VertexBuffer.PositionKind),\n          r = this.getIndices();\n      return t = this.isVerticesDataPresent(L.VertexBuffer.NormalKind) ? this.getVerticesData(L.VertexBuffer.NormalKind) : [], L.VertexData.ComputeNormals(i, r, t, {\n        useRightHandedSystem: this.getScene().useRightHandedSystem\n      }), this.setVerticesData(L.VertexBuffer.NormalKind, t, e), this;\n    }, i.prototype.alignWithNormal = function (e, t) {\n      t || (t = L.Axis.Y);\n      var i = L.Tmp.Vector3[0],\n          r = L.Tmp.Vector3[1];\n      return L.Vector3.CrossToRef(t, e, r), L.Vector3.CrossToRef(e, r, i), this.rotationQuaternion ? L.Quaternion.RotationQuaternionFromAxisToRef(i, e, r, this.rotationQuaternion) : L.Vector3.RotationFromAxisToRef(i, e, r, this.rotation), this;\n    }, i.prototype._checkOcclusionQuery = function () {\n      return !1;\n    }, i.OCCLUSION_TYPE_NONE = 0, i.OCCLUSION_TYPE_OPTIMISTIC = 1, i.OCCLUSION_TYPE_STRICT = 2, i.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0, i.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1, i.CULLINGSTRATEGY_STANDARD = 0, i.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1, i;\n  }(L.TransformNode), L.AbstractMesh = B, N = $a || ($a = {}), V = function (n) {\n    function s(e, t) {\n      var i = n.call(this, e, t) || this;\n      return i.diffuse = new N.Color3(1, 1, 1), i.specular = new N.Color3(1, 1, 1), i.falloffType = s.FALLOFF_DEFAULT, i.intensity = 1, i._range = Number.MAX_VALUE, i._inverseSquaredRange = 0, i._photometricScale = 1, i._intensityMode = s.INTENSITYMODE_AUTOMATIC, i._radius = 1e-5, i.renderPriority = 0, i._shadowEnabled = !0, i._excludeWithLayerMask = 0, i._includeOnlyWithLayerMask = 0, i._lightmapMode = 0, i._excludedMeshesIds = new Array(), i._includedOnlyMeshesIds = new Array(), i.getScene().addLight(i), i._uniformBuffer = new N.UniformBuffer(i.getScene().getEngine()), i._buildUniformLayout(), i.includedOnlyMeshes = new Array(), i.excludedMeshes = new Array(), i._resyncMeshes(), i;\n    }\n\n    return T(s, n), Object.defineProperty(s.prototype, \"range\", {\n      get: function () {\n        return this._range;\n      },\n      set: function (e) {\n        this._range = e, this._inverseSquaredRange = 1 / (this.range * this.range);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"intensityMode\", {\n      get: function () {\n        return this._intensityMode;\n      },\n      set: function (e) {\n        this._intensityMode = e, this._computePhotometricScale();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"radius\", {\n      get: function () {\n        return this._radius;\n      },\n      set: function (e) {\n        this._radius = e, this._computePhotometricScale();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"shadowEnabled\", {\n      get: function () {\n        return this._shadowEnabled;\n      },\n      set: function (e) {\n        this._shadowEnabled !== e && (this._shadowEnabled = e, this._markMeshesAsLightDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"includedOnlyMeshes\", {\n      get: function () {\n        return this._includedOnlyMeshes;\n      },\n      set: function (e) {\n        this._includedOnlyMeshes = e, this._hookArrayForIncludedOnly(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"excludedMeshes\", {\n      get: function () {\n        return this._excludedMeshes;\n      },\n      set: function (e) {\n        this._excludedMeshes = e, this._hookArrayForExcluded(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"excludeWithLayerMask\", {\n      get: function () {\n        return this._excludeWithLayerMask;\n      },\n      set: function (e) {\n        this._excludeWithLayerMask = e, this._resyncMeshes();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"includeOnlyWithLayerMask\", {\n      get: function () {\n        return this._includeOnlyWithLayerMask;\n      },\n      set: function (e) {\n        this._includeOnlyWithLayerMask = e, this._resyncMeshes();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"lightmapMode\", {\n      get: function () {\n        return this._lightmapMode;\n      },\n      set: function (e) {\n        this._lightmapMode !== e && (this._lightmapMode = e, this._markMeshesAsLightDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), s.prototype.getClassName = function () {\n      return \"Light\";\n    }, s.prototype.toString = function (e) {\n      var t = \"Name: \" + this.name;\n      if (t += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()], this.animations) for (var i = 0; i < this.animations.length; i++) t += \", animation[0]: \" + this.animations[i].toString(e);\n      return t;\n    }, s.prototype._syncParentEnabledState = function () {\n      n.prototype._syncParentEnabledState.call(this), this._resyncMeshes();\n    }, s.prototype.setEnabled = function (e) {\n      n.prototype.setEnabled.call(this, e), this._resyncMeshes();\n    }, s.prototype.getShadowGenerator = function () {\n      return this._shadowGenerator;\n    }, s.prototype.getAbsolutePosition = function () {\n      return N.Vector3.Zero();\n    }, s.prototype.canAffectMesh = function (e) {\n      return !e || !(this.includedOnlyMeshes && 0 < this.includedOnlyMeshes.length && -1 === this.includedOnlyMeshes.indexOf(e)) && !(this.excludedMeshes && 0 < this.excludedMeshes.length && -1 !== this.excludedMeshes.indexOf(e)) && (0 === this.includeOnlyWithLayerMask || 0 != (this.includeOnlyWithLayerMask & e.layerMask)) && !(0 !== this.excludeWithLayerMask && this.excludeWithLayerMask & e.layerMask);\n    }, s.CompareLightsPriority = function (e, t) {\n      return e.shadowEnabled !== t.shadowEnabled ? (t.shadowEnabled ? 1 : 0) - (e.shadowEnabled ? 1 : 0) : t.renderPriority - e.renderPriority;\n    }, s.prototype.dispose = function (e, t) {\n      void 0 === t && (t = !1), this._shadowGenerator && (this._shadowGenerator.dispose(), this._shadowGenerator = null), this.getScene().stopAnimation(this);\n\n      for (var i = 0, r = this.getScene().meshes; i < r.length; i++) {\n        r[i]._removeLightSource(this);\n      }\n\n      this._uniformBuffer.dispose(), this.getScene().removeLight(this), n.prototype.dispose.call(this, e, t);\n    }, s.prototype.getTypeID = function () {\n      return 0;\n    }, s.prototype.getScaledIntensity = function () {\n      return this._photometricScale * this.intensity;\n    }, s.prototype.clone = function (e) {\n      var t = s.GetConstructorFromName(this.getTypeID(), e, this.getScene());\n      return t ? N.SerializationHelper.Clone(t, this) : null;\n    }, s.prototype.serialize = function () {\n      var t = N.SerializationHelper.Serialize(this);\n      return t.type = this.getTypeID(), this.parent && (t.parentId = this.parent.id), 0 < this.excludedMeshes.length && (t.excludedMeshesIds = [], this.excludedMeshes.forEach(function (e) {\n        t.excludedMeshesIds.push(e.id);\n      })), 0 < this.includedOnlyMeshes.length && (t.includedOnlyMeshesIds = [], this.includedOnlyMeshes.forEach(function (e) {\n        t.includedOnlyMeshesIds.push(e.id);\n      })), N.Animation.AppendSerializedAnimations(this, t), t.ranges = this.serializeAnimationRanges(), t;\n    }, s.GetConstructorFromName = function (e, t, i) {\n      var r = N.Node.Construct(\"Light_Type_\" + e, t, i);\n      return r || null;\n    }, s.Parse = function (e, t) {\n      var i = s.GetConstructorFromName(e.type, e.name, t);\n      if (!i) return null;\n      var r = N.SerializationHelper.Parse(i, e, t);\n\n      if (e.excludedMeshesIds && (r._excludedMeshesIds = e.excludedMeshesIds), e.includedOnlyMeshesIds && (r._includedOnlyMeshesIds = e.includedOnlyMeshesIds), e.parentId && (r._waitingParentId = e.parentId), e.animations) {\n        for (var n = 0; n < e.animations.length; n++) {\n          var o = e.animations[n];\n          r.animations.push(N.Animation.Parse(o));\n        }\n\n        N.Node.ParseAnimationRanges(r, e, t);\n      }\n\n      return e.autoAnimate && t.beginAnimation(r, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), r;\n    }, s.prototype._hookArrayForExcluded = function (o) {\n      var s = this,\n          a = o.push;\n\n      o.push = function () {\n        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];\n\n        for (var i = a.apply(o, e), r = 0, n = e; r < n.length; r++) {\n          n[r]._resyncLighSource(s);\n        }\n\n        return i;\n      };\n\n      var l = o.splice;\n\n      o.splice = function (e, t) {\n        for (var i = l.apply(o, [e, t]), r = 0, n = i; r < n.length; r++) {\n          n[r]._resyncLighSource(s);\n        }\n\n        return i;\n      };\n\n      for (var e = 0, t = o; e < t.length; e++) {\n        t[e]._resyncLighSource(this);\n      }\n    }, s.prototype._hookArrayForIncludedOnly = function (r) {\n      var n = this,\n          o = r.push;\n\n      r.push = function () {\n        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];\n\n        var i = o.apply(r, e);\n        return n._resyncMeshes(), i;\n      };\n\n      var s = r.splice;\n      r.splice = function (e, t) {\n        var i = s.apply(r, [e, t]);\n        return n._resyncMeshes(), i;\n      }, this._resyncMeshes();\n    }, s.prototype._resyncMeshes = function () {\n      for (var e = 0, t = this.getScene().meshes; e < t.length; e++) {\n        t[e]._resyncLighSource(this);\n      }\n    }, s.prototype._markMeshesAsLightDirty = function () {\n      for (var e = 0, t = this.getScene().meshes; e < t.length; e++) {\n        var i = t[e];\n        -1 !== i._lightSources.indexOf(this) && i._markSubMeshesAsLightDirty();\n      }\n    }, s.prototype._computePhotometricScale = function () {\n      this._photometricScale = this._getPhotometricScale(), this.getScene().resetCachedMaterial();\n    }, s.prototype._getPhotometricScale = function () {\n      var e = 0,\n          t = this.getTypeID(),\n          i = this.intensityMode;\n\n      switch (i === s.INTENSITYMODE_AUTOMATIC && (i = t === s.LIGHTTYPEID_DIRECTIONALLIGHT ? s.INTENSITYMODE_ILLUMINANCE : s.INTENSITYMODE_LUMINOUSINTENSITY), t) {\n        case s.LIGHTTYPEID_POINTLIGHT:\n        case s.LIGHTTYPEID_SPOTLIGHT:\n          switch (i) {\n            case s.INTENSITYMODE_LUMINOUSPOWER:\n              e = 1 / (4 * Math.PI);\n              break;\n\n            case s.INTENSITYMODE_LUMINOUSINTENSITY:\n              e = 1;\n              break;\n\n            case s.INTENSITYMODE_LUMINANCE:\n              e = this.radius * this.radius;\n          }\n\n          break;\n\n        case s.LIGHTTYPEID_DIRECTIONALLIGHT:\n          switch (i) {\n            case s.INTENSITYMODE_ILLUMINANCE:\n              e = 1;\n              break;\n\n            case s.INTENSITYMODE_LUMINANCE:\n              var r = this.radius;\n              r = Math.max(r, .001), e = 2 * Math.PI * (1 - Math.cos(r));\n          }\n\n          break;\n\n        case s.LIGHTTYPEID_HEMISPHERICLIGHT:\n          e = 1;\n      }\n\n      return e;\n    }, s.prototype._reorderLightsInScene = function () {\n      var e = this.getScene();\n      0 != this._renderPriority && (e.requireLightSorting = !0), this.getScene().sortLightsByPriority();\n    }, s.FALLOFF_DEFAULT = 0, s.FALLOFF_PHYSICAL = 1, s.FALLOFF_GLTF = 2, s.FALLOFF_STANDARD = 3, s.LIGHTMAP_DEFAULT = 0, s.LIGHTMAP_SPECULAR = 1, s.LIGHTMAP_SHADOWSONLY = 2, s.INTENSITYMODE_AUTOMATIC = 0, s.INTENSITYMODE_LUMINOUSPOWER = 1, s.INTENSITYMODE_LUMINOUSINTENSITY = 2, s.INTENSITYMODE_ILLUMINANCE = 3, s.INTENSITYMODE_LUMINANCE = 4, s.LIGHTTYPEID_POINTLIGHT = 0, s.LIGHTTYPEID_DIRECTIONALLIGHT = 1, s.LIGHTTYPEID_SPOTLIGHT = 2, s.LIGHTTYPEID_HEMISPHERICLIGHT = 3, b([N.serializeAsColor3()], s.prototype, \"diffuse\", void 0), b([N.serializeAsColor3()], s.prototype, \"specular\", void 0), b([N.serialize()], s.prototype, \"falloffType\", void 0), b([N.serialize()], s.prototype, \"intensity\", void 0), b([N.serialize()], s.prototype, \"range\", null), b([N.serialize()], s.prototype, \"intensityMode\", null), b([N.serialize()], s.prototype, \"radius\", null), b([N.serialize()], s.prototype, \"_renderPriority\", void 0), b([N.expandToProperty(\"_reorderLightsInScene\")], s.prototype, \"renderPriority\", void 0), b([N.serialize(\"shadowEnabled\")], s.prototype, \"_shadowEnabled\", void 0), b([N.serialize(\"excludeWithLayerMask\")], s.prototype, \"_excludeWithLayerMask\", void 0), b([N.serialize(\"includeOnlyWithLayerMask\")], s.prototype, \"_includeOnlyWithLayerMask\", void 0), b([N.serialize(\"lightmapMode\")], s.prototype, \"_lightmapMode\", void 0), s;\n  }(N.Node), N.Light = V, U = $a || ($a = {}), z = function (o) {\n    function c(e, t, i, r) {\n      void 0 === r && (r = !0);\n      var n = o.call(this, e, i) || this;\n      return n.upVector = U.Vector3.Up(), n.orthoLeft = null, n.orthoRight = null, n.orthoBottom = null, n.orthoTop = null, n.fov = .8, n.minZ = 1, n.maxZ = 1e4, n.inertia = .9, n.mode = c.PERSPECTIVE_CAMERA, n.isIntermediate = !1, n.viewport = new U.Viewport(0, 0, 1, 1), n.layerMask = 268435455, n.fovMode = c.FOVMODE_VERTICAL_FIXED, n.cameraRigMode = c.RIG_MODE_NONE, n.customRenderTargets = new Array(), n.onViewMatrixChangedObservable = new U.Observable(), n.onProjectionMatrixChangedObservable = new U.Observable(), n.onAfterCheckInputsObservable = new U.Observable(), n.onRestoreStateObservable = new U.Observable(), n._rigCameras = new Array(), n._webvrViewMatrix = U.Matrix.Identity(), n._skipRendering = !1, n._projectionMatrix = new U.Matrix(), n._postProcesses = new Array(), n._activeMeshes = new U.SmartArray(256), n._globalPosition = U.Vector3.Zero(), n._computedViewMatrix = U.Matrix.Identity(), n._doNotComputeProjectionMatrix = !1, n._transformMatrix = U.Matrix.Zero(), n._refreshFrustumPlanes = !0, n.getScene().addCamera(n), r && !n.getScene().activeCamera && (n.getScene().activeCamera = n), n.position = t, n;\n    }\n\n    return T(c, o), c.prototype.storeState = function () {\n      return this._stateStored = !0, this._storedFov = this.fov, this;\n    }, c.prototype._restoreStateValues = function () {\n      return !!this._stateStored && (this.fov = this._storedFov, !0);\n    }, c.prototype.restoreState = function () {\n      return !!this._restoreStateValues() && (this.onRestoreStateObservable.notifyObservers(this), !0);\n    }, c.prototype.getClassName = function () {\n      return \"Camera\";\n    }, c.prototype.toString = function (e) {\n      var t = \"Name: \" + this.name;\n      if (t += \", type: \" + this.getClassName(), this.animations) for (var i = 0; i < this.animations.length; i++) t += \", animation[0]: \" + this.animations[i].toString(e);\n      return t;\n    }, Object.defineProperty(c.prototype, \"globalPosition\", {\n      get: function () {\n        return this._globalPosition;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), c.prototype.getActiveMeshes = function () {\n      return this._activeMeshes;\n    }, c.prototype.isActiveMesh = function (e) {\n      return -1 !== this._activeMeshes.indexOf(e);\n    }, c.prototype.isReady = function (e) {\n      if (void 0 === e && (e = !1), e) for (var t = 0, i = this._postProcesses; t < i.length; t++) {\n        var r = i[t];\n        if (r && !r.isReady()) return !1;\n      }\n      return o.prototype.isReady.call(this, e);\n    }, c.prototype._initCache = function () {\n      o.prototype._initCache.call(this), this._cache.position = new U.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new U.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.fov = void 0, this._cache.fovMode = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0;\n    }, c.prototype._updateCache = function (e) {\n      e || o.prototype._updateCache.call(this), this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector);\n    }, c.prototype._isSynchronized = function () {\n      return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();\n    }, c.prototype._isSynchronizedViewMatrix = function () {\n      return !!o.prototype._isSynchronized.call(this) && this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();\n    }, c.prototype._isSynchronizedProjectionMatrix = function () {\n      var e = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;\n      if (!e) return !1;\n      var t = this.getEngine();\n      return e = this.mode === c.PERSPECTIVE_CAMERA ? this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === t.getAspectRatio(this) : this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === t.getRenderWidth() && this._cache.renderHeight === t.getRenderHeight();\n    }, c.prototype.attachControl = function (e, t) {}, c.prototype.detachControl = function (e) {}, c.prototype.update = function () {\n      this._checkInputs(), this.cameraRigMode !== c.RIG_MODE_NONE && this._updateRigCameras();\n    }, c.prototype._checkInputs = function () {\n      this.onAfterCheckInputsObservable.notifyObservers(this);\n    }, Object.defineProperty(c.prototype, \"rigCameras\", {\n      get: function () {\n        return this._rigCameras;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"rigPostProcess\", {\n      get: function () {\n        return this._rigPostProcess;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), c.prototype._getFirstPostProcess = function () {\n      for (var e = 0; e < this._postProcesses.length; e++) if (null !== this._postProcesses[e]) return this._postProcesses[e];\n\n      return null;\n    }, c.prototype._cascadePostProcessesToRigCams = function () {\n      var e = this._getFirstPostProcess();\n\n      e && e.markTextureDirty();\n\n      for (var t = 0, i = this._rigCameras.length; t < i; t++) {\n        var r = this._rigCameras[t],\n            n = r._rigPostProcess;\n        if (n) n instanceof U.PassPostProcess && (r.isIntermediate = 0 === this._postProcesses.length), r._postProcesses = this._postProcesses.slice(0).concat(n), n.markTextureDirty();else r._postProcesses = this._postProcesses.slice(0);\n      }\n    }, c.prototype.attachPostProcess = function (e, t) {\n      return void 0 === t && (t = null), !e.isReusable() && -1 < this._postProcesses.indexOf(e) ? (U.Tools.Error(\"You're trying to reuse a post process not defined as reusable.\"), 0) : (null == t || t < 0 ? this._postProcesses.push(e) : null === this._postProcesses[t] ? this._postProcesses[t] = e : this._postProcesses.splice(t, 0, e), this._cascadePostProcessesToRigCams(), this._postProcesses.indexOf(e));\n    }, c.prototype.detachPostProcess = function (e) {\n      var t = this._postProcesses.indexOf(e);\n\n      -1 !== t && (this._postProcesses[t] = null), this._cascadePostProcessesToRigCams();\n    }, c.prototype.getWorldMatrix = function () {\n      return this._isSynchronizedViewMatrix() || this.getViewMatrix(), this._worldMatrix;\n    }, c.prototype._getViewMatrix = function () {\n      return U.Matrix.Identity();\n    }, c.prototype.getViewMatrix = function (e) {\n      return !e && this._isSynchronizedViewMatrix() || (this.updateCache(), this._computedViewMatrix = this._getViewMatrix(), this._currentRenderId = this.getScene().getRenderId(), this._childRenderId = this._currentRenderId, this._refreshFrustumPlanes = !0, this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix && this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix), this.onViewMatrixChangedObservable.notifyObservers(this), this._computedViewMatrix.invertToRef(this._worldMatrix)), this._computedViewMatrix;\n    }, c.prototype.freezeProjectionMatrix = function (e) {\n      this._doNotComputeProjectionMatrix = !0, void 0 !== e && (this._projectionMatrix = e);\n    }, c.prototype.unfreezeProjectionMatrix = function () {\n      this._doNotComputeProjectionMatrix = !1;\n    }, c.prototype.getProjectionMatrix = function (e) {\n      if (this._doNotComputeProjectionMatrix || !e && this._isSynchronizedProjectionMatrix()) return this._projectionMatrix;\n      this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._refreshFrustumPlanes = !0;\n      var t = this.getEngine(),\n          i = this.getScene();\n      if (this.mode === c.PERSPECTIVE_CAMERA) this._cache.fov = this.fov, this._cache.fovMode = this.fovMode, this._cache.aspectRatio = t.getAspectRatio(this), this.minZ <= 0 && (this.minZ = .1), i.useRightHandedSystem ? U.Matrix.PerspectiveFovRHToRef(this.fov, t.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix, this.fovMode === c.FOVMODE_VERTICAL_FIXED) : U.Matrix.PerspectiveFovLHToRef(this.fov, t.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix, this.fovMode === c.FOVMODE_VERTICAL_FIXED);else {\n        var r = t.getRenderWidth() / 2,\n            n = t.getRenderHeight() / 2;\n        i.useRightHandedSystem ? U.Matrix.OrthoOffCenterRHToRef(this.orthoLeft || -r, this.orthoRight || r, this.orthoBottom || -n, this.orthoTop || n, this.minZ, this.maxZ, this._projectionMatrix) : U.Matrix.OrthoOffCenterLHToRef(this.orthoLeft || -r, this.orthoRight || r, this.orthoBottom || -n, this.orthoTop || n, this.minZ, this.maxZ, this._projectionMatrix), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.renderWidth = t.getRenderWidth(), this._cache.renderHeight = t.getRenderHeight();\n      }\n      return this.onProjectionMatrixChangedObservable.notifyObservers(this), this._projectionMatrix;\n    }, c.prototype.getTransformationMatrix = function () {\n      return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._transformMatrix;\n    }, c.prototype._updateFrustumPlanes = function () {\n      this._refreshFrustumPlanes && (this.getTransformationMatrix(), this._frustumPlanes ? U.Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = U.Frustum.GetPlanes(this._transformMatrix), this._refreshFrustumPlanes = !1);\n    }, c.prototype.isInFrustum = function (e) {\n      return this._updateFrustumPlanes(), e.isInFrustum(this._frustumPlanes);\n    }, c.prototype.isCompletelyInFrustum = function (e) {\n      return this._updateFrustumPlanes(), e.isCompletelyInFrustum(this._frustumPlanes);\n    }, c.prototype.getForwardRay = function (e, t, i) {\n      void 0 === e && (e = 100), t || (t = this.getWorldMatrix()), i || (i = this.position);\n      var r = this._scene.useRightHandedSystem ? new U.Vector3(0, 0, -1) : new U.Vector3(0, 0, 1),\n          n = U.Vector3.TransformNormal(r, t),\n          o = U.Vector3.Normalize(n);\n      return new U.Ray(i, o, e);\n    }, c.prototype.dispose = function (e, t) {\n      for (void 0 === t && (t = !1), this.onViewMatrixChangedObservable.clear(), this.onProjectionMatrixChangedObservable.clear(), this.onAfterCheckInputsObservable.clear(), this.onRestoreStateObservable.clear(), this.inputs && this.inputs.clear(), this.getScene().stopAnimation(this), this.getScene().removeCamera(this); 0 < this._rigCameras.length;) {\n        var i = this._rigCameras.pop();\n\n        i && i.dispose();\n      }\n\n      if (this._rigPostProcess) this._rigPostProcess.dispose(this), this._rigPostProcess = null, this._postProcesses = [];else if (this.cameraRigMode !== c.RIG_MODE_NONE) this._rigPostProcess = null, this._postProcesses = [];else for (var r = this._postProcesses.length; 0 <= --r;) {\n        var n = this._postProcesses[r];\n        n && n.dispose(this);\n      }\n\n      for (r = this.customRenderTargets.length; 0 <= --r;) this.customRenderTargets[r].dispose();\n\n      this.customRenderTargets = [], this._activeMeshes.dispose(), o.prototype.dispose.call(this, e, t);\n    }, Object.defineProperty(c.prototype, \"leftCamera\", {\n      get: function () {\n        return this._rigCameras.length < 1 ? null : this._rigCameras[0];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"rightCamera\", {\n      get: function () {\n        return this._rigCameras.length < 2 ? null : this._rigCameras[1];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), c.prototype.getLeftTarget = function () {\n      return this._rigCameras.length < 1 ? null : this._rigCameras[0].getTarget();\n    }, c.prototype.getRightTarget = function () {\n      return this._rigCameras.length < 2 ? null : this._rigCameras[1].getTarget();\n    }, c.prototype.setCameraRigMode = function (e, t) {\n      if (this.cameraRigMode !== e) {\n        for (; 0 < this._rigCameras.length;) {\n          var i = this._rigCameras.pop();\n\n          i && i.dispose();\n        }\n\n        if (this.cameraRigMode = e, this._cameraRigParams = {}, this._cameraRigParams.interaxialDistance = t.interaxialDistance || .0637, this._cameraRigParams.stereoHalfAngle = U.Tools.ToRadians(this._cameraRigParams.interaxialDistance / .0637), this.cameraRigMode !== c.RIG_MODE_NONE) {\n          var r = this.createRigCamera(this.name + \"_L\", 0),\n              n = this.createRigCamera(this.name + \"_R\", 1);\n          r && n && (this._rigCameras.push(r), this._rigCameras.push(n));\n        }\n\n        switch (this.cameraRigMode) {\n          case c.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n            this._rigCameras[0]._rigPostProcess = new U.PassPostProcess(this.name + \"_passthru\", 1, this._rigCameras[0]), this._rigCameras[1]._rigPostProcess = new U.AnaglyphPostProcess(this.name + \"_anaglyph\", 1, this._rigCameras);\n            break;\n\n          case c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n          case c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n          case c.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n            var o = this.cameraRigMode === c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || this.cameraRigMode === c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\n            this._rigCameras[0]._rigPostProcess = new U.PassPostProcess(this.name + \"_passthru\", 1, this._rigCameras[0]), this._rigCameras[1]._rigPostProcess = new U.StereoscopicInterlacePostProcess(this.name + \"_stereoInterlace\", this._rigCameras, o);\n            break;\n\n          case c.RIG_MODE_VR:\n            var s = t.vrCameraMetrics || U.VRCameraMetrics.GetDefault();\n            this._rigCameras[0]._cameraRigParams.vrMetrics = s, this._rigCameras[0].viewport = new U.Viewport(0, 0, .5, 1), this._rigCameras[0]._cameraRigParams.vrWorkMatrix = new U.Matrix(), this._rigCameras[0]._cameraRigParams.vrHMatrix = s.leftHMatrix, this._rigCameras[0]._cameraRigParams.vrPreViewMatrix = s.leftPreViewMatrix, this._rigCameras[0].getProjectionMatrix = this._rigCameras[0]._getVRProjectionMatrix, this._rigCameras[1]._cameraRigParams.vrMetrics = s, this._rigCameras[1].viewport = new U.Viewport(.5, 0, .5, 1), this._rigCameras[1]._cameraRigParams.vrWorkMatrix = new U.Matrix(), this._rigCameras[1]._cameraRigParams.vrHMatrix = s.rightHMatrix, this._rigCameras[1]._cameraRigParams.vrPreViewMatrix = s.rightPreViewMatrix, this._rigCameras[1].getProjectionMatrix = this._rigCameras[1]._getVRProjectionMatrix, s.compensateDistortion && (this._rigCameras[0]._rigPostProcess = new U.VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Left\", this._rigCameras[0], !1, s), this._rigCameras[1]._rigPostProcess = new U.VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Right\", this._rigCameras[1], !0, s));\n            break;\n\n          case c.RIG_MODE_WEBVR:\n            if (t.vrDisplay) {\n              var a = t.vrDisplay.getEyeParameters(\"left\"),\n                  l = t.vrDisplay.getEyeParameters(\"right\");\n              this._rigCameras[0].viewport = new U.Viewport(0, 0, .5, 1), this._rigCameras[0].setCameraRigParameter(\"left\", !0), this._rigCameras[0].setCameraRigParameter(\"specs\", t.specs), this._rigCameras[0].setCameraRigParameter(\"eyeParameters\", a), this._rigCameras[0].setCameraRigParameter(\"frameData\", t.frameData), this._rigCameras[0].setCameraRigParameter(\"parentCamera\", t.parentCamera), this._rigCameras[0]._cameraRigParams.vrWorkMatrix = new U.Matrix(), this._rigCameras[0].getProjectionMatrix = this._getWebVRProjectionMatrix, (this._rigCameras[0].parent = this)._rigCameras[0]._getViewMatrix = this._getWebVRViewMatrix, this._rigCameras[1].viewport = new U.Viewport(.5, 0, .5, 1), this._rigCameras[1].setCameraRigParameter(\"eyeParameters\", l), this._rigCameras[1].setCameraRigParameter(\"specs\", t.specs), this._rigCameras[1].setCameraRigParameter(\"frameData\", t.frameData), this._rigCameras[1].setCameraRigParameter(\"parentCamera\", t.parentCamera), this._rigCameras[1]._cameraRigParams.vrWorkMatrix = new U.Matrix(), this._rigCameras[1].getProjectionMatrix = this._getWebVRProjectionMatrix, (this._rigCameras[1].parent = this)._rigCameras[1]._getViewMatrix = this._getWebVRViewMatrix, c.UseAlternateWebVRRendering && (this._rigCameras[1]._skipRendering = !0, this._rigCameras[0]._alternateCamera = this._rigCameras[1]);\n            }\n\n        }\n\n        this._cascadePostProcessesToRigCams(), this.update();\n      }\n    }, c.prototype._getVRProjectionMatrix = function () {\n      return U.Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix), this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix), this._projectionMatrix;\n    }, c.prototype._updateCameraRotationMatrix = function () {}, c.prototype._updateWebVRCameraRotationMatrix = function () {}, c.prototype._getWebVRProjectionMatrix = function () {\n      return U.Matrix.Identity();\n    }, c.prototype._getWebVRViewMatrix = function () {\n      return U.Matrix.Identity();\n    }, c.prototype.setCameraRigParameter = function (e, t) {\n      this._cameraRigParams || (this._cameraRigParams = {}), this._cameraRigParams[e] = t, \"interaxialDistance\" === e && (this._cameraRigParams.stereoHalfAngle = U.Tools.ToRadians(t / .0637));\n    }, c.prototype.createRigCamera = function (e, t) {\n      return null;\n    }, c.prototype._updateRigCameras = function () {\n      for (var e = 0; e < this._rigCameras.length; e++) this._rigCameras[e].minZ = this.minZ, this._rigCameras[e].maxZ = this.maxZ, this._rigCameras[e].fov = this.fov;\n\n      this.cameraRigMode === c.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport);\n    }, c.prototype._setupInputs = function () {}, c.prototype.serialize = function () {\n      var e = U.SerializationHelper.Serialize(this);\n      return e.type = this.getClassName(), this.parent && (e.parentId = this.parent.id), this.inputs && this.inputs.serialize(e), U.Animation.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e;\n    }, c.prototype.clone = function (e) {\n      return U.SerializationHelper.Clone(c.GetConstructorFromName(this.getClassName(), e, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);\n    }, c.prototype.getDirection = function (e) {\n      var t = U.Vector3.Zero();\n      return this.getDirectionToRef(e, t), t;\n    }, c.prototype.getDirectionToRef = function (e, t) {\n      U.Vector3.TransformNormalToRef(e, this.getWorldMatrix(), t);\n    }, c.GetConstructorFromName = function (e, t, i, r, n) {\n      void 0 === r && (r = 0), void 0 === n && (n = !0);\n      var o = U.Node.Construct(e, t, i, {\n        interaxial_distance: r,\n        isStereoscopicSideBySide: n\n      });\n      return o || function () {\n        return new U.UniversalCamera(t, U.Vector3.Zero(), i);\n      };\n    }, c.prototype.computeWorldMatrix = function () {\n      return this.getWorldMatrix();\n    }, c.Parse = function (e, t) {\n      var i = e.type,\n          r = c.GetConstructorFromName(i, e.name, t, e.interaxial_distance, e.isStereoscopicSideBySide),\n          n = U.SerializationHelper.Parse(r, e, t);\n\n      if (e.parentId && (n._waitingParentId = e.parentId), n.inputs && (n.inputs.parse(e), n._setupInputs()), n.setPosition && (n.position.copyFromFloats(0, 0, 0), n.setPosition(U.Vector3.FromArray(e.position))), e.target && n.setTarget && n.setTarget(U.Vector3.FromArray(e.target)), e.cameraRigMode) {\n        var o = e.interaxial_distance ? {\n          interaxialDistance: e.interaxial_distance\n        } : {};\n        n.setCameraRigMode(e.cameraRigMode, o);\n      }\n\n      if (e.animations) {\n        for (var s = 0; s < e.animations.length; s++) {\n          var a = e.animations[s];\n          n.animations.push(U.Animation.Parse(a));\n        }\n\n        U.Node.ParseAnimationRanges(n, e, t);\n      }\n\n      return e.autoAnimate && t.beginAnimation(n, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), n;\n    }, c.PERSPECTIVE_CAMERA = 0, c.ORTHOGRAPHIC_CAMERA = 1, c.FOVMODE_VERTICAL_FIXED = 0, c.FOVMODE_HORIZONTAL_FIXED = 1, c.RIG_MODE_NONE = 0, c.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10, c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11, c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12, c.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13, c.RIG_MODE_VR = 20, c.RIG_MODE_WEBVR = 21, c.ForceAttachControlToAlwaysPreventDefault = !1, c.UseAlternateWebVRRendering = !1, b([U.serializeAsVector3()], c.prototype, \"position\", void 0), b([U.serializeAsVector3()], c.prototype, \"upVector\", void 0), b([U.serialize()], c.prototype, \"orthoLeft\", void 0), b([U.serialize()], c.prototype, \"orthoRight\", void 0), b([U.serialize()], c.prototype, \"orthoBottom\", void 0), b([U.serialize()], c.prototype, \"orthoTop\", void 0), b([U.serialize()], c.prototype, \"fov\", void 0), b([U.serialize()], c.prototype, \"minZ\", void 0), b([U.serialize()], c.prototype, \"maxZ\", void 0), b([U.serialize()], c.prototype, \"inertia\", void 0), b([U.serialize()], c.prototype, \"mode\", void 0), b([U.serialize()], c.prototype, \"layerMask\", void 0), b([U.serialize()], c.prototype, \"fovMode\", void 0), b([U.serialize()], c.prototype, \"cameraRigMode\", void 0), b([U.serialize()], c.prototype, \"interaxialDistance\", void 0), b([U.serialize()], c.prototype, \"isStereoscopicSideBySide\", void 0), c;\n  }(U.Node), U.Camera = z, G = $a || ($a = {}), k = function () {\n    function p(e) {\n      this._useSceneAutoClearSetup = !1, this._renderingGroups = new Array(), this._autoClearDepthStencil = {}, this._customOpaqueSortCompareFn = {}, this._customAlphaTestSortCompareFn = {}, this._customTransparentSortCompareFn = {}, this._renderingGroupInfo = new G.RenderingGroupInfo(), this._scene = e;\n\n      for (var t = p.MIN_RENDERINGGROUPS; t < p.MAX_RENDERINGGROUPS; t++) this._autoClearDepthStencil[t] = {\n        autoClear: !0,\n        depth: !0,\n        stencil: !0\n      };\n    }\n\n    return p.prototype._clearDepthStencilBuffer = function (e, t) {\n      void 0 === e && (e = !0), void 0 === t && (t = !0), this._depthStencilBufferAlreadyCleaned || (this._scene.getEngine().clear(null, !1, e, t), this._depthStencilBufferAlreadyCleaned = !0);\n    }, p.prototype.render = function (e, t, i, r) {\n      var n = this._renderingGroupInfo;\n      if (n.scene = this._scene, n.camera = this._scene.activeCamera, this._scene.spriteManagers && r) for (var o = 0; o < this._scene.spriteManagers.length; o++) {\n        var s = this._scene.spriteManagers[o];\n        this.dispatchSprites(s);\n      }\n\n      for (o = p.MIN_RENDERINGGROUPS; o < p.MAX_RENDERINGGROUPS; o++) {\n        this._depthStencilBufferAlreadyCleaned = o === p.MIN_RENDERINGGROUPS;\n        var a = this._renderingGroups[o];\n\n        if (a) {\n          var l = Math.pow(2, o);\n\n          if (n.renderingGroupId = o, this._scene.onBeforeRenderingGroupObservable.notifyObservers(n, l), p.AUTOCLEAR) {\n            var c = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(o) : this._autoClearDepthStencil[o];\n            c && c.autoClear && this._clearDepthStencilBuffer(c.depth, c.stencil);\n          }\n\n          for (var h = 0, u = this._scene._beforeRenderingGroupDrawStage; h < u.length; h++) {\n            u[h].action(o);\n          }\n\n          a.render(e, r, i, t);\n\n          for (var d = 0, f = this._scene._afterRenderingGroupDrawStage; d < f.length; d++) {\n            f[d].action(o);\n          }\n\n          this._scene.onAfterRenderingGroupObservable.notifyObservers(n, l);\n        }\n      }\n    }, p.prototype.reset = function () {\n      for (var e = p.MIN_RENDERINGGROUPS; e < p.MAX_RENDERINGGROUPS; e++) {\n        var t = this._renderingGroups[e];\n        t && t.prepare();\n      }\n    }, p.prototype.dispose = function () {\n      this.freeRenderingGroups(), this._renderingGroups.length = 0, this._renderingGroupInfo = null;\n    }, p.prototype.freeRenderingGroups = function () {\n      for (var e = p.MIN_RENDERINGGROUPS; e < p.MAX_RENDERINGGROUPS; e++) {\n        var t = this._renderingGroups[e];\n        t && t.dispose();\n      }\n    }, p.prototype._prepareRenderingGroup = function (e) {\n      void 0 === this._renderingGroups[e] && (this._renderingGroups[e] = new G.RenderingGroup(e, this._scene, this._customOpaqueSortCompareFn[e], this._customAlphaTestSortCompareFn[e], this._customTransparentSortCompareFn[e]));\n    }, p.prototype.dispatchSprites = function (e) {\n      var t = e.renderingGroupId || 0;\n      this._prepareRenderingGroup(t), this._renderingGroups[t].dispatchSprites(e);\n    }, p.prototype.dispatchParticles = function (e) {\n      var t = e.renderingGroupId || 0;\n      this._prepareRenderingGroup(t), this._renderingGroups[t].dispatchParticles(e);\n    }, p.prototype.dispatch = function (e, t, i) {\n      void 0 === t && (t = e.getMesh());\n      var r = t.renderingGroupId || 0;\n      this._prepareRenderingGroup(r), this._renderingGroups[r].dispatch(e, t, i);\n    }, p.prototype.setRenderingOrder = function (e, t, i, r) {\n      if (void 0 === t && (t = null), void 0 === i && (i = null), void 0 === r && (r = null), this._customOpaqueSortCompareFn[e] = t, this._customAlphaTestSortCompareFn[e] = i, this._customTransparentSortCompareFn[e] = r, this._renderingGroups[e]) {\n        var n = this._renderingGroups[e];\n        n.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e], n.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e], n.transparentSortCompareFn = this._customTransparentSortCompareFn[e];\n      }\n    }, p.prototype.setRenderingAutoClearDepthStencil = function (e, t, i, r) {\n      void 0 === i && (i = !0), void 0 === r && (r = !0), this._autoClearDepthStencil[e] = {\n        autoClear: t,\n        depth: i,\n        stencil: r\n      };\n    }, p.prototype.getAutoClearDepthStencilSetup = function (e) {\n      return this._autoClearDepthStencil[e];\n    }, p.MAX_RENDERINGGROUPS = 4, p.MIN_RENDERINGGROUPS = 0, p.AUTOCLEAR = !0, p;\n  }(), G.RenderingManager = k, W = $a || ($a = {}), H = function () {\n    function i(e, t, i, r, n) {\n      void 0 === i && (i = null), void 0 === r && (r = null), void 0 === n && (n = null), this.index = e, this._opaqueSubMeshes = new W.SmartArray(256), this._transparentSubMeshes = new W.SmartArray(256), this._alphaTestSubMeshes = new W.SmartArray(256), this._depthOnlySubMeshes = new W.SmartArray(256), this._particleSystems = new W.SmartArray(256), this._spriteManagers = new W.SmartArray(256), this._edgesRenderers = new W.SmartArray(16), this._scene = t, this.opaqueSortCompareFn = i, this.alphaTestSortCompareFn = r, this.transparentSortCompareFn = n;\n    }\n\n    return Object.defineProperty(i.prototype, \"opaqueSortCompareFn\", {\n      set: function (e) {\n        this._opaqueSortCompareFn = e, this._renderOpaque = e ? this.renderOpaqueSorted : i.renderUnsorted;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"alphaTestSortCompareFn\", {\n      set: function (e) {\n        this._alphaTestSortCompareFn = e, this._renderAlphaTest = e ? this.renderAlphaTestSorted : i.renderUnsorted;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"transparentSortCompareFn\", {\n      set: function (e) {\n        this._transparentSortCompareFn = e || i.defaultTransparentSortCompare, this._renderTransparent = this.renderTransparentSorted;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.render = function (e, t, i, r) {\n      if (e) e(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);else {\n        var n = this._scene.getEngine();\n\n        0 !== this._depthOnlySubMeshes.length && (n.setColorWrite(!1), this._renderAlphaTest(this._depthOnlySubMeshes), n.setColorWrite(!0)), 0 !== this._opaqueSubMeshes.length && this._renderOpaque(this._opaqueSubMeshes), 0 !== this._alphaTestSubMeshes.length && this._renderAlphaTest(this._alphaTestSubMeshes);\n        var o = n.getStencilBuffer();\n\n        if (n.setStencilBuffer(!1), t && this._renderSprites(), i && this._renderParticles(r), this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), 0 !== this._transparentSubMeshes.length && (this._renderTransparent(this._transparentSubMeshes), n.setAlphaMode(W.Engine.ALPHA_DISABLE)), n.setStencilBuffer(!1), this._edgesRenderers.length) {\n          for (var s = 0; s < this._edgesRenderers.length; s++) this._edgesRenderers.data[s].render();\n\n          n.setAlphaMode(W.Engine.ALPHA_DISABLE);\n        }\n\n        n.setStencilBuffer(o);\n      }\n    }, i.prototype.renderOpaqueSorted = function (e) {\n      return i.renderSorted(e, this._opaqueSortCompareFn, this._scene.activeCamera, !1);\n    }, i.prototype.renderAlphaTestSorted = function (e) {\n      return i.renderSorted(e, this._alphaTestSortCompareFn, this._scene.activeCamera, !1);\n    }, i.prototype.renderTransparentSorted = function (e) {\n      return i.renderSorted(e, this._transparentSortCompareFn, this._scene.activeCamera, !0);\n    }, i.renderSorted = function (e, t, i, r) {\n      for (var n, o = 0, s = i ? i.globalPosition : W.Vector3.Zero(); o < e.length; o++) (n = e.data[o])._alphaIndex = n.getMesh().alphaIndex, n._distanceToCamera = n.getBoundingInfo().boundingSphere.centerWorld.subtract(s).length();\n\n      var a = e.data.slice(0, e.length);\n\n      for (t && a.sort(t), o = 0; o < a.length; o++) {\n        if (n = a[o], r) {\n          var l = n.getMaterial();\n\n          if (l && l.needDepthPrePass) {\n            var c = l.getScene().getEngine();\n            c.setColorWrite(!1), c.setAlphaMode(W.Engine.ALPHA_DISABLE), n.render(!1), c.setColorWrite(!0);\n          }\n        }\n\n        n.render(r);\n      }\n    }, i.renderUnsorted = function (e) {\n      for (var t = 0; t < e.length; t++) {\n        e.data[t].render(!1);\n      }\n    }, i.defaultTransparentSortCompare = function (e, t) {\n      return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : i.backToFrontSortCompare(e, t);\n    }, i.backToFrontSortCompare = function (e, t) {\n      return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0;\n    }, i.frontToBackSortCompare = function (e, t) {\n      return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0;\n    }, i.prototype.prepare = function () {\n      this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset(), this._depthOnlySubMeshes.reset(), this._particleSystems.reset(), this._spriteManagers.reset(), this._edgesRenderers.reset();\n    }, i.prototype.dispose = function () {\n      this._opaqueSubMeshes.dispose(), this._transparentSubMeshes.dispose(), this._alphaTestSubMeshes.dispose(), this._depthOnlySubMeshes.dispose(), this._particleSystems.dispose(), this._spriteManagers.dispose(), this._edgesRenderers.dispose();\n    }, i.prototype.dispatch = function (e, t, i) {\n      void 0 === t && (t = e.getMesh()), void 0 === i && (i = e.getMaterial()), null != i && (i.needAlphaBlendingForMesh(t) ? this._transparentSubMeshes.push(e) : i.needAlphaTesting() ? (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._alphaTestSubMeshes.push(e)) : (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._opaqueSubMeshes.push(e)), t._edgesRenderer && t._edgesRenderer.isEnabled && this._edgesRenderers.push(t._edgesRenderer));\n    }, i.prototype.dispatchSprites = function (e) {\n      this._spriteManagers.push(e);\n    }, i.prototype.dispatchParticles = function (e) {\n      this._particleSystems.push(e);\n    }, i.prototype._renderParticles = function (e) {\n      if (0 !== this._particleSystems.length) {\n        var t = this._scene.activeCamera;\n\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n\n        for (var i = 0; i < this._particleSystems.length; i++) {\n          var r = this._particleSystems.data[i];\n\n          if (0 !== (t && t.layerMask & r.layerMask)) {\n            var n = r.emitter;\n            n.position && e && -1 === e.indexOf(n) || this._scene._activeParticles.addCount(r.render(), !1);\n          }\n        }\n\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n      }\n    }, i.prototype._renderSprites = function () {\n      if (this._scene.spritesEnabled && 0 !== this._spriteManagers.length) {\n        var e = this._scene.activeCamera;\n\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n\n        for (var t = 0; t < this._spriteManagers.length; t++) {\n          var i = this._spriteManagers.data[t];\n          0 !== (e && e.layerMask & i.layerMask) && i.render();\n        }\n\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n      }\n    }, i;\n  }(), W.RenderingGroup = H, function (e) {\n    var t = function () {\n      function e() {}\n\n      return e.NAME_EFFECTLAYER = \"EffectLayer\", e.NAME_LAYER = \"Layer\", e.NAME_LENSFLARESYSTEM = \"LensFlareSystem\", e.NAME_BOUNDINGBOXRENDERER = \"BoundingBoxRenderer\", e.NAME_PARTICLESYSTEM = \"ParticleSystem\", e.NAME_GAMEPAD = \"Gamepad\", e.NAME_SIMPLIFICATIONQUEUE = \"SimplificationQueue\", e.NAME_GEOMETRYBUFFERRENDERER = \"GeometryBufferRenderer\", e.NAME_DEPTHRENDERER = \"DepthRenderer\", e.NAME_POSTPROCESSRENDERPIPELINEMANAGER = \"PostProcessRenderPipelineManager\", e.NAME_SPRITE = \"Sprite\", e.NAME_OUTLINERENDERER = \"Outline\", e.NAME_PROCEDURALTEXTURE = \"ProceduralTexture\", e.NAME_SHADOWGENERATOR = \"ShadowGenerator\", e.NAME_OCTREE = \"Octree\", e.NAME_PHYSICSENGINE = \"PhysicsEngine\", e.NAME_AUDIO = \"Audio\", e.STEP_ISREADYFORMESH_EFFECTLAYER = 0, e.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0, e.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0, e.STEP_ACTIVEMESH_BOUNDINGBOXRENDERER = 0, e.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1, e.STEP_BEFORECAMERADRAW_EFFECTLAYER = 0, e.STEP_BEFORECAMERADRAW_LAYER = 1, e.STEP_BEFORERENDERINGMESH_OUTLINE = 0, e.STEP_AFTERRENDERINGMESH_OUTLINE = 0, e.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0, e.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1, e.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0, e.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1, e.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0, e.STEP_AFTERCAMERADRAW_EFFECTLAYER = 0, e.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 1, e.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 2, e.STEP_AFTERCAMERADRAW_LAYER = 3, e.STEP_AFTERRENDER_AUDIO = 0, e.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 0, e.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1, e.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 2, e.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3, e.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0, e.STEP_POINTERMOVE_SPRITE = 0, e.STEP_POINTERDOWN_SPRITE = 0, e.STEP_POINTERUP_SPRITE = 0, e;\n    }();\n\n    e.SceneComponentConstants = t;\n\n    var i = function (t) {\n      function e(e) {\n        return t.apply(this, e) || this;\n      }\n\n      return T(e, t), e.Create = function () {\n        return Object.create(e.prototype);\n      }, e.prototype.registerStep = function (e, t, i) {\n        var r = 0;\n\n        for (Number.MAX_VALUE; r < this.length; r++) {\n          if (e < this[r].index) break;\n        }\n\n        this.splice(r, 0, {\n          index: e,\n          component: t,\n          action: i.bind(t)\n        });\n      }, e.prototype.clear = function () {\n        this.length = 0;\n      }, e;\n    }(Array);\n\n    e.Stage = i;\n  }($a || ($a = {})), X = $a || ($a = {}), j = function () {\n    function e() {\n      this.rootNodes = new Array(), this.cameras = new Array(), this.lights = new Array(), this.meshes = new Array(), this.skeletons = new Array(), this.particleSystems = new Array(), this.animations = [], this.animationGroups = new Array(), this.multiMaterials = new Array(), this.materials = new Array(), this.morphTargetManagers = new Array(), this.geometries = new Array(), this.transformNodes = new Array(), this.actionManagers = new Array(), this.textures = new Array();\n    }\n\n    return e.AddParser = function (e, t) {\n      this._BabylonFileParsers[e] = t;\n    }, e.GetParser = function (e) {\n      return this._BabylonFileParsers[e] ? this._BabylonFileParsers[e] : null;\n    }, e.AddIndividualParser = function (e, t) {\n      this._IndividualBabylonFileParsers[e] = t;\n    }, e.GetIndividualParser = function (e) {\n      return this._IndividualBabylonFileParsers[e] ? this._IndividualBabylonFileParsers[e] : null;\n    }, e.Parse = function (e, t, i, r) {\n      for (var n in this._BabylonFileParsers) this._BabylonFileParsers.hasOwnProperty(n) && this._BabylonFileParsers[n](e, t, i, r);\n    }, e._BabylonFileParsers = {}, e._IndividualBabylonFileParsers = {}, e;\n  }(), X.AbstractScene = j, function (x) {\n    var u = function () {\n      function e() {\n        this._singleClick = !1, this._doubleClick = !1, this._hasSwiped = !1, this._ignore = !1;\n      }\n\n      return Object.defineProperty(e.prototype, \"singleClick\", {\n        get: function () {\n          return this._singleClick;\n        },\n        set: function (e) {\n          this._singleClick = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"doubleClick\", {\n        get: function () {\n          return this._doubleClick;\n        },\n        set: function (e) {\n          this._doubleClick = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"hasSwiped\", {\n        get: function () {\n          return this._hasSwiped;\n        },\n        set: function (e) {\n          this._hasSwiped = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"ignore\", {\n        get: function () {\n          return this._ignore;\n        },\n        set: function (e) {\n          this._ignore = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e;\n    }(),\n        e = function () {};\n\n    x.RenderingGroupInfo = e;\n\n    var t = function (i) {\n      function E(e) {\n        var t = i.call(this) || this;\n        return t.autoClear = !0, t.autoClearDepthAndStencil = !0, t.clearColor = new x.Color4(.2, .2, .3, 1), t.ambientColor = new x.Color3(0, 0, 0), t._forceWireframe = !1, t._forcePointsCloud = !1, t.animationsEnabled = !0, t._animationPropertiesOverride = null, t.useConstantAnimationDeltaTime = !1, t.constantlyUpdateMeshUnderPointer = !1, t.hoverCursor = \"pointer\", t.defaultCursor = \"\", t.preventDefaultOnPointerDown = !0, t.metadata = null, t.disableOfflineSupportExceptionRules = new Array(), t.onDisposeObservable = new x.Observable(), t._onDisposeObserver = null, t.onBeforeRenderObservable = new x.Observable(), t._onBeforeRenderObserver = null, t.onAfterRenderObservable = new x.Observable(), t._onAfterRenderObserver = null, t.onBeforeAnimationsObservable = new x.Observable(), t.onAfterAnimationsObservable = new x.Observable(), t.onBeforeDrawPhaseObservable = new x.Observable(), t.onAfterDrawPhaseObservable = new x.Observable(), t.onReadyObservable = new x.Observable(), t.onBeforeCameraRenderObservable = new x.Observable(), t._onBeforeCameraRenderObserver = null, t.onAfterCameraRenderObservable = new x.Observable(), t._onAfterCameraRenderObserver = null, t.onBeforeActiveMeshesEvaluationObservable = new x.Observable(), t.onAfterActiveMeshesEvaluationObservable = new x.Observable(), t.onBeforeParticlesRenderingObservable = new x.Observable(), t.onAfterParticlesRenderingObservable = new x.Observable(), t.onDataLoadedObservable = new x.Observable(), t.onNewCameraAddedObservable = new x.Observable(), t.onCameraRemovedObservable = new x.Observable(), t.onNewLightAddedObservable = new x.Observable(), t.onLightRemovedObservable = new x.Observable(), t.onNewGeometryAddedObservable = new x.Observable(), t.onGeometryRemovedObservable = new x.Observable(), t.onNewTransformNodeAddedObservable = new x.Observable(), t.onTransformNodeRemovedObservable = new x.Observable(), t.onNewMeshAddedObservable = new x.Observable(), t.onMeshRemovedObservable = new x.Observable(), t.onNewMaterialAddedObservable = new x.Observable(), t.onMaterialRemovedObservable = new x.Observable(), t.onNewTextureAddedObservable = new x.Observable(), t.onTextureRemovedObservable = new x.Observable(), t.onBeforeRenderTargetsRenderObservable = new x.Observable(), t.onAfterRenderTargetsRenderObservable = new x.Observable(), t.onBeforeStepObservable = new x.Observable(), t.onAfterStepObservable = new x.Observable(), t.onBeforeRenderingGroupObservable = new x.Observable(), t.onAfterRenderingGroupObservable = new x.Observable(), t.onMeshImportedObservable = new x.Observable(), t._registeredForLateAnimationBindings = new x.SmartArrayNoDuplicate(256), t.onPrePointerObservable = new x.Observable(), t.onPointerObservable = new x.Observable(), t._meshPickProceed = !1, t._currentPickResult = null, t._previousPickResult = null, t._totalPointersPressed = 0, t._doubleClickOccured = !1, t.cameraToUseForPointers = null, t._pointerX = 0, t._pointerY = 0, t._startingPointerPosition = new x.Vector2(0, 0), t._previousStartingPointerPosition = new x.Vector2(0, 0), t._startingPointerTime = 0, t._previousStartingPointerTime = 0, t._pointerCaptures = {}, t._timeAccumulator = 0, t._currentStepId = 0, t._currentInternalStep = 0, t.onPreKeyboardObservable = new x.Observable(), t.onKeyboardObservable = new x.Observable(), t._useRightHandedSystem = !1, t._fogEnabled = !0, t._fogMode = E.FOGMODE_NONE, t.fogColor = new x.Color3(.2, .2, .3), t.fogDensity = .1, t.fogStart = 0, t.fogEnd = 1e3, t._shadowsEnabled = !0, t._lightsEnabled = !0, t.activeCameras = new Array(), t._texturesEnabled = !0, t.particlesEnabled = !0, t.spritesEnabled = !0, t._skeletonsEnabled = !0, t.lensFlaresEnabled = !0, t.collisionsEnabled = !0, t.gravity = new x.Vector3(0, -9.807, 0), t.postProcessesEnabled = !0, t.postProcesses = new Array(), t.renderTargetsEnabled = !0, t.dumpNextRenderTargets = !1, t.customRenderTargets = new Array(), t.importedMeshesFiles = new Array(), t.probesEnabled = !0, t._meshesForIntersections = new x.SmartArrayNoDuplicate(256), t.proceduralTexturesEnabled = !0, t._totalVertices = new x.PerfCounter(), t._activeIndices = new x.PerfCounter(), t._activeParticles = new x.PerfCounter(), t._activeBones = new x.PerfCounter(), t._animationTime = 0, t.animationTimeScale = 1, t._renderId = 0, t._frameId = 0, t._executeWhenReadyTimeoutId = -1, t._intermediateRendering = !1, t._viewUpdateFlag = -1, t._projectionUpdateFlag = -1, t._alternateViewUpdateFlag = -1, t._alternateProjectionUpdateFlag = -1, t._toBeDisposed = new Array(256), t._activeRequests = new Array(), t._pendingData = new Array(), t._isDisposed = !1, t.dispatchAllSubMeshesOfActiveMeshes = !1, t._activeMeshes = new x.SmartArray(256), t._processedMaterials = new x.SmartArray(256), t._renderTargets = new x.SmartArrayNoDuplicate(256), t._activeParticleSystems = new x.SmartArray(256), t._activeSkeletons = new x.SmartArrayNoDuplicate(32), t._softwareSkinnedMeshes = new x.SmartArrayNoDuplicate(32), t._activeAnimatables = new Array(), t._transformMatrix = x.Matrix.Zero(), t._useAlternateCameraConfiguration = !1, t._alternateRendering = !1, t.requireLightSorting = !1, t._components = [], t._serializableComponents = [], t._transientComponents = [], t._beforeCameraUpdateStage = x.Stage.Create(), t._beforeClearStage = x.Stage.Create(), t._gatherRenderTargetsStage = x.Stage.Create(), t._gatherActiveCameraRenderTargetsStage = x.Stage.Create(), t._isReadyForMeshStage = x.Stage.Create(), t._beforeEvaluateActiveMeshStage = x.Stage.Create(), t._evaluateSubMeshStage = x.Stage.Create(), t._activeMeshStage = x.Stage.Create(), t._cameraDrawRenderTargetStage = x.Stage.Create(), t._beforeCameraDrawStage = x.Stage.Create(), t._beforeRenderingGroupDrawStage = x.Stage.Create(), t._beforeRenderingMeshStage = x.Stage.Create(), t._afterRenderingMeshStage = x.Stage.Create(), t._afterRenderingGroupDrawStage = x.Stage.Create(), t._afterCameraDrawStage = x.Stage.Create(), t._afterRenderStage = x.Stage.Create(), t._pointerMoveStage = x.Stage.Create(), t._pointerDownStage = x.Stage.Create(), t._pointerUpStage = x.Stage.Create(), t._defaultMeshCandidates = {\n          data: [],\n          length: 0\n        }, t._defaultSubMeshCandidates = {\n          data: [],\n          length: 0\n        }, t._activeMeshesFrozen = !1, t._allowPostProcessClearColor = !0, t.getDeterministicFrameTime = function () {\n          return 1e3 / 60;\n        }, t._tempPickingRay = x.Ray ? x.Ray.Zero() : null, t._blockMaterialDirtyMechanism = !1, t._engine = e || x.Engine.LastCreatedEngine, t._engine.scenes.push(t), t._uid = null, t._renderingManager = new x.RenderingManager(t), x.PostProcessManager && (t.postProcessManager = new x.PostProcessManager(t)), x.Tools.IsWindowObjectExist() && t.attachControl(), t.workerCollisions = !1, t._createUbo(), x.ImageProcessingConfiguration && (t._imageProcessingConfiguration = new x.ImageProcessingConfiguration()), t.setDefaultCandidateProviders(), t;\n      }\n\n      return T(E, i), Object.defineProperty(E.prototype, \"environmentTexture\", {\n        get: function () {\n          return this._environmentTexture;\n        },\n        set: function (e) {\n          this._environmentTexture !== e && (this._environmentTexture = e, this.markAllMaterialsAsDirty(x.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"imageProcessingConfiguration\", {\n        get: function () {\n          return this._imageProcessingConfiguration;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"forceWireframe\", {\n        get: function () {\n          return this._forceWireframe;\n        },\n        set: function (e) {\n          this._forceWireframe !== e && (this._forceWireframe = e, this.markAllMaterialsAsDirty(x.Material.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"forcePointsCloud\", {\n        get: function () {\n          return this._forcePointsCloud;\n        },\n        set: function (e) {\n          this._forcePointsCloud !== e && (this._forcePointsCloud = e, this.markAllMaterialsAsDirty(x.Material.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"animationPropertiesOverride\", {\n        get: function () {\n          return this._animationPropertiesOverride;\n        },\n        set: function (e) {\n          this._animationPropertiesOverride = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"onDispose\", {\n        set: function (e) {\n          this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"beforeRender\", {\n        set: function (e) {\n          this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), e && (this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"afterRender\", {\n        set: function (e) {\n          this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), e && (this._onAfterRenderObserver = this.onAfterRenderObservable.add(e));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"beforeCameraRender\", {\n        set: function (e) {\n          this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"afterCameraRender\", {\n        set: function (e) {\n          this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"unTranslatedPointer\", {\n        get: function () {\n          return new x.Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"useRightHandedSystem\", {\n        get: function () {\n          return this._useRightHandedSystem;\n        },\n        set: function (e) {\n          this._useRightHandedSystem !== e && (this._useRightHandedSystem = e, this.markAllMaterialsAsDirty(x.Material.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.setStepId = function (e) {\n        this._currentStepId = e;\n      }, E.prototype.getStepId = function () {\n        return this._currentStepId;\n      }, E.prototype.getInternalStep = function () {\n        return this._currentInternalStep;\n      }, Object.defineProperty(E.prototype, \"fogEnabled\", {\n        get: function () {\n          return this._fogEnabled;\n        },\n        set: function (e) {\n          this._fogEnabled !== e && (this._fogEnabled = e, this.markAllMaterialsAsDirty(x.Material.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"fogMode\", {\n        get: function () {\n          return this._fogMode;\n        },\n        set: function (e) {\n          this._fogMode !== e && (this._fogMode = e, this.markAllMaterialsAsDirty(x.Material.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"shadowsEnabled\", {\n        get: function () {\n          return this._shadowsEnabled;\n        },\n        set: function (e) {\n          this._shadowsEnabled !== e && (this._shadowsEnabled = e, this.markAllMaterialsAsDirty(x.Material.LightDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"lightsEnabled\", {\n        get: function () {\n          return this._lightsEnabled;\n        },\n        set: function (e) {\n          this._lightsEnabled !== e && (this._lightsEnabled = e, this.markAllMaterialsAsDirty(x.Material.LightDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"defaultMaterial\", {\n        get: function () {\n          return this._defaultMaterial || (this._defaultMaterial = new x.StandardMaterial(\"default material\", this)), this._defaultMaterial;\n        },\n        set: function (e) {\n          this._defaultMaterial = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"texturesEnabled\", {\n        get: function () {\n          return this._texturesEnabled;\n        },\n        set: function (e) {\n          this._texturesEnabled !== e && (this._texturesEnabled = e, this.markAllMaterialsAsDirty(x.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"skeletonsEnabled\", {\n        get: function () {\n          return this._skeletonsEnabled;\n        },\n        set: function (e) {\n          this._skeletonsEnabled !== e && (this._skeletonsEnabled = e, this.markAllMaterialsAsDirty(x.Material.AttributesDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"_isAlternateRenderingEnabled\", {\n        get: function () {\n          return this._alternateRendering;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"frustumPlanes\", {\n        get: function () {\n          return this._frustumPlanes;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype._registerTransientComponents = function () {\n        if (0 < this._transientComponents.length) {\n          for (var e = 0, t = this._transientComponents; e < t.length; e++) {\n            t[e].register();\n          }\n\n          this._transientComponents = [];\n        }\n      }, E.prototype._addComponent = function (e) {\n        this._components.push(e), this._transientComponents.push(e);\n        var t = e;\n        t.addFromContainer && this._serializableComponents.push(t);\n      }, E.prototype._getComponent = function (e) {\n        for (var t = 0, i = this._components; t < i.length; t++) {\n          var r = i[t];\n          if (r.name === e) return r;\n        }\n\n        return null;\n      }, E.prototype._getDefaultMeshCandidates = function () {\n        return this._defaultMeshCandidates.data = this.meshes, this._defaultMeshCandidates.length = this.meshes.length, this._defaultMeshCandidates;\n      }, E.prototype._getDefaultSubMeshCandidates = function (e) {\n        return this._defaultSubMeshCandidates.data = e.subMeshes, this._defaultSubMeshCandidates.length = e.subMeshes.length, this._defaultSubMeshCandidates;\n      }, E.prototype.setDefaultCandidateProviders = function () {\n        this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this), this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n      }, Object.defineProperty(E.prototype, \"workerCollisions\", {\n        get: function () {\n          return this._workerCollisions;\n        },\n        set: function (e) {\n          x.CollisionCoordinatorLegacy && (e = e && !!Worker && !!x.CollisionWorker, this._workerCollisions = e, this.collisionCoordinator && this.collisionCoordinator.destroy(), this.collisionCoordinator = e ? new x.CollisionCoordinatorWorker() : new x.CollisionCoordinatorLegacy(), this.collisionCoordinator.init(this));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"meshUnderPointer\", {\n        get: function () {\n          return this._pointerOverMesh;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"pointerX\", {\n        get: function () {\n          return this._pointerX;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(E.prototype, \"pointerY\", {\n        get: function () {\n          return this._pointerY;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getCachedMaterial = function () {\n        return this._cachedMaterial;\n      }, E.prototype.getCachedEffect = function () {\n        return this._cachedEffect;\n      }, E.prototype.getCachedVisibility = function () {\n        return this._cachedVisibility;\n      }, E.prototype.isCachedMaterialInvalid = function (e, t, i) {\n        return void 0 === i && (i = 1), this._cachedEffect !== t || this._cachedMaterial !== e || this._cachedVisibility !== i;\n      }, E.prototype.getEngine = function () {\n        return this._engine;\n      }, E.prototype.getTotalVertices = function () {\n        return this._totalVertices.current;\n      }, Object.defineProperty(E.prototype, \"totalVerticesPerfCounter\", {\n        get: function () {\n          return this._totalVertices;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getActiveIndices = function () {\n        return this._activeIndices.current;\n      }, Object.defineProperty(E.prototype, \"totalActiveIndicesPerfCounter\", {\n        get: function () {\n          return this._activeIndices;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getActiveParticles = function () {\n        return this._activeParticles.current;\n      }, Object.defineProperty(E.prototype, \"activeParticlesPerfCounter\", {\n        get: function () {\n          return this._activeParticles;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getActiveBones = function () {\n        return this._activeBones.current;\n      }, Object.defineProperty(E.prototype, \"activeBonesPerfCounter\", {\n        get: function () {\n          return this._activeBones;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getInterFramePerfCounter = function () {\n        return x.Tools.Warn(\"getInterFramePerfCounter is deprecated. Please use SceneInstrumentation class\"), 0;\n      }, Object.defineProperty(E.prototype, \"interFramePerfCounter\", {\n        get: function () {\n          return x.Tools.Warn(\"interFramePerfCounter is deprecated. Please use SceneInstrumentation class\"), null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getLastFrameDuration = function () {\n        return x.Tools.Warn(\"getLastFrameDuration is deprecated. Please use SceneInstrumentation class\"), 0;\n      }, Object.defineProperty(E.prototype, \"lastFramePerfCounter\", {\n        get: function () {\n          return x.Tools.Warn(\"lastFramePerfCounter is deprecated. Please use SceneInstrumentation class\"), null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getEvaluateActiveMeshesDuration = function () {\n        return x.Tools.Warn(\"getEvaluateActiveMeshesDuration is deprecated. Please use SceneInstrumentation class\"), 0;\n      }, Object.defineProperty(E.prototype, \"evaluateActiveMeshesDurationPerfCounter\", {\n        get: function () {\n          return x.Tools.Warn(\"evaluateActiveMeshesDurationPerfCounter is deprecated. Please use SceneInstrumentation class\"), null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getActiveMeshes = function () {\n        return this._activeMeshes;\n      }, E.prototype.getRenderTargetsDuration = function () {\n        return x.Tools.Warn(\"getRenderTargetsDuration is deprecated. Please use SceneInstrumentation class\"), 0;\n      }, E.prototype.getRenderDuration = function () {\n        return x.Tools.Warn(\"getRenderDuration is deprecated. Please use SceneInstrumentation class\"), 0;\n      }, Object.defineProperty(E.prototype, \"renderDurationPerfCounter\", {\n        get: function () {\n          return x.Tools.Warn(\"renderDurationPerfCounter is deprecated. Please use SceneInstrumentation class\"), null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getParticlesDuration = function () {\n        return x.Tools.Warn(\"getParticlesDuration is deprecated. Please use SceneInstrumentation class\"), 0;\n      }, Object.defineProperty(E.prototype, \"particlesDurationPerfCounter\", {\n        get: function () {\n          return x.Tools.Warn(\"particlesDurationPerfCounter is deprecated. Please use SceneInstrumentation class\"), null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getSpritesDuration = function () {\n        return x.Tools.Warn(\"getSpritesDuration is deprecated. Please use SceneInstrumentation class\"), 0;\n      }, Object.defineProperty(E.prototype, \"spriteDuractionPerfCounter\", {\n        get: function () {\n          return x.Tools.Warn(\"spriteDuractionPerfCounter is deprecated. Please use SceneInstrumentation class\"), null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.getAnimationRatio = function () {\n        return void 0 !== this._animationRatio ? this._animationRatio : 1;\n      }, E.prototype.getRenderId = function () {\n        return this._renderId;\n      }, E.prototype.getFrameId = function () {\n        return this._frameId;\n      }, E.prototype.incrementRenderId = function () {\n        this._renderId++;\n      }, E.prototype._updatePointerPosition = function (e) {\n        var t = this._engine.getRenderingCanvasClientRect();\n\n        t && (this._pointerX = e.clientX - t.left, this._pointerY = e.clientY - t.top, this._unTranslatedPointerX = this._pointerX, this._unTranslatedPointerY = this._pointerY);\n      }, E.prototype._createUbo = function () {\n        this._sceneUbo = new x.UniformBuffer(this._engine, void 0, !0), this._sceneUbo.addUniform(\"viewProjection\", 16), this._sceneUbo.addUniform(\"view\", 16);\n      }, E.prototype._createAlternateUbo = function () {\n        this._alternateSceneUbo = new x.UniformBuffer(this._engine, void 0, !0), this._alternateSceneUbo.addUniform(\"viewProjection\", 16), this._alternateSceneUbo.addUniform(\"view\", 16);\n      }, E.prototype._setRayOnPointerInfo = function (e) {\n        e.pickInfo && (e.pickInfo.ray || (e.pickInfo.ray = this.createPickingRay(e.event.offsetX, e.event.offsetY, x.Matrix.Identity(), this.activeCamera)));\n      }, E.prototype.simulatePointerMove = function (e, t) {\n        var i = new PointerEvent(\"pointermove\", t);\n        return this._checkPrePointerObservable(e, i, x.PointerEventTypes.POINTERMOVE) ? this : this._processPointerMove(e, i);\n      }, E.prototype._processPointerMove = function (e, t) {\n        var i = this._engine.getRenderingCanvas();\n\n        if (!i) return this;\n        i.style.cursor = this.defaultCursor;\n        var r = !!(e && e.hit && e.pickedMesh);\n        r ? (this.setPointerOverMesh(e.pickedMesh), this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.hasPointerTriggers && (this._pointerOverMesh.actionManager.hoverCursor ? i.style.cursor = this._pointerOverMesh.actionManager.hoverCursor : i.style.cursor = this.hoverCursor)) : this.setPointerOverMesh(null);\n\n        for (var n = 0, o = this._pointerMoveStage; n < o.length; n++) {\n          e = o[n].action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, r, i);\n        }\n\n        if (e) {\n          var s = \"mousewheel\" === t.type || \"DOMMouseScroll\" === t.type ? x.PointerEventTypes.POINTERWHEEL : x.PointerEventTypes.POINTERMOVE;\n\n          if (this.onPointerMove && this.onPointerMove(t, e, s), this.onPointerObservable.hasObservers()) {\n            var a = new x.PointerInfo(s, t, e);\n            this._setRayOnPointerInfo(a), this.onPointerObservable.notifyObservers(a, s);\n          }\n        }\n\n        return this;\n      }, E.prototype._checkPrePointerObservable = function (e, t, i) {\n        var r = new x.PointerInfoPre(i, t, this._unTranslatedPointerX, this._unTranslatedPointerY);\n        return e && (r.ray = e.ray), this.onPrePointerObservable.notifyObservers(r, i), !!r.skipOnPointerObservable;\n      }, E.prototype.simulatePointerDown = function (e, t) {\n        var i = new PointerEvent(\"pointerdown\", t);\n        return this._checkPrePointerObservable(e, i, x.PointerEventTypes.POINTERDOWN) ? this : this._processPointerDown(e, i);\n      }, E.prototype._processPointerDown = function (e, t) {\n        var i = this;\n\n        if (e && e.hit && e.pickedMesh) {\n          this._pickedDownMesh = e.pickedMesh;\n          var r = e.pickedMesh.actionManager;\n\n          if (r) {\n            if (r.hasPickTriggers) switch (r.processTrigger(x.ActionManager.OnPickDownTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t)), t.button) {\n              case 0:\n                r.processTrigger(x.ActionManager.OnLeftPickTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t));\n                break;\n\n              case 1:\n                r.processTrigger(x.ActionManager.OnCenterPickTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t));\n                break;\n\n              case 2:\n                r.processTrigger(x.ActionManager.OnRightPickTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t));\n            }\n            r.hasSpecificTrigger(x.ActionManager.OnLongPressTrigger) && window.setTimeout(function () {\n              var e = i.pick(i._unTranslatedPointerX, i._unTranslatedPointerY, function (e) {\n                return e.isPickable && e.isVisible && e.isReady() && e.actionManager && e.actionManager.hasSpecificTrigger(x.ActionManager.OnLongPressTrigger) && e == i._pickedDownMesh;\n              }, !1, i.cameraToUseForPointers);\n              e && e.hit && e.pickedMesh && r && 0 !== i._totalPointersPressed && Date.now() - i._startingPointerTime > E.LongPressDelay && !i._isPointerSwiping() && (i._startingPointerTime = 0, r.processTrigger(x.ActionManager.OnLongPressTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t)));\n            }, E.LongPressDelay);\n          }\n        } else for (var n = 0, o = this._pointerDownStage; n < o.length; n++) {\n          e = o[n].action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t);\n        }\n\n        if (e) {\n          var s = x.PointerEventTypes.POINTERDOWN;\n\n          if (this.onPointerDown && this.onPointerDown(t, e, s), this.onPointerObservable.hasObservers()) {\n            var a = new x.PointerInfo(s, t, e);\n            this._setRayOnPointerInfo(a), this.onPointerObservable.notifyObservers(a, s);\n          }\n        }\n\n        return this;\n      }, E.prototype.simulatePointerUp = function (e, t) {\n        var i = new PointerEvent(\"pointerup\", t),\n            r = new u();\n        return r.singleClick = !0, r.ignore = !0, this._checkPrePointerObservable(e, i, x.PointerEventTypes.POINTERUP) ? this : this._processPointerUp(e, i, r);\n      }, E.prototype._processPointerUp = function (e, t, i) {\n        if (e && e && e.pickedMesh) {\n          if (this._pickedUpMesh = e.pickedMesh, this._pickedDownMesh === this._pickedUpMesh && (this.onPointerPick && this.onPointerPick(t, e), i.singleClick && !i.ignore && this.onPointerObservable.hasObservers())) {\n            var r = x.PointerEventTypes.POINTERPICK,\n                n = new x.PointerInfo(r, t, e);\n            this._setRayOnPointerInfo(n), this.onPointerObservable.notifyObservers(n, r);\n          }\n\n          e.pickedMesh.actionManager && (i.ignore && e.pickedMesh.actionManager.processTrigger(x.ActionManager.OnPickUpTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t)), i.hasSwiped || i.ignore || !i.singleClick || e.pickedMesh.actionManager.processTrigger(x.ActionManager.OnPickTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t)), i.doubleClick && !i.ignore && e.pickedMesh.actionManager.hasSpecificTrigger(x.ActionManager.OnDoublePickTrigger) && e.pickedMesh.actionManager.processTrigger(x.ActionManager.OnDoublePickTrigger, x.ActionEvent.CreateNew(e.pickedMesh, t)));\n        } else if (!i.ignore) for (var o = 0, s = this._pointerUpStage; o < s.length; o++) {\n          e = s[o].action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t);\n        }\n\n        this._pickedDownMesh && this._pickedDownMesh.actionManager && this._pickedDownMesh.actionManager.hasSpecificTrigger(x.ActionManager.OnPickOutTrigger) && this._pickedDownMesh !== this._pickedUpMesh && this._pickedDownMesh.actionManager.processTrigger(x.ActionManager.OnPickOutTrigger, x.ActionEvent.CreateNew(this._pickedDownMesh, t));\n        var a = x.PointerEventTypes.POINTERUP;\n        if (this.onPointerObservable.hasObservers()) if (i.ignore) {\n          n = new x.PointerInfo(a, t, e);\n          this._setRayOnPointerInfo(n), this.onPointerObservable.notifyObservers(n, a);\n        } else if (!i.hasSwiped) {\n          if (i.singleClick && this.onPointerObservable.hasSpecificMask(x.PointerEventTypes.POINTERTAP)) {\n            var l = x.PointerEventTypes.POINTERTAP,\n                n = new x.PointerInfo(l, t, e);\n            this._setRayOnPointerInfo(n), this.onPointerObservable.notifyObservers(n, l);\n          }\n\n          if (i.doubleClick && this.onPointerObservable.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP)) {\n            var c = x.PointerEventTypes.POINTERDOUBLETAP;\n            n = new x.PointerInfo(c, t, e);\n            this._setRayOnPointerInfo(n), this.onPointerObservable.notifyObservers(n, c);\n          }\n        }\n        return this.onPointerUp && this.onPointerUp(t, e, a), this;\n      }, E.prototype.isPointerCaptured = function (e) {\n        return void 0 === e && (e = 0), this._pointerCaptures[e];\n      }, E.prototype._isPointerSwiping = function () {\n        return Math.abs(this._startingPointerPosition.x - this._pointerX) > E.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > E.DragMovementThreshold;\n      }, E.prototype.attachControl = function (e, t, i) {\n        var h = this;\n        void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === i && (i = !0), this._initActionManager = function (e, t) {\n          if (!h._meshPickProceed) {\n            var i = h.pick(h._unTranslatedPointerX, h._unTranslatedPointerY, h.pointerDownPredicate, !1, h.cameraToUseForPointers);\n            (h._currentPickResult = i) && (e = i.hit && i.pickedMesh ? i.pickedMesh.actionManager : null), h._meshPickProceed = !0;\n          }\n\n          return e;\n        }, this._delayedSimpleClick = function (e, t, i) {\n          (Date.now() - h._previousStartingPointerTime > E.DoubleClickDelay && !h._doubleClickOccured || e !== h._previousButtonPressed) && (h._doubleClickOccured = !1, t.singleClick = !0, t.ignore = !1, i(t, h._currentPickResult));\n        }, this._initClickEvent = function (e, t, i, r) {\n          var n = new u(),\n              o = h._currentPickResult = null,\n              s = e.hasSpecificMask(x.PointerEventTypes.POINTERPICK) || t.hasSpecificMask(x.PointerEventTypes.POINTERPICK) || e.hasSpecificMask(x.PointerEventTypes.POINTERTAP) || t.hasSpecificMask(x.PointerEventTypes.POINTERTAP) || e.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP) || t.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP);\n\n          if (!s && x.ActionManager && x.ActionManager.HasPickTriggers && (o = h._initActionManager(o, n)) && (s = o.hasPickTriggers), s) {\n            var a = i.button;\n\n            if (n.hasSwiped = h._isPointerSwiping(), !n.hasSwiped) {\n              var l = !E.ExclusiveDoubleClickMode;\n              l || (l = !e.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP) && !t.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP)) && !x.ActionManager.HasSpecificTrigger(x.ActionManager.OnDoublePickTrigger) && (o = h._initActionManager(o, n)) && (l = !o.hasSpecificTrigger(x.ActionManager.OnDoublePickTrigger)), l ? (Date.now() - h._previousStartingPointerTime > E.DoubleClickDelay || a !== h._previousButtonPressed) && (n.singleClick = !0, r(n, h._currentPickResult)) : (h._previousDelayedSimpleClickTimeout = h._delayedSimpleClickTimeout, h._delayedSimpleClickTimeout = window.setTimeout(h._delayedSimpleClick.bind(h, a, n, r), E.DoubleClickDelay));\n              var c = e.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP) || t.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP);\n              !c && x.ActionManager.HasSpecificTrigger(x.ActionManager.OnDoublePickTrigger) && (o = h._initActionManager(o, n)) && (c = o.hasSpecificTrigger(x.ActionManager.OnDoublePickTrigger)), c && (a === h._previousButtonPressed && Date.now() - h._previousStartingPointerTime < E.DoubleClickDelay && !h._doubleClickOccured ? n.hasSwiped || h._isPointerSwiping() ? (h._doubleClickOccured = !1, h._previousStartingPointerTime = h._startingPointerTime, h._previousStartingPointerPosition.x = h._startingPointerPosition.x, h._previousStartingPointerPosition.y = h._startingPointerPosition.y, h._previousButtonPressed = a, E.ExclusiveDoubleClickMode ? (h._previousDelayedSimpleClickTimeout && clearTimeout(h._previousDelayedSimpleClickTimeout), h._previousDelayedSimpleClickTimeout = h._delayedSimpleClickTimeout, r(n, h._previousPickResult)) : r(n, h._currentPickResult)) : (h._previousStartingPointerTime = 0, h._doubleClickOccured = !0, n.doubleClick = !0, n.ignore = !1, E.ExclusiveDoubleClickMode && h._previousDelayedSimpleClickTimeout && clearTimeout(h._previousDelayedSimpleClickTimeout), h._previousDelayedSimpleClickTimeout = h._delayedSimpleClickTimeout, r(n, h._currentPickResult)) : (h._doubleClickOccured = !1, h._previousStartingPointerTime = h._startingPointerTime, h._previousStartingPointerPosition.x = h._startingPointerPosition.x, h._previousStartingPointerPosition.y = h._startingPointerPosition.y, h._previousButtonPressed = a));\n            }\n          }\n\n          n.ignore = !0, r(n, h._currentPickResult);\n        }, this._onPointerMove = function (e) {\n          if (h._updatePointerPosition(e), !h._checkPrePointerObservable(null, e, \"mousewheel\" === e.type || \"DOMMouseScroll\" === e.type ? x.PointerEventTypes.POINTERWHEEL : x.PointerEventTypes.POINTERMOVE) && (h.cameraToUseForPointers || h.activeCamera)) {\n            h.pointerMovePredicate || (h.pointerMovePredicate = function (e) {\n              return e.isPickable && e.isVisible && e.isReady() && e.isEnabled() && (e.enablePointerMoveEvents || h.constantlyUpdateMeshUnderPointer || null !== e.actionManager && void 0 !== e.actionManager);\n            });\n            var t = h.pick(h._unTranslatedPointerX, h._unTranslatedPointerY, h.pointerMovePredicate, !1, h.cameraToUseForPointers);\n\n            h._processPointerMove(t, e);\n          }\n        }, this._onPointerDown = function (e) {\n          if (h._totalPointersPressed++, h._pickedDownMesh = null, h._meshPickProceed = !1, h._updatePointerPosition(e), h.preventDefaultOnPointerDown && o && (e.preventDefault(), o.focus()), !h._checkPrePointerObservable(null, e, x.PointerEventTypes.POINTERDOWN) && (h.cameraToUseForPointers || h.activeCamera)) {\n            h._pointerCaptures[e.pointerId] = !0, h._startingPointerPosition.x = h._pointerX, h._startingPointerPosition.y = h._pointerY, h._startingPointerTime = Date.now(), h.pointerDownPredicate || (h.pointerDownPredicate = function (e) {\n              return e.isPickable && e.isVisible && e.isReady() && e.isEnabled();\n            }), h._pickedDownMesh = null;\n            var t = h.pick(h._unTranslatedPointerX, h._unTranslatedPointerY, h.pointerDownPredicate, !1, h.cameraToUseForPointers);\n\n            h._processPointerDown(t, e);\n          }\n        }, this._onPointerUp = function (i) {\n          0 !== h._totalPointersPressed && (h._totalPointersPressed--, h._pickedUpMesh = null, h._meshPickProceed = !1, h._updatePointerPosition(i), h._initClickEvent(h.onPrePointerObservable, h.onPointerObservable, i, function (e, t) {\n            if (h.onPrePointerObservable.hasObservers()) if (e.ignore) {\n              if (h._checkPrePointerObservable(null, i, x.PointerEventTypes.POINTERUP)) return;\n            } else if (!e.hasSwiped) {\n              if (e.singleClick && h.onPrePointerObservable.hasSpecificMask(x.PointerEventTypes.POINTERTAP) && h._checkPrePointerObservable(null, i, x.PointerEventTypes.POINTERTAP)) return;\n              if (e.doubleClick && h.onPrePointerObservable.hasSpecificMask(x.PointerEventTypes.POINTERDOUBLETAP) && h._checkPrePointerObservable(null, i, x.PointerEventTypes.POINTERDOUBLETAP)) return;\n            }\n            (h.cameraToUseForPointers || h.activeCamera) && (h._pointerCaptures[i.pointerId] = !1, h.pointerUpPredicate || (h.pointerUpPredicate = function (e) {\n              return e.isPickable && e.isVisible && e.isReady() && e.isEnabled();\n            }), !h._meshPickProceed && (x.ActionManager && x.ActionManager.HasTriggers || h.onPointerObservable.hasObservers()) && h._initActionManager(null, e), t || (t = h._currentPickResult), h._processPointerUp(t, i, e), h._previousPickResult = h._currentPickResult);\n          }));\n        }, this._onKeyDown = function (e) {\n          var t = x.KeyboardEventTypes.KEYDOWN;\n\n          if (h.onPreKeyboardObservable.hasObservers()) {\n            var i = new x.KeyboardInfoPre(t, e);\n            if (h.onPreKeyboardObservable.notifyObservers(i, t), i.skipOnPointerObservable) return;\n          }\n\n          if (h.onKeyboardObservable.hasObservers()) {\n            i = new x.KeyboardInfo(t, e);\n            h.onKeyboardObservable.notifyObservers(i, t);\n          }\n\n          h.actionManager && h.actionManager.processTrigger(x.ActionManager.OnKeyDownTrigger, x.ActionEvent.CreateNewFromScene(h, e));\n        }, this._onKeyUp = function (e) {\n          var t = x.KeyboardEventTypes.KEYUP;\n\n          if (h.onPreKeyboardObservable.hasObservers()) {\n            var i = new x.KeyboardInfoPre(t, e);\n            if (h.onPreKeyboardObservable.notifyObservers(i, t), i.skipOnPointerObservable) return;\n          }\n\n          if (h.onKeyboardObservable.hasObservers()) {\n            i = new x.KeyboardInfo(t, e);\n            h.onKeyboardObservable.notifyObservers(i, t);\n          }\n\n          h.actionManager && h.actionManager.processTrigger(x.ActionManager.OnKeyUpTrigger, x.ActionEvent.CreateNewFromScene(h, e));\n        };\n        var r = this.getEngine();\n        this._onCanvasFocusObserver = r.onCanvasFocusObservable.add(function () {\n          o && (o.addEventListener(\"keydown\", h._onKeyDown, !1), o.addEventListener(\"keyup\", h._onKeyUp, !1));\n        }), this._onCanvasBlurObserver = r.onCanvasBlurObservable.add(function () {\n          o && (o.removeEventListener(\"keydown\", h._onKeyDown), o.removeEventListener(\"keyup\", h._onKeyUp));\n        });\n\n        var n = x.Tools.GetPointerPrefix(),\n            o = this._engine.getRenderingCanvas();\n\n        o && (i && (o.addEventListener(n + \"move\", this._onPointerMove, !1), o.addEventListener(\"mousewheel\", this._onPointerMove, !1), o.addEventListener(\"DOMMouseScroll\", this._onPointerMove, !1)), t && o.addEventListener(n + \"down\", this._onPointerDown, !1), e && window.addEventListener(n + \"up\", this._onPointerUp, !1), o.tabIndex = 1);\n      }, E.prototype.detachControl = function () {\n        var e = this.getEngine(),\n            t = x.Tools.GetPointerPrefix(),\n            i = e.getRenderingCanvas();\n        i && (i.removeEventListener(t + \"move\", this._onPointerMove), i.removeEventListener(t + \"down\", this._onPointerDown), window.removeEventListener(t + \"up\", this._onPointerUp), this._onCanvasBlurObserver && e.onCanvasBlurObservable.remove(this._onCanvasBlurObserver), this._onCanvasFocusObserver && e.onCanvasFocusObservable.remove(this._onCanvasFocusObserver), i.removeEventListener(\"mousewheel\", this._onPointerMove), i.removeEventListener(\"DOMMouseScroll\", this._onPointerMove), i.removeEventListener(\"keydown\", this._onKeyDown), i.removeEventListener(\"keyup\", this._onKeyUp), this.onKeyboardObservable.clear(), this.onPreKeyboardObservable.clear(), this.onPointerObservable.clear(), this.onPrePointerObservable.clear());\n      }, E.prototype.isReady = function () {\n        if (this._isDisposed) return !1;\n        if (0 < this._pendingData.length) return !1;\n        var e,\n            t = this.getEngine();\n\n        for (e = 0; e < this.geometries.length; e++) {\n          if (this.geometries[e].delayLoadState === x.Engine.DELAYLOADSTATE_LOADING) return !1;\n        }\n\n        for (e = 0; e < this.meshes.length; e++) {\n          var i = this.meshes[e];\n\n          if (i.isEnabled() && i.subMeshes && 0 !== i.subMeshes.length) {\n            if (!i.isReady(!0)) return !1;\n\n            for (var r = \"InstancedMesh\" === i.getClassName() || t.getCaps().instancedArrays && 0 < i.instances.length, n = 0, o = this._isReadyForMeshStage; n < o.length; n++) {\n              if (!o[n].action(i, r)) return !1;\n            }\n          }\n        }\n\n        if (this.activeCameras && 0 < this.activeCameras.length) for (var s = 0, a = this.activeCameras; s < a.length; s++) {\n          if (!a[s].isReady(!0)) return !1;\n        } else if (this.activeCamera && !this.activeCamera.isReady(!0)) return !1;\n\n        for (var l = 0, c = this.particleSystems; l < c.length; l++) {\n          if (!c[l].isReady()) return !1;\n        }\n\n        return !0;\n      }, E.prototype.resetCachedMaterial = function () {\n        this._cachedMaterial = null, this._cachedEffect = null, this._cachedVisibility = null;\n      }, E.prototype.registerBeforeRender = function (e) {\n        this.onBeforeRenderObservable.add(e);\n      }, E.prototype.unregisterBeforeRender = function (e) {\n        this.onBeforeRenderObservable.removeCallback(e);\n      }, E.prototype.registerAfterRender = function (e) {\n        this.onAfterRenderObservable.add(e);\n      }, E.prototype.unregisterAfterRender = function (e) {\n        this.onAfterRenderObservable.removeCallback(e);\n      }, E.prototype._executeOnceBeforeRender = function (e) {\n        var t = this,\n            i = function () {\n          e(), setTimeout(function () {\n            t.unregisterBeforeRender(i);\n          });\n        };\n\n        this.registerBeforeRender(i);\n      }, E.prototype.executeOnceBeforeRender = function (e, t) {\n        var i = this;\n        void 0 !== t ? setTimeout(function () {\n          i._executeOnceBeforeRender(e);\n        }, t) : this._executeOnceBeforeRender(e);\n      }, E.prototype._addPendingData = function (e) {\n        this._pendingData.push(e);\n      }, E.prototype._removePendingData = function (e) {\n        var t = this.isLoading,\n            i = this._pendingData.indexOf(e);\n\n        -1 !== i && this._pendingData.splice(i, 1), t && !this.isLoading && this.onDataLoadedObservable.notifyObservers(this);\n      }, E.prototype.getWaitingItemsCount = function () {\n        return this._pendingData.length;\n      }, Object.defineProperty(E.prototype, \"isLoading\", {\n        get: function () {\n          return 0 < this._pendingData.length;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.executeWhenReady = function (e) {\n        var t = this;\n        this.onReadyObservable.add(e), -1 === this._executeWhenReadyTimeoutId && (this._executeWhenReadyTimeoutId = setTimeout(function () {\n          t._checkIsReady();\n        }, 150));\n      }, E.prototype.whenReadyAsync = function () {\n        var t = this;\n        return new Promise(function (e) {\n          t.executeWhenReady(function () {\n            e();\n          });\n        });\n      }, E.prototype._checkIsReady = function () {\n        var e = this;\n        if (this._registerTransientComponents(), this.isReady()) return this.onReadyObservable.notifyObservers(this), this.onReadyObservable.clear(), void (this._executeWhenReadyTimeoutId = -1);\n        this._executeWhenReadyTimeoutId = setTimeout(function () {\n          e._checkIsReady();\n        }, 150);\n      }, E.prototype.beginWeightedAnimation = function (e, t, i, r, n, o, s, a, l) {\n        void 0 === r && (r = 1), void 0 === o && (o = 1);\n        var c = this.beginAnimation(e, t, i, n, o, s, a, !1, l);\n        return c.weight = r, c;\n      }, E.prototype.beginAnimation = function (e, t, i, r, n, o, s, a, l) {\n        void 0 === n && (n = 1), void 0 === a && (a = !0), i < t && 0 < n && (n *= -1), a && this.stopAnimation(e, void 0, l), s || (s = new x.Animatable(this, e, t, i, r, n, o));\n        var c = !l || l(e);\n        if (e.animations && c && s.appendAnimations(e, e.animations), e.getAnimatables) for (var h = e.getAnimatables(), u = 0; u < h.length; u++) this.beginAnimation(h[u], t, i, r, n, o, s, a, l);\n        return s.reset(), s;\n      }, E.prototype.beginDirectAnimation = function (e, t, i, r, n, o, s) {\n        return void 0 === o && (o = 1), new x.Animatable(this, e, i, r, n, o, s, t);\n      }, E.prototype.beginDirectHierarchyAnimation = function (e, t, i, r, n, o, s, a) {\n        var l = e.getDescendants(t),\n            c = [];\n        c.push(this.beginDirectAnimation(e, i, r, n, o, s, a));\n\n        for (var h = 0, u = l; h < u.length; h++) {\n          var d = u[h];\n          c.push(this.beginDirectAnimation(d, i, r, n, o, s, a));\n        }\n\n        return c;\n      }, E.prototype.getAnimatableByTarget = function (e) {\n        for (var t = 0; t < this._activeAnimatables.length; t++) if (this._activeAnimatables[t].target === e) return this._activeAnimatables[t];\n\n        return null;\n      }, E.prototype.getAllAnimatablesByTarget = function (e) {\n        for (var t = [], i = 0; i < this._activeAnimatables.length; i++) this._activeAnimatables[i].target === e && t.push(this._activeAnimatables[i]);\n\n        return t;\n      }, Object.defineProperty(E.prototype, \"animatables\", {\n        get: function () {\n          return this._activeAnimatables;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.stopAnimation = function (e, t, i) {\n        for (var r = 0, n = this.getAllAnimatablesByTarget(e); r < n.length; r++) {\n          n[r].stop(t, i);\n        }\n      }, E.prototype.stopAllAnimations = function () {\n        if (this._activeAnimatables) {\n          for (var e = 0; e < this._activeAnimatables.length; e++) this._activeAnimatables[e].stop();\n\n          this._activeAnimatables = [];\n        }\n\n        for (var t = 0, i = this.animationGroups; t < i.length; t++) {\n          i[t].stop();\n        }\n      }, E.prototype._animate = function () {\n        if (this.animationsEnabled && 0 !== this._activeAnimatables.length) {\n          var e = x.Tools.Now;\n\n          if (!this._animationTimeLast) {\n            if (0 < this._pendingData.length) return;\n            this._animationTimeLast = e;\n          }\n\n          var t = this.useConstantAnimationDeltaTime ? 16 : (e - this._animationTimeLast) * this.animationTimeScale;\n          this._animationTime += t, this._animationTimeLast = e;\n\n          for (var i = 0; i < this._activeAnimatables.length; i++) this._activeAnimatables[i]._animate(this._animationTime);\n\n          this._processLateAnimationBindings();\n        }\n      }, E.prototype._registerTargetForLateAnimationBinding = function (e, t) {\n        var i = e.target;\n        this._registeredForLateAnimationBindings.pushNoDuplicate(i), i._lateAnimationHolders || (i._lateAnimationHolders = {}), i._lateAnimationHolders[e.targetPath] || (i._lateAnimationHolders[e.targetPath] = {\n          totalWeight: 0,\n          animations: [],\n          originalValue: t\n        }), i._lateAnimationHolders[e.targetPath].animations.push(e), i._lateAnimationHolders[e.targetPath].totalWeight += e.weight;\n      }, E.prototype._processLateAnimationBindingsForMatrices = function (e) {\n        var t = 1,\n            i = x.Tmp.Vector3[0],\n            r = x.Tmp.Vector3[1],\n            n = x.Tmp.Quaternion[0],\n            o = 0,\n            s = e.animations[0],\n            a = e.originalValue,\n            l = 1;\n        if (e.totalWeight < 1) a.decompose(r, n, i), l = 1 - e.totalWeight;else if (o = 1, t = e.totalWeight, s.currentValue.decompose(r, n, i), 1 == (l = s.weight / t)) return s.currentValue;\n        r.scaleInPlace(l), i.scaleInPlace(l), n.scaleInPlace(l);\n\n        for (var c = o; c < e.animations.length; c++) {\n          var h = e.animations[c],\n              u = (l = h.weight / t, x.Tmp.Vector3[2]),\n              d = x.Tmp.Vector3[3],\n              f = x.Tmp.Quaternion[1];\n          h.currentValue.decompose(d, f, u), d.scaleAndAddToRef(l, r), f.scaleAndAddToRef(l, n), u.scaleAndAddToRef(l, i);\n        }\n\n        return x.Matrix.ComposeToRef(r, n, i, s._workValue), s._workValue;\n      }, E.prototype._processLateAnimationBindingsForQuaternions = function (e, t) {\n        var i = e.animations[0],\n            r = e.originalValue;\n        if (1 === e.animations.length) return x.Quaternion.SlerpToRef(r, i.currentValue, Math.min(1, e.totalWeight), t), t;\n        var n,\n            o,\n            s = 1;\n\n        if (e.totalWeight < 1) {\n          var a = 1 - e.totalWeight;\n          o = [], (n = []).push(r), o.push(a);\n        } else {\n          if (2 === e.animations.length) return x.Quaternion.SlerpToRef(e.animations[0].currentValue, e.animations[1].currentValue, e.animations[1].weight / e.totalWeight, t), t;\n          n = [], o = [], s = e.totalWeight;\n        }\n\n        for (var l = 0; l < e.animations.length; l++) {\n          var c = e.animations[l];\n          n.push(c.currentValue), o.push(c.weight / s);\n        }\n\n        for (var h = 0, u = null, d = 0; d < n.length;) u ? (h += o[d], x.Quaternion.SlerpToRef(u, n[d], o[d] / h, u), d++) : (x.Quaternion.SlerpToRef(n[d], n[d + 1], o[d + 1] / (o[d] + o[d + 1]), t), u = t, h = o[d] + o[d + 1], d += 2);\n\n        return u;\n      }, E.prototype._processLateAnimationBindings = function () {\n        if (this._registeredForLateAnimationBindings.length) {\n          for (var e = 0; e < this._registeredForLateAnimationBindings.length; e++) {\n            var t = this._registeredForLateAnimationBindings.data[e];\n\n            for (var i in t._lateAnimationHolders) {\n              var r = t._lateAnimationHolders[i],\n                  n = r.animations[0],\n                  o = r.originalValue,\n                  s = x.Animation.AllowMatrixDecomposeForInterpolation && o.m,\n                  a = t[i];\n              if (s) a = this._processLateAnimationBindingsForMatrices(r);else if (void 0 !== o.w) a = this._processLateAnimationBindingsForQuaternions(r, a || x.Quaternion.Identity());else {\n                var l = 0,\n                    c = 1;\n                if (r.totalWeight < 1) a = o.scale ? o.scale(1 - r.totalWeight) : o * (1 - r.totalWeight);else {\n                  c = r.totalWeight;\n                  var h = n.weight / c;\n                  a = 1 !== h ? n.currentValue.scale ? n.currentValue.scale(h) : n.currentValue * h : n.currentValue, l = 1;\n                }\n\n                for (var u = l; u < r.animations.length; u++) {\n                  var d = r.animations[u],\n                      f = d.weight / c;\n                  d.currentValue.scaleAndAddToRef ? d.currentValue.scaleAndAddToRef(f, a) : a += d.currentValue * f;\n                }\n              }\n              t[i] = a;\n            }\n\n            t._lateAnimationHolders = {};\n          }\n\n          this._registeredForLateAnimationBindings.reset();\n        }\n      }, E.prototype._switchToAlternateCameraConfiguration = function (e) {\n        this._useAlternateCameraConfiguration = e;\n      }, E.prototype.getViewMatrix = function () {\n        return this._useAlternateCameraConfiguration ? this._alternateViewMatrix : this._viewMatrix;\n      }, E.prototype.getProjectionMatrix = function () {\n        return this._useAlternateCameraConfiguration ? this._alternateProjectionMatrix : this._projectionMatrix;\n      }, E.prototype.getTransformMatrix = function () {\n        return this._useAlternateCameraConfiguration ? this._alternateTransformMatrix : this._transformMatrix;\n      }, E.prototype.setTransformMatrix = function (e, t) {\n        if (this._viewUpdateFlag !== e.updateFlag || this._projectionUpdateFlag !== t.updateFlag) {\n          if (this._viewUpdateFlag = e.updateFlag, this._projectionUpdateFlag = t.updateFlag, this._viewMatrix = e, this._projectionMatrix = t, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._frustumPlanes ? x.Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = x.Frustum.GetPlanes(this._transformMatrix), this.activeCamera && this.activeCamera._alternateCamera) {\n            var i = this.activeCamera._alternateCamera;\n            i.getViewMatrix().multiplyToRef(i.getProjectionMatrix(), x.Tmp.Matrix[0]), x.Frustum.GetRightPlaneToRef(x.Tmp.Matrix[0], this._frustumPlanes[3]);\n          }\n\n          this._sceneUbo.useUbo && (this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix), this._sceneUbo.updateMatrix(\"view\", this._viewMatrix), this._sceneUbo.update());\n        }\n      }, E.prototype._setAlternateTransformMatrix = function (e, t) {\n        this._alternateViewUpdateFlag === e.updateFlag && this._alternateProjectionUpdateFlag === t.updateFlag || (this._alternateViewUpdateFlag = e.updateFlag, this._alternateProjectionUpdateFlag = t.updateFlag, this._alternateViewMatrix = e, this._alternateProjectionMatrix = t, this._alternateTransformMatrix || (this._alternateTransformMatrix = x.Matrix.Zero()), this._alternateViewMatrix.multiplyToRef(this._alternateProjectionMatrix, this._alternateTransformMatrix), this._alternateSceneUbo || this._createAlternateUbo(), this._alternateSceneUbo.useUbo && (this._alternateSceneUbo.updateMatrix(\"viewProjection\", this._alternateTransformMatrix), this._alternateSceneUbo.updateMatrix(\"view\", this._alternateViewMatrix), this._alternateSceneUbo.update()));\n      }, E.prototype.getSceneUniformBuffer = function () {\n        return this._useAlternateCameraConfiguration ? this._alternateSceneUbo : this._sceneUbo;\n      }, E.prototype.getUniqueId = function () {\n        var e = E._uniqueIdCounter;\n        return E._uniqueIdCounter++, e;\n      }, E.prototype.addMesh = function (e, t) {\n        var i = this;\n        void 0 === t && (t = !1), this.meshes.push(e), this.collisionCoordinator && this.collisionCoordinator.onMeshAdded(e), e._resyncLightSources(), this.onNewMeshAddedObservable.notifyObservers(e), t && e.getChildMeshes().forEach(function (e) {\n          i.addMesh(e);\n        });\n      }, E.prototype.removeMesh = function (e, t) {\n        var i = this;\n        void 0 === t && (t = !1);\n        var r = this.meshes.indexOf(e);\n        return -1 !== r && this.meshes.splice(r, 1), this.onMeshRemovedObservable.notifyObservers(e), t && e.getChildMeshes().forEach(function (e) {\n          i.removeMesh(e);\n        }), r;\n      }, E.prototype.addTransformNode = function (e) {\n        this.transformNodes.push(e), this.onNewTransformNodeAddedObservable.notifyObservers(e);\n      }, E.prototype.removeTransformNode = function (e) {\n        var t = this.transformNodes.indexOf(e);\n        return -1 !== t && this.transformNodes.splice(t, 1), this.onTransformNodeRemovedObservable.notifyObservers(e), t;\n      }, E.prototype.removeSkeleton = function (e) {\n        var t = this.skeletons.indexOf(e);\n        return -1 !== t && this.skeletons.splice(t, 1), t;\n      }, E.prototype.removeMorphTargetManager = function (e) {\n        var t = this.morphTargetManagers.indexOf(e);\n        return -1 !== t && this.morphTargetManagers.splice(t, 1), t;\n      }, E.prototype.removeLight = function (e) {\n        var t = this.lights.indexOf(e);\n\n        if (-1 !== t) {\n          for (var i = 0, r = this.meshes; i < r.length; i++) {\n            r[i]._removeLightSource(e);\n          }\n\n          this.lights.splice(t, 1), this.sortLightsByPriority();\n        }\n\n        return this.onLightRemovedObservable.notifyObservers(e), t;\n      }, E.prototype.removeCamera = function (e) {\n        var t = this.cameras.indexOf(e);\n        -1 !== t && this.cameras.splice(t, 1);\n        var i = this.activeCameras.indexOf(e);\n        return -1 !== i && this.activeCameras.splice(i, 1), this.activeCamera === e && (0 < this.cameras.length ? this.activeCamera = this.cameras[0] : this.activeCamera = null), this.onCameraRemovedObservable.notifyObservers(e), t;\n      }, E.prototype.removeParticleSystem = function (e) {\n        var t = this.particleSystems.indexOf(e);\n        return -1 !== t && this.particleSystems.splice(t, 1), t;\n      }, E.prototype.removeAnimation = function (e) {\n        var t = this.animations.indexOf(e);\n        return -1 !== t && this.animations.splice(t, 1), t;\n      }, E.prototype.removeAnimationGroup = function (e) {\n        var t = this.animationGroups.indexOf(e);\n        return -1 !== t && this.animationGroups.splice(t, 1), t;\n      }, E.prototype.removeMultiMaterial = function (e) {\n        var t = this.multiMaterials.indexOf(e);\n        return -1 !== t && this.multiMaterials.splice(t, 1), t;\n      }, E.prototype.removeMaterial = function (e) {\n        var t = this.materials.indexOf(e);\n        return -1 !== t && this.materials.splice(t, 1), this.onMaterialRemovedObservable.notifyObservers(e), t;\n      }, E.prototype.removeActionManager = function (e) {\n        var t = this.actionManagers.indexOf(e);\n        return -1 !== t && this.actionManagers.splice(t, 1), t;\n      }, E.prototype.removeTexture = function (e) {\n        var t = this.textures.indexOf(e);\n        return -1 !== t && this.textures.splice(t, 1), this.onTextureRemovedObservable.notifyObservers(e), t;\n      }, E.prototype.addLight = function (e) {\n        this.lights.push(e), this.sortLightsByPriority();\n\n        for (var t = 0, i = this.meshes; t < i.length; t++) {\n          var r = i[t];\n          -1 === r._lightSources.indexOf(e) && (r._lightSources.push(e), r._resyncLightSources());\n        }\n\n        this.onNewLightAddedObservable.notifyObservers(e);\n      }, E.prototype.sortLightsByPriority = function () {\n        this.requireLightSorting && this.lights.sort(x.Light.CompareLightsPriority);\n      }, E.prototype.addCamera = function (e) {\n        this.cameras.push(e), this.onNewCameraAddedObservable.notifyObservers(e);\n      }, E.prototype.addSkeleton = function (e) {\n        this.skeletons.push(e);\n      }, E.prototype.addParticleSystem = function (e) {\n        this.particleSystems.push(e);\n      }, E.prototype.addAnimation = function (e) {\n        this.animations.push(e);\n      }, E.prototype.addAnimationGroup = function (e) {\n        this.animationGroups.push(e);\n      }, E.prototype.addMultiMaterial = function (e) {\n        this.multiMaterials.push(e);\n      }, E.prototype.addMaterial = function (e) {\n        this.materials.push(e), this.onNewMaterialAddedObservable.notifyObservers(e);\n      }, E.prototype.addMorphTargetManager = function (e) {\n        this.morphTargetManagers.push(e);\n      }, E.prototype.addGeometry = function (e) {\n        this.geometries.push(e);\n      }, E.prototype.addActionManager = function (e) {\n        this.actionManagers.push(e);\n      }, E.prototype.addTexture = function (e) {\n        this.textures.push(e), this.onNewTextureAddedObservable.notifyObservers(e);\n      }, E.prototype.switchActiveCamera = function (e, t) {\n        void 0 === t && (t = !0);\n\n        var i = this._engine.getRenderingCanvas();\n\n        i && (this.activeCamera && this.activeCamera.detachControl(i), this.activeCamera = e, t && e.attachControl(i));\n      }, E.prototype.setActiveCameraByID = function (e) {\n        var t = this.getCameraByID(e);\n        return t ? this.activeCamera = t : null;\n      }, E.prototype.setActiveCameraByName = function (e) {\n        var t = this.getCameraByName(e);\n        return t ? this.activeCamera = t : null;\n      }, E.prototype.getAnimationGroupByName = function (e) {\n        for (var t = 0; t < this.animationGroups.length; t++) if (this.animationGroups[t].name === e) return this.animationGroups[t];\n\n        return null;\n      }, E.prototype.getMaterialByID = function (e) {\n        for (var t = 0; t < this.materials.length; t++) if (this.materials[t].id === e) return this.materials[t];\n\n        return null;\n      }, E.prototype.getMaterialByName = function (e) {\n        for (var t = 0; t < this.materials.length; t++) if (this.materials[t].name === e) return this.materials[t];\n\n        return null;\n      }, E.prototype.getCameraByID = function (e) {\n        for (var t = 0; t < this.cameras.length; t++) if (this.cameras[t].id === e) return this.cameras[t];\n\n        return null;\n      }, E.prototype.getCameraByUniqueID = function (e) {\n        for (var t = 0; t < this.cameras.length; t++) if (this.cameras[t].uniqueId === e) return this.cameras[t];\n\n        return null;\n      }, E.prototype.getCameraByName = function (e) {\n        for (var t = 0; t < this.cameras.length; t++) if (this.cameras[t].name === e) return this.cameras[t];\n\n        return null;\n      }, E.prototype.getBoneByID = function (e) {\n        for (var t = 0; t < this.skeletons.length; t++) for (var i = this.skeletons[t], r = 0; r < i.bones.length; r++) if (i.bones[r].id === e) return i.bones[r];\n\n        return null;\n      }, E.prototype.getBoneByName = function (e) {\n        for (var t = 0; t < this.skeletons.length; t++) for (var i = this.skeletons[t], r = 0; r < i.bones.length; r++) if (i.bones[r].name === e) return i.bones[r];\n\n        return null;\n      }, E.prototype.getLightByName = function (e) {\n        for (var t = 0; t < this.lights.length; t++) if (this.lights[t].name === e) return this.lights[t];\n\n        return null;\n      }, E.prototype.getLightByID = function (e) {\n        for (var t = 0; t < this.lights.length; t++) if (this.lights[t].id === e) return this.lights[t];\n\n        return null;\n      }, E.prototype.getLightByUniqueID = function (e) {\n        for (var t = 0; t < this.lights.length; t++) if (this.lights[t].uniqueId === e) return this.lights[t];\n\n        return null;\n      }, E.prototype.getParticleSystemByID = function (e) {\n        for (var t = 0; t < this.particleSystems.length; t++) if (this.particleSystems[t].id === e) return this.particleSystems[t];\n\n        return null;\n      }, E.prototype.getGeometryByID = function (e) {\n        for (var t = 0; t < this.geometries.length; t++) if (this.geometries[t].id === e) return this.geometries[t];\n\n        return null;\n      }, E.prototype.pushGeometry = function (e, t) {\n        return !(!t && this.getGeometryByID(e.id)) && (this.geometries.push(e), this.collisionCoordinator && this.collisionCoordinator.onGeometryAdded(e), this.onNewGeometryAddedObservable.notifyObservers(e), !0);\n      }, E.prototype.removeGeometry = function (e) {\n        var t = this.geometries.indexOf(e);\n        return -1 < t && (this.geometries.splice(t, 1), this.collisionCoordinator && this.collisionCoordinator.onGeometryDeleted(e), this.onGeometryRemovedObservable.notifyObservers(e), !0);\n      }, E.prototype.getGeometries = function () {\n        return this.geometries;\n      }, E.prototype.getMeshByID = function (e) {\n        for (var t = 0; t < this.meshes.length; t++) if (this.meshes[t].id === e) return this.meshes[t];\n\n        return null;\n      }, E.prototype.getMeshesByID = function (t) {\n        return this.meshes.filter(function (e) {\n          return e.id === t;\n        });\n      }, E.prototype.getTransformNodeByID = function (e) {\n        for (var t = 0; t < this.transformNodes.length; t++) if (this.transformNodes[t].id === e) return this.transformNodes[t];\n\n        return null;\n      }, E.prototype.getTransformNodesByID = function (t) {\n        return this.transformNodes.filter(function (e) {\n          return e.id === t;\n        });\n      }, E.prototype.getMeshByUniqueID = function (e) {\n        for (var t = 0; t < this.meshes.length; t++) if (this.meshes[t].uniqueId === e) return this.meshes[t];\n\n        return null;\n      }, E.prototype.getLastMeshByID = function (e) {\n        for (var t = this.meshes.length - 1; 0 <= t; t--) if (this.meshes[t].id === e) return this.meshes[t];\n\n        return null;\n      }, E.prototype.getLastEntryByID = function (e) {\n        var t;\n\n        for (t = this.meshes.length - 1; 0 <= t; t--) if (this.meshes[t].id === e) return this.meshes[t];\n\n        for (t = this.transformNodes.length - 1; 0 <= t; t--) if (this.transformNodes[t].id === e) return this.transformNodes[t];\n\n        for (t = this.cameras.length - 1; 0 <= t; t--) if (this.cameras[t].id === e) return this.cameras[t];\n\n        for (t = this.lights.length - 1; 0 <= t; t--) if (this.lights[t].id === e) return this.lights[t];\n\n        return null;\n      }, E.prototype.getNodeByID = function (e) {\n        var t = this.getMeshByID(e);\n        if (t) return t;\n        var i = this.getLightByID(e);\n        if (i) return i;\n        var r = this.getCameraByID(e);\n        return r || this.getBoneByID(e);\n      }, E.prototype.getNodeByName = function (e) {\n        var t = this.getMeshByName(e);\n        if (t) return t;\n        var i = this.getLightByName(e);\n        if (i) return i;\n        var r = this.getCameraByName(e);\n        return r || this.getBoneByName(e);\n      }, E.prototype.getMeshByName = function (e) {\n        for (var t = 0; t < this.meshes.length; t++) if (this.meshes[t].name === e) return this.meshes[t];\n\n        return null;\n      }, E.prototype.getTransformNodeByName = function (e) {\n        for (var t = 0; t < this.transformNodes.length; t++) if (this.transformNodes[t].name === e) return this.transformNodes[t];\n\n        return null;\n      }, E.prototype.getLastSkeletonByID = function (e) {\n        for (var t = this.skeletons.length - 1; 0 <= t; t--) if (this.skeletons[t].id === e) return this.skeletons[t];\n\n        return null;\n      }, E.prototype.getSkeletonById = function (e) {\n        for (var t = 0; t < this.skeletons.length; t++) if (this.skeletons[t].id === e) return this.skeletons[t];\n\n        return null;\n      }, E.prototype.getSkeletonByName = function (e) {\n        for (var t = 0; t < this.skeletons.length; t++) if (this.skeletons[t].name === e) return this.skeletons[t];\n\n        return null;\n      }, E.prototype.getMorphTargetManagerById = function (e) {\n        for (var t = 0; t < this.morphTargetManagers.length; t++) if (this.morphTargetManagers[t].uniqueId === e) return this.morphTargetManagers[t];\n\n        return null;\n      }, E.prototype.isActiveMesh = function (e) {\n        return -1 !== this._activeMeshes.indexOf(e);\n      }, Object.defineProperty(E.prototype, \"uid\", {\n        get: function () {\n          return this._uid || (this._uid = x.Tools.RandomId()), this._uid;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.addExternalData = function (e, t) {\n        return this._externalData || (this._externalData = new x.StringDictionary()), this._externalData.add(e, t);\n      }, E.prototype.getExternalData = function (e) {\n        return this._externalData ? this._externalData.get(e) : null;\n      }, E.prototype.getOrAddExternalDataWithFactory = function (e, t) {\n        return this._externalData || (this._externalData = new x.StringDictionary()), this._externalData.getOrAddWithFactory(e, t);\n      }, E.prototype.removeExternalData = function (e) {\n        return this._externalData.remove(e);\n      }, E.prototype._evaluateSubMesh = function (e, t) {\n        if (this.dispatchAllSubMeshesOfActiveMeshes || t.alwaysSelectAsActiveMesh || 1 === t.subMeshes.length || e.isInFrustum(this._frustumPlanes)) {\n          for (var i = 0, r = this._evaluateSubMeshStage; i < r.length; i++) {\n            r[i].action(t, e);\n          }\n\n          var n = e.getMaterial();\n          null != n && (n.hasRenderTargetTextures && void 0 !== n.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(n) && (this._processedMaterials.push(n), this._renderTargets.concatWithNoDuplicate(n.getRenderTargetTextures())), this._activeIndices.addCount(e.indexCount, !1), this._renderingManager.dispatch(e, t, n));\n        }\n      }, E.prototype.freeProcessedMaterials = function () {\n        this._processedMaterials.dispose();\n      }, E.prototype.freeActiveMeshes = function () {\n        if (this._activeMeshes.dispose(), this.activeCamera && this.activeCamera._activeMeshes && this.activeCamera._activeMeshes.dispose(), this.activeCameras) for (var e = 0; e < this.activeCameras.length; e++) {\n          var t = this.activeCameras[e];\n          t && t._activeMeshes && t._activeMeshes.dispose();\n        }\n      }, E.prototype.freeRenderingGroups = function () {\n        if (this._renderingManager && this._renderingManager.freeRenderingGroups(), this.textures) for (var e = 0; e < this.textures.length; e++) {\n          var t = this.textures[e];\n          t && t.renderList && t.freeRenderingGroups();\n        }\n      }, E.prototype._isInIntermediateRendering = function () {\n        return this._intermediateRendering;\n      }, E.prototype.freezeActiveMeshes = function () {\n        return this.activeCamera && (this._frustumPlanes || this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix()), this._evaluateActiveMeshes(), this._activeMeshesFrozen = !0), this;\n      }, E.prototype.unfreezeActiveMeshes = function () {\n        return this._activeMeshesFrozen = !1, this;\n      }, E.prototype._evaluateActiveMeshes = function () {\n        if ((!this._activeMeshesFrozen || !this._activeMeshes.length) && this.activeCamera) {\n          this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this), this.activeCamera._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset();\n\n          for (var e = 0, t = this._beforeEvaluateActiveMeshStage; e < t.length; e++) {\n            t[e].action();\n          }\n\n          for (var i = this.getActiveMeshCandidates(), r = i.length, n = 0; n < r; n++) {\n            var o = i.data[n];\n\n            if (!o.isBlocked && (this._totalVertices.addCount(o.getTotalVertices(), !1), o.isReady() && o.isEnabled())) {\n              o.computeWorldMatrix(), o.actionManager && o.actionManager.hasSpecificTriggers2(x.ActionManager.OnIntersectionEnterTrigger, x.ActionManager.OnIntersectionExitTrigger) && this._meshesForIntersections.pushNoDuplicate(o);\n              var s = o.getLOD(this.activeCamera);\n              null != s && (o._preActivate(), o.isVisible && 0 < o.visibility && (o.alwaysSelectAsActiveMesh || 0 != (o.layerMask & this.activeCamera.layerMask) && o.isInFrustum(this._frustumPlanes)) && (this._activeMeshes.push(o), this.activeCamera._activeMeshes.push(o), o._activate(this._renderId), s !== o && s._activate(this._renderId), this._activeMesh(o, s)));\n            }\n          }\n\n          if (this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this), this.particlesEnabled) {\n            this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n\n            for (var a = 0; a < this.particleSystems.length; a++) {\n              var l = this.particleSystems[a];\n\n              if (l.isStarted() && l.emitter) {\n                var c = l.emitter;\n                c.position && !c.isEnabled() || (this._activeParticleSystems.push(l), l.animate(), this._renderingManager.dispatchParticles(l));\n              }\n            }\n\n            this.onAfterParticlesRenderingObservable.notifyObservers(this);\n          }\n        }\n      }, E.prototype._activeMesh = function (e, t) {\n        this._skeletonsEnabled && null !== t.skeleton && void 0 !== t.skeleton && (this._activeSkeletons.pushNoDuplicate(t.skeleton) && t.skeleton.prepare(), t.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(t));\n\n        for (var i = 0, r = this._activeMeshStage; i < r.length; i++) {\n          r[i].action(e, t);\n        }\n\n        if (null != t && void 0 !== t.subMeshes && null !== t.subMeshes && 0 < t.subMeshes.length) for (var n = this.getActiveSubMeshCandidates(t), o = n.length, s = 0; s < o; s++) {\n          var a = n.data[s];\n\n          this._evaluateSubMesh(a, t);\n        }\n      }, E.prototype.updateTransformMatrix = function (e) {\n        this.activeCamera && this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(e));\n      }, E.prototype.updateAlternateTransformMatrix = function (e) {\n        this._setAlternateTransformMatrix(e.getViewMatrix(), e.getProjectionMatrix());\n      }, E.prototype._renderForCamera = function (e, t) {\n        if (!e || !e._skipRendering) {\n          var i = this._engine;\n          if (this.activeCamera = e, !this.activeCamera) throw new Error(\"Active camera not set\");\n          i.setViewport(this.activeCamera.viewport), this.resetCachedMaterial(), this._renderId++, this.updateTransformMatrix(), e._alternateCamera && (this.updateAlternateTransformMatrix(e._alternateCamera), this._alternateRendering = !0), this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera), this._evaluateActiveMeshes();\n\n          for (var r = 0; r < this._softwareSkinnedMeshes.length; r++) {\n            var n = this._softwareSkinnedMeshes.data[r];\n            n.applySkeleton(n.skeleton);\n          }\n\n          this.onBeforeRenderTargetsRenderObservable.notifyObservers(this), e.customRenderTargets && 0 < e.customRenderTargets.length && this._renderTargets.concatWithNoDuplicate(e.customRenderTargets), t && t.customRenderTargets && 0 < t.customRenderTargets.length && this._renderTargets.concatWithNoDuplicate(t.customRenderTargets);\n\n          for (var o = 0, s = this._gatherActiveCameraRenderTargetsStage; o < s.length; o++) {\n            s[o].action(this._renderTargets);\n          }\n\n          if (this.renderTargetsEnabled) {\n            if (this._intermediateRendering = !0, 0 < this._renderTargets.length) {\n              x.Tools.StartPerformanceCounter(\"Render targets\", 0 < this._renderTargets.length);\n\n              for (var a = 0; a < this._renderTargets.length; a++) {\n                var l = this._renderTargets.data[a];\n\n                if (l._shouldRender()) {\n                  this._renderId++;\n                  var c = l.activeCamera && l.activeCamera !== this.activeCamera;\n                  l.render(c, this.dumpNextRenderTargets);\n                }\n              }\n\n              x.Tools.EndPerformanceCounter(\"Render targets\", 0 < this._renderTargets.length), this._renderId++;\n            }\n\n            for (var h = 0, u = this._cameraDrawRenderTargetStage; h < u.length; h++) {\n              u[h].action(this.activeCamera);\n            }\n\n            this._intermediateRendering = !1, i.restoreDefaultFramebuffer();\n          }\n\n          this.onAfterRenderTargetsRenderObservable.notifyObservers(this), this.postProcessManager && this.postProcessManager._prepareFrame();\n\n          for (var d = 0, f = this._beforeCameraDrawStage; d < f.length; d++) {\n            f[d].action(this.activeCamera);\n          }\n\n          this.onBeforeDrawPhaseObservable.notifyObservers(this), this._renderingManager.render(null, null, !0, !0), this.onAfterDrawPhaseObservable.notifyObservers(this);\n\n          for (var p = 0, _ = this._afterCameraDrawStage; p < _.length; p++) {\n            _[p].action(this.activeCamera);\n          }\n\n          this.postProcessManager && this.postProcessManager._finalizeFrame(e.isIntermediate), this._renderTargets.reset(), this._alternateRendering = !1, this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n        }\n      }, E.prototype._processSubCameras = function (e) {\n        if (e.cameraRigMode !== x.Camera.RIG_MODE_NONE) {\n          for (var t = 0; t < e._rigCameras.length; t++) this._renderForCamera(e._rigCameras[t], e);\n\n          this.activeCamera = e, this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix());\n        } else this._renderForCamera(e);\n      }, E.prototype._checkIntersections = function () {\n        for (var e = 0; e < this._meshesForIntersections.length; e++) {\n          var t = this._meshesForIntersections.data[e];\n          if (t.actionManager) for (var i = 0; i < t.actionManager.actions.length; i++) {\n            var r = t.actionManager.actions[i];\n\n            if (r.trigger === x.ActionManager.OnIntersectionEnterTrigger || r.trigger === x.ActionManager.OnIntersectionExitTrigger) {\n              var n = r.getTriggerParameter(),\n                  o = n instanceof x.AbstractMesh ? n : n.mesh,\n                  s = o.intersectsMesh(t, n.usePreciseIntersection),\n                  a = t._intersectionsInProgress.indexOf(o);\n\n              s && -1 === a ? r.trigger === x.ActionManager.OnIntersectionEnterTrigger ? (r._executeCurrent(x.ActionEvent.CreateNew(t, void 0, o)), t._intersectionsInProgress.push(o)) : r.trigger === x.ActionManager.OnIntersectionExitTrigger && t._intersectionsInProgress.push(o) : !s && -1 < a && (r.trigger === x.ActionManager.OnIntersectionExitTrigger && r._executeCurrent(x.ActionEvent.CreateNew(t, void 0, o)), t.actionManager.hasSpecificTrigger(x.ActionManager.OnIntersectionExitTrigger, function (e) {\n                var t = e instanceof x.AbstractMesh ? e : e.mesh;\n                return o === t;\n              }) && r.trigger !== x.ActionManager.OnIntersectionExitTrigger || t._intersectionsInProgress.splice(a, 1));\n            }\n          }\n        }\n      }, E.prototype._advancePhysicsEngineStep = function (e) {}, E.prototype.render = function (e) {\n        if (void 0 === e && (e = !0), !this.isDisposed) {\n          if (this._frameId++, this._registerTransientComponents(), this._activeParticles.fetchNewFrame(), this._totalVertices.fetchNewFrame(), this._activeIndices.fetchNewFrame(), this._activeBones.fetchNewFrame(), this._meshesForIntersections.reset(), this.resetCachedMaterial(), this.onBeforeAnimationsObservable.notifyObservers(this), this.actionManager && this.actionManager.processTrigger(x.ActionManager.OnEveryFrameTrigger), this._engine.isDeterministicLockStep()) {\n            var t = Math.max(E.MinDeltaTime, Math.min(this._engine.getDeltaTime(), E.MaxDeltaTime)) + this._timeAccumulator,\n                i = this.getDeterministicFrameTime(),\n                r = 0,\n                n = this._engine.getLockstepMaxSteps(),\n                o = Math.floor(t / 60);\n\n            for (o = Math.min(o, n); this.onBeforeStepObservable.notifyObservers(this), this._animationRatio = .06 * i, this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this._advancePhysicsEngineStep(i), this.onAfterStepObservable.notifyObservers(this), this._currentStepId++, 0 < (t -= i) && ++r < o;);\n\n            this._timeAccumulator = t < 0 ? 0 : t;\n          } else {\n            t = this.useConstantAnimationDeltaTime ? 16 : Math.max(E.MinDeltaTime, Math.min(this._engine.getDeltaTime(), E.MaxDeltaTime));\n            this._animationRatio = .06 * t, this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this._advancePhysicsEngineStep(t);\n          }\n\n          for (var s = 0, a = this._beforeCameraUpdateStage; s < a.length; s++) {\n            a[s].action();\n          }\n\n          if (e) if (0 < this.activeCameras.length) for (var l = 0; l < this.activeCameras.length; l++) {\n            var c = this.activeCameras[l];\n            if (c.update(), c.cameraRigMode !== x.Camera.RIG_MODE_NONE) for (var h = 0; h < c._rigCameras.length; h++) c._rigCameras[h].update();\n          } else if (this.activeCamera && (this.activeCamera.update(), this.activeCamera.cameraRigMode !== x.Camera.RIG_MODE_NONE)) for (h = 0; h < this.activeCamera._rigCameras.length; h++) this.activeCamera._rigCameras[h].update();\n          this.onBeforeRenderObservable.notifyObservers(this), this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n          var u = this.getEngine(),\n              d = this.activeCamera;\n\n          if (this.renderTargetsEnabled) {\n            x.Tools.StartPerformanceCounter(\"Custom render targets\", 0 < this.customRenderTargets.length), this._intermediateRendering = !0;\n\n            for (var f = 0; f < this.customRenderTargets.length; f++) {\n              var p = this.customRenderTargets[f];\n\n              if (p._shouldRender()) {\n                if (this._renderId++, this.activeCamera = p.activeCamera || this.activeCamera, !this.activeCamera) throw new Error(\"Active camera not set\");\n                u.setViewport(this.activeCamera.viewport), this.updateTransformMatrix(), p.render(d !== this.activeCamera, this.dumpNextRenderTargets);\n              }\n            }\n\n            x.Tools.EndPerformanceCounter(\"Custom render targets\", 0 < this.customRenderTargets.length), this._intermediateRendering = !1, this._renderId++;\n          }\n\n          0 < this.customRenderTargets.length && u.restoreDefaultFramebuffer(), this.onAfterRenderTargetsRenderObservable.notifyObservers(this), this.activeCamera = d;\n\n          for (var _ = 0, m = this._beforeClearStage; _ < m.length; _++) {\n            m[_].action();\n          }\n\n          (this.autoClearDepthAndStencil || this.autoClear) && this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n\n          for (var g = 0, v = this._gatherRenderTargetsStage; g < v.length; g++) {\n            v[g].action(this._renderTargets);\n          }\n\n          if (0 < this.activeCameras.length) for (l = 0; l < this.activeCameras.length; l++) 0 < l && this._engine.clear(null, !1, !0, !0), this._processSubCameras(this.activeCameras[l]);else {\n            if (!this.activeCamera) throw new Error(\"No camera defined\");\n\n            this._processSubCameras(this.activeCamera);\n          }\n\n          this._checkIntersections();\n\n          for (var y = 0, b = this._afterRenderStage; y < b.length; y++) {\n            b[y].action();\n          }\n\n          if (this.afterRender && this.afterRender(), this.onAfterRenderObservable.notifyObservers(this), this._toBeDisposed.length) {\n            for (h = 0; h < this._toBeDisposed.length; h++) {\n              var T = this._toBeDisposed[h];\n              T && T.dispose();\n            }\n\n            this._toBeDisposed = [];\n          }\n\n          this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1), this._activeBones.addCount(0, !0), this._activeIndices.addCount(0, !0), this._activeParticles.addCount(0, !0);\n        }\n      }, E.prototype.freezeMaterials = function () {\n        for (var e = 0; e < this.materials.length; e++) this.materials[e].freeze();\n      }, E.prototype.unfreezeMaterials = function () {\n        for (var e = 0; e < this.materials.length; e++) this.materials[e].unfreeze();\n      }, E.prototype.dispose = function () {\n        this.beforeRender = null, this.afterRender = null, this.skeletons = [], this.morphTargetManagers = [], this._transientComponents = [], this._isReadyForMeshStage.clear(), this._beforeEvaluateActiveMeshStage.clear(), this._evaluateSubMeshStage.clear(), this._activeMeshStage.clear(), this._cameraDrawRenderTargetStage.clear(), this._beforeCameraDrawStage.clear(), this._beforeRenderingGroupDrawStage.clear(), this._beforeRenderingMeshStage.clear(), this._afterRenderingMeshStage.clear(), this._afterRenderingGroupDrawStage.clear(), this._afterCameraDrawStage.clear(), this._afterRenderStage.clear(), this._beforeCameraUpdateStage.clear(), this._beforeClearStage.clear(), this._gatherRenderTargetsStage.clear(), this._gatherActiveCameraRenderTargetsStage.clear(), this._pointerMoveStage.clear(), this._pointerDownStage.clear(), this._pointerUpStage.clear();\n\n        for (var e = 0, t = this._components; e < t.length; e++) {\n          t[e].dispose();\n        }\n\n        this.importedMeshesFiles = new Array(), this.stopAllAnimations(), this.resetCachedMaterial(), this.activeCamera && (this.activeCamera._activeMeshes.dispose(), this.activeCamera = null), this._activeMeshes.dispose(), this._renderingManager.dispose(), this._processedMaterials.dispose(), this._activeParticleSystems.dispose(), this._activeSkeletons.dispose(), this._softwareSkinnedMeshes.dispose(), this._renderTargets.dispose(), this._registeredForLateAnimationBindings.dispose(), this._meshesForIntersections.dispose(), this._toBeDisposed = [];\n\n        for (var i = 0, r = this._activeRequests; i < r.length; i++) {\n          r[i].abort();\n        }\n\n        this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onBeforeRenderObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderTargetsRenderObservable.clear(), this.onAfterRenderTargetsRenderObservable.clear(), this.onAfterStepObservable.clear(), this.onBeforeStepObservable.clear(), this.onBeforeActiveMeshesEvaluationObservable.clear(), this.onAfterActiveMeshesEvaluationObservable.clear(), this.onBeforeParticlesRenderingObservable.clear(), this.onAfterParticlesRenderingObservable.clear(), this.onBeforeDrawPhaseObservable.clear(), this.onAfterDrawPhaseObservable.clear(), this.onBeforeAnimationsObservable.clear(), this.onAfterAnimationsObservable.clear(), this.onDataLoadedObservable.clear(), this.onBeforeRenderingGroupObservable.clear(), this.onAfterRenderingGroupObservable.clear(), this.onMeshImportedObservable.clear(), this.onBeforeCameraRenderObservable.clear(), this.onAfterCameraRenderObservable.clear(), this.onReadyObservable.clear(), this.onNewCameraAddedObservable.clear(), this.onCameraRemovedObservable.clear(), this.onNewLightAddedObservable.clear(), this.onLightRemovedObservable.clear(), this.onNewGeometryAddedObservable.clear(), this.onGeometryRemovedObservable.clear(), this.onNewTransformNodeAddedObservable.clear(), this.onTransformNodeRemovedObservable.clear(), this.onNewMeshAddedObservable.clear(), this.onMeshRemovedObservable.clear(), this.onNewMaterialAddedObservable.clear(), this.onMaterialRemovedObservable.clear(), this.onNewTextureAddedObservable.clear(), this.onTextureRemovedObservable.clear(), this.onPrePointerObservable.clear(), this.onPointerObservable.clear(), this.onPreKeyboardObservable.clear(), this.onKeyboardObservable.clear(), this.detachControl();\n\n        var n,\n            o = this._engine.getRenderingCanvas();\n\n        if (o) for (n = 0; n < this.cameras.length; n++) this.cameras[n].detachControl(o);\n\n        for (; this.animationGroups.length;) this.animationGroups[0].dispose();\n\n        for (; this.lights.length;) this.lights[0].dispose();\n\n        for (; this.meshes.length;) this.meshes[0].dispose(!0);\n\n        for (; this.transformNodes.length;) this.removeTransformNode(this.transformNodes[0]);\n\n        for (; this.cameras.length;) this.cameras[0].dispose();\n\n        for (this.defaultMaterial && this.defaultMaterial.dispose(); this.multiMaterials.length;) this.multiMaterials[0].dispose();\n\n        for (; this.materials.length;) this.materials[0].dispose();\n\n        for (; this.particleSystems.length;) this.particleSystems[0].dispose();\n\n        for (; this.postProcesses.length;) this.postProcesses[0].dispose();\n\n        for (; this.textures.length;) this.textures[0].dispose();\n\n        this._sceneUbo.dispose(), this._alternateSceneUbo && this._alternateSceneUbo.dispose(), this.postProcessManager.dispose(), -1 < (n = this._engine.scenes.indexOf(this)) && this._engine.scenes.splice(n, 1), this._engine.wipeCaches(!0), this._isDisposed = !0;\n      }, Object.defineProperty(E.prototype, \"isDisposed\", {\n        get: function () {\n          return this._isDisposed;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.clearCachedVertexData = function () {\n        for (var e = 0; e < this.meshes.length; e++) {\n          var t = this.meshes[e].geometry;\n          if (t) for (var i in t._indices = [], t._vertexBuffers) t._vertexBuffers.hasOwnProperty(i) && (t._vertexBuffers[i]._buffer._data = null);\n        }\n      }, E.prototype.cleanCachedTextureBuffer = function () {\n        for (var e = 0, t = this.textures; e < t.length; e++) {\n          var i = t[e];\n          i._buffer && (i._buffer = null);\n        }\n      }, E.prototype.getWorldExtends = function (e) {\n        var n = new x.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),\n            o = new x.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        return e = e || function () {\n          return !0;\n        }, this.meshes.filter(e).forEach(function (e) {\n          if (e.computeWorldMatrix(!0), e.subMeshes && 0 !== e.subMeshes.length && !e.infiniteDistance) {\n            var t = e.getBoundingInfo(),\n                i = t.boundingBox.minimumWorld,\n                r = t.boundingBox.maximumWorld;\n            x.Tools.CheckExtends(i, n, o), x.Tools.CheckExtends(r, n, o);\n          }\n        }), {\n          min: n,\n          max: o\n        };\n      }, E.prototype.createPickingRay = function (e, t, i, r, n) {\n        void 0 === n && (n = !1);\n        var o = x.Ray.Zero();\n        return this.createPickingRayToRef(e, t, i, o, r, n), o;\n      }, E.prototype.createPickingRayToRef = function (e, t, i, r, n, o) {\n        void 0 === o && (o = !1);\n        var s = this._engine;\n\n        if (!n) {\n          if (!this.activeCamera) throw new Error(\"Active camera not set\");\n          n = this.activeCamera;\n        }\n\n        var a = n.viewport.toGlobal(s.getRenderWidth(), s.getRenderHeight());\n        return e = e / this._engine.getHardwareScalingLevel() - a.x, t = t / this._engine.getHardwareScalingLevel() - (this._engine.getRenderHeight() - a.y - a.height), r.update(e, t, a.width, a.height, i || x.Matrix.Identity(), o ? x.Matrix.Identity() : n.getViewMatrix(), n.getProjectionMatrix()), this;\n      }, E.prototype.createPickingRayInCameraSpace = function (e, t, i) {\n        var r = x.Ray.Zero();\n        return this.createPickingRayInCameraSpaceToRef(e, t, r, i), r;\n      }, E.prototype.createPickingRayInCameraSpaceToRef = function (e, t, i, r) {\n        if (!x.PickingInfo) return this;\n        var n = this._engine;\n\n        if (!r) {\n          if (!this.activeCamera) throw new Error(\"Active camera not set\");\n          r = this.activeCamera;\n        }\n\n        var o = r.viewport.toGlobal(n.getRenderWidth(), n.getRenderHeight()),\n            s = x.Matrix.Identity();\n        return e = e / this._engine.getHardwareScalingLevel() - o.x, t = t / this._engine.getHardwareScalingLevel() - (this._engine.getRenderHeight() - o.y - o.height), i.update(e, t, o.width, o.height, s, s, r.getProjectionMatrix()), this;\n      }, E.prototype._internalPick = function (e, t, i) {\n        if (!x.PickingInfo) return null;\n\n        for (var r = null, n = 0; n < this.meshes.length; n++) {\n          var o = this.meshes[n];\n\n          if (t) {\n            if (!t(o)) continue;\n          } else if (!o.isEnabled() || !o.isVisible || !o.isPickable) continue;\n\n          var s = e(o.getWorldMatrix()),\n              a = o.intersects(s, i);\n          if (a && a.hit && (i || null == r || !(a.distance >= r.distance)) && (r = a, i)) break;\n        }\n\n        return r || new x.PickingInfo();\n      }, E.prototype._internalMultiPick = function (e, t) {\n        if (!x.PickingInfo) return null;\n\n        for (var i = new Array(), r = 0; r < this.meshes.length; r++) {\n          var n = this.meshes[r];\n\n          if (t) {\n            if (!t(n)) continue;\n          } else if (!n.isEnabled() || !n.isVisible || !n.isPickable) continue;\n\n          var o = e(n.getWorldMatrix()),\n              s = n.intersects(o, !1);\n          s && s.hit && i.push(s);\n        }\n\n        return i;\n      }, E.prototype.pick = function (t, i, e, r, n) {\n        var o = this;\n        if (!x.PickingInfo) return null;\n\n        var s = this._internalPick(function (e) {\n          return o.createPickingRayToRef(t, i, e, o._tempPickingRay, n || null), o._tempPickingRay;\n        }, e, r);\n\n        return s && (s.ray = this.createPickingRay(t, i, x.Matrix.Identity(), n || null)), s;\n      }, E.prototype.pickWithRay = function (t, e, i) {\n        var r = this,\n            n = this._internalPick(function (e) {\n          return r._pickWithRayInverseMatrix || (r._pickWithRayInverseMatrix = x.Matrix.Identity()), e.invertToRef(r._pickWithRayInverseMatrix), r._cachedRayForTransform || (r._cachedRayForTransform = x.Ray.Zero()), x.Ray.TransformToRef(t, r._pickWithRayInverseMatrix, r._cachedRayForTransform), r._cachedRayForTransform;\n        }, e, i);\n\n        return n && (n.ray = t), n;\n      }, E.prototype.multiPick = function (t, i, e, r) {\n        var n = this;\n        return this._internalMultiPick(function (e) {\n          return n.createPickingRay(t, i, e, r || null);\n        }, e);\n      }, E.prototype.multiPickWithRay = function (t, e) {\n        var i = this;\n        return this._internalMultiPick(function (e) {\n          return i._pickWithRayInverseMatrix || (i._pickWithRayInverseMatrix = x.Matrix.Identity()), e.invertToRef(i._pickWithRayInverseMatrix), i._cachedRayForTransform || (i._cachedRayForTransform = x.Ray.Zero()), x.Ray.TransformToRef(t, i._pickWithRayInverseMatrix, i._cachedRayForTransform), i._cachedRayForTransform;\n        }, e);\n      }, E.prototype.setPointerOverMesh = function (e) {\n        this._pointerOverMesh !== e && (this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.processTrigger(x.ActionManager.OnPointerOutTrigger, x.ActionEvent.CreateNew(this._pointerOverMesh)), this._pointerOverMesh = e, this._pointerOverMesh && this._pointerOverMesh.actionManager && this._pointerOverMesh.actionManager.processTrigger(x.ActionManager.OnPointerOverTrigger, x.ActionEvent.CreateNew(this._pointerOverMesh)));\n      }, E.prototype.getPointerOverMesh = function () {\n        return this._pointerOverMesh;\n      }, E.prototype._rebuildGeometries = function () {\n        for (var e = 0, t = this.geometries; e < t.length; e++) {\n          t[e]._rebuild();\n        }\n\n        for (var i = 0, r = this.meshes; i < r.length; i++) {\n          r[i]._rebuild();\n        }\n\n        this.postProcessManager && this.postProcessManager._rebuild();\n\n        for (var n = 0, o = this._components; n < o.length; n++) {\n          o[n].rebuild();\n        }\n\n        for (var s = 0, a = this.particleSystems; s < a.length; s++) {\n          a[s].rebuild();\n        }\n      }, E.prototype._rebuildTextures = function () {\n        for (var e = 0, t = this.textures; e < t.length; e++) {\n          t[e]._rebuild();\n        }\n\n        this.markAllMaterialsAsDirty(x.Material.TextureDirtyFlag);\n      }, E.prototype._getByTags = function (e, t, i) {\n        if (void 0 === t) return e;\n        var r = [];\n\n        for (var n in i = i || function (e) {}, e) {\n          var o = e[n];\n          x.Tags && x.Tags.MatchesQuery(o, t) && (r.push(o), i(o));\n        }\n\n        return r;\n      }, E.prototype.getMeshesByTags = function (e, t) {\n        return this._getByTags(this.meshes, e, t);\n      }, E.prototype.getCamerasByTags = function (e, t) {\n        return this._getByTags(this.cameras, e, t);\n      }, E.prototype.getLightsByTags = function (e, t) {\n        return this._getByTags(this.lights, e, t);\n      }, E.prototype.getMaterialByTags = function (e, t) {\n        return this._getByTags(this.materials, e, t).concat(this._getByTags(this.multiMaterials, e, t));\n      }, E.prototype.setRenderingOrder = function (e, t, i, r) {\n        void 0 === t && (t = null), void 0 === i && (i = null), void 0 === r && (r = null), this._renderingManager.setRenderingOrder(e, t, i, r);\n      }, E.prototype.setRenderingAutoClearDepthStencil = function (e, t, i, r) {\n        void 0 === i && (i = !0), void 0 === r && (r = !0), this._renderingManager.setRenderingAutoClearDepthStencil(e, t, i, r);\n      }, E.prototype.getAutoClearDepthStencilSetup = function (e) {\n        return this._renderingManager.getAutoClearDepthStencilSetup(e);\n      }, Object.defineProperty(E.prototype, \"blockMaterialDirtyMechanism\", {\n        get: function () {\n          return this._blockMaterialDirtyMechanism;\n        },\n        set: function (e) {\n          this._blockMaterialDirtyMechanism !== e && ((this._blockMaterialDirtyMechanism = e) || this.markAllMaterialsAsDirty(x.Material.AllDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), E.prototype.markAllMaterialsAsDirty = function (e, t) {\n        if (!this._blockMaterialDirtyMechanism) for (var i = 0, r = this.materials; i < r.length; i++) {\n          var n = r[i];\n          t && !t(n) || n.markAsDirty(e);\n        }\n      }, E.prototype._loadFile = function (e, t, i, r, n, o) {\n        var s = this,\n            a = x.Tools.LoadFile(e, t, i, r ? this.database : void 0, n, o);\n        return this._activeRequests.push(a), a.onCompleteObservable.add(function (e) {\n          s._activeRequests.splice(s._activeRequests.indexOf(e), 1);\n        }), a;\n      }, E.prototype._loadFileAsync = function (e, r, n) {\n        var o = this;\n        return new Promise(function (t, i) {\n          o._loadFile(e, function (e) {\n            t(e);\n          }, void 0, r, n, function (e, t) {\n            i(t);\n          });\n        });\n      }, E._uniqueIdCounter = 0, E.FOGMODE_NONE = 0, E.FOGMODE_EXP = 1, E.FOGMODE_EXP2 = 2, E.FOGMODE_LINEAR = 3, E.MinDeltaTime = 1, E.MaxDeltaTime = 1e3, E.DragMovementThreshold = 10, E.LongPressDelay = 500, E.DoubleClickDelay = 300, E.ExclusiveDoubleClickMode = !1, E;\n    }(x.AbstractScene);\n\n    x.Scene = t;\n  }($a || ($a = {})), function (r) {\n    var n = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t;\n    }(r.AbstractScene);\n\n    r.KeepAssets = n;\n\n    var e = function (i) {\n      function e(e) {\n        var t = i.call(this) || this;\n        return t.scene = e, t;\n      }\n\n      return T(e, i), e.prototype.addAllToScene = function () {\n        var t = this;\n        this.cameras.forEach(function (e) {\n          t.scene.addCamera(e);\n        }), this.lights.forEach(function (e) {\n          t.scene.addLight(e);\n        }), this.meshes.forEach(function (e) {\n          t.scene.addMesh(e);\n        }), this.skeletons.forEach(function (e) {\n          t.scene.addSkeleton(e);\n        }), this.animations.forEach(function (e) {\n          t.scene.addAnimation(e);\n        }), this.animationGroups.forEach(function (e) {\n          t.scene.addAnimationGroup(e);\n        }), this.multiMaterials.forEach(function (e) {\n          t.scene.addMultiMaterial(e);\n        }), this.materials.forEach(function (e) {\n          t.scene.addMaterial(e);\n        }), this.morphTargetManagers.forEach(function (e) {\n          t.scene.addMorphTargetManager(e);\n        }), this.geometries.forEach(function (e) {\n          t.scene.addGeometry(e);\n        }), this.transformNodes.forEach(function (e) {\n          t.scene.addTransformNode(e);\n        }), this.actionManagers.forEach(function (e) {\n          t.scene.addActionManager(e);\n        }), this.textures.forEach(function (e) {\n          t.scene.addTexture(e);\n        });\n\n        for (var e = 0, i = this.scene._serializableComponents; e < i.length; e++) {\n          i[e].addFromContainer(this.scene);\n        }\n      }, e.prototype.removeAllFromScene = function () {\n        var t = this;\n        this.cameras.forEach(function (e) {\n          t.scene.removeCamera(e);\n        }), this.lights.forEach(function (e) {\n          t.scene.removeLight(e);\n        }), this.meshes.forEach(function (e) {\n          t.scene.removeMesh(e);\n        }), this.skeletons.forEach(function (e) {\n          t.scene.removeSkeleton(e);\n        }), this.animations.forEach(function (e) {\n          t.scene.removeAnimation(e);\n        }), this.animationGroups.forEach(function (e) {\n          t.scene.removeAnimationGroup(e);\n        }), this.multiMaterials.forEach(function (e) {\n          t.scene.removeMultiMaterial(e);\n        }), this.materials.forEach(function (e) {\n          t.scene.removeMaterial(e);\n        }), this.morphTargetManagers.forEach(function (e) {\n          t.scene.removeMorphTargetManager(e);\n        }), this.geometries.forEach(function (e) {\n          t.scene.removeGeometry(e);\n        }), this.transformNodes.forEach(function (e) {\n          t.scene.removeTransformNode(e);\n        }), this.actionManagers.forEach(function (e) {\n          t.scene.removeActionManager(e);\n        }), this.textures.forEach(function (e) {\n          t.scene.removeTexture(e);\n        });\n\n        for (var e = 0, i = this.scene._serializableComponents; e < i.length; e++) {\n          i[e].removeFromContainer(this.scene);\n        }\n      }, e.prototype._moveAssets = function (e, t, i) {\n        if (e) for (var r = 0, n = e; r < n.length; r++) {\n          var o = n[r],\n              s = !0;\n          if (i) for (var a = 0, l = i; a < l.length; a++) {\n            if (o === l[a]) {\n              s = !1;\n              break;\n            }\n          }\n          s && t.push(o);\n        }\n      }, e.prototype.moveAllFromScene = function (e) {\n        for (var t in void 0 === e && (e = new n()), this) this.hasOwnProperty(t) && (this[t] = this[t] || [], this._moveAssets(this.scene[t], this[t], e[t]));\n\n        this.removeAllFromScene();\n      }, e.prototype.createRootMesh = function () {\n        var t = new r.Mesh(\"assetContainerRootMesh\", this.scene);\n        return this.meshes.forEach(function (e) {\n          e.parent || t.addChild(e);\n        }), this.meshes.unshift(t), t;\n      }, e;\n    }(r.AbstractScene);\n\n    r.AssetContainer = e;\n  }($a || ($a = {})), Y = $a || ($a = {}), K = function () {\n    function e(e, t, i, r, n, o, s) {\n      void 0 === r && (r = 0), void 0 === n && (n = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), e instanceof Y.Mesh ? this._engine = e.getScene().getEngine() : this._engine = e, this._updatable = i, this._instanced = o, this._data = t, this.byteStride = s ? r : r * Float32Array.BYTES_PER_ELEMENT, n || this.create();\n    }\n\n    return e.prototype.createVertexBuffer = function (e, t, i, r, n, o) {\n      void 0 === o && (o = !1);\n      var s = o ? t : t * Float32Array.BYTES_PER_ELEMENT,\n          a = r ? o ? r : r * Float32Array.BYTES_PER_ELEMENT : this.byteStride;\n      return new Y.VertexBuffer(this._engine, this, e, this._updatable, !0, a, void 0 === n ? this._instanced : n, s, i, void 0, void 0, !0);\n    }, e.prototype.isUpdatable = function () {\n      return this._updatable;\n    }, e.prototype.getData = function () {\n      return this._data;\n    }, e.prototype.getBuffer = function () {\n      return this._buffer;\n    }, e.prototype.getStrideSize = function () {\n      return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\n    }, e.prototype.create = function (e) {\n      void 0 === e && (e = null), !e && this._buffer || (e = e || this._data) && (this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e), this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e), this._data = e) : this._buffer = this._engine.createVertexBuffer(e));\n    }, e.prototype._rebuild = function () {\n      this._buffer = null, this.create(this._data);\n    }, e.prototype.update = function (e) {\n      this.create(e);\n    }, e.prototype.updateDirectly = function (e, t, i, r) {\n      void 0 === r && (r = !1), this._buffer && this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, r ? t : t * Float32Array.BYTES_PER_ELEMENT, i ? i * this.byteStride : void 0), this._data = null);\n    }, e.prototype.dispose = function () {\n      this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null);\n    }, e;\n  }(), Y.Buffer = K, Q = $a || ($a = {}), Z = function () {\n    function _(e, t, i, r, n, o, s, a, l, c, h, u) {\n      if (void 0 === h && (h = !1), void 0 === u && (u = !1), t instanceof Q.Buffer ? (this._buffer = t, this._ownsBuffer = !1) : (this._buffer = new Q.Buffer(e, t, r, o, n, s, u), this._ownsBuffer = !0), this._kind = i, null == c) {\n        var d = this.getData();\n        this.type = _.FLOAT, d instanceof Int8Array ? this.type = _.BYTE : d instanceof Uint8Array ? this.type = _.UNSIGNED_BYTE : d instanceof Int16Array ? this.type = _.SHORT : d instanceof Uint16Array ? this.type = _.UNSIGNED_SHORT : d instanceof Int32Array ? this.type = _.INT : d instanceof Uint32Array && (this.type = _.UNSIGNED_INT);\n      } else this.type = c;\n\n      var f = _.GetTypeByteLength(this.type);\n\n      u ? (this._size = l || (o ? o / f : _.DeduceStride(i)), this.byteStride = o || this._buffer.byteStride || this._size * f, this.byteOffset = a || 0) : (this._size = l || o || _.DeduceStride(i), this.byteStride = o ? o * f : this._buffer.byteStride || this._size * f, this.byteOffset = (a || 0) * f), this.normalized = h, this._instanced = void 0 !== s && s, this._instanceDivisor = s ? 1 : 0;\n    }\n\n    return Object.defineProperty(_.prototype, \"instanceDivisor\", {\n      get: function () {\n        return this._instanceDivisor;\n      },\n      set: function (e) {\n        this._instanceDivisor = e, this._instanced = 0 != e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), _.prototype._rebuild = function () {\n      this._buffer && this._buffer._rebuild();\n    }, _.prototype.getKind = function () {\n      return this._kind;\n    }, _.prototype.isUpdatable = function () {\n      return this._buffer.isUpdatable();\n    }, _.prototype.getData = function () {\n      return this._buffer.getData();\n    }, _.prototype.getBuffer = function () {\n      return this._buffer.getBuffer();\n    }, _.prototype.getStrideSize = function () {\n      return this.byteStride / _.GetTypeByteLength(this.type);\n    }, _.prototype.getOffset = function () {\n      return this.byteOffset / _.GetTypeByteLength(this.type);\n    }, _.prototype.getSize = function () {\n      return this._size;\n    }, _.prototype.getIsInstanced = function () {\n      return this._instanced;\n    }, _.prototype.getInstanceDivisor = function () {\n      return this._instanceDivisor;\n    }, _.prototype.create = function (e) {\n      this._buffer.create(e);\n    }, _.prototype.update = function (e) {\n      this._buffer.update(e);\n    }, _.prototype.updateDirectly = function (e, t, i) {\n      void 0 === i && (i = !1), this._buffer.updateDirectly(e, t, void 0, i);\n    }, _.prototype.dispose = function () {\n      this._ownsBuffer && this._buffer.dispose();\n    }, _.prototype.forEach = function (e, t) {\n      _.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, e, this.normalized, t);\n    }, _.DeduceStride = function (e) {\n      switch (e) {\n        case _.UVKind:\n        case _.UV2Kind:\n        case _.UV3Kind:\n        case _.UV4Kind:\n        case _.UV5Kind:\n        case _.UV6Kind:\n          return 2;\n\n        case _.NormalKind:\n        case _.PositionKind:\n          return 3;\n\n        case _.ColorKind:\n        case _.MatricesIndicesKind:\n        case _.MatricesIndicesExtraKind:\n        case _.MatricesWeightsKind:\n        case _.MatricesWeightsExtraKind:\n        case _.TangentKind:\n          return 4;\n\n        default:\n          throw new Error(\"Invalid kind '\" + e + \"'\");\n      }\n    }, _.GetTypeByteLength = function (e) {\n      switch (e) {\n        case _.BYTE:\n        case _.UNSIGNED_BYTE:\n          return 1;\n\n        case _.SHORT:\n        case _.UNSIGNED_SHORT:\n          return 2;\n\n        case _.INT:\n        case _.FLOAT:\n          return 4;\n\n        default:\n          throw new Error(\"Invalid type '\" + e + \"'\");\n      }\n    }, _.ForEach = function (e, t, i, r, n, o, s, a) {\n      if (e instanceof Array) for (var l = t / 4, c = i / 4, h = 0; h < o; h += r) {\n        for (var u = 0; u < r; u++) a(e[l + u], h + u);\n\n        l += c;\n      } else {\n        var d = e instanceof ArrayBuffer ? new DataView(e) : new DataView(e.buffer, e.byteOffset, e.byteLength),\n            f = _.GetTypeByteLength(n);\n\n        for (h = 0; h < o; h += r) {\n          var p = t;\n\n          for (u = 0; u < r; u++) {\n            a(_._GetFloatValue(d, n, p, s), h + u), p += f;\n          }\n\n          t += i;\n        }\n      }\n    }, _._GetFloatValue = function (e, t, i, r) {\n      switch (t) {\n        case _.BYTE:\n          var n = e.getInt8(i);\n          return r && (n = Math.max(n / 127, -1)), n;\n\n        case _.UNSIGNED_BYTE:\n          n = e.getUint8(i);\n          return r && (n /= 255), n;\n\n        case _.SHORT:\n          n = e.getInt16(i, !0);\n          return r && (n = Math.max(n / 16383, -1)), n;\n\n        case _.UNSIGNED_SHORT:\n          n = e.getUint16(i, !0);\n          return r && (n /= 65535), n;\n\n        case _.FLOAT:\n          return e.getFloat32(i, !0);\n\n        default:\n          throw new Error(\"Invalid component type \" + t);\n      }\n    }, _.BYTE = 5120, _.UNSIGNED_BYTE = 5121, _.SHORT = 5122, _.UNSIGNED_SHORT = 5123, _.INT = 5124, _.UNSIGNED_INT = 5125, _.FLOAT = 5126, _.PositionKind = \"position\", _.NormalKind = \"normal\", _.TangentKind = \"tangent\", _.UVKind = \"uv\", _.UV2Kind = \"uv2\", _.UV3Kind = \"uv3\", _.UV4Kind = \"uv4\", _.UV5Kind = \"uv5\", _.UV6Kind = \"uv6\", _.ColorKind = \"color\", _.MatricesIndicesKind = \"matricesIndices\", _.MatricesWeightsKind = \"matricesWeights\", _.MatricesIndicesExtraKind = \"matricesIndicesExtra\", _.MatricesWeightsExtraKind = \"matricesWeightsExtra\", _;\n  }(), Q.VertexBuffer = Z, q = function () {\n    this.previous = null, this.next = null;\n  }, ($a || ($a = {})).DummyInternalTextureTracker = q, J = $a || ($a = {}), $ = function () {\n    function o(e, t) {\n      this.onLoadedObservable = new J.Observable(), this.previous = null, this.next = null, this._initialSlot = -1, this._designatedSlot = -1, this._dataSource = o.DATASOURCE_UNKNOWN, this._comparisonFunction = 0, this._sphericalPolynomial = null, this._lodGenerationScale = 0, this._lodGenerationOffset = 0, this._isRGBD = !1, this._references = 1, this._engine = e, this._dataSource = t, this._webGLTexture = e._createTexture();\n    }\n\n    return o.prototype.getEngine = function () {\n      return this._engine;\n    }, Object.defineProperty(o.prototype, \"dataSource\", {\n      get: function () {\n        return this._dataSource;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), o.prototype.incrementReferences = function () {\n      this._references++;\n    }, o.prototype.updateSize = function (e, t, i) {\n      void 0 === i && (i = 1), this.width = e, this.height = t, this.depth = i, this.baseWidth = e, this.baseHeight = t, this.baseDepth = i, this._size = e * t * i;\n    }, o.prototype._rebuild = function () {\n      var e,\n          t = this;\n\n      switch (this.isReady = !1, this._cachedCoordinatesMode = null, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedAnisotropicFilteringLevel = null, this._dataSource) {\n        case o.DATASOURCE_TEMP:\n          return;\n\n        case o.DATASOURCE_URL:\n          return void (e = this._engine.createTexture(this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function () {\n            t.isReady = !0;\n          }, null, this._buffer, void 0, this.format))._swapAndDie(this);\n\n        case o.DATASOURCE_RAW:\n          return (e = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression))._swapAndDie(this), void (this.isReady = !0);\n\n        case o.DATASOURCE_RAW3D:\n          return (e = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression))._swapAndDie(this), void (this.isReady = !0);\n\n        case o.DATASOURCE_DYNAMIC:\n          return void (e = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode))._swapAndDie(this);\n\n        case o.DATASOURCE_RENDERTARGET:\n          var i = new J.RenderTargetCreationOptions();\n          if (i.generateDepthBuffer = this._generateDepthBuffer, i.generateMipMaps = this.generateMipMaps, i.generateStencilBuffer = this._generateStencilBuffer, i.samplingMode = this.samplingMode, i.type = this.type, this.isCube) e = this._engine.createRenderTargetCubeTexture(this.width, i);else {\n            var r = {\n              width: this.width,\n              height: this.height\n            };\n            e = this._engine.createRenderTargetTexture(r, i);\n          }\n          return e._swapAndDie(this), void (this.isReady = !0);\n\n        case o.DATASOURCE_DEPTHTEXTURE:\n          var n = {\n            bilinearFiltering: this.samplingMode !== J.Texture.BILINEAR_SAMPLINGMODE,\n            comparisonFunction: this._comparisonFunction,\n            generateStencil: this._generateStencilBuffer,\n            isCube: this.isCube\n          };\n          return (e = this._engine.createDepthStencilTexture({\n            width: this.width,\n            height: this.height\n          }, n))._swapAndDie(this), void (this.isReady = !0);\n\n        case o.DATASOURCE_CUBE:\n          return void (e = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function () {\n            t.isReady = !0;\n          }, null, this.format, this._extension))._swapAndDie(this);\n\n        case o.DATASOURCE_CUBERAW:\n          return (e = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression))._swapAndDie(this), void (this.isReady = !0);\n\n        case o.DATASOURCE_CUBERAW_RGBD:\n          return e = this._engine.createRawCubeTexture(null, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression), J.RawCubeTexture._UpdateRGBDAsync(e, this._bufferViewArrayArray, this._sphericalPolynomial, this._lodGenerationScale, this._lodGenerationOffset).then(function () {\n            t.isReady = !0;\n          }), void e._swapAndDie(this);\n\n        case o.DATASOURCE_CUBEPREFILTERED:\n          return void ((e = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function (e) {\n            e && e._swapAndDie(t), t.isReady = !0;\n          }, null, this.format, this._extension))._sphericalPolynomial = this._sphericalPolynomial);\n      }\n    }, o.prototype._swapAndDie = function (e) {\n      e._webGLTexture = this._webGLTexture, this._framebuffer && (e._framebuffer = this._framebuffer), this._depthStencilBuffer && (e._depthStencilBuffer = this._depthStencilBuffer), this._lodTextureHigh && (e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureHigh = this._lodTextureHigh), this._lodTextureMid && (e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureMid = this._lodTextureMid), this._lodTextureLow && (e._lodTextureLow && e._lodTextureLow.dispose(), e._lodTextureLow = this._lodTextureLow);\n\n      var t = this._engine.getLoadedTexturesCache(),\n          i = t.indexOf(this);\n\n      -1 !== i && t.splice(i, 1);\n    }, o.prototype.dispose = function () {\n      this._webGLTexture && (this._references--, 0 === this._references && (this._engine._releaseTexture(this), this._webGLTexture = null, this.previous = null, this.next = null));\n    }, o.DATASOURCE_UNKNOWN = 0, o.DATASOURCE_URL = 1, o.DATASOURCE_TEMP = 2, o.DATASOURCE_RAW = 3, o.DATASOURCE_DYNAMIC = 4, o.DATASOURCE_RENDERTARGET = 5, o.DATASOURCE_MULTIRENDERTARGET = 6, o.DATASOURCE_CUBE = 7, o.DATASOURCE_CUBERAW = 8, o.DATASOURCE_CUBEPREFILTERED = 9, o.DATASOURCE_RAW3D = 10, o.DATASOURCE_DEPTHTEXTURE = 11, o.DATASOURCE_CUBERAW_RGBD = 12, o;\n  }(), J.InternalTexture = $, ee = $a || ($a = {}), te = function () {\n    function t(e) {\n      this._hasAlpha = !1, this.getAlphaFromRGB = !1, this.level = 1, this.coordinatesIndex = 0, this._coordinatesMode = ee.Texture.EXPLICIT_MODE, this.wrapU = ee.Texture.WRAP_ADDRESSMODE, this.wrapV = ee.Texture.WRAP_ADDRESSMODE, this.wrapR = ee.Texture.WRAP_ADDRESSMODE, this.anisotropicFilteringLevel = t.DEFAULT_ANISOTROPIC_FILTERING_LEVEL, this.isCube = !1, this.is3D = !1, this.gammaSpace = !0, this.invertZ = !1, this.lodLevelInAlpha = !1, this.isRenderTarget = !1, this.animations = new Array(), this.onDisposeObservable = new ee.Observable(), this.delayLoadState = ee.Engine.DELAYLOADSTATE_NONE, this._cachedSize = ee.Size.Zero(), this._scene = e || ee.Engine.LastCreatedScene, this._scene && (this._scene.textures.push(this), this._scene.onNewTextureAddedObservable.notifyObservers(this)), this._uid = null;\n    }\n\n    return Object.defineProperty(t.prototype, \"hasAlpha\", {\n      get: function () {\n        return this._hasAlpha;\n      },\n      set: function (e) {\n        this._hasAlpha !== e && (this._hasAlpha = e, this._scene && this._scene.markAllMaterialsAsDirty(ee.Material.TextureDirtyFlag | ee.Material.MiscDirtyFlag));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"coordinatesMode\", {\n      get: function () {\n        return this._coordinatesMode;\n      },\n      set: function (e) {\n        this._coordinatesMode !== e && (this._coordinatesMode = e, this._scene && this._scene.markAllMaterialsAsDirty(ee.Material.TextureDirtyFlag));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"isRGBD\", {\n      get: function () {\n        return null != this._texture && this._texture._isRGBD;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"lodGenerationOffset\", {\n      get: function () {\n        return this._texture ? this._texture._lodGenerationOffset : 0;\n      },\n      set: function (e) {\n        this._texture && (this._texture._lodGenerationOffset = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"lodGenerationScale\", {\n      get: function () {\n        return this._texture ? this._texture._lodGenerationScale : 0;\n      },\n      set: function (e) {\n        this._texture && (this._texture._lodGenerationScale = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"uid\", {\n      get: function () {\n        return this._uid || (this._uid = ee.Tools.RandomId()), this._uid;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.prototype.toString = function () {\n      return this.name;\n    }, t.prototype.getClassName = function () {\n      return \"BaseTexture\";\n    }, Object.defineProperty(t.prototype, \"onDispose\", {\n      set: function (e) {\n        this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"isBlocking\", {\n      get: function () {\n        return !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.prototype.getScene = function () {\n      return this._scene;\n    }, t.prototype.getTextureMatrix = function () {\n      return ee.Matrix.IdentityReadOnly;\n    }, t.prototype.getReflectionTextureMatrix = function () {\n      return ee.Matrix.IdentityReadOnly;\n    }, t.prototype.getInternalTexture = function () {\n      return this._texture;\n    }, t.prototype.isReadyOrNotBlocking = function () {\n      return !this.isBlocking || this.isReady();\n    }, t.prototype.isReady = function () {\n      return this.delayLoadState === ee.Engine.DELAYLOADSTATE_NOTLOADED ? (this.delayLoad(), !1) : !!this._texture && this._texture.isReady;\n    }, t.prototype.getSize = function () {\n      if (this._texture) {\n        if (this._texture.width) return this._cachedSize.width = this._texture.width, this._cachedSize.height = this._texture.height, this._cachedSize;\n        if (this._texture._size) return this._cachedSize.width = this._texture._size, this._cachedSize.height = this._texture._size, this._cachedSize;\n      }\n\n      return this._cachedSize;\n    }, t.prototype.getBaseSize = function () {\n      return this.isReady() && this._texture ? this._texture._size ? new ee.Size(this._texture._size, this._texture._size) : new ee.Size(this._texture.baseWidth, this._texture.baseHeight) : ee.Size.Zero();\n    }, t.prototype.scale = function (e) {}, Object.defineProperty(t.prototype, \"canRescale\", {\n      get: function () {\n        return !1;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.prototype._getFromCache = function (e, t, i) {\n      if (!this._scene) return null;\n\n      for (var r = this._scene.getEngine().getLoadedTexturesCache(), n = 0; n < r.length; n++) {\n        var o = r[n];\n        if (o.url === e && o.generateMipMaps === !t && (!i || i === o.samplingMode)) return o.incrementReferences(), o;\n      }\n\n      return null;\n    }, t.prototype._rebuild = function () {}, t.prototype.delayLoad = function () {}, t.prototype.clone = function () {\n      return null;\n    }, Object.defineProperty(t.prototype, \"textureType\", {\n      get: function () {\n        return this._texture && void 0 !== this._texture.type ? this._texture.type : ee.Engine.TEXTURETYPE_UNSIGNED_INT;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"textureFormat\", {\n      get: function () {\n        return this._texture && void 0 !== this._texture.format ? this._texture.format : ee.Engine.TEXTUREFORMAT_RGBA;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.prototype.readPixels = function (e, t, i) {\n      if (void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = null), !this._texture) return null;\n      var r = this.getSize(),\n          n = r.width,\n          o = r.height,\n          s = this.getScene();\n      if (!s) return null;\n      var a = s.getEngine();\n      return 0 != t && (n /= Math.pow(2, t), o /= Math.pow(2, t), n = Math.round(n), o = Math.round(o)), this._texture.isCube ? a._readTexturePixels(this._texture, n, o, e, t, i) : a._readTexturePixels(this._texture, n, o, -1, t, i);\n    }, t.prototype.releaseInternalTexture = function () {\n      this._texture && (this._texture.dispose(), this._texture = null);\n    }, Object.defineProperty(t.prototype, \"sphericalPolynomial\", {\n      get: function () {\n        return this._texture && ee.CubeMapToSphericalPolynomialTools && this.isReady() ? (this._texture._sphericalPolynomial || (this._texture._sphericalPolynomial = ee.CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this)), this._texture._sphericalPolynomial) : null;\n      },\n      set: function (e) {\n        this._texture && (this._texture._sphericalPolynomial = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"_lodTextureHigh\", {\n      get: function () {\n        return this._texture ? this._texture._lodTextureHigh : null;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"_lodTextureMid\", {\n      get: function () {\n        return this._texture ? this._texture._lodTextureMid : null;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"_lodTextureLow\", {\n      get: function () {\n        return this._texture ? this._texture._lodTextureLow : null;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.prototype.dispose = function () {\n      if (this._scene) {\n        this._scene.stopAnimation(this), this._scene._removePendingData(this);\n\n        var e = this._scene.textures.indexOf(this);\n\n        0 <= e && this._scene.textures.splice(e, 1), this._scene.onTextureRemovedObservable.notifyObservers(this), void 0 !== this._texture && (this.releaseInternalTexture(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear());\n      }\n    }, t.prototype.serialize = function () {\n      if (!this.name) return null;\n      var e = ee.SerializationHelper.Serialize(this);\n      return ee.Animation.AppendSerializedAnimations(this, e), e;\n    }, t.WhenAllReady = function (t, i) {\n      var r = t.length;\n      if (0 !== r) for (var n, o, e = function () {\n        if ((n = t[s]).isReady()) 0 == --r && i();else {\n          o = n.onLoadObservable;\n\n          var e = function () {\n            o.removeCallback(e), 0 == --r && i();\n          };\n\n          o.add(e);\n        }\n      }, s = 0; s < t.length; s++) e();else i();\n    }, t.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4, b([ee.serialize()], t.prototype, \"name\", void 0), b([ee.serialize(\"hasAlpha\")], t.prototype, \"_hasAlpha\", void 0), b([ee.serialize()], t.prototype, \"getAlphaFromRGB\", void 0), b([ee.serialize()], t.prototype, \"level\", void 0), b([ee.serialize()], t.prototype, \"coordinatesIndex\", void 0), b([ee.serialize(\"coordinatesMode\")], t.prototype, \"_coordinatesMode\", void 0), b([ee.serialize()], t.prototype, \"wrapU\", void 0), b([ee.serialize()], t.prototype, \"wrapV\", void 0), b([ee.serialize()], t.prototype, \"wrapR\", void 0), b([ee.serialize()], t.prototype, \"anisotropicFilteringLevel\", void 0), b([ee.serialize()], t.prototype, \"isCube\", void 0), b([ee.serialize()], t.prototype, \"is3D\", void 0), b([ee.serialize()], t.prototype, \"gammaSpace\", void 0), b([ee.serialize()], t.prototype, \"invertZ\", void 0), b([ee.serialize()], t.prototype, \"lodLevelInAlpha\", void 0), b([ee.serialize()], t.prototype, \"lodGenerationOffset\", null), b([ee.serialize()], t.prototype, \"lodGenerationScale\", null), b([ee.serialize()], t.prototype, \"isRenderTarget\", void 0), t;\n  }(), ee.BaseTexture = te, ie = $a || ($a = {}), re = function (d) {\n    function f(e, t, i, r, n, o, s, a, l, c) {\n      void 0 === i && (i = !1), void 0 === r && (r = !0), void 0 === n && (n = f.TRILINEAR_SAMPLINGMODE), void 0 === o && (o = null), void 0 === s && (s = null), void 0 === a && (a = null), void 0 === l && (l = !1);\n      var h = d.call(this, t) || this;\n      if (h.uOffset = 0, h.vOffset = 0, h.uScale = 1, h.vScale = 1, h.uAng = 0, h.vAng = 0, h.wAng = 0, h.uRotationCenter = .5, h.vRotationCenter = .5, h.wRotationCenter = .5, h.onLoadObservable = new ie.Observable(), h._isBlocking = !0, h.name = e || \"\", h.url = e, h._noMipmap = i, h._invertY = r, h._samplingMode = n, h._buffer = a, h._deleteBuffer = l, c && (h._format = c), !(t = h.getScene())) return h;\n      t.getEngine().onBeforeTextureInitObservable.notifyObservers(h);\n\n      var u = function () {\n        h.onLoadObservable.hasObservers() && h.onLoadObservable.notifyObservers(h), o && o(), !h.isBlocking && t && t.resetCachedMaterial();\n      };\n\n      return h.url ? (h._texture = h._getFromCache(h.url, i, n), h._texture ? h._texture.isReady ? ie.Tools.SetImmediate(function () {\n        return u();\n      }) : h._texture.onLoadedObservable.add(u) : t.useDelayedTextureLoading ? (h.delayLoadState = ie.Engine.DELAYLOADSTATE_NOTLOADED, h._delayedOnLoad = u, h._delayedOnError = s) : (h._texture = t.getEngine().createTexture(h.url, i, r, t, h._samplingMode, u, s, h._buffer, void 0, h._format), l && delete h._buffer)) : (h._delayedOnLoad = u, h._delayedOnError = s), h;\n    }\n\n    return T(f, d), Object.defineProperty(f.prototype, \"noMipmap\", {\n      get: function () {\n        return this._noMipmap;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(f.prototype, \"isBlocking\", {\n      get: function () {\n        return this._isBlocking;\n      },\n      set: function (e) {\n        this._isBlocking = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(f.prototype, \"samplingMode\", {\n      get: function () {\n        return this._samplingMode;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), f.prototype.updateURL = function (e, t) {\n      if (void 0 === t && (t = null), this.url) throw new Error(\"URL is already set\");\n      this.url = e, this._buffer = t, this.delayLoadState = ie.Engine.DELAYLOADSTATE_NOTLOADED, this.delayLoad();\n    }, f.prototype.delayLoad = function () {\n      if (this.delayLoadState === ie.Engine.DELAYLOADSTATE_NOTLOADED) {\n        var e = this.getScene();\n        e && (this.delayLoadState = ie.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap, this._samplingMode), this._texture ? this._delayedOnLoad && (this._texture.isReady ? ie.Tools.SetImmediate(this._delayedOnLoad) : this._texture.onLoadedObservable.add(this._delayedOnLoad)) : (this._texture = e.getEngine().createTexture(this.url, this._noMipmap, this._invertY, e, this._samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format), this._deleteBuffer && delete this._buffer), this._delayedOnLoad = null, this._delayedOnError = null);\n      }\n    }, f.prototype.updateSamplingMode = function (e) {\n      if (this._texture) {\n        var t = this.getScene();\n        t && (this._samplingMode = e, t.getEngine().updateTextureSamplingMode(e, this._texture));\n      }\n    }, f.prototype._prepareRowForTextureGeneration = function (e, t, i, r) {\n      e *= this.uScale, t *= this.vScale, e -= this.uRotationCenter * this.uScale, t -= this.vRotationCenter * this.vScale, i -= this.wRotationCenter, ie.Vector3.TransformCoordinatesFromFloatsToRef(e, t, i, this._rowGenerationMatrix, r), r.x += this.uRotationCenter * this.uScale + this.uOffset, r.y += this.vRotationCenter * this.vScale + this.vOffset, r.z += this.wRotationCenter;\n    }, f.prototype.getTextureMatrix = function () {\n      var t = this;\n      if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng) return this._cachedTextureMatrix;\n      this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedTextureMatrix || (this._cachedTextureMatrix = ie.Matrix.Zero(), this._rowGenerationMatrix = new ie.Matrix(), this._t0 = ie.Vector3.Zero(), this._t1 = ie.Vector3.Zero(), this._t2 = ie.Vector3.Zero()), ie.Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), ie.Matrix.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix.m[0] = this._t1.x, this._cachedTextureMatrix.m[1] = this._t1.y, this._cachedTextureMatrix.m[2] = this._t1.z, this._cachedTextureMatrix.m[4] = this._t2.x, this._cachedTextureMatrix.m[5] = this._t2.y, this._cachedTextureMatrix.m[6] = this._t2.z, this._cachedTextureMatrix.m[8] = this._t0.x, this._cachedTextureMatrix.m[9] = this._t0.y, this._cachedTextureMatrix.m[10] = this._t0.z;\n      var e = this.getScene();\n      return e && e.markAllMaterialsAsDirty(ie.Material.TextureDirtyFlag, function (e) {\n        return e.hasTexture(t);\n      }), this._cachedTextureMatrix;\n    }, f.prototype.getReflectionTextureMatrix = function () {\n      var t = this,\n          e = this.getScene();\n      if (!e) return this._cachedTextureMatrix;\n\n      if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) {\n        if (this.coordinatesMode !== f.PROJECTION_MODE) return this._cachedTextureMatrix;\n        if (this._cachedProjectionMatrixId === e.getProjectionMatrix().updateFlag) return this._cachedTextureMatrix;\n      }\n\n      switch (this._cachedTextureMatrix || (this._cachedTextureMatrix = ie.Matrix.Zero()), this._projectionModeMatrix || (this._projectionModeMatrix = ie.Matrix.Zero()), this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale, this._cachedVScale = this.vScale, this._cachedCoordinatesMode = this.coordinatesMode, this.coordinatesMode) {\n        case f.PLANAR_MODE:\n          ie.Matrix.IdentityToRef(this._cachedTextureMatrix), this._cachedTextureMatrix[0] = this.uScale, this._cachedTextureMatrix[5] = this.vScale, this._cachedTextureMatrix[12] = this.uOffset, this._cachedTextureMatrix[13] = this.vOffset;\n          break;\n\n        case f.PROJECTION_MODE:\n          ie.Matrix.IdentityToRef(this._projectionModeMatrix), this._projectionModeMatrix.m[0] = .5, this._projectionModeMatrix.m[5] = -.5, this._projectionModeMatrix.m[10] = 0, this._projectionModeMatrix.m[12] = .5, this._projectionModeMatrix.m[13] = .5, this._projectionModeMatrix.m[14] = 1, this._projectionModeMatrix.m[15] = 1;\n          var i = e.getProjectionMatrix();\n          this._cachedProjectionMatrixId = i.updateFlag, i.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);\n          break;\n\n        default:\n          ie.Matrix.IdentityToRef(this._cachedTextureMatrix);\n      }\n\n      return e.markAllMaterialsAsDirty(ie.Material.TextureDirtyFlag, function (e) {\n        return -1 !== e.getActiveTextures().indexOf(t);\n      }), this._cachedTextureMatrix;\n    }, f.prototype.clone = function () {\n      var e = this;\n      return ie.SerializationHelper.Clone(function () {\n        return new f(e._texture ? e._texture.url : null, e.getScene(), e._noMipmap, e._invertY, e._samplingMode);\n      }, this);\n    }, f.prototype.serialize = function () {\n      var e = d.prototype.serialize.call(this);\n      return \"string\" == typeof this._buffer && \"data:\" === this._buffer.substr(0, 5) && (e.base64String = this._buffer, e.name = e.name.replace(\"data:\", \"\")), e.invertY = this._invertY, e.samplingMode = this.samplingMode, e;\n    }, f.prototype.getClassName = function () {\n      return \"Texture\";\n    }, f.prototype.dispose = function () {\n      d.prototype.dispose.call(this), this.onLoadObservable.clear(), this._delayedOnLoad = null, this._delayedOnError = null;\n    }, f.Parse = function (o, s, a) {\n      if (o.customType) {\n        var e = ie.Tools.Instantiate(o.customType).Parse(o, s, a);\n        return o.samplingMode && e.updateSamplingMode && e._samplingMode && e._samplingMode !== o.samplingMode && e.updateSamplingMode(o.samplingMode), e;\n      }\n\n      if (o.isCube) return ie.CubeTexture.Parse(o, s, a);\n      if (!o.name && !o.isRenderTarget) return null;\n      var t = ie.SerializationHelper.Parse(function () {\n        var e,\n            t = !0;\n\n        if (o.noMipmap && (t = !1), o.mirrorPlane) {\n          var i = new ie.MirrorTexture(o.name, o.renderTargetSize, s, t);\n          return i._waitingRenderList = o.renderList, i.mirrorPlane = ie.Plane.FromArray(o.mirrorPlane), i;\n        }\n\n        if (o.isRenderTarget) {\n          var r = new ie.RenderTargetTexture(o.name, o.renderTargetSize, s, t);\n          return r._waitingRenderList = o.renderList, r;\n        }\n\n        if (o.base64String) e = f.CreateFromBase64String(o.base64String, o.name, s, !t);else {\n          var n = a + o.name;\n          f.UseSerializedUrlIfAny && o.url && (n = o.url), e = new f(n, s, !t, o.invertY);\n        }\n        return e;\n      }, o, s);\n\n      if (o.samplingMode) {\n        var i = o.samplingMode;\n        t._samplingMode !== i && t.updateSamplingMode(i);\n      }\n\n      if (o.animations) for (var r = 0; r < o.animations.length; r++) {\n        var n = o.animations[r];\n        t.animations.push(ie.Animation.Parse(n));\n      }\n      return t;\n    }, f.CreateFromBase64String = function (e, t, i, r, n, o, s, a, l) {\n      return void 0 === o && (o = f.TRILINEAR_SAMPLINGMODE), void 0 === s && (s = null), void 0 === a && (a = null), void 0 === l && (l = ie.Engine.TEXTUREFORMAT_RGBA), new f(\"data:\" + t, i, r, n, o, s, a, e, !1, l);\n    }, f.LoadFromDataString = function (e, t, i, r, n, o, s, a, l, c) {\n      return void 0 === r && (r = !1), void 0 === n && (n = !1), void 0 === o && (o = !0), void 0 === s && (s = f.TRILINEAR_SAMPLINGMODE), void 0 === a && (a = null), void 0 === l && (l = null), void 0 === c && (c = ie.Engine.TEXTUREFORMAT_RGBA), \"data:\" !== e.substr(0, 5) && (e = \"data:\" + e), new f(e, i, n, o, s, a, l, t, r, c);\n    }, f.NEAREST_SAMPLINGMODE = ie.Engine.TEXTURE_NEAREST_SAMPLINGMODE, f.NEAREST_NEAREST_MIPLINEAR = ie.Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR, f.BILINEAR_SAMPLINGMODE = ie.Engine.TEXTURE_BILINEAR_SAMPLINGMODE, f.LINEAR_LINEAR_MIPNEAREST = ie.Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST, f.TRILINEAR_SAMPLINGMODE = ie.Engine.TEXTURE_TRILINEAR_SAMPLINGMODE, f.LINEAR_LINEAR_MIPLINEAR = ie.Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR, f.NEAREST_NEAREST_MIPNEAREST = ie.Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST, f.NEAREST_LINEAR_MIPNEAREST = ie.Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST, f.NEAREST_LINEAR_MIPLINEAR = ie.Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR, f.NEAREST_LINEAR = ie.Engine.TEXTURE_NEAREST_LINEAR, f.NEAREST_NEAREST = ie.Engine.TEXTURE_NEAREST_NEAREST, f.LINEAR_NEAREST_MIPNEAREST = ie.Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST, f.LINEAR_NEAREST_MIPLINEAR = ie.Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR, f.LINEAR_LINEAR = ie.Engine.TEXTURE_LINEAR_LINEAR, f.LINEAR_NEAREST = ie.Engine.TEXTURE_LINEAR_NEAREST, f.EXPLICIT_MODE = ie.Engine.TEXTURE_EXPLICIT_MODE, f.SPHERICAL_MODE = ie.Engine.TEXTURE_SPHERICAL_MODE, f.PLANAR_MODE = ie.Engine.TEXTURE_PLANAR_MODE, f.CUBIC_MODE = ie.Engine.TEXTURE_CUBIC_MODE, f.PROJECTION_MODE = ie.Engine.TEXTURE_PROJECTION_MODE, f.SKYBOX_MODE = ie.Engine.TEXTURE_SKYBOX_MODE, f.INVCUBIC_MODE = ie.Engine.TEXTURE_INVCUBIC_MODE, f.EQUIRECTANGULAR_MODE = ie.Engine.TEXTURE_EQUIRECTANGULAR_MODE, f.FIXED_EQUIRECTANGULAR_MODE = ie.Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MODE, f.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = ie.Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE, f.CLAMP_ADDRESSMODE = ie.Engine.TEXTURE_CLAMP_ADDRESSMODE, f.WRAP_ADDRESSMODE = ie.Engine.TEXTURE_WRAP_ADDRESSMODE, f.MIRROR_ADDRESSMODE = ie.Engine.TEXTURE_MIRROR_ADDRESSMODE, f.UseSerializedUrlIfAny = !1, b([ie.serialize()], f.prototype, \"url\", void 0), b([ie.serialize()], f.prototype, \"uOffset\", void 0), b([ie.serialize()], f.prototype, \"vOffset\", void 0), b([ie.serialize()], f.prototype, \"uScale\", void 0), b([ie.serialize()], f.prototype, \"vScale\", void 0), b([ie.serialize()], f.prototype, \"uAng\", void 0), b([ie.serialize()], f.prototype, \"vAng\", void 0), b([ie.serialize()], f.prototype, \"wAng\", void 0), b([ie.serialize()], f.prototype, \"uRotationCenter\", void 0), b([ie.serialize()], f.prototype, \"vRotationCenter\", void 0), b([ie.serialize()], f.prototype, \"wRotationCenter\", void 0), b([ie.serialize()], f.prototype, \"isBlocking\", null), f;\n  }(ie.BaseTexture), ie.Texture = re, function (S) {\n    var e = function () {};\n\n    S._CreationDataStorage = e;\n\n    var m = function () {\n      this.visibleInstances = {}, this.renderIdForInstances = new Array(), this.batchCache = new t(), this.instancesBufferSize = 2048;\n    },\n        t = function () {\n      this.mustReturn = !1, this.visibleInstances = new Array(), this.renderSelf = new Array();\n    };\n\n    S._InstancesBatch = t;\n\n    var i = function (v) {\n      function _(e, t, i, r, n, o) {\n        void 0 === t && (t = null), void 0 === i && (i = null), void 0 === r && (r = null), void 0 === o && (o = !0);\n        var s = v.call(this, e, t) || this;\n\n        if (s.delayLoadState = S.Engine.DELAYLOADSTATE_NONE, s.instances = new Array(), s._LODLevels = new Array(), s._instanceDataStorage = new m(), s._originalBuilderSideOrientation = _.DEFAULTSIDE, s.overrideMaterialSideOrientation = null, s._areNormalsFrozen = !1, s._source = null, t = s.getScene(), r) {\n          if (r._geometry && r._geometry.applyToMesh(s), S.Tools.DeepCopy(r, s, [\"name\", \"material\", \"skeleton\", \"instances\", \"parent\", \"uniqueId\", \"source\", \"metadata\", \"hasLODLevels\", \"geometry\", \"isBlocked\", \"areNormalsFrozen\", \"onBeforeDrawObservable\", \"onBeforeRenderObservable\", \"onAfterRenderObservable\", \"onBeforeDraw\"], [\"_poseMatrix\"]), s._source = r, s._originalBuilderSideOrientation = r._originalBuilderSideOrientation, s._creationDataStorage = r._creationDataStorage, s._source._ranges) {\n            var a = s._source._ranges;\n\n            for (var e in a) a.hasOwnProperty(e) && a[e] && s.createAnimationRange(e, a[e].from, a[e].to);\n          }\n\n          var l;\n          if (r.metadata && r.metadata.clone ? s.metadata = r.metadata.clone() : s.metadata = r.metadata, S.Tags && S.Tags.HasTags(r) && S.Tags.AddTagsTo(s, S.Tags.GetTags(r, !0)), s.parent = r.parent, s.setPivotMatrix(r.getPivotMatrix()), s.id = e + \".\" + r.id, s.material = r.material, !n) for (var c = r.getDescendants(!0), h = 0; h < c.length; h++) {\n            var u = c[h];\n            u.clone && u.clone(e + \".\" + u.name, s);\n          }\n          var d = s.getScene().getPhysicsEngine();\n\n          if (o && d) {\n            var f = d.getImpostorForPhysicsObject(r);\n            f && (s.physicsImpostor = f.clone(s));\n          }\n\n          for (l = 0; l < t.particleSystems.length; l++) {\n            var p = t.particleSystems[l];\n            p.emitter === r && p.clone(p.name, s);\n          }\n\n          s.refreshBoundingInfo(), s.computeWorldMatrix(!0);\n        }\n\n        return null !== i && (s.parent = i), s;\n      }\n\n      return T(_, v), Object.defineProperty(_.prototype, \"onBeforeRenderObservable\", {\n        get: function () {\n          return this._onBeforeRenderObservable || (this._onBeforeRenderObservable = new S.Observable()), this._onBeforeRenderObservable;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(_.prototype, \"onAfterRenderObservable\", {\n        get: function () {\n          return this._onAfterRenderObservable || (this._onAfterRenderObservable = new S.Observable()), this._onAfterRenderObservable;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(_.prototype, \"onBeforeDrawObservable\", {\n        get: function () {\n          return this._onBeforeDrawObservable || (this._onBeforeDrawObservable = new S.Observable()), this._onBeforeDrawObservable;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(_.prototype, \"onBeforeDraw\", {\n        set: function (e) {\n          this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver), this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(_.prototype, \"morphTargetManager\", {\n        get: function () {\n          return this._morphTargetManager;\n        },\n        set: function (e) {\n          this._morphTargetManager !== e && (this._morphTargetManager = e, this._syncGeometryWithMorphTargetManager());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(_.prototype, \"source\", {\n        get: function () {\n          return this._source;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(_.prototype, \"isUnIndexed\", {\n        get: function () {\n          return this._unIndexed;\n        },\n        set: function (e) {\n          this._unIndexed !== e && (this._unIndexed = e, this._markSubMeshesAsAttributesDirty());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), _.prototype.getClassName = function () {\n        return \"Mesh\";\n      }, _.prototype.toString = function (e) {\n        var t = v.prototype.toString.call(this, e);\n        if (t += \", n vertices: \" + this.getTotalVertices(), t += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\"), this.animations) for (var i = 0; i < this.animations.length; i++) t += \", animation[0]: \" + this.animations[i].toString(e);\n        if (e) if (this._geometry) {\n          var r = this.getIndices(),\n              n = this.getVerticesData(S.VertexBuffer.PositionKind);\n          n && r && (t += \", flat shading: \" + (n.length / 3 === r.length ? \"YES\" : \"NO\"));\n        } else t += \", flat shading: UNKNOWN\";\n        return t;\n      }, _.prototype._unBindEffect = function () {\n        v.prototype._unBindEffect.call(this);\n\n        for (var e = 0, t = this.instances; e < t.length; e++) {\n          t[e]._unBindEffect();\n        }\n      }, Object.defineProperty(_.prototype, \"hasLODLevels\", {\n        get: function () {\n          return 0 < this._LODLevels.length;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), _.prototype.getLODLevels = function () {\n        return this._LODLevels;\n      }, _.prototype._sortLODLevels = function () {\n        this._LODLevels.sort(function (e, t) {\n          return e.distance < t.distance ? 1 : e.distance > t.distance ? -1 : 0;\n        });\n      }, _.prototype.addLODLevel = function (e, t) {\n        if (t && t._masterMesh) return S.Tools.Warn(\"You cannot use a mesh as LOD level twice\"), this;\n        var i = new S.MeshLODLevel(e, t);\n        return this._LODLevels.push(i), t && (t._masterMesh = this), this._sortLODLevels(), this;\n      }, _.prototype.getLODLevelAtDistance = function (e) {\n        for (var t = 0; t < this._LODLevels.length; t++) {\n          var i = this._LODLevels[t];\n          if (i.distance === e) return i.mesh;\n        }\n\n        return null;\n      }, _.prototype.removeLODLevel = function (e) {\n        for (var t = 0; t < this._LODLevels.length; t++) this._LODLevels[t].mesh === e && (this._LODLevels.splice(t, 1), e && (e._masterMesh = null));\n\n        return this._sortLODLevels(), this;\n      }, _.prototype.getLOD = function (e, t) {\n        if (!this._LODLevels || 0 === this._LODLevels.length) return this;\n        var i;\n        t ? i = t : i = this.getBoundingInfo().boundingSphere;\n        var r = i.centerWorld.subtract(e.globalPosition).length();\n        if (this._LODLevels[this._LODLevels.length - 1].distance > r) return this.onLODLevelSelection && this.onLODLevelSelection(r, this, this._LODLevels[this._LODLevels.length - 1].mesh), this;\n\n        for (var n = 0; n < this._LODLevels.length; n++) {\n          var o = this._LODLevels[n];\n          if (o.distance < r) return o.mesh && (o.mesh._preActivate(), o.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)), this.onLODLevelSelection && this.onLODLevelSelection(r, this, o.mesh), o.mesh;\n        }\n\n        return this.onLODLevelSelection && this.onLODLevelSelection(r, this, this), this;\n      }, Object.defineProperty(_.prototype, \"geometry\", {\n        get: function () {\n          return this._geometry;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), _.prototype.getTotalVertices = function () {\n        return null === this._geometry || void 0 === this._geometry ? 0 : this._geometry.getTotalVertices();\n      }, _.prototype.getVerticesData = function (e, t, i) {\n        return this._geometry ? this._geometry.getVerticesData(e, t, i) : null;\n      }, _.prototype.getVertexBuffer = function (e) {\n        return this._geometry ? this._geometry.getVertexBuffer(e) : null;\n      }, _.prototype.isVerticesDataPresent = function (e) {\n        return this._geometry ? this._geometry.isVerticesDataPresent(e) : !!this._delayInfo && -1 !== this._delayInfo.indexOf(e);\n      }, _.prototype.isVertexBufferUpdatable = function (e) {\n        return this._geometry ? this._geometry.isVertexBufferUpdatable(e) : !!this._delayInfo && -1 !== this._delayInfo.indexOf(e);\n      }, _.prototype.getVerticesDataKinds = function () {\n        if (!this._geometry) {\n          var r = new Array();\n          return this._delayInfo && this._delayInfo.forEach(function (e, t, i) {\n            r.push(e);\n          }), r;\n        }\n\n        return this._geometry.getVerticesDataKinds();\n      }, _.prototype.getTotalIndices = function () {\n        return this._geometry ? this._geometry.getTotalIndices() : 0;\n      }, _.prototype.getIndices = function (e, t) {\n        return this._geometry ? this._geometry.getIndices(e, t) : [];\n      }, Object.defineProperty(_.prototype, \"isBlocked\", {\n        get: function () {\n          return null !== this._masterMesh && void 0 !== this._masterMesh;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), _.prototype.isReady = function (e, t) {\n        if (void 0 === e && (e = !1), void 0 === t && (t = !1), this.delayLoadState === S.Engine.DELAYLOADSTATE_LOADING) return !1;\n        if (!v.prototype.isReady.call(this, e)) return !1;\n        if (!this.subMeshes || 0 === this.subMeshes.length) return !0;\n        if (!e) return !0;\n        var i = this.getEngine(),\n            r = this.getScene(),\n            n = t || i.getCaps().instancedArrays && 0 < this.instances.length;\n        this.computeWorldMatrix();\n        var o = this.material || r.defaultMaterial;\n        if (o) if (o.storeEffectOnSubMeshes) for (var s = 0, a = this.subMeshes; s < a.length; s++) {\n          var l = (p = a[s]).getMaterial();\n          if (l) if (l.storeEffectOnSubMeshes) {\n            if (!l.isReadyForSubMesh(this, p, n)) return !1;\n          } else if (!l.isReady(this, n)) return !1;\n        } else if (!o.isReady(this, n)) return !1;\n\n        for (var c = 0, h = this._lightSources; c < h.length; c++) {\n          var u = h[c].getShadowGenerator();\n          if (u) for (var d = 0, f = this.subMeshes; d < f.length; d++) {\n            var p = f[d];\n            if (!u.isReady(p, n)) return !1;\n          }\n        }\n\n        for (var _ = 0, m = this._LODLevels; _ < m.length; _++) {\n          var g = m[_];\n          if (g.mesh && !g.mesh.isReady(n)) return !1;\n        }\n\n        return !0;\n      }, Object.defineProperty(_.prototype, \"areNormalsFrozen\", {\n        get: function () {\n          return this._areNormalsFrozen;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), _.prototype.freezeNormals = function () {\n        return this._areNormalsFrozen = !0, this;\n      }, _.prototype.unfreezeNormals = function () {\n        return this._areNormalsFrozen = !1, this;\n      }, Object.defineProperty(_.prototype, \"overridenInstanceCount\", {\n        set: function (e) {\n          this._instanceDataStorage.overridenInstanceCount = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), _.prototype._preActivate = function () {\n        var e = this.getScene().getRenderId();\n        return this._preActivateId === e || (this._preActivateId = e, this._instanceDataStorage.visibleInstances = null), this;\n      }, _.prototype._preActivateForIntermediateRendering = function (e) {\n        return this._instanceDataStorage.visibleInstances && (this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = e), this;\n      }, _.prototype._registerInstanceForRenderId = function (e, t) {\n        return this._instanceDataStorage.visibleInstances || (this._instanceDataStorage.visibleInstances = {}, this._instanceDataStorage.visibleInstances.defaultRenderId = t, this._instanceDataStorage.visibleInstances.selfDefaultRenderId = this._renderId), this._instanceDataStorage.visibleInstances[t] || (this._instanceDataStorage.visibleInstances[t] = new Array()), this._instanceDataStorage.visibleInstances[t].push(e), this;\n      }, _.prototype.refreshBoundingInfo = function () {\n        return this._refreshBoundingInfo(!1);\n      }, _.prototype._refreshBoundingInfo = function (e) {\n        if (this._boundingInfo && this._boundingInfo.isLocked) return this;\n\n        var t = this._getPositionData(e);\n\n        if (t) {\n          var i = this.geometry ? this.geometry.boundingBias : null,\n              r = S.Tools.ExtractMinAndMax(t, 0, this.getTotalVertices(), i);\n          this._boundingInfo = new S.BoundingInfo(r.minimum, r.maximum);\n        }\n\n        if (this.subMeshes) for (var n = 0; n < this.subMeshes.length; n++) this.subMeshes[n].refreshBoundingInfo();\n        return this._updateBoundingInfo(), this;\n      }, _.prototype._getPositionData = function (e) {\n        var t = this.getVerticesData(S.VertexBuffer.PositionKind);\n\n        if (t && e && this.skeleton) {\n          t = S.Tools.Slice(t);\n          var i = this.getVerticesData(S.VertexBuffer.MatricesIndicesKind),\n              r = this.getVerticesData(S.VertexBuffer.MatricesWeightsKind);\n          if (r && i) for (var n = 4 < this.numBoneInfluencers, o = n ? this.getVerticesData(S.VertexBuffer.MatricesIndicesExtraKind) : null, s = n ? this.getVerticesData(S.VertexBuffer.MatricesWeightsExtraKind) : null, a = this.skeleton.getTransformMatrices(this), l = S.Tmp.Vector3[0], c = S.Tmp.Matrix[0], h = S.Tmp.Matrix[1], u = 0, d = 0; d < t.length; d += 3, u += 4) {\n            var f, p;\n\n            for (c.reset(), f = 0; f < 4; f++) 0 < (p = r[u + f]) && (S.Matrix.FromFloat32ArrayToRefScaled(a, Math.floor(16 * i[u + f]), p, h), c.addToSelf(h));\n\n            if (n) for (f = 0; f < 4; f++) 0 < (p = s[u + f]) && (S.Matrix.FromFloat32ArrayToRefScaled(a, Math.floor(16 * o[u + f]), p, h), c.addToSelf(h));\n            S.Vector3.TransformCoordinatesFromFloatsToRef(t[d], t[d + 1], t[d + 2], c, l), l.toArray(t, d);\n          }\n        }\n\n        return t;\n      }, _.prototype._createGlobalSubMesh = function (e) {\n        var t = this.getTotalVertices();\n        if (!t || !this.getIndices()) return null;\n\n        if (this.subMeshes && 0 < this.subMeshes.length) {\n          var i = this.getIndices();\n          if (!i) return null;\n          var r = i.length,\n              n = !1;\n          if (e) n = !0;else for (var o = 0, s = this.subMeshes; o < s.length; o++) {\n            var a = s[o];\n\n            if (a.indexStart + a.indexCount >= r) {\n              n = !0;\n              break;\n            }\n\n            if (a.verticesStart + a.verticesCount >= t) {\n              n = !0;\n              break;\n            }\n          }\n          if (!n) return this.subMeshes[0];\n        }\n\n        return this.releaseSubMeshes(), new S.SubMesh(0, 0, t, 0, this.getTotalIndices(), this);\n      }, _.prototype.subdivide = function (e) {\n        if (!(e < 1)) {\n          for (var t = this.getTotalIndices(), i = t / e | 0, r = 0; i % 3 != 0;) i++;\n\n          this.releaseSubMeshes();\n\n          for (var n = 0; n < e && !(t <= r); n++) S.SubMesh.CreateFromIndices(0, r, Math.min(i, t - r), this), r += i;\n\n          this.synchronizeInstances();\n        }\n      }, _.prototype.setVerticesData = function (e, t, i, r) {\n        if (void 0 === i && (i = !1), this._geometry) this._geometry.setVerticesData(e, t, i, r);else {\n          var n = new S.VertexData();\n          n.set(t, e);\n          var o = this.getScene();\n          new S.Geometry(S.Geometry.RandomId(), o, n, i, this);\n        }\n        return this;\n      }, _.prototype.markVerticesDataAsUpdatable = function (e, t) {\n        void 0 === t && (t = !0);\n        var i = this.getVertexBuffer(e);\n        i && i.isUpdatable() !== t && this.setVerticesData(e, this.getVerticesData(e), t);\n      }, _.prototype.setVerticesBuffer = function (e) {\n        return this._geometry || (this._geometry = S.Geometry.CreateGeometryForMesh(this)), this._geometry.setVerticesBuffer(e), this;\n      }, _.prototype.updateVerticesData = function (e, t, i, r) {\n        return this._geometry && (r ? (this.makeGeometryUnique(), this.updateVerticesData(e, t, i, !1)) : this._geometry.updateVerticesData(e, t, i)), this;\n      }, _.prototype.updateMeshPositions = function (e, t) {\n        void 0 === t && (t = !0);\n        var i = this.getVerticesData(S.VertexBuffer.PositionKind);\n        if (!i) return this;\n\n        if (e(i), this.updateVerticesData(S.VertexBuffer.PositionKind, i, !1, !1), t) {\n          var r = this.getIndices(),\n              n = this.getVerticesData(S.VertexBuffer.NormalKind);\n          if (!n) return this;\n          S.VertexData.ComputeNormals(i, r, n), this.updateVerticesData(S.VertexBuffer.NormalKind, n, !1, !1);\n        }\n\n        return this;\n      }, _.prototype.makeGeometryUnique = function () {\n        if (!this._geometry) return this;\n\n        var e = this._geometry,\n            t = this._geometry.copy(S.Geometry.RandomId());\n\n        return e.releaseForMesh(this, !0), t.applyToMesh(this), this;\n      }, _.prototype.setIndices = function (e, t, i) {\n        if (void 0 === t && (t = null), void 0 === i && (i = !1), this._geometry) this._geometry.setIndices(e, t, i);else {\n          var r = new S.VertexData();\n          r.indices = e;\n          var n = this.getScene();\n          new S.Geometry(S.Geometry.RandomId(), n, r, i, this);\n        }\n        return this;\n      }, _.prototype.updateIndices = function (e, t) {\n        return this._geometry && this._geometry.updateIndices(e, t), this;\n      }, _.prototype.toLeftHanded = function () {\n        return this._geometry && this._geometry.toLeftHanded(), this;\n      }, _.prototype._bind = function (e, t, i) {\n        if (!this._geometry) return this;\n        var r,\n            n = this.getScene().getEngine();\n        if (this._unIndexed) r = null;else switch (i) {\n          case S.Material.PointFillMode:\n            r = null;\n            break;\n\n          case S.Material.WireFrameFillMode:\n            r = e._getLinesIndexBuffer(this.getIndices(), n);\n            break;\n\n          default:\n          case S.Material.TriangleFillMode:\n            r = this._unIndexed ? null : this._geometry.getIndexBuffer();\n        }\n        return this._geometry._bind(t, r), this;\n      }, _.prototype._draw = function (e, t, i, r) {\n        if (void 0 === r && (r = !1), !this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) return this;\n        this._onBeforeDrawObservable && this._onBeforeDrawObservable.notifyObservers(this);\n        var n = this.getScene(),\n            o = n.getEngine();\n\n        if (this._unIndexed || t == S.Material.PointFillMode ? o.drawArraysType(t, e.verticesStart, e.verticesCount, i) : t == S.Material.WireFrameFillMode ? o.drawElementsType(t, 0, e._linesIndexCount, i) : o.drawElementsType(t, e.indexStart, e.indexCount, i), n._isAlternateRenderingEnabled && !r) {\n          var s = e.effect || this._effectiveMaterial.getEffect();\n\n          if (!s || !n.activeCamera) return this;\n          n._switchToAlternateCameraConfiguration(!0), this._effectiveMaterial.bindView(s), this._effectiveMaterial.bindViewProjection(s), o.setViewport(n.activeCamera._alternateCamera.viewport), this._draw(e, t, i, !0), o.setViewport(n.activeCamera.viewport), n._switchToAlternateCameraConfiguration(!1), this._effectiveMaterial.bindView(s), this._effectiveMaterial.bindViewProjection(s);\n        }\n\n        return this;\n      }, _.prototype.registerBeforeRender = function (e) {\n        return this.onBeforeRenderObservable.add(e), this;\n      }, _.prototype.unregisterBeforeRender = function (e) {\n        return this.onBeforeRenderObservable.removeCallback(e), this;\n      }, _.prototype.registerAfterRender = function (e) {\n        return this.onAfterRenderObservable.add(e), this;\n      }, _.prototype.unregisterAfterRender = function (e) {\n        return this.onAfterRenderObservable.removeCallback(e), this;\n      }, _.prototype._getInstancesRenderList = function (e) {\n        var t = this.getScene(),\n            i = this._instanceDataStorage.batchCache;\n\n        if (i.mustReturn = !1, i.renderSelf[e] = this.isEnabled() && this.isVisible, i.visibleInstances[e] = null, this._instanceDataStorage.visibleInstances) {\n          var r = this._instanceDataStorage.visibleInstances,\n              n = t.getRenderId(),\n              o = t._isInIntermediateRendering() ? r.intermediateDefaultRenderId : r.defaultRenderId;\n          i.visibleInstances[e] = r[n];\n          var s = this._renderId;\n          !i.visibleInstances[e] && o && (i.visibleInstances[e] = r[o], n = Math.max(o, n), s = Math.max(r.selfDefaultRenderId, n));\n          var a = i.visibleInstances[e];\n\n          if (a && a.length) {\n            if (this._instanceDataStorage.renderIdForInstances[e] === n) return i.mustReturn = !0, i;\n            n !== s && (i.renderSelf[e] = !1);\n          }\n\n          this._instanceDataStorage.renderIdForInstances[e] = n;\n        }\n\n        return i;\n      }, _.prototype._renderWithInstances = function (e, t, i, r, n) {\n        var o = i.visibleInstances[e._id];\n        if (!o) return this;\n\n        for (var s = 16 * (o.length + 1) * 4, a = this._instanceDataStorage, l = a.instancesBufferSize, c = a.instancesBuffer; a.instancesBufferSize < s;) a.instancesBufferSize *= 2;\n\n        a.instancesData && l == a.instancesBufferSize || (a.instancesData = new Float32Array(a.instancesBufferSize / 4));\n        var h = 0,\n            u = 0,\n            d = this.getWorldMatrix();\n        if (i.renderSelf[e._id] && (d.copyToArray(a.instancesData, h), h += 16, u++), o) for (var f = 0; f < o.length; f++) {\n          o[f].getWorldMatrix().copyToArray(a.instancesData, h), h += 16, u++;\n        }\n        return c && l == a.instancesBufferSize ? c.updateDirectly(a.instancesData, 0, u) : (c && c.dispose(), c = new S.Buffer(n, a.instancesData, !0, 16, !1, !0), a.instancesBuffer = c, this.setVerticesBuffer(c.createVertexBuffer(\"world0\", 0, 4)), this.setVerticesBuffer(c.createVertexBuffer(\"world1\", 4, 4)), this.setVerticesBuffer(c.createVertexBuffer(\"world2\", 8, 4)), this.setVerticesBuffer(c.createVertexBuffer(\"world3\", 12, 4))), this._bind(e, r, t), this._draw(e, t, u), n.unbindInstanceAttributes(), this;\n      }, _.prototype._processRendering = function (e, t, i, r, n, o, s) {\n        var a = this.getScene().getEngine();\n        if (n) this._renderWithInstances(e, i, r, t, a);else {\n          r.renderSelf[e._id] && (o && o(!1, this.getWorldMatrix(), s), this._draw(e, i, this._instanceDataStorage.overridenInstanceCount));\n          var l = r.visibleInstances[e._id];\n          if (l) for (var c = 0; c < l.length; c++) {\n            var h = l[c].getWorldMatrix();\n            o && o(!0, h, s), this._draw(e, i);\n          }\n        }\n        return this;\n      }, _.prototype.render = function (e, t) {\n        if (this._checkOcclusionQuery()) return this;\n\n        var i = this.getScene(),\n            r = this._getInstancesRenderList(e._id);\n\n        if (r.mustReturn) return this;\n        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) return this;\n        this._onBeforeRenderObservable && this._onBeforeRenderObservable.notifyObservers(this);\n\n        var n,\n            o = i.getEngine(),\n            s = o.getCaps().instancedArrays && null !== r.visibleInstances[e._id] && void 0 !== r.visibleInstances[e._id],\n            a = e.getMaterial();\n\n        if (!a) return this;\n\n        if (this._effectiveMaterial = a, this._effectiveMaterial.storeEffectOnSubMeshes) {\n          if (!this._effectiveMaterial.isReadyForSubMesh(this, e, s)) return this;\n        } else if (!this._effectiveMaterial.isReady(this, s)) return this;\n\n        t && o.setAlphaMode(this._effectiveMaterial.alphaMode);\n\n        for (var l = 0, c = i._beforeRenderingMeshStage; l < c.length; l++) {\n          c[l].action(this, e, r);\n        }\n\n        if (!(n = this._effectiveMaterial.storeEffectOnSubMeshes ? e.effect : this._effectiveMaterial.getEffect())) return this;\n        var h = this.overrideMaterialSideOrientation;\n        null == h && (h = this._effectiveMaterial.sideOrientation, this._getWorldMatrixDeterminant() < 0 && (h = h === S.Material.ClockWiseSideOrientation ? S.Material.CounterClockWiseSideOrientation : S.Material.ClockWiseSideOrientation));\n\n        var u = this._effectiveMaterial._preBind(n, h);\n\n        this._effectiveMaterial.forceDepthWrite && o.setDepthWrite(!0);\n        var d = i.forcePointsCloud ? S.Material.PointFillMode : i.forceWireframe ? S.Material.WireFrameFillMode : this._effectiveMaterial.fillMode;\n        s || this._bind(e, n, d);\n        var f = this.getWorldMatrix();\n        this._effectiveMaterial.storeEffectOnSubMeshes ? this._effectiveMaterial.bindForSubMesh(f, this, e) : this._effectiveMaterial.bind(f, this), !this._effectiveMaterial.backFaceCulling && this._effectiveMaterial.separateCullingPass && (o.setState(!0, this._effectiveMaterial.zOffset, !1, !u), this._processRendering(e, n, d, r, s, this._onBeforeDraw, this._effectiveMaterial), o.setState(!0, this._effectiveMaterial.zOffset, !1, u)), this._processRendering(e, n, d, r, s, this._onBeforeDraw, this._effectiveMaterial), this._effectiveMaterial.unbind();\n\n        for (var p = 0, _ = i._afterRenderingMeshStage; p < _.length; p++) {\n          _[p].action(this, e, r);\n        }\n\n        return this._onAfterRenderObservable && this._onAfterRenderObservable.notifyObservers(this), this;\n      }, _.prototype._onBeforeDraw = function (e, t, i) {\n        e && i && i.bindOnlyWorldMatrix(t);\n      }, _.prototype.cleanMatrixWeights = function () {\n        this.isVerticesDataPresent(S.VertexBuffer.MatricesWeightsKind) && (this.isVerticesDataPresent(S.VertexBuffer.MatricesWeightsExtraKind) ? this.normalizeSkinWeightsAndExtra() : this.normalizeSkinFourWeights());\n      }, _.prototype.normalizeSkinFourWeights = function () {\n        for (var e = this.getVerticesData(S.VertexBuffer.MatricesWeightsKind), t = e.length, i = 0; i < t; i += 4) {\n          var r = e[i] + e[i + 1] + e[i + 2] + e[i + 3];\n          if (0 === r) e[i] = 1;else {\n            var n = 1 / r;\n            e[i] *= n, e[i + 1] *= n, e[i + 2] *= n, e[i + 3] *= n;\n          }\n        }\n\n        this.setVerticesData(S.VertexBuffer.MatricesWeightsKind, e);\n      }, _.prototype.normalizeSkinWeightsAndExtra = function () {\n        for (var e = this.getVerticesData(S.VertexBuffer.MatricesWeightsExtraKind), t = this.getVerticesData(S.VertexBuffer.MatricesWeightsKind), i = t.length, r = 0; r < i; r += 4) {\n          var n = t[r] + t[r + 1] + t[r + 2] + t[r + 3];\n          if (0 === (n += e[r] + e[r + 1] + e[r + 2] + e[r + 3])) t[r] = 1;else {\n            var o = 1 / n;\n            t[r] *= o, t[r + 1] *= o, t[r + 2] *= o, t[r + 3] *= o, e[r] *= o, e[r + 1] *= o, e[r + 2] *= o, e[r + 3] *= o;\n          }\n        }\n\n        this.setVerticesData(S.VertexBuffer.MatricesWeightsKind, t), this.setVerticesData(S.VertexBuffer.MatricesWeightsKind, e);\n      }, _.prototype.validateSkinning = function () {\n        var e = this.getVerticesData(S.VertexBuffer.MatricesWeightsExtraKind),\n            t = this.getVerticesData(S.VertexBuffer.MatricesWeightsKind);\n        if (null === t || null == this.skeleton) return {\n          skinned: !1,\n          valid: !0,\n          report: \"not skinned\"\n        };\n\n        for (var i = t.length, r = 0, n = 0, o = 0, s = 0, a = null === e ? 4 : 8, l = new Array(), c = 0; c <= a; c++) l[c] = 0;\n\n        for (c = 0; c < i; c += 4) {\n          for (var h = t[c], u = h, d = 0 === u ? 0 : 1, f = 1; f < a; f++) {\n            var p = f < 4 ? t[c + f] : e[c + f - 4];\n            h < p && r++, 0 !== p && d++, u += p, h = p;\n          }\n\n          if (l[d]++, o < d && (o = d), 0 === u) n++;else {\n            var _ = 1 / u,\n                m = 0;\n\n            for (f = 0; f < a; f++) m += f < 4 ? Math.abs(t[c + f] - t[c + f] * _) : Math.abs(e[c + f - 4] - e[c + f - 4] * _);\n\n            .001 < m && s++;\n          }\n        }\n\n        var g = this.skeleton.bones.length,\n            v = this.getVerticesData(S.VertexBuffer.MatricesIndicesKind),\n            y = this.getVerticesData(S.VertexBuffer.MatricesIndicesExtraKind),\n            b = 0;\n\n        for (c = 0; c < i; c++) for (f = 0; f < a; f++) {\n          var T = f < 4 ? v[f] : y[f - 4];\n          (g <= T || T < 0) && b++;\n        }\n\n        return {\n          skinned: !0,\n          valid: 0 === n && 0 === s && 0 === b,\n          report: \"Number of Weights = \" + i / 4 + \"\\nMaximum influences = \" + o + \"\\nMissing Weights = \" + n + \"\\nNot Sorted = \" + r + \"\\nNot Normalized = \" + s + \"\\nWeightCounts = [\" + l + \"]\\nNumber of bones = \" + g + \"\\nBad Bone Indices = \" + b\n        };\n      }, _.prototype._checkDelayState = function () {\n        var e = this.getScene();\n        return this._geometry ? this._geometry.load(e) : this.delayLoadState === S.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = S.Engine.DELAYLOADSTATE_LOADING, this._queueLoad(e)), this;\n      }, _.prototype._queueLoad = function (t) {\n        var i = this;\n\n        t._addPendingData(this);\n\n        var e = -1 !== this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\");\n        return S.Tools.LoadFile(this.delayLoadingFile, function (e) {\n          e instanceof ArrayBuffer ? i._delayLoadingFunction(e, i) : i._delayLoadingFunction(JSON.parse(e), i), i.instances.forEach(function (e) {\n            e._syncSubMeshes();\n          }), i.delayLoadState = S.Engine.DELAYLOADSTATE_LOADED, t._removePendingData(i);\n        }, function () {}, t.database, e), this;\n      }, _.prototype.isInFrustum = function (e) {\n        return this.delayLoadState !== S.Engine.DELAYLOADSTATE_LOADING && !!v.prototype.isInFrustum.call(this, e) && (this._checkDelayState(), !0);\n      }, _.prototype.setMaterialByID = function (e) {\n        var t,\n            i = this.getScene().materials;\n\n        for (t = i.length - 1; -1 < t; t--) if (i[t].id === e) return this.material = i[t], this;\n\n        var r = this.getScene().multiMaterials;\n\n        for (t = r.length - 1; -1 < t; t--) if (r[t].id === e) return this.material = r[t], this;\n\n        return this;\n      }, _.prototype.getAnimatables = function () {\n        var e = new Array();\n        return this.material && e.push(this.material), this.skeleton && e.push(this.skeleton), e;\n      }, _.prototype.bakeTransformIntoVertices = function (e) {\n        if (!this.isVerticesDataPresent(S.VertexBuffer.PositionKind)) return this;\n        var t = this.subMeshes.splice(0);\n\n        this._resetPointsArrayCache();\n\n        var i,\n            r = this.getVerticesData(S.VertexBuffer.PositionKind),\n            n = new Array();\n\n        for (i = 0; i < r.length; i += 3) S.Vector3.TransformCoordinates(S.Vector3.FromArray(r, i), e).toArray(n, i);\n\n        if (this.setVerticesData(S.VertexBuffer.PositionKind, n, this.getVertexBuffer(S.VertexBuffer.PositionKind).isUpdatable()), this.isVerticesDataPresent(S.VertexBuffer.NormalKind)) {\n          for (r = this.getVerticesData(S.VertexBuffer.NormalKind), n = [], i = 0; i < r.length; i += 3) S.Vector3.TransformNormal(S.Vector3.FromArray(r, i), e).normalize().toArray(n, i);\n\n          this.setVerticesData(S.VertexBuffer.NormalKind, n, this.getVertexBuffer(S.VertexBuffer.NormalKind).isUpdatable());\n        }\n\n        return e.m[0] * e.m[5] * e.m[10] < 0 && this.flipFaces(), this.releaseSubMeshes(), this.subMeshes = t, this;\n      }, _.prototype.bakeCurrentTransformIntoVertices = function () {\n        return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)), this.scaling.copyFromFloats(1, 1, 1), this.position.copyFromFloats(0, 0, 0), this.rotation.copyFromFloats(0, 0, 0), this.rotationQuaternion && (this.rotationQuaternion = S.Quaternion.Identity()), this._worldMatrix = S.Matrix.Identity(), this;\n      }, Object.defineProperty(_.prototype, \"_positions\", {\n        get: function () {\n          return this._geometry ? this._geometry._positions : null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), _.prototype._resetPointsArrayCache = function () {\n        return this._geometry && this._geometry._resetPointsArrayCache(), this;\n      }, _.prototype._generatePointsArray = function () {\n        return !!this._geometry && this._geometry._generatePointsArray();\n      }, _.prototype.clone = function (e, t, i, r) {\n        return void 0 === e && (e = \"\"), void 0 === r && (r = !0), new _(e, this.getScene(), t, this, i, r);\n      }, _.prototype.dispose = function (e, t) {\n        var i = this;\n\n        for (void 0 === t && (t = !1), this.morphTargetManager = null, this._geometry && this._geometry.releaseForMesh(this, !0), this._onBeforeDrawObservable && this._onBeforeDrawObservable.clear(), this._onBeforeRenderObservable && this._onBeforeRenderObservable.clear(), this._onAfterRenderObservable && this._onAfterRenderObservable.clear(), this.getScene().meshes.forEach(function (e) {\n          var t = e;\n          t._source && t._source === i && (t._source = null);\n        }), this._source = null, this._instanceDataStorage.instancesBuffer && (this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null); this.instances.length;) this.instances[0].dispose();\n\n        v.prototype.dispose.call(this, e, t);\n      }, _.prototype.applyDisplacementMap = function (e, s, a, l, c, h, u) {\n        var d = this;\n        void 0 === u && (u = !1);\n        var t = this.getScene();\n        return S.Tools.LoadImage(e, function (e) {\n          var t = document.createElement(\"canvas\"),\n              i = t.getContext(\"2d\"),\n              r = e.width,\n              n = e.height;\n          t.width = r, t.height = n, i.drawImage(e, 0, 0);\n          var o = i.getImageData(0, 0, r, n).data;\n          d.applyDisplacementMapFromBuffer(o, r, n, s, a, c, h, u), l && l(d);\n        }, function () {}, t.database), this;\n      }, _.prototype.applyDisplacementMapFromBuffer = function (e, t, i, r, n, o, s, a) {\n        if (void 0 === a && (a = !1), !this.isVerticesDataPresent(S.VertexBuffer.PositionKind) || !this.isVerticesDataPresent(S.VertexBuffer.NormalKind) || !this.isVerticesDataPresent(S.VertexBuffer.UVKind)) return S.Tools.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\"), this;\n        var l = this.getVerticesData(S.VertexBuffer.PositionKind, !0, !0),\n            c = this.getVerticesData(S.VertexBuffer.NormalKind),\n            h = this.getVerticesData(S.VertexBuffer.UVKind),\n            u = S.Vector3.Zero(),\n            d = S.Vector3.Zero(),\n            f = S.Vector2.Zero();\n        o = o || S.Vector2.Zero(), s = s || new S.Vector2(1, 1);\n\n        for (var p = 0; p < l.length; p += 3) {\n          S.Vector3.FromArrayToRef(l, p, u), S.Vector3.FromArrayToRef(c, p, d), S.Vector2.FromArrayToRef(h, p / 3 * 2, f);\n\n          var _ = 4 * ((Math.abs(f.x * s.x + o.x) * t % t | 0) + (Math.abs(f.y * s.y + o.y) * i % i | 0) * t),\n              m = .3 * (e[_] / 255) + .59 * (e[_ + 1] / 255) + .11 * (e[_ + 2] / 255);\n\n          d.normalize(), d.scaleInPlace(r + (n - r) * m), (u = u.add(d)).toArray(l, p);\n        }\n\n        return S.VertexData.ComputeNormals(l, this.getIndices(), c), a ? (this.setVerticesData(S.VertexBuffer.PositionKind, l), this.setVerticesData(S.VertexBuffer.NormalKind, c)) : (this.updateVerticesData(S.VertexBuffer.PositionKind, l), this.updateVerticesData(S.VertexBuffer.NormalKind, c)), this;\n      }, _.prototype.convertToFlatShadedMesh = function () {\n        var e,\n            t,\n            i = this.getVerticesDataKinds(),\n            r = {},\n            n = {},\n            o = {},\n            s = !1;\n\n        for (e = 0; e < i.length; e++) {\n          t = i[e];\n          var a = this.getVertexBuffer(t);\n          t !== S.VertexBuffer.NormalKind ? (r[t] = a, n[t] = r[t].getData(), o[t] = []) : (s = a.isUpdatable(), i.splice(e, 1), e--);\n        }\n\n        var l,\n            c = this.subMeshes.slice(0),\n            h = this.getIndices(),\n            u = this.getTotalIndices();\n\n        for (l = 0; l < u; l++) {\n          var d = h[l];\n\n          for (e = 0; e < i.length; e++) for (var f = r[t = i[e]].getStrideSize(), p = 0; p < f; p++) o[t].push(n[t][d * f + p]);\n        }\n\n        var _ = [],\n            m = o[S.VertexBuffer.PositionKind];\n\n        for (l = 0; l < u; l += 3) {\n          h[l] = l, h[l + 1] = l + 1, h[l + 2] = l + 2;\n\n          for (var g = S.Vector3.FromArray(m, 3 * l), v = S.Vector3.FromArray(m, 3 * (l + 1)), y = S.Vector3.FromArray(m, 3 * (l + 2)), b = g.subtract(v), T = y.subtract(v), E = S.Vector3.Normalize(S.Vector3.Cross(b, T)), x = 0; x < 3; x++) _.push(E.x), _.push(E.y), _.push(E.z);\n        }\n\n        for (this.setIndices(h), this.setVerticesData(S.VertexBuffer.NormalKind, _, s), e = 0; e < i.length; e++) t = i[e], this.setVerticesData(t, o[t], r[t].isUpdatable());\n\n        this.releaseSubMeshes();\n\n        for (var P = 0; P < c.length; P++) {\n          var A = c[P];\n          S.SubMesh.AddToMesh(A.materialIndex, A.indexStart, A.indexCount, A.indexStart, A.indexCount, this);\n        }\n\n        return this.synchronizeInstances(), this;\n      }, _.prototype.convertToUnIndexedMesh = function () {\n        var e,\n            t,\n            i = this.getVerticesDataKinds(),\n            r = {},\n            n = {},\n            o = {};\n\n        for (e = 0; e < i.length; e++) {\n          t = i[e];\n          var s = this.getVertexBuffer(t);\n          r[t] = s, n[t] = r[t].getData(), o[t] = [];\n        }\n\n        var a,\n            l = this.subMeshes.slice(0),\n            c = this.getIndices(),\n            h = this.getTotalIndices();\n\n        for (a = 0; a < h; a++) {\n          var u = c[a];\n\n          for (e = 0; e < i.length; e++) for (var d = r[t = i[e]].getStrideSize(), f = 0; f < d; f++) o[t].push(n[t][u * d + f]);\n        }\n\n        for (a = 0; a < h; a += 3) c[a] = a, c[a + 1] = a + 1, c[a + 2] = a + 2;\n\n        for (this.setIndices(c), e = 0; e < i.length; e++) t = i[e], this.setVerticesData(t, o[t], r[t].isUpdatable());\n\n        this.releaseSubMeshes();\n\n        for (var p = 0; p < l.length; p++) {\n          var _ = l[p];\n          S.SubMesh.AddToMesh(_.materialIndex, _.indexStart, _.indexCount, _.indexStart, _.indexCount, this);\n        }\n\n        return this._unIndexed = !0, this.synchronizeInstances(), this;\n      }, _.prototype.flipFaces = function (e) {\n        void 0 === e && (e = !1);\n        var t,\n            i,\n            r = S.VertexData.ExtractFromMesh(this);\n        if (e && this.isVerticesDataPresent(S.VertexBuffer.NormalKind) && r.normals) for (t = 0; t < r.normals.length; t++) r.normals[t] *= -1;\n        if (r.indices) for (t = 0; t < r.indices.length; t += 3) i = r.indices[t + 1], r.indices[t + 1] = r.indices[t + 2], r.indices[t + 2] = i;\n        return r.applyToMesh(this), this;\n      }, _.prototype.createInstance = function (e) {\n        return new S.InstancedMesh(e, this);\n      }, _.prototype.synchronizeInstances = function () {\n        for (var e = 0; e < this.instances.length; e++) {\n          this.instances[e]._syncSubMeshes();\n        }\n\n        return this;\n      }, _.prototype.optimizeIndices = function (i) {\n        var r = this,\n            n = this.getIndices(),\n            e = this.getVerticesData(S.VertexBuffer.PositionKind);\n        if (!e || !n) return this;\n\n        for (var o = new Array(), t = 0; t < e.length; t += 3) o.push(S.Vector3.FromArray(e, t));\n\n        var s = new Array();\n        return S.AsyncLoop.SyncAsyncForLoop(o.length, 40, function (e) {\n          for (var t = o.length - 1 - e, i = o[t], r = 0; r < t; ++r) {\n            var n = o[r];\n\n            if (i.equals(n)) {\n              s[t] = r;\n              break;\n            }\n          }\n        }, function () {\n          for (var e = 0; e < n.length; ++e) n[e] = s[n[e]] || n[e];\n\n          var t = r.subMeshes.slice(0);\n          r.setIndices(n), r.subMeshes = t, i && i(r);\n        }), this;\n      }, _.prototype.serialize = function (e) {\n        e.name = this.name, e.id = this.id, e.type = this.getClassName(), S.Tags && S.Tags.HasTags(this) && (e.tags = S.Tags.GetTags(this)), e.position = this.position.asArray(), this.rotationQuaternion ? e.rotationQuaternion = this.rotationQuaternion.asArray() : this.rotation && (e.rotation = this.rotation.asArray()), e.scaling = this.scaling.asArray(), e.localMatrix = this.getPivotMatrix().asArray(), e.isEnabled = this.isEnabled(!1), e.isVisible = this.isVisible, e.infiniteDistance = this.infiniteDistance, e.pickable = this.isPickable, e.receiveShadows = this.receiveShadows, e.billboardMode = this.billboardMode, e.visibility = this.visibility, e.checkCollisions = this.checkCollisions, e.isBlocker = this.isBlocker, this.parent && (e.parentId = this.parent.id), e.isUnIndexed = this.isUnIndexed;\n        var t = this._geometry;\n\n        if (t) {\n          var i = t.id;\n          e.geometryId = i, e.subMeshes = [];\n\n          for (var r = 0; r < this.subMeshes.length; r++) {\n            var n = this.subMeshes[r];\n            e.subMeshes.push({\n              materialIndex: n.materialIndex,\n              verticesStart: n.verticesStart,\n              verticesCount: n.verticesCount,\n              indexStart: n.indexStart,\n              indexCount: n.indexCount\n            });\n          }\n        }\n\n        this.material ? e.materialId = this.material.id : this.material = null, this.morphTargetManager && (e.morphTargetManagerId = this.morphTargetManager.uniqueId), this.skeleton && (e.skeletonId = this.skeleton.id);\n        var o = this.getPhysicsImpostor();\n        o && (e.physicsMass = o.getParam(\"mass\"), e.physicsFriction = o.getParam(\"friction\"), e.physicsRestitution = o.getParam(\"mass\"), e.physicsImpostor = o.type), this.metadata && (e.metadata = this.metadata), e.instances = [];\n\n        for (var s = 0; s < this.instances.length; s++) {\n          var a = this.instances[s];\n\n          if (!a.doNotSerialize) {\n            var l = {\n              name: a.name,\n              id: a.id,\n              position: a.position.asArray(),\n              scaling: a.scaling.asArray()\n            };\n            a.parent && (l.parentId = a.parent.id), a.rotationQuaternion ? l.rotationQuaternion = a.rotationQuaternion.asArray() : a.rotation && (l.rotation = a.rotation.asArray()), e.instances.push(l), S.Animation.AppendSerializedAnimations(a, l), l.ranges = a.serializeAnimationRanges();\n          }\n        }\n\n        S.Animation.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.layerMask = this.layerMask, e.alphaIndex = this.alphaIndex, e.hasVertexAlpha = this.hasVertexAlpha, e.overlayAlpha = this.overlayAlpha, e.overlayColor = this.overlayColor.asArray(), e.renderOverlay = this.renderOverlay, e.applyFog = this.applyFog, this.actionManager && (e.actions = this.actionManager.serialize(this.name));\n      }, _.prototype._syncGeometryWithMorphTargetManager = function () {\n        if (this.geometry) {\n          this._markSubMeshesAsAttributesDirty();\n\n          var e = this._morphTargetManager;\n\n          if (e && e.vertexCount) {\n            if (e.vertexCount !== this.getTotalVertices()) return S.Tools.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\"), void (this.morphTargetManager = null);\n\n            for (var t = 0; t < e.numInfluencers; t++) {\n              var i = e.getActiveTarget(t),\n                  r = i.getPositions();\n              if (!r) return void S.Tools.Error(\"Invalid morph target. Target must have positions.\");\n              this.geometry.setVerticesData(S.VertexBuffer.PositionKind + t, r, !1, 3);\n              var n = i.getNormals();\n              n && this.geometry.setVerticesData(S.VertexBuffer.NormalKind + t, n, !1, 3);\n              var o = i.getTangents();\n              o && this.geometry.setVerticesData(S.VertexBuffer.TangentKind + t, o, !1, 3);\n            }\n          } else for (t = 0; this.geometry.isVerticesDataPresent(S.VertexBuffer.PositionKind + t);) this.geometry.removeVerticesData(S.VertexBuffer.PositionKind + t), this.geometry.isVerticesDataPresent(S.VertexBuffer.NormalKind + t) && this.geometry.removeVerticesData(S.VertexBuffer.NormalKind + t), this.geometry.isVerticesDataPresent(S.VertexBuffer.TangentKind + t) && this.geometry.removeVerticesData(S.VertexBuffer.TangentKind + t), t++;\n        }\n      }, _.Parse = function (e, t, i) {\n        var r;\n\n        if ((r = e.type && \"GroundMesh\" === e.type ? S.GroundMesh.Parse(e, t) : new _(e.name, t)).id = e.id, S.Tags && S.Tags.AddTagsTo(r, e.tags), r.position = S.Vector3.FromArray(e.position), void 0 !== e.metadata && (r.metadata = e.metadata), e.rotationQuaternion ? r.rotationQuaternion = S.Quaternion.FromArray(e.rotationQuaternion) : e.rotation && (r.rotation = S.Vector3.FromArray(e.rotation)), r.scaling = S.Vector3.FromArray(e.scaling), e.localMatrix ? r.setPreTransformMatrix(S.Matrix.FromArray(e.localMatrix)) : e.pivotMatrix && r.setPivotMatrix(S.Matrix.FromArray(e.pivotMatrix)), r.setEnabled(e.isEnabled), r.isVisible = e.isVisible, r.infiniteDistance = e.infiniteDistance, r.showBoundingBox = e.showBoundingBox, r.showSubMeshesBoundingBox = e.showSubMeshesBoundingBox, void 0 !== e.applyFog && (r.applyFog = e.applyFog), void 0 !== e.pickable && (r.isPickable = e.pickable), void 0 !== e.alphaIndex && (r.alphaIndex = e.alphaIndex), r.receiveShadows = e.receiveShadows, r.billboardMode = e.billboardMode, void 0 !== e.visibility && (r.visibility = e.visibility), r.checkCollisions = e.checkCollisions, void 0 !== e.isBlocker && (r.isBlocker = e.isBlocker), r._shouldGenerateFlatShading = e.useFlatShading, e.freezeWorldMatrix && (r._waitingFreezeWorldMatrix = e.freezeWorldMatrix), e.parentId && (r._waitingParentId = e.parentId), void 0 !== e.actions && (r._waitingActions = e.actions), void 0 !== e.overlayAlpha && (r.overlayAlpha = e.overlayAlpha), void 0 !== e.overlayColor && (r.overlayColor = S.Color3.FromArray(e.overlayColor)), void 0 !== e.renderOverlay && (r.renderOverlay = e.renderOverlay), r.isUnIndexed = !!e.isUnIndexed, r.hasVertexAlpha = e.hasVertexAlpha, e.delayLoadingFile ? (r.delayLoadState = S.Engine.DELAYLOADSTATE_NOTLOADED, r.delayLoadingFile = i + e.delayLoadingFile, r._boundingInfo = new S.BoundingInfo(S.Vector3.FromArray(e.boundingBoxMinimum), S.Vector3.FromArray(e.boundingBoxMaximum)), e._binaryInfo && (r._binaryInfo = e._binaryInfo), r._delayInfo = [], e.hasUVs && r._delayInfo.push(S.VertexBuffer.UVKind), e.hasUVs2 && r._delayInfo.push(S.VertexBuffer.UV2Kind), e.hasUVs3 && r._delayInfo.push(S.VertexBuffer.UV3Kind), e.hasUVs4 && r._delayInfo.push(S.VertexBuffer.UV4Kind), e.hasUVs5 && r._delayInfo.push(S.VertexBuffer.UV5Kind), e.hasUVs6 && r._delayInfo.push(S.VertexBuffer.UV6Kind), e.hasColors && r._delayInfo.push(S.VertexBuffer.ColorKind), e.hasMatricesIndices && r._delayInfo.push(S.VertexBuffer.MatricesIndicesKind), e.hasMatricesWeights && r._delayInfo.push(S.VertexBuffer.MatricesWeightsKind), r._delayLoadingFunction = S.Geometry._ImportGeometry, S.SceneLoader.ForceFullSceneLoadingForIncremental && r._checkDelayState()) : S.Geometry._ImportGeometry(e, r), e.materialId ? r.setMaterialByID(e.materialId) : r.material = null, -1 < e.morphTargetManagerId && (r.morphTargetManager = t.getMorphTargetManagerById(e.morphTargetManagerId)), -1 < e.skeletonId && (r.skeleton = t.getLastSkeletonByID(e.skeletonId), e.numBoneInfluencers && (r.numBoneInfluencers = e.numBoneInfluencers)), e.animations) {\n          for (var n = 0; n < e.animations.length; n++) {\n            var o = e.animations[n];\n            r.animations.push(S.Animation.Parse(o));\n          }\n\n          S.Node.ParseAnimationRanges(r, e, t);\n        }\n\n        if (e.autoAnimate && t.beginAnimation(r, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.layerMask && !isNaN(e.layerMask) ? r.layerMask = Math.abs(parseInt(e.layerMask)) : r.layerMask = 268435455, e.physicsImpostor && (r.physicsImpostor = new S.PhysicsImpostor(r, e.physicsImpostor, {\n          mass: e.physicsMass,\n          friction: e.physicsFriction,\n          restitution: e.physicsRestitution\n        }, t)), e.instances) for (var s = 0; s < e.instances.length; s++) {\n          var a = e.instances[s],\n              l = r.createInstance(a.name);\n\n          if (a.id && (l.id = a.id), S.Tags && (a.tags ? S.Tags.AddTagsTo(l, a.tags) : S.Tags.AddTagsTo(l, e.tags)), l.position = S.Vector3.FromArray(a.position), a.parentId && (l._waitingParentId = a.parentId), a.rotationQuaternion ? l.rotationQuaternion = S.Quaternion.FromArray(a.rotationQuaternion) : a.rotation && (l.rotation = S.Vector3.FromArray(a.rotation)), l.scaling = S.Vector3.FromArray(a.scaling), null != a.checkCollisions && null != a.checkCollisions && (l.checkCollisions = a.checkCollisions), null != a.pickable && null != a.pickable && (l.isPickable = a.pickable), null != a.showBoundingBox && null != a.showBoundingBox && (l.showBoundingBox = a.showBoundingBox), null != a.showSubMeshesBoundingBox && null != a.showSubMeshesBoundingBox && (l.showSubMeshesBoundingBox = a.showSubMeshesBoundingBox), null != a.alphaIndex && null != a.showSubMeshesBoundingBox && (l.alphaIndex = a.alphaIndex), a.physicsImpostor && (l.physicsImpostor = new S.PhysicsImpostor(l, a.physicsImpostor, {\n            mass: a.physicsMass,\n            friction: a.physicsFriction,\n            restitution: a.physicsRestitution\n          }, t)), a.animations) {\n            for (n = 0; n < a.animations.length; n++) o = a.animations[n], l.animations.push(S.Animation.Parse(o));\n\n            S.Node.ParseAnimationRanges(l, a, t), a.autoAnimate && t.beginAnimation(l, a.autoAnimateFrom, a.autoAnimateTo, a.autoAnimateLoop, a.autoAnimateSpeed || 1);\n          }\n        }\n        return r;\n      }, _.CreateRibbon = function (e, t, i, r, n, o, s, a, l) {\n        return void 0 === i && (i = !1), void 0 === s && (s = !1), S.MeshBuilder.CreateRibbon(e, {\n          pathArray: t,\n          closeArray: i,\n          closePath: r,\n          offset: n,\n          updatable: s,\n          sideOrientation: a,\n          instance: l\n        }, o);\n      }, _.CreateDisc = function (e, t, i, r, n, o) {\n        void 0 === r && (r = null);\n        var s = {\n          radius: t,\n          tessellation: i,\n          sideOrientation: o,\n          updatable: n\n        };\n        return S.MeshBuilder.CreateDisc(e, s, r);\n      }, _.CreateBox = function (e, t, i, r, n) {\n        void 0 === i && (i = null);\n        var o = {\n          size: t,\n          sideOrientation: n,\n          updatable: r\n        };\n        return S.MeshBuilder.CreateBox(e, o, i);\n      }, _.CreateSphere = function (e, t, i, r, n, o) {\n        var s = {\n          segments: t,\n          diameterX: i,\n          diameterY: i,\n          diameterZ: i,\n          sideOrientation: o,\n          updatable: n\n        };\n        return S.MeshBuilder.CreateSphere(e, s, r);\n      }, _.CreateCylinder = function (e, t, i, r, n, o, s, a, l) {\n        void 0 !== s && s instanceof S.Scene || (void 0 !== s && (l = a || _.DEFAULTSIDE, a = s), s = o, o = 1);\n        var c = {\n          height: t,\n          diameterTop: i,\n          diameterBottom: r,\n          tessellation: n,\n          subdivisions: o,\n          sideOrientation: l,\n          updatable: a\n        };\n        return S.MeshBuilder.CreateCylinder(e, c, s);\n      }, _.CreateTorus = function (e, t, i, r, n, o, s) {\n        var a = {\n          diameter: t,\n          thickness: i,\n          tessellation: r,\n          sideOrientation: s,\n          updatable: o\n        };\n        return S.MeshBuilder.CreateTorus(e, a, n);\n      }, _.CreateTorusKnot = function (e, t, i, r, n, o, s, a, l, c) {\n        var h = {\n          radius: t,\n          tube: i,\n          radialSegments: r,\n          tubularSegments: n,\n          p: o,\n          q: s,\n          sideOrientation: c,\n          updatable: l\n        };\n        return S.MeshBuilder.CreateTorusKnot(e, h, a);\n      }, _.CreateLines = function (e, t, i, r, n) {\n        void 0 === i && (i = null), void 0 === r && (r = !1), void 0 === n && (n = null);\n        var o = {\n          points: t,\n          updatable: r,\n          instance: n\n        };\n        return S.MeshBuilder.CreateLines(e, o, i);\n      }, _.CreateDashedLines = function (e, t, i, r, n, o, s, a) {\n        void 0 === o && (o = null);\n        var l = {\n          points: t,\n          dashSize: i,\n          gapSize: r,\n          dashNb: n,\n          updatable: s,\n          instance: a\n        };\n        return S.MeshBuilder.CreateDashedLines(e, l, o);\n      }, _.CreatePolygon = function (e, t, i, r, n, o) {\n        var s = {\n          shape: t,\n          holes: r,\n          updatable: n,\n          sideOrientation: o\n        };\n        return S.MeshBuilder.CreatePolygon(e, s, i);\n      }, _.ExtrudePolygon = function (e, t, i, r, n, o, s) {\n        var a = {\n          shape: t,\n          holes: n,\n          depth: i,\n          updatable: o,\n          sideOrientation: s\n        };\n        return S.MeshBuilder.ExtrudePolygon(e, a, r);\n      }, _.ExtrudeShape = function (e, t, i, r, n, o, s, a, l, c) {\n        void 0 === s && (s = null);\n        var h = {\n          shape: t,\n          path: i,\n          scale: r,\n          rotation: n,\n          cap: 0 === o ? 0 : o || _.NO_CAP,\n          sideOrientation: l,\n          instance: c,\n          updatable: a\n        };\n        return S.MeshBuilder.ExtrudeShape(e, h, s);\n      }, _.ExtrudeShapeCustom = function (e, t, i, r, n, o, s, a, l, c, h, u) {\n        var d = {\n          shape: t,\n          path: i,\n          scaleFunction: r,\n          rotationFunction: n,\n          ribbonCloseArray: o,\n          ribbonClosePath: s,\n          cap: 0 === a ? 0 : a || _.NO_CAP,\n          sideOrientation: h,\n          instance: u,\n          updatable: c\n        };\n        return S.MeshBuilder.ExtrudeShapeCustom(e, d, l);\n      }, _.CreateLathe = function (e, t, i, r, n, o, s) {\n        var a = {\n          shape: t,\n          radius: i,\n          tessellation: r,\n          sideOrientation: s,\n          updatable: o\n        };\n        return S.MeshBuilder.CreateLathe(e, a, n);\n      }, _.CreatePlane = function (e, t, i, r, n) {\n        var o = {\n          size: t,\n          width: t,\n          height: t,\n          sideOrientation: n,\n          updatable: r\n        };\n        return S.MeshBuilder.CreatePlane(e, o, i);\n      }, _.CreateGround = function (e, t, i, r, n, o) {\n        var s = {\n          width: t,\n          height: i,\n          subdivisions: r,\n          updatable: o\n        };\n        return S.MeshBuilder.CreateGround(e, s, n);\n      }, _.CreateTiledGround = function (e, t, i, r, n, o, s, a, l) {\n        var c = {\n          xmin: t,\n          zmin: i,\n          xmax: r,\n          zmax: n,\n          subdivisions: o,\n          precision: s,\n          updatable: l\n        };\n        return S.MeshBuilder.CreateTiledGround(e, c, a);\n      }, _.CreateGroundFromHeightMap = function (e, t, i, r, n, o, s, a, l, c, h) {\n        var u = {\n          width: i,\n          height: r,\n          subdivisions: n,\n          minHeight: o,\n          maxHeight: s,\n          updatable: l,\n          onReady: c,\n          alphaFilter: h\n        };\n        return S.MeshBuilder.CreateGroundFromHeightMap(e, t, u, a);\n      }, _.CreateTube = function (e, t, i, r, n, o, s, a, l, c) {\n        var h = {\n          path: t,\n          radius: i,\n          tessellation: r,\n          radiusFunction: n,\n          arc: 1,\n          cap: o,\n          updatable: a,\n          sideOrientation: l,\n          instance: c\n        };\n        return S.MeshBuilder.CreateTube(e, h, s);\n      }, _.CreatePolyhedron = function (e, t, i) {\n        return S.MeshBuilder.CreatePolyhedron(e, t, i);\n      }, _.CreateIcoSphere = function (e, t, i) {\n        return S.MeshBuilder.CreateIcoSphere(e, t, i);\n      }, _.CreateDecal = function (e, t, i, r, n, o) {\n        var s = {\n          position: i,\n          normal: r,\n          size: n,\n          angle: o\n        };\n        return S.MeshBuilder.CreateDecal(e, t, s);\n      }, _.prototype.setPositionsForCPUSkinning = function () {\n        if (!this._sourcePositions) {\n          var e = this.getVerticesData(S.VertexBuffer.PositionKind);\n          if (!e) return this._sourcePositions;\n          this._sourcePositions = new Float32Array(e), this.isVertexBufferUpdatable(S.VertexBuffer.PositionKind) || this.setVerticesData(S.VertexBuffer.PositionKind, e, !0);\n        }\n\n        return this._sourcePositions;\n      }, _.prototype.setNormalsForCPUSkinning = function () {\n        if (!this._sourceNormals) {\n          var e = this.getVerticesData(S.VertexBuffer.NormalKind);\n          if (!e) return this._sourceNormals;\n          this._sourceNormals = new Float32Array(e), this.isVertexBufferUpdatable(S.VertexBuffer.NormalKind) || this.setVerticesData(S.VertexBuffer.NormalKind, e, !0);\n        }\n\n        return this._sourceNormals;\n      }, _.prototype.applySkeleton = function (e) {\n        if (!this.geometry) return this;\n        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) return this;\n        if (this.geometry._softwareSkinningFrameId = this.getScene().getFrameId(), !this.isVerticesDataPresent(S.VertexBuffer.PositionKind)) return this;\n        if (!this.isVerticesDataPresent(S.VertexBuffer.NormalKind)) return this;\n        if (!this.isVerticesDataPresent(S.VertexBuffer.MatricesIndicesKind)) return this;\n        if (!this.isVerticesDataPresent(S.VertexBuffer.MatricesWeightsKind)) return this;\n\n        if (!this._sourcePositions) {\n          var t = this.subMeshes.slice();\n          this.setPositionsForCPUSkinning(), this.subMeshes = t;\n        }\n\n        this._sourceNormals || this.setNormalsForCPUSkinning();\n        var i = this.getVerticesData(S.VertexBuffer.PositionKind);\n        if (!i) return this;\n        i instanceof Float32Array || (i = new Float32Array(i));\n        var r = this.getVerticesData(S.VertexBuffer.NormalKind);\n        if (!r) return this;\n        r instanceof Float32Array || (r = new Float32Array(r));\n        var n = this.getVerticesData(S.VertexBuffer.MatricesIndicesKind),\n            o = this.getVerticesData(S.VertexBuffer.MatricesWeightsKind);\n        if (!o || !n) return this;\n\n        for (var s, a = 4 < this.numBoneInfluencers, l = a ? this.getVerticesData(S.VertexBuffer.MatricesIndicesExtraKind) : null, c = a ? this.getVerticesData(S.VertexBuffer.MatricesWeightsExtraKind) : null, h = e.getTransformMatrices(this), u = S.Vector3.Zero(), d = new S.Matrix(), f = new S.Matrix(), p = 0, _ = 0; _ < i.length; _ += 3, p += 4) {\n          var m;\n\n          for (s = 0; s < 4; s++) 0 < (m = o[p + s]) && (S.Matrix.FromFloat32ArrayToRefScaled(h, Math.floor(16 * n[p + s]), m, f), d.addToSelf(f));\n\n          if (a) for (s = 0; s < 4; s++) 0 < (m = c[p + s]) && (S.Matrix.FromFloat32ArrayToRefScaled(h, Math.floor(16 * l[p + s]), m, f), d.addToSelf(f));\n          S.Vector3.TransformCoordinatesFromFloatsToRef(this._sourcePositions[_], this._sourcePositions[_ + 1], this._sourcePositions[_ + 2], d, u), u.toArray(i, _), S.Vector3.TransformNormalFromFloatsToRef(this._sourceNormals[_], this._sourceNormals[_ + 1], this._sourceNormals[_ + 2], d, u), u.toArray(r, _), d.reset();\n        }\n\n        return this.updateVerticesData(S.VertexBuffer.PositionKind, i), this.updateVerticesData(S.VertexBuffer.NormalKind, r), this;\n      }, _.MinMax = function (e) {\n        var n = null,\n            o = null;\n        return e.forEach(function (e, t, i) {\n          var r = e.getBoundingInfo().boundingBox;\n          n && o ? (n.minimizeInPlace(r.minimumWorld), o.maximizeInPlace(r.maximumWorld)) : (n = r.minimumWorld, o = r.maximumWorld);\n        }), n && o ? {\n          min: n,\n          max: o\n        } : {\n          min: S.Vector3.Zero(),\n          max: S.Vector3.Zero()\n        };\n      }, _.Center = function (e) {\n        var t = e instanceof Array ? _.MinMax(e) : e;\n        return S.Vector3.Center(t.min, t.max);\n      }, _.MergeMeshes = function (e, t, i, r, n) {\n        var o;\n\n        if (void 0 === t && (t = !0), !i) {\n          var s = 0;\n\n          for (o = 0; o < e.length; o++) if (e[o] && 65536 < (s += e[o].getTotalVertices())) return S.Tools.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\"), null;\n        }\n\n        var a,\n            l = null,\n            c = new Array(),\n            h = null;\n\n        for (o = 0; o < e.length; o++) if (e[o]) {\n          var u = e[o].computeWorldMatrix(!0);\n          (a = S.VertexData.ExtractFromMesh(e[o], !0, !0)).transform(u), l ? l.merge(a, i) : (l = a, h = e[o]), n && c.push(e[o].getTotalIndices());\n        }\n\n        if (h = h, r || (r = new _(h.name + \"_merged\", h.getScene())), l.applyToMesh(r), r.material = h.material, r.checkCollisions = h.checkCollisions, t) for (o = 0; o < e.length; o++) e[o] && e[o].dispose();\n\n        if (n) {\n          r.releaseSubMeshes();\n\n          for (var d = o = 0; o < c.length;) S.SubMesh.CreateFromIndices(0, d, c[o], r), d += c[o], o++;\n        }\n\n        return r;\n      }, _.FRONTSIDE = 0, _.BACKSIDE = 1, _.DOUBLESIDE = 2, _.DEFAULTSIDE = 0, _.NO_CAP = 0, _.CAP_START = 1, _.CAP_END = 2, _.CAP_ALL = 3, _;\n    }(S.AbstractMesh);\n\n    S.Mesh = i;\n  }($a || ($a = {})), ne = $a || ($a = {}), oe = function () {\n    function e() {}\n\n    return Object.defineProperty(e.prototype, \"effect\", {\n      get: function () {\n        return this._materialEffect;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.setEffect = function (e, t) {\n      void 0 === t && (t = null), this._materialEffect !== e ? (this._materialDefines = t, this._materialEffect = e) : e || (this._materialDefines = null);\n    }, e;\n  }(), se = function (c) {\n    function h(e, t, i, r, n, o, s, a) {\n      void 0 === a && (a = !0);\n      var l = c.call(this) || this;\n      return l.materialIndex = e, l.verticesStart = t, l.verticesCount = i, l.indexStart = r, l.indexCount = n, l._renderId = 0, l._mesh = o, l._renderingMesh = s || o, o.subMeshes.push(l), l._trianglePlanes = [], l._id = o.subMeshes.length - 1, a && (l.refreshBoundingInfo(), o.computeWorldMatrix(!0)), l;\n    }\n\n    return T(h, c), h.AddToMesh = function (e, t, i, r, n, o, s, a) {\n      return void 0 === a && (a = !0), new h(e, t, i, r, n, o, s, a);\n    }, Object.defineProperty(h.prototype, \"IsGlobal\", {\n      get: function () {\n        return 0 === this.verticesStart && this.verticesCount === this._mesh.getTotalVertices();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), h.prototype.getBoundingInfo = function () {\n      return this.IsGlobal ? this._mesh.getBoundingInfo() : this._boundingInfo;\n    }, h.prototype.setBoundingInfo = function (e) {\n      return this._boundingInfo = e, this;\n    }, h.prototype.getMesh = function () {\n      return this._mesh;\n    }, h.prototype.getRenderingMesh = function () {\n      return this._renderingMesh;\n    }, h.prototype.getMaterial = function () {\n      var e = this._renderingMesh.material;\n      if (null == e) return this._mesh.getScene().defaultMaterial;\n\n      if (e.getSubMaterial) {\n        var t = e.getSubMaterial(this.materialIndex);\n        return this._currentMaterial !== t && (this._currentMaterial = t, this._materialDefines = null), t;\n      }\n\n      return e;\n    }, h.prototype.refreshBoundingInfo = function () {\n      if (this._lastColliderWorldVertices = null, this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) return this;\n\n      var e = this._renderingMesh.getVerticesData(ne.VertexBuffer.PositionKind);\n\n      if (!e) return this._boundingInfo = this._mesh.getBoundingInfo(), this;\n\n      var t,\n          i = this._renderingMesh.getIndices();\n\n      if (0 === this.indexStart && this.indexCount === i.length) {\n        var r = this._renderingMesh.getBoundingInfo();\n\n        t = {\n          minimum: r.minimum.clone(),\n          maximum: r.maximum.clone()\n        };\n      } else t = ne.Tools.ExtractMinAndMaxIndexed(e, i, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n\n      return this._boundingInfo = new ne.BoundingInfo(t.minimum, t.maximum), this;\n    }, h.prototype._checkCollision = function (e) {\n      return this.getBoundingInfo()._checkCollision(e);\n    }, h.prototype.updateBoundingInfo = function (e) {\n      var t = this.getBoundingInfo();\n      return t || (this.refreshBoundingInfo(), t = this.getBoundingInfo()), t.update(e), this;\n    }, h.prototype.isInFrustum = function (e) {\n      var t = this.getBoundingInfo();\n      return !!t && t.isInFrustum(e, this._mesh.cullingStrategy);\n    }, h.prototype.isCompletelyInFrustum = function (e) {\n      var t = this.getBoundingInfo();\n      return !!t && t.isCompletelyInFrustum(e);\n    }, h.prototype.render = function (e) {\n      return this._renderingMesh.render(this, e), this;\n    }, h.prototype._getLinesIndexBuffer = function (e, t) {\n      if (!this._linesIndexBuffer) {\n        for (var i = [], r = this.indexStart; r < this.indexStart + this.indexCount; r += 3) i.push(e[r], e[r + 1], e[r + 1], e[r + 2], e[r + 2], e[r]);\n\n        this._linesIndexBuffer = t.createIndexBuffer(i), this._linesIndexCount = i.length;\n      }\n\n      return this._linesIndexBuffer;\n    }, h.prototype.canIntersects = function (e) {\n      var t = this.getBoundingInfo();\n      return !!t && e.intersectsBox(t.boundingBox);\n    }, h.prototype.intersects = function (e, t, i, r) {\n      var n = this.getMaterial();\n      if (!n) return null;\n\n      switch (n.fillMode) {\n        case ne.Material.PointListDrawMode:\n        case ne.Material.LineListDrawMode:\n        case ne.Material.LineLoopDrawMode:\n        case ne.Material.LineStripDrawMode:\n        case ne.Material.TriangleFanDrawMode:\n        case ne.Material.TriangleStripDrawMode:\n          return null;\n      }\n\n      if (ne.LinesMesh) {\n        var o = this._mesh instanceof ne.InstancedMesh ? this._mesh.sourceMesh : this._mesh;\n\n        if (o instanceof ne.LinesMesh) {\n          var s = o;\n          return this._intersectLines(e, t, i, s.intersectionThreshold, r);\n        }\n      }\n\n      return this._intersectTriangles(e, t, i, r);\n    }, h.prototype._intersectLines = function (e, t, i, r, n) {\n      for (var o = null, s = this.indexStart; s < this.indexStart + this.indexCount; s += 2) {\n        var a = t[i[s]],\n            l = t[i[s + 1]],\n            c = e.intersectionSegment(a, l, r);\n        if (!(c < 0) && (n || !o || c < o.distance) && (o = new ne.IntersectionInfo(null, null, c), n)) break;\n      }\n\n      return o;\n    }, h.prototype._intersectTriangles = function (e, t, i, r) {\n      for (var n = null, o = this.indexStart; o < this.indexStart + this.indexCount; o += 3) {\n        var s = t[i[o]],\n            a = t[i[o + 1]],\n            l = t[i[o + 2]],\n            c = e.intersectsTriangle(s, a, l);\n\n        if (c) {\n          if (c.distance < 0) continue;\n          if ((r || !n || c.distance < n.distance) && ((n = c).faceId = o / 3, r)) break;\n        }\n      }\n\n      return n;\n    }, h.prototype._rebuild = function () {\n      this._linesIndexBuffer && (this._linesIndexBuffer = null);\n    }, h.prototype.clone = function (e, t) {\n      var i = new h(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, e, t, !1);\n\n      if (!this.IsGlobal) {\n        var r = this.getBoundingInfo();\n        if (!r) return i;\n        i._boundingInfo = new ne.BoundingInfo(r.minimum, r.maximum);\n      }\n\n      return i;\n    }, h.prototype.dispose = function () {\n      this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer), this._linesIndexBuffer = null);\n\n      var e = this._mesh.subMeshes.indexOf(this);\n\n      this._mesh.subMeshes.splice(e, 1);\n    }, h.CreateFromIndices = function (e, t, i, r, n) {\n      for (var o = Number.MAX_VALUE, s = -Number.MAX_VALUE, a = (n = n || r).getIndices(), l = t; l < t + i; l++) {\n        var c = a[l];\n        c < o && (o = c), s < c && (s = c);\n      }\n\n      return new h(e, o, s - o + 1, t, i, r, n);\n    }, h;\n  }(ne.BaseSubMesh = oe), ne.SubMesh = se;\n\n  var le, ce, he, ue, de, fe, pe, _e, me, ge, ve, ye, be, Te, Ee, xe, Pe, Ae, Se, Me, Re, Ce, Oe, De, Ie, we, Le, Fe, Be, Ne, Ve, Ue, ze, Ge, ke, We, He, Xe, je, Ye, Ke, Qe, Ze, qe, Je, $e, et, tt, it, rt, nt, ot, st, at, lt, ct, ht, ut, dt, ft, pt, _t, mt, gt, vt, yt, bt, Tt, Et, xt, Pt, At, St, Mt, Rt, Ct, Ot, Dt, It, wt, Lt, Ft, Bt, Nt, Vt, Ut, zt, Gt, kt, Wt, Ht, Xt, jt, Yt, Kt, Qt, Zt, qt, Jt, $t, ei, ti, ii, ri, ni, oi, si, ai, li, ci, hi, ui, di, fi, pi, _i, mi, gi, vi, yi, bi, Ti, Ei, xi, Pi, Ai, Si, Mi, Ri, Ci, Oi, Di, Ii, wi, Li, Fi, Bi, Ni, Vi, Ui, zi, Gi, ki, Wi, Hi, Xi, ji, Yi, Ki, Qi, Zi, qi, Ji;\n\n  ae = this && this.__assign || function () {\n    return (ae = Object.assign || function (e) {\n      for (var t, i = 1, r = arguments.length; i < r; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n      return e;\n    }).apply(this, arguments);\n  };\n\n  !function (l) {\n    var e = function () {\n      function e() {\n        this._isDirty = !0, this._areLightsDirty = !0, this._areAttributesDirty = !0, this._areTexturesDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._areImageProcessingDirty = !0, this._normals = !1, this._uvs = !1, this._needNormals = !1, this._needUVs = !1;\n      }\n\n      return Object.defineProperty(e.prototype, \"isDirty\", {\n        get: function () {\n          return this._isDirty;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.markAsProcessed = function () {\n        this._isDirty = !1, this._areAttributesDirty = !1, this._areTexturesDirty = !1, this._areFresnelDirty = !1, this._areLightsDirty = !1, this._areMiscDirty = !1, this._areImageProcessingDirty = !1;\n      }, e.prototype.markAsUnprocessed = function () {\n        this._isDirty = !0;\n      }, e.prototype.markAllAsDirty = function () {\n        this._areTexturesDirty = !0, this._areAttributesDirty = !0, this._areLightsDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._areImageProcessingDirty = !0, this._isDirty = !0;\n      }, e.prototype.markAsImageProcessingDirty = function () {\n        this._areImageProcessingDirty = !0, this._isDirty = !0;\n      }, e.prototype.markAsLightDirty = function () {\n        this._areLightsDirty = !0, this._isDirty = !0;\n      }, e.prototype.markAsAttributesDirty = function () {\n        this._areAttributesDirty = !0, this._isDirty = !0;\n      }, e.prototype.markAsTexturesDirty = function () {\n        this._areTexturesDirty = !0, this._isDirty = !0;\n      }, e.prototype.markAsFresnelDirty = function () {\n        this._areFresnelDirty = !0, this._isDirty = !0;\n      }, e.prototype.markAsMiscDirty = function () {\n        this._areMiscDirty = !0, this._isDirty = !0;\n      }, e.prototype.rebuild = function () {\n        this._keys && delete this._keys, this._keys = [];\n\n        for (var e = 0, t = Object.keys(this); e < t.length; e++) {\n          var i = t[e];\n          \"_\" !== i[0] && this._keys.push(i);\n        }\n      }, e.prototype.isEqual = function (e) {\n        if (this._keys.length !== e._keys.length) return !1;\n\n        for (var t = 0; t < this._keys.length; t++) {\n          var i = this._keys[t];\n          if (this[i] !== e[i]) return !1;\n        }\n\n        return !0;\n      }, e.prototype.cloneTo = function (e) {\n        this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0));\n\n        for (var t = 0; t < this._keys.length; t++) {\n          var i = this._keys[t];\n          e[i] = this[i];\n        }\n      }, e.prototype.reset = function () {\n        for (var e = 0; e < this._keys.length; e++) {\n          var t = this._keys[e];\n\n          switch (typeof this[t]) {\n            case \"number\":\n              this[t] = 0;\n              break;\n\n            case \"string\":\n              this[t] = \"\";\n              break;\n\n            default:\n              this[t] = !1;\n          }\n        }\n      }, e.prototype.toString = function () {\n        for (var e = \"\", t = 0; t < this._keys.length; t++) {\n          var i = this._keys[t],\n              r = this[i];\n\n          switch (typeof r) {\n            case \"number\":\n            case \"string\":\n              e += \"#define \" + i + \" \" + r + \"\\n\";\n              break;\n\n            default:\n              r && (e += \"#define \" + i + \"\\n\");\n          }\n        }\n\n        return e;\n      }, e;\n    }();\n\n    l.MaterialDefines = e;\n\n    var t = function () {\n      function n(e, t, i) {\n        this.checkReadyOnEveryCall = !1, this.checkReadyOnlyOnce = !1, this.state = \"\", this._alpha = 1, this._backFaceCulling = !0, this.doNotSerialize = !1, this.storeEffectOnSubMeshes = !1, this.onDisposeObservable = new l.Observable(), this._alphaMode = l.Engine.ALPHA_COMBINE, this._needDepthPrePass = !1, this.disableDepthWrite = !1, this.forceDepthWrite = !1, this.separateCullingPass = !1, this._fogEnabled = !0, this.pointSize = 1, this.zOffset = 0, this._wasPreviouslyReady = !1, this._fillMode = n.TriangleFillMode, this.name = e, this.id = e || l.Tools.RandomId(), this._scene = t || l.Engine.LastCreatedScene, this.uniqueId = this._scene.getUniqueId(), this._scene.useRightHandedSystem ? this.sideOrientation = n.ClockWiseSideOrientation : this.sideOrientation = n.CounterClockWiseSideOrientation, this._uniformBuffer = new l.UniformBuffer(this._scene.getEngine()), this._useUBO = this.getScene().getEngine().supportsUniformBuffers, i || (this._scene.materials.push(this), this._scene.onNewMaterialAddedObservable.notifyObservers(this));\n      }\n\n      return Object.defineProperty(n, \"TriangleFillMode\", {\n        get: function () {\n          return n._TriangleFillMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"WireFrameFillMode\", {\n        get: function () {\n          return n._WireFrameFillMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"PointFillMode\", {\n        get: function () {\n          return n._PointFillMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"PointListDrawMode\", {\n        get: function () {\n          return n._PointListDrawMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"LineListDrawMode\", {\n        get: function () {\n          return n._LineListDrawMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"LineLoopDrawMode\", {\n        get: function () {\n          return n._LineLoopDrawMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"LineStripDrawMode\", {\n        get: function () {\n          return n._LineStripDrawMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"TriangleStripDrawMode\", {\n        get: function () {\n          return n._TriangleStripDrawMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"TriangleFanDrawMode\", {\n        get: function () {\n          return n._TriangleFanDrawMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"ClockWiseSideOrientation\", {\n        get: function () {\n          return n._ClockWiseSideOrientation;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n, \"CounterClockWiseSideOrientation\", {\n        get: function () {\n          return n._CounterClockWiseSideOrientation;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"alpha\", {\n        get: function () {\n          return this._alpha;\n        },\n        set: function (e) {\n          this._alpha !== e && (this._alpha = e, this.markAsDirty(n.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"backFaceCulling\", {\n        get: function () {\n          return this._backFaceCulling;\n        },\n        set: function (e) {\n          this._backFaceCulling !== e && (this._backFaceCulling = e, this.markAsDirty(n.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"hasRenderTargetTextures\", {\n        get: function () {\n          return !1;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"onDispose\", {\n        set: function (e) {\n          this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"onBindObservable\", {\n        get: function () {\n          return this._onBindObservable || (this._onBindObservable = new l.Observable()), this._onBindObservable;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"onBind\", {\n        set: function (e) {\n          this._onBindObserver && this.onBindObservable.remove(this._onBindObserver), this._onBindObserver = this.onBindObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"onUnBindObservable\", {\n        get: function () {\n          return this._onUnBindObservable || (this._onUnBindObservable = new l.Observable()), this._onUnBindObservable;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"alphaMode\", {\n        get: function () {\n          return this._alphaMode;\n        },\n        set: function (e) {\n          this._alphaMode !== e && (this._alphaMode = e, this.markAsDirty(n.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"needDepthPrePass\", {\n        get: function () {\n          return this._needDepthPrePass;\n        },\n        set: function (e) {\n          this._needDepthPrePass !== e && (this._needDepthPrePass = e, this._needDepthPrePass && (this.checkReadyOnEveryCall = !0));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"fogEnabled\", {\n        get: function () {\n          return this._fogEnabled;\n        },\n        set: function (e) {\n          this._fogEnabled !== e && (this._fogEnabled = e, this.markAsDirty(n.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"wireframe\", {\n        get: function () {\n          switch (this._fillMode) {\n            case n.WireFrameFillMode:\n            case n.LineListDrawMode:\n            case n.LineLoopDrawMode:\n            case n.LineStripDrawMode:\n              return !0;\n          }\n\n          return this._scene.forceWireframe;\n        },\n        set: function (e) {\n          this.fillMode = e ? n.WireFrameFillMode : n.TriangleFillMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"pointsCloud\", {\n        get: function () {\n          switch (this._fillMode) {\n            case n.PointFillMode:\n            case n.PointListDrawMode:\n              return !0;\n          }\n\n          return this._scene.forcePointsCloud;\n        },\n        set: function (e) {\n          this.fillMode = e ? n.PointFillMode : n.TriangleFillMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"fillMode\", {\n        get: function () {\n          return this._fillMode;\n        },\n        set: function (e) {\n          this._fillMode !== e && (this._fillMode = e, this.markAsDirty(n.MiscDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), n.prototype.toString = function (e) {\n        return \"Name: \" + this.name;\n      }, n.prototype.getClassName = function () {\n        return \"Material\";\n      }, Object.defineProperty(n.prototype, \"isFrozen\", {\n        get: function () {\n          return this.checkReadyOnlyOnce;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), n.prototype.freeze = function () {\n        this.checkReadyOnlyOnce = !0;\n      }, n.prototype.unfreeze = function () {\n        this.checkReadyOnlyOnce = !1;\n      }, n.prototype.isReady = function (e, t) {\n        return !0;\n      }, n.prototype.isReadyForSubMesh = function (e, t, i) {\n        return !1;\n      }, n.prototype.getEffect = function () {\n        return this._effect;\n      }, n.prototype.getScene = function () {\n        return this._scene;\n      }, n.prototype.needAlphaBlending = function () {\n        return this.alpha < 1;\n      }, n.prototype.needAlphaBlendingForMesh = function (e) {\n        return this.needAlphaBlending() || e.visibility < 1 || e.hasVertexAlpha;\n      }, n.prototype.needAlphaTesting = function () {\n        return !1;\n      }, n.prototype.getAlphaTestTexture = function () {\n        return null;\n      }, n.prototype.markDirty = function () {\n        this._wasPreviouslyReady = !1;\n      }, n.prototype._preBind = function (e, t) {\n        void 0 === t && (t = null);\n\n        var i = this._scene.getEngine(),\n            r = (null == t ? this.sideOrientation : t) === n.ClockWiseSideOrientation;\n\n        return i.enableEffect(e || this._effect), i.setState(this.backFaceCulling, this.zOffset, !1, r), r;\n      }, n.prototype.bind = function (e, t) {}, n.prototype.bindForSubMesh = function (e, t, i) {}, n.prototype.bindOnlyWorldMatrix = function (e) {}, n.prototype.bindSceneUniformBuffer = function (e, t) {\n        t.bindToEffect(e, \"Scene\");\n      }, n.prototype.bindView = function (e) {\n        this._useUBO ? this.bindSceneUniformBuffer(e, this.getScene().getSceneUniformBuffer()) : e.setMatrix(\"view\", this.getScene().getViewMatrix());\n      }, n.prototype.bindViewProjection = function (e) {\n        this._useUBO ? this.bindSceneUniformBuffer(e, this.getScene().getSceneUniformBuffer()) : e.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n      }, n.prototype._shouldTurnAlphaTestOn = function (e) {\n        return !this.needAlphaBlendingForMesh(e) && this.needAlphaTesting();\n      }, n.prototype._afterBind = function (e) {\n        if ((this._scene._cachedMaterial = this)._scene._cachedVisibility = e ? e.visibility : 1, this._onBindObservable && e && this._onBindObservable.notifyObservers(e), this.disableDepthWrite) {\n          var t = this._scene.getEngine();\n\n          this._cachedDepthWriteState = t.getDepthWrite(), t.setDepthWrite(!1);\n        }\n      }, n.prototype.unbind = function () {\n        (this._onUnBindObservable && this._onUnBindObservable.notifyObservers(this), this.disableDepthWrite) && this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState);\n      }, n.prototype.getActiveTextures = function () {\n        return [];\n      }, n.prototype.hasTexture = function (e) {\n        return !1;\n      }, n.prototype.clone = function (e) {\n        return null;\n      }, n.prototype.getBindedMeshes = function () {\n        for (var e = new Array(), t = 0; t < this._scene.meshes.length; t++) {\n          var i = this._scene.meshes[t];\n          i.material === this && e.push(i);\n        }\n\n        return e;\n      }, n.prototype.forceCompilation = function (t, i, e) {\n        var r = this,\n            n = ae({\n          clipPlane: !1\n        }, e),\n            o = new l.BaseSubMesh(),\n            s = this.getScene(),\n            a = function () {\n          if (r._scene && r._scene.getEngine()) {\n            o._materialDefines && (o._materialDefines._renderId = -1);\n            var e = s.clipPlane;\n            n.clipPlane && (s.clipPlane = new l.Plane(0, 0, 0, 1)), r.storeEffectOnSubMeshes ? r.isReadyForSubMesh(t, o) ? i && i(r) : setTimeout(a, 16) : r.isReady(t) ? i && i(r) : setTimeout(a, 16), n.clipPlane && (s.clipPlane = e);\n          }\n        };\n\n        a();\n      }, n.prototype.forceCompilationAsync = function (t, i) {\n        var r = this;\n        return new Promise(function (e) {\n          r.forceCompilation(t, function () {\n            e();\n          }, i);\n        });\n      }, n.prototype.markAsDirty = function (e) {\n        e & n.TextureDirtyFlag && this._markAllSubMeshesAsTexturesDirty(), e & n.LightDirtyFlag && this._markAllSubMeshesAsLightsDirty(), e & n.FresnelDirtyFlag && this._markAllSubMeshesAsFresnelDirty(), e & n.AttributesDirtyFlag && this._markAllSubMeshesAsAttributesDirty(), e & n.MiscDirtyFlag && this._markAllSubMeshesAsMiscDirty(), this.getScene().resetCachedMaterial();\n      }, n.prototype._markAllSubMeshesAsDirty = function (e) {\n        for (var t = 0, i = this.getScene().meshes; t < i.length; t++) {\n          var r = i[t];\n          if (r.subMeshes) for (var n = 0, o = r.subMeshes; n < o.length; n++) {\n            var s = o[n];\n            s.getMaterial() === this && s._materialDefines && e(s._materialDefines);\n          }\n        }\n      }, n.prototype._markAllSubMeshesAsImageProcessingDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          return e.markAsImageProcessingDirty();\n        });\n      }, n.prototype._markAllSubMeshesAsTexturesDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          return e.markAsTexturesDirty();\n        });\n      }, n.prototype._markAllSubMeshesAsFresnelDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          return e.markAsFresnelDirty();\n        });\n      }, n.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          e.markAsFresnelDirty(), e.markAsMiscDirty();\n        });\n      }, n.prototype._markAllSubMeshesAsLightsDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          return e.markAsLightDirty();\n        });\n      }, n.prototype._markAllSubMeshesAsAttributesDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          return e.markAsAttributesDirty();\n        });\n      }, n.prototype._markAllSubMeshesAsMiscDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          return e.markAsMiscDirty();\n        });\n      }, n.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function () {\n        this._markAllSubMeshesAsDirty(function (e) {\n          e.markAsTexturesDirty(), e.markAsMiscDirty();\n        });\n      }, n.prototype.dispose = function (e, t) {\n        this.getScene().stopAnimation(this), this.getScene().freeProcessedMaterials();\n\n        var i = this._scene.materials.indexOf(this);\n\n        for (0 <= i && this._scene.materials.splice(i, 1), this._scene.onMaterialRemovedObservable.notifyObservers(this), i = 0; i < this._scene.meshes.length; i++) {\n          var r = this._scene.meshes[i];\n\n          if (r.material === this && (r.material = null, r.geometry)) {\n            var n = r.geometry;\n            if (this.storeEffectOnSubMeshes) for (var o = 0, s = r.subMeshes; o < s.length; o++) {\n              var a = s[o];\n              n._releaseVertexArrayObject(a._materialEffect), e && a._materialEffect && this._scene.getEngine()._releaseEffect(a._materialEffect);\n            } else n._releaseVertexArrayObject(this._effect);\n          }\n        }\n\n        this._uniformBuffer.dispose(), e && this._effect && (this.storeEffectOnSubMeshes || this._scene.getEngine()._releaseEffect(this._effect), this._effect = null), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this._onBindObservable && this._onBindObservable.clear(), this._onUnBindObservable && this._onUnBindObservable.clear();\n      }, n.prototype.serialize = function () {\n        return l.SerializationHelper.Serialize(this);\n      }, n.ParseMultiMaterial = function (e, t) {\n        var i = new l.MultiMaterial(e.name, t);\n        i.id = e.id, l.Tags && l.Tags.AddTagsTo(i, e.tags);\n\n        for (var r = 0; r < e.materials.length; r++) {\n          var n = e.materials[r];\n          n ? i.subMaterials.push(t.getMaterialByID(n)) : i.subMaterials.push(null);\n        }\n\n        return i;\n      }, n.Parse = function (e, t, i) {\n        return e.customType && \"BABYLON.StandardMaterial\" !== e.customType ? \"BABYLON.PBRMaterial\" !== e.customType || !e.overloadedAlbedo || (e.customType = \"BABYLON.LegacyPBRMaterial\", l.LegacyPBRMaterial) ? l.Tools.Instantiate(e.customType).Parse(e, t, i) : void l.Tools.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\") : l.StandardMaterial.Parse(e, t, i);\n      }, n._TriangleFillMode = 0, n._WireFrameFillMode = 1, n._PointFillMode = 2, n._PointListDrawMode = 3, n._LineListDrawMode = 4, n._LineLoopDrawMode = 5, n._LineStripDrawMode = 6, n._TriangleStripDrawMode = 7, n._TriangleFanDrawMode = 8, n._ClockWiseSideOrientation = 0, n._CounterClockWiseSideOrientation = 1, n.TextureDirtyFlag = 1, n.LightDirtyFlag = 2, n.FresnelDirtyFlag = 4, n.AttributesDirtyFlag = 8, n.MiscDirtyFlag = 16, n.AllDirtyFlag = 31, b([l.serialize()], n.prototype, \"id\", void 0), b([l.serialize()], n.prototype, \"uniqueId\", void 0), b([l.serialize()], n.prototype, \"name\", void 0), b([l.serialize()], n.prototype, \"checkReadyOnEveryCall\", void 0), b([l.serialize()], n.prototype, \"checkReadyOnlyOnce\", void 0), b([l.serialize()], n.prototype, \"state\", void 0), b([l.serialize(\"alpha\")], n.prototype, \"_alpha\", void 0), b([l.serialize(\"backFaceCulling\")], n.prototype, \"_backFaceCulling\", void 0), b([l.serialize()], n.prototype, \"sideOrientation\", void 0), b([l.serialize(\"alphaMode\")], n.prototype, \"_alphaMode\", void 0), b([l.serialize()], n.prototype, \"_needDepthPrePass\", void 0), b([l.serialize()], n.prototype, \"disableDepthWrite\", void 0), b([l.serialize()], n.prototype, \"forceDepthWrite\", void 0), b([l.serialize()], n.prototype, \"separateCullingPass\", void 0), b([l.serialize(\"fogEnabled\")], n.prototype, \"_fogEnabled\", void 0), b([l.serialize()], n.prototype, \"pointSize\", void 0), b([l.serialize()], n.prototype, \"zOffset\", void 0), b([l.serialize()], n.prototype, \"wireframe\", null), b([l.serialize()], n.prototype, \"pointsCloud\", null), b([l.serialize()], n.prototype, \"fillMode\", null), n;\n    }();\n\n    l.Material = t;\n  }($a || ($a = {})), le = $a || ($a = {}), ce = function () {\n    function s(e, t, i) {\n      this._engine = e, this._noUBO = !e.supportsUniformBuffers, this._dynamic = i, this._data = t || [], this._uniformLocations = {}, this._uniformSizes = {}, this._uniformLocationPointer = 0, this._needSync = !1, this._noUBO ? (this.updateMatrix3x3 = this._updateMatrix3x3ForEffect, this.updateMatrix2x2 = this._updateMatrix2x2ForEffect, this.updateFloat = this._updateFloatForEffect, this.updateFloat2 = this._updateFloat2ForEffect, this.updateFloat3 = this._updateFloat3ForEffect, this.updateFloat4 = this._updateFloat4ForEffect, this.updateMatrix = this._updateMatrixForEffect, this.updateVector3 = this._updateVector3ForEffect, this.updateVector4 = this._updateVector4ForEffect, this.updateColor3 = this._updateColor3ForEffect, this.updateColor4 = this._updateColor4ForEffect) : (this._engine._uniformBuffers.push(this), this.updateMatrix3x3 = this._updateMatrix3x3ForUniform, this.updateMatrix2x2 = this._updateMatrix2x2ForUniform, this.updateFloat = this._updateFloatForUniform, this.updateFloat2 = this._updateFloat2ForUniform, this.updateFloat3 = this._updateFloat3ForUniform, this.updateFloat4 = this._updateFloat4ForUniform, this.updateMatrix = this._updateMatrixForUniform, this.updateVector3 = this._updateVector3ForUniform, this.updateVector4 = this._updateVector4ForUniform, this.updateColor3 = this._updateColor3ForUniform, this.updateColor4 = this._updateColor4ForUniform);\n    }\n\n    return Object.defineProperty(s.prototype, \"useUbo\", {\n      get: function () {\n        return !this._noUBO;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"isSync\", {\n      get: function () {\n        return !this._needSync;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), s.prototype.isDynamic = function () {\n      return void 0 !== this._dynamic;\n    }, s.prototype.getData = function () {\n      return this._bufferData;\n    }, s.prototype.getBuffer = function () {\n      return this._buffer;\n    }, s.prototype._fillAlignment = function (e) {\n      var t;\n\n      if (t = e <= 2 ? e : 4, this._uniformLocationPointer % t != 0) {\n        var i = this._uniformLocationPointer;\n        this._uniformLocationPointer += t - this._uniformLocationPointer % t;\n\n        for (var r = this._uniformLocationPointer - i, n = 0; n < r; n++) this._data.push(0);\n      }\n    }, s.prototype.addUniform = function (e, t) {\n      if (!this._noUBO && void 0 === this._uniformLocations[e]) {\n        var i;\n        if (t instanceof Array) t = (i = t).length;else {\n          t = t, i = [];\n\n          for (var r = 0; r < t; r++) i.push(0);\n        }\n        this._fillAlignment(t), this._uniformSizes[e] = t, this._uniformLocations[e] = this._uniformLocationPointer, this._uniformLocationPointer += t;\n\n        for (r = 0; r < t; r++) this._data.push(i[r]);\n\n        this._needSync = !0;\n      }\n    }, s.prototype.addMatrix = function (e, t) {\n      this.addUniform(e, Array.prototype.slice.call(t.toArray()));\n    }, s.prototype.addFloat2 = function (e, t, i) {\n      var r = [t, i];\n      this.addUniform(e, r);\n    }, s.prototype.addFloat3 = function (e, t, i, r) {\n      var n = [t, i, r];\n      this.addUniform(e, n);\n    }, s.prototype.addColor3 = function (e, t) {\n      var i = new Array();\n      t.toArray(i), this.addUniform(e, i);\n    }, s.prototype.addColor4 = function (e, t, i) {\n      var r = new Array();\n      t.toArray(r), r.push(i), this.addUniform(e, r);\n    }, s.prototype.addVector3 = function (e, t) {\n      var i = new Array();\n      t.toArray(i), this.addUniform(e, i);\n    }, s.prototype.addMatrix3x3 = function (e) {\n      this.addUniform(e, 12);\n    }, s.prototype.addMatrix2x2 = function (e) {\n      this.addUniform(e, 8);\n    }, s.prototype.create = function () {\n      this._noUBO || this._buffer || (this._fillAlignment(4), this._bufferData = new Float32Array(this._data), this._rebuild(), this._needSync = !0);\n    }, s.prototype._rebuild = function () {\n      this._noUBO || (this._dynamic ? this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData) : this._buffer = this._engine.createUniformBuffer(this._bufferData));\n    }, s.prototype.update = function () {\n      this._buffer ? (this._dynamic || this._needSync) && (this._engine.updateUniformBuffer(this._buffer, this._bufferData), this._needSync = !1) : this.create();\n    }, s.prototype.updateUniform = function (e, t, i) {\n      var r = this._uniformLocations[e];\n\n      if (void 0 === r) {\n        if (this._buffer) return void le.Tools.Error(\"Cannot add an uniform after UBO has been created.\");\n        this.addUniform(e, i), r = this._uniformLocations[e];\n      }\n\n      if (this._buffer || this.create(), this._dynamic) for (o = 0; o < i; o++) this._bufferData[r + o] = t[o];else {\n        for (var n = !1, o = 0; o < i; o++) this._bufferData[r + o] !== t[o] && (n = !0, this._bufferData[r + o] = t[o]);\n\n        this._needSync = this._needSync || n;\n      }\n    }, s.prototype._updateMatrix3x3ForUniform = function (e, t) {\n      for (var i = 0; i < 3; i++) s._tempBuffer[4 * i] = t[3 * i], s._tempBuffer[4 * i + 1] = t[3 * i + 1], s._tempBuffer[4 * i + 2] = t[3 * i + 2], s._tempBuffer[4 * i + 3] = 0;\n\n      this.updateUniform(e, s._tempBuffer, 12);\n    }, s.prototype._updateMatrix3x3ForEffect = function (e, t) {\n      this._currentEffect.setMatrix3x3(e, t);\n    }, s.prototype._updateMatrix2x2ForEffect = function (e, t) {\n      this._currentEffect.setMatrix2x2(e, t);\n    }, s.prototype._updateMatrix2x2ForUniform = function (e, t) {\n      for (var i = 0; i < 2; i++) s._tempBuffer[4 * i] = t[2 * i], s._tempBuffer[4 * i + 1] = t[2 * i + 1], s._tempBuffer[4 * i + 2] = 0, s._tempBuffer[4 * i + 3] = 0;\n\n      this.updateUniform(e, s._tempBuffer, 8);\n    }, s.prototype._updateFloatForEffect = function (e, t) {\n      this._currentEffect.setFloat(e, t);\n    }, s.prototype._updateFloatForUniform = function (e, t) {\n      s._tempBuffer[0] = t, this.updateUniform(e, s._tempBuffer, 1);\n    }, s.prototype._updateFloat2ForEffect = function (e, t, i, r) {\n      void 0 === r && (r = \"\"), this._currentEffect.setFloat2(e + r, t, i);\n    }, s.prototype._updateFloat2ForUniform = function (e, t, i, r) {\n      void 0 === r && (r = \"\"), s._tempBuffer[0] = t, s._tempBuffer[1] = i, this.updateUniform(e, s._tempBuffer, 2);\n    }, s.prototype._updateFloat3ForEffect = function (e, t, i, r, n) {\n      void 0 === n && (n = \"\"), this._currentEffect.setFloat3(e + n, t, i, r);\n    }, s.prototype._updateFloat3ForUniform = function (e, t, i, r, n) {\n      void 0 === n && (n = \"\"), s._tempBuffer[0] = t, s._tempBuffer[1] = i, s._tempBuffer[2] = r, this.updateUniform(e, s._tempBuffer, 3);\n    }, s.prototype._updateFloat4ForEffect = function (e, t, i, r, n, o) {\n      void 0 === o && (o = \"\"), this._currentEffect.setFloat4(e + o, t, i, r, n);\n    }, s.prototype._updateFloat4ForUniform = function (e, t, i, r, n, o) {\n      void 0 === o && (o = \"\"), s._tempBuffer[0] = t, s._tempBuffer[1] = i, s._tempBuffer[2] = r, s._tempBuffer[3] = n, this.updateUniform(e, s._tempBuffer, 4);\n    }, s.prototype._updateMatrixForEffect = function (e, t) {\n      this._currentEffect.setMatrix(e, t);\n    }, s.prototype._updateMatrixForUniform = function (e, t) {\n      this.updateUniform(e, t.toArray(), 16);\n    }, s.prototype._updateVector3ForEffect = function (e, t) {\n      this._currentEffect.setVector3(e, t);\n    }, s.prototype._updateVector3ForUniform = function (e, t) {\n      t.toArray(s._tempBuffer), this.updateUniform(e, s._tempBuffer, 3);\n    }, s.prototype._updateVector4ForEffect = function (e, t) {\n      this._currentEffect.setVector4(e, t);\n    }, s.prototype._updateVector4ForUniform = function (e, t) {\n      t.toArray(s._tempBuffer), this.updateUniform(e, s._tempBuffer, 4);\n    }, s.prototype._updateColor3ForEffect = function (e, t, i) {\n      void 0 === i && (i = \"\"), this._currentEffect.setColor3(e + i, t);\n    }, s.prototype._updateColor3ForUniform = function (e, t, i) {\n      void 0 === i && (i = \"\"), t.toArray(s._tempBuffer), this.updateUniform(e, s._tempBuffer, 3);\n    }, s.prototype._updateColor4ForEffect = function (e, t, i, r) {\n      void 0 === r && (r = \"\"), this._currentEffect.setColor4(e + r, t, i);\n    }, s.prototype._updateColor4ForUniform = function (e, t, i, r) {\n      void 0 === r && (r = \"\"), t.toArray(s._tempBuffer), s._tempBuffer[3] = i, this.updateUniform(e, s._tempBuffer, 4);\n    }, s.prototype.setTexture = function (e, t) {\n      this._currentEffect.setTexture(e, t);\n    }, s.prototype.updateUniformDirectly = function (e, t) {\n      this.updateUniform(e, t, t.length), this.update();\n    }, s.prototype.bindToEffect = function (e, t) {\n      this._currentEffect = e, !this._noUBO && this._buffer && e.bindUniformBuffer(this._buffer, t);\n    }, s.prototype.dispose = function () {\n      if (!this._noUBO) {\n        var e = this._engine._uniformBuffers.indexOf(this);\n\n        -1 !== e && this._engine._uniformBuffers.splice(e, 1), this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null);\n      }\n    }, s._MAX_UNIFORM_SIZE = 256, s._tempBuffer = new Float32Array(s._MAX_UNIFORM_SIZE), s;\n  }(), le.UniformBuffer = ce, he = $a || ($a = {}), ue = function () {\n    function q() {}\n\n    return q.prototype.set = function (e, t) {\n      switch (t) {\n        case he.VertexBuffer.PositionKind:\n          this.positions = e;\n          break;\n\n        case he.VertexBuffer.NormalKind:\n          this.normals = e;\n          break;\n\n        case he.VertexBuffer.TangentKind:\n          this.tangents = e;\n          break;\n\n        case he.VertexBuffer.UVKind:\n          this.uvs = e;\n          break;\n\n        case he.VertexBuffer.UV2Kind:\n          this.uvs2 = e;\n          break;\n\n        case he.VertexBuffer.UV3Kind:\n          this.uvs3 = e;\n          break;\n\n        case he.VertexBuffer.UV4Kind:\n          this.uvs4 = e;\n          break;\n\n        case he.VertexBuffer.UV5Kind:\n          this.uvs5 = e;\n          break;\n\n        case he.VertexBuffer.UV6Kind:\n          this.uvs6 = e;\n          break;\n\n        case he.VertexBuffer.ColorKind:\n          this.colors = e;\n          break;\n\n        case he.VertexBuffer.MatricesIndicesKind:\n          this.matricesIndices = e;\n          break;\n\n        case he.VertexBuffer.MatricesWeightsKind:\n          this.matricesWeights = e;\n          break;\n\n        case he.VertexBuffer.MatricesIndicesExtraKind:\n          this.matricesIndicesExtra = e;\n          break;\n\n        case he.VertexBuffer.MatricesWeightsExtraKind:\n          this.matricesWeightsExtra = e;\n      }\n    }, q.prototype.applyToMesh = function (e, t) {\n      return this._applyTo(e, t), this;\n    }, q.prototype.applyToGeometry = function (e, t) {\n      return this._applyTo(e, t), this;\n    }, q.prototype.updateMesh = function (e, t, i) {\n      return this._update(e), this;\n    }, q.prototype.updateGeometry = function (e, t, i) {\n      return this._update(e), this;\n    }, q.prototype._applyTo = function (e, t) {\n      return void 0 === t && (t = !1), this.positions && e.setVerticesData(he.VertexBuffer.PositionKind, this.positions, t), this.normals && e.setVerticesData(he.VertexBuffer.NormalKind, this.normals, t), this.tangents && e.setVerticesData(he.VertexBuffer.TangentKind, this.tangents, t), this.uvs && e.setVerticesData(he.VertexBuffer.UVKind, this.uvs, t), this.uvs2 && e.setVerticesData(he.VertexBuffer.UV2Kind, this.uvs2, t), this.uvs3 && e.setVerticesData(he.VertexBuffer.UV3Kind, this.uvs3, t), this.uvs4 && e.setVerticesData(he.VertexBuffer.UV4Kind, this.uvs4, t), this.uvs5 && e.setVerticesData(he.VertexBuffer.UV5Kind, this.uvs5, t), this.uvs6 && e.setVerticesData(he.VertexBuffer.UV6Kind, this.uvs6, t), this.colors && e.setVerticesData(he.VertexBuffer.ColorKind, this.colors, t), this.matricesIndices && e.setVerticesData(he.VertexBuffer.MatricesIndicesKind, this.matricesIndices, t), this.matricesWeights && e.setVerticesData(he.VertexBuffer.MatricesWeightsKind, this.matricesWeights, t), this.matricesIndicesExtra && e.setVerticesData(he.VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, t), this.matricesWeightsExtra && e.setVerticesData(he.VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, t), this.indices ? e.setIndices(this.indices, null, t) : e.setIndices([], null), this;\n    }, q.prototype._update = function (e, t, i) {\n      return this.positions && e.updateVerticesData(he.VertexBuffer.PositionKind, this.positions, t, i), this.normals && e.updateVerticesData(he.VertexBuffer.NormalKind, this.normals, t, i), this.tangents && e.updateVerticesData(he.VertexBuffer.TangentKind, this.tangents, t, i), this.uvs && e.updateVerticesData(he.VertexBuffer.UVKind, this.uvs, t, i), this.uvs2 && e.updateVerticesData(he.VertexBuffer.UV2Kind, this.uvs2, t, i), this.uvs3 && e.updateVerticesData(he.VertexBuffer.UV3Kind, this.uvs3, t, i), this.uvs4 && e.updateVerticesData(he.VertexBuffer.UV4Kind, this.uvs4, t, i), this.uvs5 && e.updateVerticesData(he.VertexBuffer.UV5Kind, this.uvs5, t, i), this.uvs6 && e.updateVerticesData(he.VertexBuffer.UV6Kind, this.uvs6, t, i), this.colors && e.updateVerticesData(he.VertexBuffer.ColorKind, this.colors, t, i), this.matricesIndices && e.updateVerticesData(he.VertexBuffer.MatricesIndicesKind, this.matricesIndices, t, i), this.matricesWeights && e.updateVerticesData(he.VertexBuffer.MatricesWeightsKind, this.matricesWeights, t, i), this.matricesIndicesExtra && e.updateVerticesData(he.VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, t, i), this.matricesWeightsExtra && e.updateVerticesData(he.VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, t, i), this.indices && e.setIndices(this.indices, null), this;\n    }, q.prototype.transform = function (e) {\n      var t,\n          i = e.m[0] * e.m[5] * e.m[10] < 0,\n          r = he.Vector3.Zero();\n\n      if (this.positions) {\n        var n = he.Vector3.Zero();\n\n        for (t = 0; t < this.positions.length; t += 3) he.Vector3.FromArrayToRef(this.positions, t, n), he.Vector3.TransformCoordinatesToRef(n, e, r), this.positions[t] = r.x, this.positions[t + 1] = r.y, this.positions[t + 2] = r.z;\n      }\n\n      if (this.normals) {\n        var o = he.Vector3.Zero();\n\n        for (t = 0; t < this.normals.length; t += 3) he.Vector3.FromArrayToRef(this.normals, t, o), he.Vector3.TransformNormalToRef(o, e, r), this.normals[t] = r.x, this.normals[t + 1] = r.y, this.normals[t + 2] = r.z;\n      }\n\n      if (this.tangents) {\n        var s = he.Vector4.Zero(),\n            a = he.Vector4.Zero();\n\n        for (t = 0; t < this.tangents.length; t += 4) he.Vector4.FromArrayToRef(this.tangents, t, s), he.Vector4.TransformNormalToRef(s, e, a), this.tangents[t] = a.x, this.tangents[t + 1] = a.y, this.tangents[t + 2] = a.z, this.tangents[t + 3] = a.w;\n      }\n\n      if (i && this.indices) for (t = 0; t < this.indices.length; t += 3) {\n        var l = this.indices[t + 1];\n        this.indices[t + 1] = this.indices[t + 2], this.indices[t + 2] = l;\n      }\n      return this;\n    }, q.prototype.merge = function (e, t) {\n      if (void 0 === t && (t = !1), this._validate(), e._validate(), !this.normals != !e.normals || !this.tangents != !e.tangents || !this.uvs != !e.uvs || !this.uvs2 != !e.uvs2 || !this.uvs3 != !e.uvs3 || !this.uvs4 != !e.uvs4 || !this.uvs5 != !e.uvs5 || !this.uvs6 != !e.uvs6 || !this.colors != !e.colors || !this.matricesIndices != !e.matricesIndices || !this.matricesWeights != !e.matricesWeights || !this.matricesIndicesExtra != !e.matricesIndicesExtra || !this.matricesWeightsExtra != !e.matricesWeightsExtra) throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n\n      if (e.indices) {\n        this.indices || (this.indices = []);\n        var i = this.positions ? this.positions.length / 3 : 0;\n\n        if (void 0 !== this.indices.BYTES_PER_ELEMENT) {\n          var r = this.indices.length + e.indices.length,\n              n = t || this.indices instanceof Uint32Array ? new Uint32Array(r) : new Uint16Array(r);\n          n.set(this.indices);\n\n          for (var o = this.indices.length, s = 0; s < e.indices.length; s++) n[o + s] = e.indices[s] + i;\n\n          this.indices = n;\n        } else for (s = 0; s < e.indices.length; s++) this.indices.push(e.indices[s] + i);\n      }\n\n      return this.positions = this._mergeElement(this.positions, e.positions), this.normals = this._mergeElement(this.normals, e.normals), this.tangents = this._mergeElement(this.tangents, e.tangents), this.uvs = this._mergeElement(this.uvs, e.uvs), this.uvs2 = this._mergeElement(this.uvs2, e.uvs2), this.uvs3 = this._mergeElement(this.uvs3, e.uvs3), this.uvs4 = this._mergeElement(this.uvs4, e.uvs4), this.uvs5 = this._mergeElement(this.uvs5, e.uvs5), this.uvs6 = this._mergeElement(this.uvs6, e.uvs6), this.colors = this._mergeElement(this.colors, e.colors), this.matricesIndices = this._mergeElement(this.matricesIndices, e.matricesIndices), this.matricesWeights = this._mergeElement(this.matricesWeights, e.matricesWeights), this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, e.matricesIndicesExtra), this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, e.matricesWeightsExtra), this;\n    }, q.prototype._mergeElement = function (e, t) {\n      if (!e) return t;\n      if (!t) return e;\n      var i = t.length + e.length,\n          r = e instanceof Float32Array,\n          n = t instanceof Float32Array;\n\n      if (r) {\n        var o = new Float32Array(i);\n        return o.set(e), o.set(t, e.length), o;\n      }\n\n      if (n) {\n        var s = e.slice(0),\n            a = 0;\n\n        for (i = t.length; a < i; a++) s.push(t[a]);\n\n        return s;\n      }\n\n      return e.concat(t);\n    }, q.prototype._validate = function () {\n      if (!this.positions) throw new Error(\"Positions are required\");\n\n      var r = function (e, t) {\n        var i = he.VertexBuffer.DeduceStride(e);\n        if (t.length % i != 0) throw new Error(\"The \" + e + \"s array count must be a multiple of \" + i);\n        return t.length / i;\n      },\n          n = r(he.VertexBuffer.PositionKind, this.positions),\n          e = function (e, t) {\n        var i = r(e, t);\n        if (i !== n) throw new Error(\"The \" + e + \"s element count (\" + i + \") does not match the positions count (\" + n + \")\");\n      };\n\n      this.normals && e(he.VertexBuffer.NormalKind, this.normals), this.tangents && e(he.VertexBuffer.TangentKind, this.tangents), this.uvs && e(he.VertexBuffer.UVKind, this.uvs), this.uvs2 && e(he.VertexBuffer.UV2Kind, this.uvs2), this.uvs3 && e(he.VertexBuffer.UV3Kind, this.uvs3), this.uvs4 && e(he.VertexBuffer.UV4Kind, this.uvs4), this.uvs5 && e(he.VertexBuffer.UV5Kind, this.uvs5), this.uvs6 && e(he.VertexBuffer.UV6Kind, this.uvs6), this.colors && e(he.VertexBuffer.ColorKind, this.colors), this.matricesIndices && e(he.VertexBuffer.MatricesIndicesKind, this.matricesIndices), this.matricesWeights && e(he.VertexBuffer.MatricesWeightsKind, this.matricesWeights), this.matricesIndicesExtra && e(he.VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra), this.matricesWeightsExtra && e(he.VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n    }, q.prototype.serialize = function () {\n      var e = this.serialize();\n      return this.positions && (e.positions = this.positions), this.normals && (e.normals = this.normals), this.tangents && (e.tangents = this.tangents), this.uvs && (e.uvs = this.uvs), this.uvs2 && (e.uvs2 = this.uvs2), this.uvs3 && (e.uvs3 = this.uvs3), this.uvs4 && (e.uvs4 = this.uvs4), this.uvs5 && (e.uvs5 = this.uvs5), this.uvs6 && (e.uvs6 = this.uvs6), this.colors && (e.colors = this.colors), this.matricesIndices && (e.matricesIndices = this.matricesIndices, e.matricesIndices._isExpanded = !0), this.matricesWeights && (e.matricesWeights = this.matricesWeights), this.matricesIndicesExtra && (e.matricesIndicesExtra = this.matricesIndicesExtra, e.matricesIndicesExtra._isExpanded = !0), this.matricesWeightsExtra && (e.matricesWeightsExtra = this.matricesWeightsExtra), e.indices = this.indices, e;\n    }, q.ExtractFromMesh = function (e, t, i) {\n      return q._ExtractFrom(e, t, i);\n    }, q.ExtractFromGeometry = function (e, t, i) {\n      return q._ExtractFrom(e, t, i);\n    }, q._ExtractFrom = function (e, t, i) {\n      var r = new q();\n      return e.isVerticesDataPresent(he.VertexBuffer.PositionKind) && (r.positions = e.getVerticesData(he.VertexBuffer.PositionKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.NormalKind) && (r.normals = e.getVerticesData(he.VertexBuffer.NormalKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.TangentKind) && (r.tangents = e.getVerticesData(he.VertexBuffer.TangentKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.UVKind) && (r.uvs = e.getVerticesData(he.VertexBuffer.UVKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.UV2Kind) && (r.uvs2 = e.getVerticesData(he.VertexBuffer.UV2Kind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.UV3Kind) && (r.uvs3 = e.getVerticesData(he.VertexBuffer.UV3Kind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.UV4Kind) && (r.uvs4 = e.getVerticesData(he.VertexBuffer.UV4Kind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.UV5Kind) && (r.uvs5 = e.getVerticesData(he.VertexBuffer.UV5Kind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.UV6Kind) && (r.uvs6 = e.getVerticesData(he.VertexBuffer.UV6Kind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.ColorKind) && (r.colors = e.getVerticesData(he.VertexBuffer.ColorKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.MatricesIndicesKind) && (r.matricesIndices = e.getVerticesData(he.VertexBuffer.MatricesIndicesKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.MatricesWeightsKind) && (r.matricesWeights = e.getVerticesData(he.VertexBuffer.MatricesWeightsKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.MatricesIndicesExtraKind) && (r.matricesIndicesExtra = e.getVerticesData(he.VertexBuffer.MatricesIndicesExtraKind, t, i)), e.isVerticesDataPresent(he.VertexBuffer.MatricesWeightsExtraKind) && (r.matricesWeightsExtra = e.getVerticesData(he.VertexBuffer.MatricesWeightsExtraKind, t, i)), r.indices = e.getIndices(t, i), r;\n    }, q.CreateRibbon = function (e) {\n      var t = e.pathArray,\n          i = e.closeArray || !1,\n          r = e.closePath || !1,\n          n = e.invertUV || !1,\n          o = Math.floor(t[0].length / 2),\n          s = e.offset || o;\n      s = o < s ? o : Math.floor(s);\n      var a,\n          l,\n          c,\n          h,\n          u = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE,\n          d = e.uvs,\n          f = e.colors,\n          p = [],\n          _ = [],\n          m = [],\n          g = [],\n          v = [],\n          y = [],\n          b = [],\n          T = [],\n          E = [],\n          x = [];\n\n      if (t.length < 2) {\n        var P = [],\n            A = [];\n\n        for (c = 0; c < t[0].length - s; c++) P.push(t[0][c]), A.push(t[0][c + s]);\n\n        t = [P, A];\n      }\n\n      var S,\n          M,\n          R,\n          C,\n          O,\n          D = 0,\n          I = r ? 1 : 0;\n\n      for (a = t[0].length, l = 0; l < t.length; l++) {\n        for (b[l] = 0, v[l] = [0], a = a < (M = (S = t[l]).length) ? a : M, h = 0; h < M;) p.push(S[h].x, S[h].y, S[h].z), 0 < h && (R = S[h].subtract(S[h - 1]).length() + b[l], v[l].push(R), b[l] = R), h++;\n\n        r && (h--, p.push(S[0].x, S[0].y, S[0].z), R = S[h].subtract(S[0]).length() + b[l], v[l].push(R), b[l] = R), E[l] = M + I, x[l] = D, D += M + I;\n      }\n\n      var w,\n          L,\n          F = null,\n          B = null;\n\n      for (c = 0; c < a + I; c++) {\n        for (T[c] = 0, y[c] = [0], l = 0; l < t.length - 1; l++) C = t[l], O = t[l + 1], c === a ? (F = C[0], B = O[0]) : (F = C[c], B = O[c]), R = B.subtract(F).length() + T[c], y[c].push(R), T[c] = R;\n\n        i && B && F && (C = t[l], O = t[0], c === a && (B = O[0]), R = B.subtract(F).length() + T[c], T[c] = R);\n      }\n\n      if (d) for (l = 0; l < d.length; l++) g.push(d[l].x, d[l].y);else for (l = 0; l < t.length; l++) for (c = 0; c < a + I; c++) w = 0 != b[l] ? v[l][c] / b[l] : 0, L = 0 != T[c] ? y[c][l] / T[c] : 0, n ? g.push(L, w) : g.push(w, L);\n\n      for (var N = l = 0, V = E[l] - 1, U = E[l + 1] - 1, z = V < U ? V : U, G = x[1] - x[0], k = i ? E.length : E.length - 1; N <= z && l < k;) _.push(N, N + G, N + 1), _.push(N + G + 1, N + 1, N + G), (N += 1) === z && (++l === E.length - 1 ? (G = x[0] - x[l], V = E[l] - 1, U = E[0] - 1) : (G = x[l + 1] - x[l], V = E[l] - 1, U = E[l + 1] - 1), N = x[l], z = V < U ? V + N : U + N);\n\n      if (q.ComputeNormals(p, _, m), r) {\n        var W = 0,\n            H = 0;\n\n        for (l = 0; l < t.length; l++) W = 3 * x[l], H = l + 1 < t.length ? 3 * (x[l + 1] - 1) : m.length - 3, m[W] = .5 * (m[W] + m[H]), m[W + 1] = .5 * (m[W + 1] + m[H + 1]), m[W + 2] = .5 * (m[W + 2] + m[H + 2]), m[H] = m[W], m[H + 1] = m[W + 1], m[H + 2] = m[W + 2];\n      }\n\n      q._ComputeSides(u, p, _, m, g, e.frontUVs, e.backUVs);\n\n      var X = null;\n\n      if (f) {\n        X = new Float32Array(4 * f.length);\n\n        for (var j = 0; j < f.length; j++) X[4 * j] = f[j].r, X[4 * j + 1] = f[j].g, X[4 * j + 2] = f[j].b, X[4 * j + 3] = f[j].a;\n      }\n\n      var Y = new q(),\n          K = new Float32Array(p),\n          Q = new Float32Array(m),\n          Z = new Float32Array(g);\n      return Y.indices = _, Y.positions = K, Y.normals = Q, Y.uvs = Z, X && Y.set(X, he.VertexBuffer.ColorKind), r && (Y._idx = x), Y;\n    }, q.CreateBox = function (e) {\n      for (var t = [new he.Vector3(0, 0, 1), new he.Vector3(0, 0, -1), new he.Vector3(1, 0, 0), new he.Vector3(-1, 0, 0), new he.Vector3(0, 1, 0), new he.Vector3(0, -1, 0)], i = [], r = [], n = [], o = [], s = e.width || e.size || 1, a = e.height || e.size || 1, l = e.depth || e.size || 1, c = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE, h = e.faceUV || new Array(6), u = e.faceColors, d = [], f = 0; f < 6; f++) void 0 === h[f] && (h[f] = new he.Vector4(0, 0, 1, 1)), u && void 0 === u[f] && (u[f] = new he.Color4(1, 1, 1, 1));\n\n      for (var p = new he.Vector3(s / 2, a / 2, l / 2), _ = 0; _ < t.length; _++) {\n        var m = t[_],\n            g = new he.Vector3(m.y, m.z, m.x),\n            v = he.Vector3.Cross(m, g),\n            y = r.length / 3;\n        i.push(y), i.push(y + 1), i.push(y + 2), i.push(y), i.push(y + 2), i.push(y + 3);\n        var b = m.subtract(g).subtract(v).multiply(p);\n        r.push(b.x, b.y, b.z), n.push(m.x, m.y, m.z), o.push(h[_].z, h[_].w), u && d.push(u[_].r, u[_].g, u[_].b, u[_].a), b = m.subtract(g).add(v).multiply(p), r.push(b.x, b.y, b.z), n.push(m.x, m.y, m.z), o.push(h[_].x, h[_].w), u && d.push(u[_].r, u[_].g, u[_].b, u[_].a), b = m.add(g).add(v).multiply(p), r.push(b.x, b.y, b.z), n.push(m.x, m.y, m.z), o.push(h[_].x, h[_].y), u && d.push(u[_].r, u[_].g, u[_].b, u[_].a), b = m.add(g).subtract(v).multiply(p), r.push(b.x, b.y, b.z), n.push(m.x, m.y, m.z), o.push(h[_].z, h[_].y), u && d.push(u[_].r, u[_].g, u[_].b, u[_].a);\n      }\n\n      q._ComputeSides(c, r, i, n, o, e.frontUVs, e.backUVs);\n\n      var T = new q();\n\n      if (T.indices = i, T.positions = r, T.normals = n, T.uvs = o, u) {\n        var E = c === he.Mesh.DOUBLESIDE ? d.concat(d) : d;\n        T.colors = E;\n      }\n\n      return T;\n    }, q.CreateSphere = function (e) {\n      for (var t = e.segments || 32, i = e.diameterX || e.diameter || 1, r = e.diameterY || e.diameter || 1, n = e.diameterZ || e.diameter || 1, o = e.arc && (e.arc <= 0 || 1 < e.arc) ? 1 : e.arc || 1, s = e.slice && e.slice <= 0 ? 1 : e.slice || 1, a = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE, l = new he.Vector3(i / 2, r / 2, n / 2), c = 2 + t, h = 2 * c, u = [], d = [], f = [], p = [], _ = 0; _ <= c; _++) {\n        for (var m = _ / c, g = m * Math.PI * s, v = 0; v <= h; v++) {\n          var y = v / h,\n              b = y * Math.PI * 2 * o,\n              T = he.Matrix.RotationZ(-g),\n              E = he.Matrix.RotationY(b),\n              x = he.Vector3.TransformCoordinates(he.Vector3.Up(), T),\n              P = he.Vector3.TransformCoordinates(x, E),\n              A = P.multiply(l),\n              S = P.divide(l).normalize();\n          d.push(A.x, A.y, A.z), f.push(S.x, S.y, S.z), p.push(y, m);\n        }\n\n        if (0 < _) for (var M = d.length / 3, R = M - 2 * (h + 1); R + h + 2 < M; R++) u.push(R), u.push(R + 1), u.push(R + h + 1), u.push(R + h + 1), u.push(R + 1), u.push(R + h + 2);\n      }\n\n      q._ComputeSides(a, d, u, f, p, e.frontUVs, e.backUVs);\n\n      var C = new q();\n      return C.indices = u, C.positions = d, C.normals = f, C.uvs = p, C;\n    }, q.CreateCylinder = function (e) {\n      var t,\n          p = e.height || 2,\n          _ = 0 === e.diameterTop ? 0 : e.diameterTop || e.diameter || 1,\n          m = 0 === e.diameterBottom ? 0 : e.diameterBottom || e.diameter || 1,\n          g = e.tessellation || 24,\n          i = e.subdivisions || 1,\n          r = !!e.hasRings,\n          n = !!e.enclose,\n          v = e.arc && (e.arc <= 0 || 1 < e.arc) ? 1 : e.arc || 1,\n          o = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE,\n          y = e.faceUV || new Array(3),\n          b = e.faceColors,\n          T = 2 + (1 + (1 !== v && n ? 2 : 0)) * (r ? i : 1);\n\n      for (t = 0; t < T; t++) b && void 0 === b[t] && (b[t] = new he.Color4(1, 1, 1, 1));\n\n      for (t = 0; t < T; t++) y && void 0 === y[t] && (y[t] = new he.Vector4(0, 0, 1, 1));\n\n      var s,\n          a,\n          l,\n          c,\n          h,\n          u,\n          E = new Array(),\n          x = new Array(),\n          P = new Array(),\n          A = new Array(),\n          S = new Array(),\n          d = 2 * Math.PI * v / g,\n          f = (m - _) / 2 / p,\n          M = he.Vector3.Zero(),\n          R = he.Vector3.Zero(),\n          C = he.Vector3.Zero(),\n          O = he.Vector3.Zero(),\n          D = he.Vector3.Zero(),\n          I = he.Axis.Y,\n          w = 1,\n          L = 1,\n          F = 0,\n          B = 0;\n\n      for (c = 0; c <= i; c++) for (l = ((a = c / i) * (_ - m) + m) / 2, w = r && 0 !== c && c !== i ? 2 : 1, u = 0; u < w; u++) {\n        for (r && (L += u), n && (L += 2 * u), h = 0; h <= g; h++) s = h * d, M.x = Math.cos(-s) * l, M.y = -p / 2 + a * p, M.z = Math.sin(-s) * l, 0 === _ && c === i ? (R.x = P[P.length - 3 * (g + 1)], R.y = P[P.length - 3 * (g + 1) + 1], R.z = P[P.length - 3 * (g + 1) + 2]) : (R.x = M.x, R.z = M.z, R.y = Math.sqrt(R.x * R.x + R.z * R.z) * f, R.normalize()), 0 === h && (C.copyFrom(M), O.copyFrom(R)), x.push(M.x, M.y, M.z), P.push(R.x, R.y, R.z), B = r ? F !== L ? y[L].y : y[L].w : y[L].y + (y[L].w - y[L].y) * a, A.push(y[L].x + (y[L].z - y[L].x) * h / g, B), b && S.push(b[L].r, b[L].g, b[L].b, b[L].a);\n\n        1 !== v && n && (x.push(M.x, M.y, M.z), x.push(0, M.y, 0), x.push(0, M.y, 0), x.push(C.x, C.y, C.z), he.Vector3.CrossToRef(I, R, D), D.normalize(), P.push(D.x, D.y, D.z, D.x, D.y, D.z), he.Vector3.CrossToRef(O, I, D), D.normalize(), P.push(D.x, D.y, D.z, D.x, D.y, D.z), B = r ? F !== L ? y[L + 1].y : y[L + 1].w : y[L + 1].y + (y[L + 1].w - y[L + 1].y) * a, A.push(y[L + 1].x, B), A.push(y[L + 1].z, B), B = r ? F !== L ? y[L + 2].y : y[L + 2].w : y[L + 2].y + (y[L + 2].w - y[L + 2].y) * a, A.push(y[L + 2].x, B), A.push(y[L + 2].z, B), b && (S.push(b[L + 1].r, b[L + 1].g, b[L + 1].b, b[L + 1].a), S.push(b[L + 1].r, b[L + 1].g, b[L + 1].b, b[L + 1].a), S.push(b[L + 2].r, b[L + 2].g, b[L + 2].b, b[L + 2].a), S.push(b[L + 2].r, b[L + 2].g, b[L + 2].b, b[L + 2].a))), F !== L && (F = L);\n      }\n\n      var N = 1 !== v && n ? g + 4 : g;\n\n      for (L = c = 0; L < i; L++) {\n        var V = 0,\n            U = 0,\n            z = 0,\n            G = 0;\n\n        for (h = 0; h < g; h++) V = c * (N + 1) + h, U = (c + 1) * (N + 1) + h, z = c * (N + 1) + (h + 1), G = (c + 1) * (N + 1) + (h + 1), E.push(V, U, z), E.push(G, z, U);\n\n        1 !== v && n && (E.push(V + 2, U + 2, z + 2), E.push(G + 2, z + 2, U + 2), E.push(V + 4, U + 4, z + 4), E.push(G + 4, z + 4, U + 4)), c = r ? c + 2 : c + 1;\n      }\n\n      var k = function (e) {\n        var t = e ? _ / 2 : m / 2;\n\n        if (0 !== t) {\n          var i,\n              r,\n              n,\n              o = e ? y[T - 1] : y[0],\n              s = null;\n          b && (s = e ? b[T - 1] : b[0]);\n          var a = x.length / 3,\n              l = e ? p / 2 : -p / 2,\n              c = new he.Vector3(0, l, 0);\n          x.push(c.x, c.y, c.z), P.push(0, e ? 1 : -1, 0), A.push(o.x + .5 * (o.z - o.x), o.y + .5 * (o.w - o.y)), s && S.push(s.r, s.g, s.b, s.a);\n          var h = new he.Vector2(.5, .5);\n\n          for (n = 0; n <= g; n++) {\n            i = 2 * Math.PI * n * v / g;\n            var u = Math.cos(-i),\n                d = Math.sin(-i);\n            r = new he.Vector3(u * t, l, d * t);\n            var f = new he.Vector2(u * h.x + .5, d * h.y + .5);\n            x.push(r.x, r.y, r.z), P.push(0, e ? 1 : -1, 0), A.push(o.x + (o.z - o.x) * f.x, o.y + (o.w - o.y) * f.y), s && S.push(s.r, s.g, s.b, s.a);\n          }\n\n          for (n = 0; n < g; n++) e ? (E.push(a), E.push(a + (n + 2)), E.push(a + (n + 1))) : (E.push(a), E.push(a + (n + 1)), E.push(a + (n + 2)));\n        }\n      };\n\n      k(!1), k(!0), q._ComputeSides(o, x, E, P, A, e.frontUVs, e.backUVs);\n      var W = new q();\n      return W.indices = E, W.positions = x, W.normals = P, W.uvs = A, b && (W.colors = S), W;\n    }, q.CreateTorus = function (e) {\n      for (var t = [], i = [], r = [], n = [], o = e.diameter || 1, s = e.thickness || .5, a = e.tessellation || 16, l = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE, c = a + 1, h = 0; h <= a; h++) for (var u = h / a, d = h * Math.PI * 2 / a - Math.PI / 2, f = he.Matrix.Translation(o / 2, 0, 0).multiply(he.Matrix.RotationY(d)), p = 0; p <= a; p++) {\n        var _ = 1 - p / a,\n            m = p * Math.PI * 2 / a + Math.PI,\n            g = Math.cos(m),\n            v = Math.sin(m),\n            y = new he.Vector3(g, v, 0),\n            b = y.scale(s / 2),\n            T = new he.Vector2(u, _);\n\n        b = he.Vector3.TransformCoordinates(b, f), y = he.Vector3.TransformNormal(y, f), i.push(b.x, b.y, b.z), r.push(y.x, y.y, y.z), n.push(T.x, T.y);\n        var E = (h + 1) % c,\n            x = (p + 1) % c;\n        t.push(h * c + p), t.push(h * c + x), t.push(E * c + p), t.push(h * c + x), t.push(E * c + x), t.push(E * c + p);\n      }\n\n      q._ComputeSides(l, i, t, r, n, e.frontUVs, e.backUVs);\n\n      var P = new q();\n      return P.indices = t, P.positions = i, P.normals = r, P.uvs = n, P;\n    }, q.CreateLineSystem = function (e) {\n      for (var t = [], i = [], r = e.lines, n = e.colors, o = [], s = 0, a = 0; a < r.length; a++) for (var l = r[a], c = 0; c < l.length; c++) {\n        if (i.push(l[c].x, l[c].y, l[c].z), n) {\n          var h = n[a];\n          o.push(h[c].r, h[c].g, h[c].b, h[c].a);\n        }\n\n        0 < c && (t.push(s - 1), t.push(s)), s++;\n      }\n\n      var u = new q();\n      return u.indices = t, u.positions = i, n && (u.colors = o), u;\n    }, q.CreateDashedLines = function (e) {\n      var t,\n          i,\n          r = e.dashSize || 3,\n          n = e.gapSize || 1,\n          o = e.dashNb || 200,\n          s = e.points,\n          a = new Array(),\n          l = new Array(),\n          c = he.Vector3.Zero(),\n          h = 0,\n          u = 0,\n          d = 0,\n          f = 0,\n          p = 0;\n\n      for (p = 0; p < s.length - 1; p++) s[p + 1].subtractToRef(s[p], c), h += c.length();\n\n      for (i = r * (t = h / o) / (r + n), p = 0; p < s.length - 1; p++) {\n        s[p + 1].subtractToRef(s[p], c), u = Math.floor(c.length() / t), c.normalize();\n\n        for (var _ = 0; _ < u; _++) d = t * _, a.push(s[p].x + d * c.x, s[p].y + d * c.y, s[p].z + d * c.z), a.push(s[p].x + (d + i) * c.x, s[p].y + (d + i) * c.y, s[p].z + (d + i) * c.z), l.push(f, f + 1), f += 2;\n      }\n\n      var m = new q();\n      return m.positions = a, m.indices = l, m;\n    }, q.CreateGround = function (e) {\n      var t,\n          i,\n          r = [],\n          n = [],\n          o = [],\n          s = [],\n          a = e.width || 1,\n          l = e.height || 1,\n          c = e.subdivisionsX || e.subdivisions || 1,\n          h = e.subdivisionsY || e.subdivisions || 1;\n\n      for (t = 0; t <= h; t++) for (i = 0; i <= c; i++) {\n        var u = new he.Vector3(i * a / c - a / 2, 0, (h - t) * l / h - l / 2),\n            d = new he.Vector3(0, 1, 0);\n        n.push(u.x, u.y, u.z), o.push(d.x, d.y, d.z), s.push(i / c, 1 - t / h);\n      }\n\n      for (t = 0; t < h; t++) for (i = 0; i < c; i++) r.push(i + 1 + (t + 1) * (c + 1)), r.push(i + 1 + t * (c + 1)), r.push(i + t * (c + 1)), r.push(i + (t + 1) * (c + 1)), r.push(i + 1 + (t + 1) * (c + 1)), r.push(i + t * (c + 1));\n\n      var f = new q();\n      return f.indices = r, f.positions = n, f.normals = o, f.uvs = s, f;\n    }, q.CreateTiledGround = function (e) {\n      var c,\n          h,\n          t,\n          i,\n          r = void 0 !== e.xmin && null !== e.xmin ? e.xmin : -1,\n          n = void 0 !== e.zmin && null !== e.zmin ? e.zmin : -1,\n          o = void 0 !== e.xmax && null !== e.xmax ? e.xmax : 1,\n          s = void 0 !== e.zmax && null !== e.zmax ? e.zmax : 1,\n          a = e.subdivisions || {\n        w: 1,\n        h: 1\n      },\n          u = e.precision || {\n        w: 1,\n        h: 1\n      },\n          d = new Array(),\n          f = new Array(),\n          p = new Array(),\n          _ = new Array();\n\n      a.h = a.h < 1 ? 1 : a.h, a.w = a.w < 1 ? 1 : a.w, u.w = u.w < 1 ? 1 : u.w, u.h = u.h < 1 ? 1 : u.h;\n      var l = (o - r) / a.w,\n          m = (s - n) / a.h;\n\n      function g(e, t, i, r) {\n        var n = f.length / 3,\n            o = u.w + 1;\n\n        for (c = 0; c < u.h; c++) for (h = 0; h < u.w; h++) {\n          var s = [n + h + c * o, n + (h + 1) + c * o, n + (h + 1) + (c + 1) * o, n + h + (c + 1) * o];\n          d.push(s[1]), d.push(s[2]), d.push(s[3]), d.push(s[0]), d.push(s[1]), d.push(s[3]);\n        }\n\n        var a = he.Vector3.Zero(),\n            l = new he.Vector3(0, 1, 0);\n\n        for (c = 0; c <= u.h; c++) for (a.z = c * (r - t) / u.h + t, h = 0; h <= u.w; h++) a.x = h * (i - e) / u.w + e, a.y = 0, f.push(a.x, a.y, a.z), p.push(l.x, l.y, l.z), _.push(h / u.w, c / u.h);\n      }\n\n      for (t = 0; t < a.h; t++) for (i = 0; i < a.w; i++) g(r + i * l, n + t * m, r + (i + 1) * l, n + (t + 1) * m);\n\n      var v = new q();\n      return v.indices = d, v.positions = f, v.normals = p, v.uvs = _, v;\n    }, q.CreateGroundFromHeightMap = function (e) {\n      var t,\n          i,\n          r = [],\n          n = [],\n          o = [],\n          s = [],\n          a = e.colorFilter || new he.Color3(.3, .59, .11),\n          l = e.alphaFilter || 0;\n\n      for (t = 0; t <= e.subdivisions; t++) for (i = 0; i <= e.subdivisions; i++) {\n        var c = new he.Vector3(i * e.width / e.subdivisions - e.width / 2, 0, (e.subdivisions - t) * e.height / e.subdivisions - e.height / 2),\n            h = 4 * (((c.x + e.width / 2) / e.width * (e.bufferWidth - 1) | 0) + ((1 - (c.z + e.height / 2) / e.height) * (e.bufferHeight - 1) | 0) * e.bufferWidth),\n            u = e.buffer[h] / 255,\n            d = e.buffer[h + 1] / 255,\n            f = e.buffer[h + 2] / 255,\n            p = e.buffer[h + 3] / 255,\n            _ = u * a.r + d * a.g + f * a.b;\n\n        c.y = l <= p ? e.minHeight + (e.maxHeight - e.minHeight) * _ : e.minHeight - he.Epsilon, n.push(c.x, c.y, c.z), o.push(0, 0, 0), s.push(i / e.subdivisions, 1 - t / e.subdivisions);\n      }\n\n      for (t = 0; t < e.subdivisions; t++) for (i = 0; i < e.subdivisions; i++) {\n        var m = i + 1 + (t + 1) * (e.subdivisions + 1),\n            g = i + 1 + t * (e.subdivisions + 1),\n            v = i + t * (e.subdivisions + 1),\n            y = i + (t + 1) * (e.subdivisions + 1),\n            b = n[3 * m + 1] >= e.minHeight,\n            T = n[3 * g + 1] >= e.minHeight,\n            E = n[3 * v + 1] >= e.minHeight;\n        b && T && E && (r.push(m), r.push(g), r.push(v)), n[3 * y + 1] >= e.minHeight && b && E && (r.push(y), r.push(m), r.push(v));\n      }\n\n      q.ComputeNormals(n, r, o);\n      var x = new q();\n      return x.indices = r, x.positions = n, x.normals = o, x.uvs = s, x;\n    }, q.CreatePlane = function (e) {\n      var t = [],\n          i = [],\n          r = [],\n          n = [],\n          o = e.width || e.size || 1,\n          s = e.height || e.size || 1,\n          a = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE,\n          l = o / 2,\n          c = s / 2;\n      i.push(-l, -c, 0), r.push(0, 0, -1), n.push(0, 0), i.push(l, -c, 0), r.push(0, 0, -1), n.push(1, 0), i.push(l, c, 0), r.push(0, 0, -1), n.push(1, 1), i.push(-l, c, 0), r.push(0, 0, -1), n.push(0, 1), t.push(0), t.push(1), t.push(2), t.push(0), t.push(2), t.push(3), q._ComputeSides(a, i, t, r, n, e.frontUVs, e.backUVs);\n      var h = new q();\n      return h.indices = t, h.positions = i, h.normals = r, h.uvs = n, h;\n    }, q.CreateDisc = function (e) {\n      var t = new Array(),\n          i = new Array(),\n          r = new Array(),\n          n = new Array(),\n          o = e.radius || .5,\n          s = e.tessellation || 64,\n          a = e.arc && (e.arc <= 0 || 1 < e.arc) ? 1 : e.arc || 1,\n          l = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE;\n      t.push(0, 0, 0), n.push(.5, .5);\n\n      for (var c = 2 * Math.PI * a, h = c / s, u = 0; u < c; u += h) {\n        var d = Math.cos(u),\n            f = Math.sin(u),\n            p = (d + 1) / 2,\n            _ = (1 - f) / 2;\n\n        t.push(o * d, o * f, 0), n.push(p, _);\n      }\n\n      1 === a && (t.push(t[3], t[4], t[5]), n.push(n[2], n[3]));\n\n      for (var m = t.length / 3, g = 1; g < m - 1; g++) i.push(g + 1, 0, g);\n\n      q.ComputeNormals(t, i, r), q._ComputeSides(l, t, i, r, n, e.frontUVs, e.backUVs);\n      var v = new q();\n      return v.indices = i, v.positions = t, v.normals = r, v.uvs = n, v;\n    }, q.CreatePolygon = function (e, t, i, r, n, o) {\n      for (var s = i || new Array(3), a = r, l = [], c = 0; c < 3; c++) void 0 === s[c] && (s[c] = new he.Vector4(0, 0, 1, 1)), a && void 0 === a[c] && (a[c] = new he.Color4(1, 1, 1, 1));\n\n      for (var h = e.getVerticesData(he.VertexBuffer.PositionKind), u = e.getVerticesData(he.VertexBuffer.NormalKind), d = e.getVerticesData(he.VertexBuffer.UVKind), f = e.getIndices(), p = 0, _ = 0, m = 0; m < u.length; m += 3) Math.abs(u[m + 1]) < .001 && (_ = 1), Math.abs(u[m + 1] - 1) < .001 && (_ = 0), Math.abs(u[m + 1] + 1) < .001 && (_ = 2), d[2 * (p = m / 3)] = (1 - d[2 * p]) * s[_].x + d[2 * p] * s[_].z, d[2 * p + 1] = (1 - d[2 * p + 1]) * s[_].y + d[2 * p + 1] * s[_].w, a && l.push(a[_].r, a[_].g, a[_].b, a[_].a);\n\n      q._ComputeSides(t, h, f, u, d, n, o);\n\n      var g = new q();\n\n      if (g.indices = f, g.positions = h, g.normals = u, g.uvs = d, a) {\n        var v = t === he.Mesh.DOUBLESIDE ? l.concat(l) : l;\n        g.colors = v;\n      }\n\n      return g;\n    }, q.CreateIcoSphere = function (e) {\n      var t,\n          i = e.sideOrientation || he.Mesh.DEFAULTSIDE,\n          r = e.radius || 1,\n          f = void 0 === e.flat || e.flat,\n          p = e.subdivisions || 4,\n          _ = e.radiusX || r,\n          m = e.radiusY || r,\n          g = e.radiusZ || r,\n          n = (1 + Math.sqrt(5)) / 2,\n          o = [-1, n, -0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, -n, 0, 1, -n, 0, -1, n, 0, 1, n, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, -1],\n          s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17, 23, 6, 13, 22, 19, 6, 18, 9, 8, 1],\n          a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 2, 3, 3, 3, 4, 7, 8, 9, 9, 10, 11],\n          l = [5, 1, 3, 1, 6, 4, 0, 0, 5, 3, 4, 2, 2, 2, 4, 0, 2, 0, 1, 1, 6, 0, 6, 2, 0, 4, 3, 3, 4, 4, 3, 1, 4, 2, 4, 4, 0, 2, 1, 1, 2, 2, 3, 3, 1, 3, 2, 4],\n          c = [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0],\n          v = new Array(),\n          y = new Array(),\n          b = new Array(),\n          T = new Array(),\n          E = 0,\n          x = new Array(3),\n          P = new Array(3);\n\n      for (t = 0; t < 3; t++) x[t] = he.Vector3.Zero(), P[t] = he.Vector2.Zero();\n\n      for (var h = 0; h < 20; h++) {\n        for (t = 0; t < 3; t++) {\n          var u = s[3 * h + t];\n          x[t].copyFromFloats(o[3 * a[u]], o[3 * a[u] + 1], o[3 * a[u] + 2]), x[t].normalize().scaleInPlace(r), P[t].copyFromFloats(l[2 * u] * (138 / 1024) + 60 / 1024 + c[h] * (-40 / 1024), l[2 * u + 1] * (239 / 1024) + 26 / 1024 + c[h] * (20 / 1024));\n        }\n\n        for (var d = function (e, t, i, r) {\n          var n,\n              o = he.Vector3.Lerp(x[0], x[2], t / p),\n              s = he.Vector3.Lerp(x[1], x[2], t / p),\n              a = p === t ? x[2] : he.Vector3.Lerp(o, s, e / (p - t));\n\n          if (a.normalize(), f) {\n            var l = he.Vector3.Lerp(x[0], x[2], r / p),\n                c = he.Vector3.Lerp(x[1], x[2], r / p);\n            n = he.Vector3.Lerp(l, c, i / (p - r));\n          } else n = new he.Vector3(a.x, a.y, a.z);\n\n          n.x /= _, n.y /= m, n.z /= g, n.normalize();\n          var h = he.Vector2.Lerp(P[0], P[2], t / p),\n              u = he.Vector2.Lerp(P[1], P[2], t / p),\n              d = p === t ? P[2] : he.Vector2.Lerp(h, u, e / (p - t));\n          y.push(a.x * _, a.y * m, a.z * g), b.push(n.x, n.y, n.z), T.push(d.x, d.y), v.push(E), E++;\n        }, A = 0; A < p; A++) for (var S = 0; S + A < p; S++) d(S, A, S + 1 / 3, A + 1 / 3), d(S + 1, A, S + 1 / 3, A + 1 / 3), d(S, A + 1, S + 1 / 3, A + 1 / 3), S + A + 1 < p && (d(S + 1, A, S + 2 / 3, A + 2 / 3), d(S + 1, A + 1, S + 2 / 3, A + 2 / 3), d(S, A + 1, S + 2 / 3, A + 2 / 3));\n      }\n\n      q._ComputeSides(i, y, v, b, T, e.frontUVs, e.backUVs);\n\n      var M = new q();\n      return M.indices = v, M.positions = y, M.normals = b, M.uvs = T, M;\n    }, q.CreatePolyhedron = function (e) {\n      var t = [];\n      t[0] = {\n        vertex: [[0, 0, 1.732051], [1.632993, 0, -.5773503], [-.8164966, 1.414214, -.5773503], [-.8164966, -1.414214, -.5773503]],\n        face: [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]]\n      }, t[1] = {\n        vertex: [[0, 0, 1.414214], [1.414214, 0, 0], [0, 1.414214, 0], [-1.414214, 0, 0], [0, -1.414214, 0], [0, 0, -1.414214]],\n        face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1], [1, 4, 5], [1, 5, 2], [2, 5, 3], [3, 5, 4]]\n      }, t[2] = {\n        vertex: [[0, 0, 1.070466], [.7136442, 0, .7978784], [-.3568221, .618034, .7978784], [-.3568221, -.618034, .7978784], [.7978784, .618034, .3568221], [.7978784, -.618034, .3568221], [-.9341724, .381966, .3568221], [.1362939, 1, .3568221], [.1362939, -1, .3568221], [-.9341724, -.381966, .3568221], [.9341724, .381966, -.3568221], [.9341724, -.381966, -.3568221], [-.7978784, .618034, -.3568221], [-.1362939, 1, -.3568221], [-.1362939, -1, -.3568221], [-.7978784, -.618034, -.3568221], [.3568221, .618034, -.7978784], [.3568221, -.618034, -.7978784], [-.7136442, 0, -.7978784], [0, 0, -1.070466]],\n        face: [[0, 1, 4, 7, 2], [0, 2, 6, 9, 3], [0, 3, 8, 5, 1], [1, 5, 11, 10, 4], [2, 7, 13, 12, 6], [3, 9, 15, 14, 8], [4, 10, 16, 13, 7], [5, 8, 14, 17, 11], [6, 12, 18, 15, 9], [10, 11, 17, 19, 16], [12, 13, 16, 19, 18], [14, 15, 18, 19, 17]]\n      }, t[3] = {\n        vertex: [[0, 0, 1.175571], [1.051462, 0, .5257311], [.3249197, 1, .5257311], [-.8506508, .618034, .5257311], [-.8506508, -.618034, .5257311], [.3249197, -1, .5257311], [.8506508, .618034, -.5257311], [.8506508, -.618034, -.5257311], [-.3249197, 1, -.5257311], [-1.051462, 0, -.5257311], [-.3249197, -1, -.5257311], [0, 0, -1.175571]],\n        face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1], [1, 5, 7], [1, 7, 6], [1, 6, 2], [2, 6, 8], [2, 8, 3], [3, 8, 9], [3, 9, 4], [4, 9, 10], [4, 10, 5], [5, 10, 7], [6, 7, 11], [6, 11, 8], [7, 10, 11], [8, 11, 9], [9, 11, 10]]\n      }, t[4] = {\n        vertex: [[0, 0, 1.070722], [.7148135, 0, .7971752], [-.104682, .7071068, .7971752], [-.6841528, .2071068, .7971752], [-.104682, -.7071068, .7971752], [.6101315, .7071068, .5236279], [1.04156, .2071068, .1367736], [.6101315, -.7071068, .5236279], [-.3574067, 1, .1367736], [-.7888348, -.5, .5236279], [-.9368776, .5, .1367736], [-.3574067, -1, .1367736], [.3574067, 1, -.1367736], [.9368776, -.5, -.1367736], [.7888348, .5, -.5236279], [.3574067, -1, -.1367736], [-.6101315, .7071068, -.5236279], [-1.04156, -.2071068, -.1367736], [-.6101315, -.7071068, -.5236279], [.104682, .7071068, -.7971752], [.6841528, -.2071068, -.7971752], [.104682, -.7071068, -.7971752], [-.7148135, 0, -.7971752], [0, 0, -1.070722]],\n        face: [[0, 2, 3], [1, 6, 5], [4, 9, 11], [7, 15, 13], [8, 16, 10], [12, 14, 19], [17, 22, 18], [20, 21, 23], [0, 1, 5, 2], [0, 3, 9, 4], [0, 4, 7, 1], [1, 7, 13, 6], [2, 5, 12, 8], [2, 8, 10, 3], [3, 10, 17, 9], [4, 11, 15, 7], [5, 6, 14, 12], [6, 13, 20, 14], [8, 12, 19, 16], [9, 17, 18, 11], [10, 16, 22, 17], [11, 18, 21, 15], [13, 15, 21, 20], [14, 20, 23, 19], [16, 19, 23, 22], [18, 22, 23, 21]]\n      }, t[5] = {\n        vertex: [[0, 0, 1.322876], [1.309307, 0, .1889822], [-.9819805, .8660254, .1889822], [.1636634, -1.299038, .1889822], [.3273268, .8660254, -.9449112], [-.8183171, -.4330127, -.9449112]],\n        face: [[0, 3, 1], [2, 4, 5], [0, 1, 4, 2], [0, 2, 5, 3], [1, 3, 5, 4]]\n      }, t[6] = {\n        vertex: [[0, 0, 1.159953], [1.013464, 0, .5642542], [-.3501431, .9510565, .5642542], [-.7715208, -.6571639, .5642542], [.6633206, .9510565, -.03144481], [.8682979, -.6571639, -.3996071], [-1.121664, .2938926, -.03144481], [-.2348831, -1.063314, -.3996071], [.5181548, .2938926, -.9953061], [-.5850262, -.112257, -.9953061]],\n        face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 9, 7], [5, 7, 9, 8], [0, 3, 7, 5, 1], [2, 4, 8, 9, 6]]\n      }, t[7] = {\n        vertex: [[0, 0, 1.118034], [.8944272, 0, .6708204], [-.2236068, .8660254, .6708204], [-.7826238, -.4330127, .6708204], [.6708204, .8660254, .2236068], [1.006231, -.4330127, -.2236068], [-1.006231, .4330127, .2236068], [-.6708204, -.8660254, -.2236068], [.7826238, .4330127, -.6708204], [.2236068, -.8660254, -.6708204], [-.8944272, 0, -.6708204], [0, 0, -1.118034]],\n        face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 10, 7], [5, 9, 11, 8], [7, 10, 11, 9], [0, 3, 7, 9, 5, 1], [2, 4, 8, 11, 10, 6]]\n      }, t[8] = {\n        vertex: [[-.729665, .670121, .319155], [-.655235, -.29213, -.754096], [-.093922, -.607123, .537818], [.702196, .595691, .485187], [.776626, -.36656, -.588064]],\n        face: [[1, 4, 2], [0, 1, 2], [3, 0, 2], [4, 3, 2], [4, 1, 0, 3]]\n      }, t[9] = {\n        vertex: [[-.868849, -.100041, .61257], [-.329458, .976099, .28078], [-.26629, -.013796, -.477654], [-.13392, -1.034115, .229829], [.738834, .707117, -.307018], [.859683, -.535264, -.338508]],\n        face: [[3, 0, 2], [5, 3, 2], [4, 5, 2], [1, 4, 2], [0, 1, 2], [0, 3, 5, 4, 1]]\n      }, t[10] = {\n        vertex: [[-.610389, .243975, .531213], [-.187812, -.48795, -.664016], [-.187812, .9759, -.664016], [.187812, -.9759, .664016], [.798201, .243975, .132803]],\n        face: [[1, 3, 0], [3, 4, 0], [3, 1, 4], [0, 2, 1], [0, 4, 2], [2, 4, 1]]\n      }, t[11] = {\n        vertex: [[-1.028778, .392027, -.048786], [-.640503, -.646161, .621837], [-.125162, -.395663, -.540059], [.004683, .888447, -.651988], [.125161, .395663, .540059], [.632925, -.791376, .433102], [1.031672, .157063, -.354165]],\n        face: [[3, 2, 0], [2, 1, 0], [2, 5, 1], [0, 4, 3], [0, 1, 4], [4, 1, 5], [2, 3, 6], [3, 4, 6], [5, 2, 6], [4, 5, 6]]\n      }, t[12] = {\n        vertex: [[-.669867, .334933, -.529576], [-.669867, .334933, .529577], [-.4043, 1.212901, 0], [-.334933, -.669867, -.529576], [-.334933, -.669867, .529577], [.334933, .669867, -.529576], [.334933, .669867, .529577], [.4043, -1.212901, 0], [.669867, -.334933, -.529576], [.669867, -.334933, .529577]],\n        face: [[8, 9, 7], [6, 5, 2], [3, 8, 7], [5, 0, 2], [4, 3, 7], [0, 1, 2], [9, 4, 7], [1, 6, 2], [9, 8, 5, 6], [8, 3, 0, 5], [3, 4, 1, 0], [4, 9, 6, 1]]\n      }, t[13] = {\n        vertex: [[-.931836, .219976, -.264632], [-.636706, .318353, .692816], [-.613483, -.735083, -.264632], [-.326545, .979634, 0], [-.318353, -.636706, .692816], [-.159176, .477529, -.856368], [.159176, -.477529, -.856368], [.318353, .636706, .692816], [.326545, -.979634, 0], [.613482, .735082, -.264632], [.636706, -.318353, .692816], [.931835, -.219977, -.264632]],\n        face: [[11, 10, 8], [7, 9, 3], [6, 11, 8], [9, 5, 3], [2, 6, 8], [5, 0, 3], [4, 2, 8], [0, 1, 3], [10, 4, 8], [1, 7, 3], [10, 11, 9, 7], [11, 6, 5, 9], [6, 2, 0, 5], [2, 4, 1, 0], [4, 10, 7, 1]]\n      }, t[14] = {\n        vertex: [[-.93465, .300459, -.271185], [-.838689, -.260219, -.516017], [-.711319, .717591, .128359], [-.710334, -.156922, .080946], [-.599799, .556003, -.725148], [-.503838, -.004675, -.969981], [-.487004, .26021, .48049], [-.460089, -.750282, -.512622], [-.376468, .973135, -.325605], [-.331735, -.646985, .084342], [-.254001, .831847, .530001], [-.125239, -.494738, -.966586], [.029622, .027949, .730817], [.056536, -.982543, -.262295], [.08085, 1.087391, .076037], [.125583, -.532729, .485984], [.262625, .599586, .780328], [.391387, -.726999, -.716259], [.513854, -.868287, .139347], [.597475, .85513, .326364], [.641224, .109523, .783723], [.737185, -.451155, .538891], [.848705, -.612742, -.314616], [.976075, .365067, .32976], [1.072036, -.19561, .084927]],\n        face: [[15, 18, 21], [12, 20, 16], [6, 10, 2], [3, 0, 1], [9, 7, 13], [2, 8, 4, 0], [0, 4, 5, 1], [1, 5, 11, 7], [7, 11, 17, 13], [13, 17, 22, 18], [18, 22, 24, 21], [21, 24, 23, 20], [20, 23, 19, 16], [16, 19, 14, 10], [10, 14, 8, 2], [15, 9, 13, 18], [12, 15, 21, 20], [6, 12, 16, 10], [3, 6, 2, 0], [9, 3, 1, 7], [9, 15, 12, 6, 3], [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]]\n      };\n\n      var i,\n          r,\n          n,\n          o,\n          s,\n          a,\n          l = e.type && (e.type < 0 || e.type >= t.length) ? 0 : e.type || 0,\n          c = e.size,\n          h = e.sizeX || c || 1,\n          u = e.sizeY || c || 1,\n          d = e.sizeZ || c || 1,\n          f = e.custom || t[l],\n          p = f.face.length,\n          _ = e.faceUV || new Array(p),\n          m = e.faceColors,\n          g = void 0 === e.flat || e.flat,\n          v = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE,\n          y = new Array(),\n          b = new Array(),\n          T = new Array(),\n          E = new Array(),\n          x = new Array(),\n          P = 0,\n          A = 0,\n          S = new Array(),\n          M = 0,\n          R = 0;\n\n      if (g) for (R = 0; R < p; R++) m && void 0 === m[R] && (m[R] = new he.Color4(1, 1, 1, 1)), _ && void 0 === _[R] && (_[R] = new he.Vector4(0, 0, 1, 1));\n      if (g) for (R = 0; R < p; R++) {\n        var C = f.face[R].length;\n\n        for (n = 2 * Math.PI / C, o = .5 * Math.tan(n / 2), s = .5, M = 0; M < C; M++) y.push(f.vertex[f.face[R][M]][0] * h, f.vertex[f.face[R][M]][1] * u, f.vertex[f.face[R][M]][2] * d), S.push(P), P++, i = _[R].x + (_[R].z - _[R].x) * (.5 + o), r = _[R].y + (_[R].w - _[R].y) * (s - .5), E.push(i, r), a = o * Math.cos(n) - s * Math.sin(n), s = o * Math.sin(n) + s * Math.cos(n), o = a, m && x.push(m[R].r, m[R].g, m[R].b, m[R].a);\n\n        for (M = 0; M < C - 2; M++) b.push(S[0 + A], S[M + 2 + A], S[M + 1 + A]);\n\n        A += C;\n      } else {\n        for (M = 0; M < f.vertex.length; M++) y.push(f.vertex[M][0] * h, f.vertex[M][1] * u, f.vertex[M][2] * d), E.push(0, 0);\n\n        for (R = 0; R < p; R++) for (M = 0; M < f.face[R].length - 2; M++) b.push(f.face[R][0], f.face[R][M + 2], f.face[R][M + 1]);\n      }\n      q.ComputeNormals(y, b, T), q._ComputeSides(v, y, b, T, E, e.frontUVs, e.backUVs);\n      var O = new q();\n      return O.positions = y, O.indices = b, O.normals = T, O.uvs = E, m && g && (O.colors = x), O;\n    }, q.CreateTorusKnot = function (e) {\n      var t,\n          i,\n          r = new Array(),\n          n = new Array(),\n          o = new Array(),\n          s = new Array(),\n          l = e.radius || 2,\n          a = e.tube || .5,\n          c = e.radialSegments || 32,\n          h = e.tubularSegments || 32,\n          u = e.p || 2,\n          d = e.q || 3,\n          f = 0 === e.sideOrientation ? 0 : e.sideOrientation || he.Mesh.DEFAULTSIDE,\n          p = function (e) {\n        var t = Math.cos(e),\n            i = Math.sin(e),\n            r = d / u * e,\n            n = Math.cos(r),\n            o = l * (2 + n) * .5 * t,\n            s = l * (2 + n) * i * .5,\n            a = l * Math.sin(r) * .5;\n        return new he.Vector3(o, s, a);\n      };\n\n      for (t = 0; t <= c; t++) {\n        var _ = t % c / c * 2 * u * Math.PI,\n            m = p(_),\n            g = p(_ + .01),\n            v = g.subtract(m),\n            y = g.add(m),\n            b = he.Vector3.Cross(v, y);\n\n        for (y = he.Vector3.Cross(b, v), b.normalize(), y.normalize(), i = 0; i < h; i++) {\n          var T = i % h / h * 2 * Math.PI,\n              E = -a * Math.cos(T),\n              x = a * Math.sin(T);\n          n.push(m.x + E * y.x + x * b.x), n.push(m.y + E * y.y + x * b.y), n.push(m.z + E * y.z + x * b.z), s.push(t / c), s.push(i / h);\n        }\n      }\n\n      for (t = 0; t < c; t++) for (i = 0; i < h; i++) {\n        var P = (i + 1) % h,\n            A = t * h + i,\n            S = (t + 1) * h + i,\n            M = (t + 1) * h + P,\n            R = t * h + P;\n        r.push(R), r.push(S), r.push(A), r.push(R), r.push(M), r.push(S);\n      }\n\n      q.ComputeNormals(n, r, o), q._ComputeSides(f, n, r, o, s, e.frontUVs, e.backUVs);\n      var C = new q();\n      return C.indices = r, C.positions = n, C.normals = o, C.uvs = s, C;\n    }, q.ComputeNormals = function (e, t, i, r) {\n      var n = 0,\n          o = 0,\n          s = 0,\n          a = 0,\n          l = 0,\n          c = 0,\n          h = 0,\n          u = 0,\n          d = 0,\n          f = 0,\n          p = 0,\n          _ = 0,\n          m = 0,\n          g = 0,\n          v = 0,\n          y = 0,\n          b = 0,\n          T = 0,\n          E = 0,\n          x = 0,\n          P = !1,\n          A = !1,\n          S = !1,\n          M = !1,\n          R = 1,\n          C = 0,\n          O = null;\n\n      if (r && (P = !!r.facetNormals, A = !!r.facetPositions, S = !!r.facetPartitioning, R = !0 === r.useRightHandedSystem ? -1 : 1, C = r.ratio || 0, M = !!r.depthSort, O = r.distanceTo, M)) {\n        void 0 === O && (O = he.Vector3.Zero());\n        var D = r.depthSortedFacets;\n      }\n\n      var I = 0,\n          w = 0,\n          L = 0,\n          F = 0;\n\n      if (S && r && r.bbSize) {\n        var B = 0,\n            N = 0,\n            V = 0,\n            U = 0,\n            z = 0,\n            G = 0,\n            k = 0,\n            W = 0,\n            H = 0,\n            X = 0,\n            j = 0,\n            Y = 0,\n            K = 0,\n            Q = 0,\n            Z = 0,\n            q = 0,\n            J = r.bbSize.x > r.bbSize.y ? r.bbSize.x : r.bbSize.y;\n        J = J > r.bbSize.z ? J : r.bbSize.z, I = r.subDiv.X * C / r.bbSize.x, w = r.subDiv.Y * C / r.bbSize.y, L = r.subDiv.Z * C / r.bbSize.z, F = r.subDiv.max * r.subDiv.max, r.facetPartitioning.length = 0;\n      }\n\n      for (n = 0; n < e.length; n++) i[n] = 0;\n\n      var $ = t.length / 3 | 0;\n\n      for (n = 0; n < $; n++) {\n        if (m = (_ = 3 * t[3 * n]) + 1, g = _ + 2, y = (v = 3 * t[3 * n + 1]) + 1, b = v + 2, E = (T = 3 * t[3 * n + 2]) + 1, x = T + 2, o = e[_] - e[v], s = e[m] - e[y], a = e[g] - e[b], l = e[T] - e[v], c = e[E] - e[y], u = R * (s * (h = e[x] - e[b]) - a * c), d = R * (a * l - o * h), f = R * (o * c - s * l), u /= p = 0 === (p = Math.sqrt(u * u + d * d + f * f)) ? 1 : p, d /= p, f /= p, P && r && (r.facetNormals[n].x = u, r.facetNormals[n].y = d, r.facetNormals[n].z = f), A && r && (r.facetPositions[n].x = (e[_] + e[v] + e[T]) / 3, r.facetPositions[n].y = (e[m] + e[y] + e[E]) / 3, r.facetPositions[n].z = (e[g] + e[b] + e[x]) / 3), S && r && (B = Math.floor((r.facetPositions[n].x - r.bInfo.minimum.x * C) * I), N = Math.floor((r.facetPositions[n].y - r.bInfo.minimum.y * C) * w), V = Math.floor((r.facetPositions[n].z - r.bInfo.minimum.z * C) * L), U = Math.floor((e[_] - r.bInfo.minimum.x * C) * I), z = Math.floor((e[m] - r.bInfo.minimum.y * C) * w), G = Math.floor((e[g] - r.bInfo.minimum.z * C) * L), k = Math.floor((e[v] - r.bInfo.minimum.x * C) * I), W = Math.floor((e[y] - r.bInfo.minimum.y * C) * w), H = Math.floor((e[b] - r.bInfo.minimum.z * C) * L), X = Math.floor((e[T] - r.bInfo.minimum.x * C) * I), j = Math.floor((e[E] - r.bInfo.minimum.y * C) * w), Y = Math.floor((e[x] - r.bInfo.minimum.z * C) * L), Q = U + r.subDiv.max * z + F * G, Z = k + r.subDiv.max * W + F * H, q = X + r.subDiv.max * j + F * Y, K = B + r.subDiv.max * N + F * V, r.facetPartitioning[K] = r.facetPartitioning[K] ? r.facetPartitioning[K] : new Array(), r.facetPartitioning[Q] = r.facetPartitioning[Q] ? r.facetPartitioning[Q] : new Array(), r.facetPartitioning[Z] = r.facetPartitioning[Z] ? r.facetPartitioning[Z] : new Array(), r.facetPartitioning[q] = r.facetPartitioning[q] ? r.facetPartitioning[q] : new Array(), r.facetPartitioning[Q].push(n), Z != Q && r.facetPartitioning[Z].push(n), q != Z && q != Q && r.facetPartitioning[q].push(n), K != Q && K != Z && K != q && r.facetPartitioning[K].push(n)), M && r && r.facetPositions) {\n          var ee = D[n];\n          ee.ind = 3 * n, ee.sqDistance = he.Vector3.DistanceSquared(r.facetPositions[n], O);\n        }\n\n        i[_] += u, i[m] += d, i[g] += f, i[v] += u, i[y] += d, i[b] += f, i[T] += u, i[E] += d, i[x] += f;\n      }\n\n      for (n = 0; n < i.length / 3; n++) u = i[3 * n], d = i[3 * n + 1], f = i[3 * n + 2], u /= p = 0 === (p = Math.sqrt(u * u + d * d + f * f)) ? 1 : p, d /= p, f /= p, i[3 * n] = u, i[3 * n + 1] = d, i[3 * n + 2] = f;\n    }, q._ComputeSides = function (e, t, i, r, n, o, s) {\n      var a,\n          l,\n          c = i.length,\n          h = r.length;\n\n      switch (e = e || he.Mesh.DEFAULTSIDE) {\n        case he.Mesh.FRONTSIDE:\n          break;\n\n        case he.Mesh.BACKSIDE:\n          var u;\n\n          for (a = 0; a < c; a += 3) u = i[a], i[a] = i[a + 2], i[a + 2] = u;\n\n          for (l = 0; l < h; l++) r[l] = -r[l];\n\n          break;\n\n        case he.Mesh.DOUBLESIDE:\n          for (var d = t.length, f = d / 3, p = 0; p < d; p++) t[d + p] = t[p];\n\n          for (a = 0; a < c; a += 3) i[a + c] = i[a + 2] + f, i[a + 1 + c] = i[a + 1] + f, i[a + 2 + c] = i[a] + f;\n\n          for (l = 0; l < h; l++) r[h + l] = -r[l];\n\n          var _ = n.length,\n              m = 0;\n\n          for (m = 0; m < _; m++) n[m + _] = n[m];\n\n          for (o = o || new he.Vector4(0, 0, 1, 1), s = s || new he.Vector4(0, 0, 1, 1), a = m = 0; a < _ / 2; a++) n[m] = o.x + (o.z - o.x) * n[m], n[m + 1] = o.y + (o.w - o.y) * n[m + 1], n[m + _] = s.x + (s.z - s.x) * n[m + _], n[m + _ + 1] = s.y + (s.w - s.y) * n[m + _ + 1], m += 2;\n\n      }\n    }, q.ImportVertexData = function (e, t) {\n      var i = new q(),\n          r = e.positions;\n      r && i.set(r, he.VertexBuffer.PositionKind);\n      var n = e.normals;\n      n && i.set(n, he.VertexBuffer.NormalKind);\n      var o = e.tangents;\n      o && i.set(o, he.VertexBuffer.TangentKind);\n      var s = e.uvs;\n      s && i.set(s, he.VertexBuffer.UVKind);\n      var a = e.uv2s;\n      a && i.set(a, he.VertexBuffer.UV2Kind);\n      var l = e.uv3s;\n      l && i.set(l, he.VertexBuffer.UV3Kind);\n      var c = e.uv4s;\n      c && i.set(c, he.VertexBuffer.UV4Kind);\n      var h = e.uv5s;\n      h && i.set(h, he.VertexBuffer.UV5Kind);\n      var u = e.uv6s;\n      u && i.set(u, he.VertexBuffer.UV6Kind);\n      var d = e.colors;\n      d && i.set(he.Color4.CheckColors4(d, r.length / 3), he.VertexBuffer.ColorKind);\n      var f = e.matricesIndices;\n      f && i.set(f, he.VertexBuffer.MatricesIndicesKind);\n      var p = e.matricesWeights;\n      p && i.set(p, he.VertexBuffer.MatricesWeightsKind);\n      var _ = e.indices;\n      _ && (i.indices = _), t.setAllVerticesData(i, e.updatable);\n    }, q;\n  }(), he.VertexData = ue, function (I) {\n    var e = function () {\n      function D(e, t, i, r, n) {\n        void 0 === r && (r = !1), void 0 === n && (n = null), this.delayLoadState = I.Engine.DELAYLOADSTATE_NONE, this._totalVertices = 0, this._isDisposed = !1, this._indexBufferIsUpdatable = !1, this.id = e, this._engine = t.getEngine(), this._meshes = [], this._scene = t, this._vertexBuffers = {}, this._indices = [], this._updatable = r, i ? this.setAllVerticesData(i, r) : (this._totalVertices = 0, this._indices = []), this._engine.getCaps().vertexArrayObject && (this._vertexArrayObjects = {}), n && (\"LinesMesh\" === n.getClassName() && (this.boundingBias = new I.Vector2(0, n.intersectionThreshold), this._updateExtend()), this.applyToMesh(n), n.computeWorldMatrix(!0));\n      }\n\n      return Object.defineProperty(D.prototype, \"boundingBias\", {\n        get: function () {\n          return this._boundingBias;\n        },\n        set: function (e) {\n          if (this._boundingBias) {\n            if (this._boundingBias.equals(e)) return;\n\n            this._boundingBias.copyFrom(e);\n          } else this._boundingBias = e.clone();\n\n          this._updateBoundingInfo(!0, null);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), D.CreateGeometryForMesh = function (e) {\n        var t = new D(D.RandomId(), e.getScene());\n        return t.applyToMesh(e), t;\n      }, Object.defineProperty(D.prototype, \"extend\", {\n        get: function () {\n          return this._extend;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), D.prototype.getScene = function () {\n        return this._scene;\n      }, D.prototype.getEngine = function () {\n        return this._engine;\n      }, D.prototype.isReady = function () {\n        return this.delayLoadState === I.Engine.DELAYLOADSTATE_LOADED || this.delayLoadState === I.Engine.DELAYLOADSTATE_NONE;\n      }, Object.defineProperty(D.prototype, \"doNotSerialize\", {\n        get: function () {\n          for (var e = 0; e < this._meshes.length; e++) if (!this._meshes[e].doNotSerialize) return !1;\n\n          return !0;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), D.prototype._rebuild = function () {\n        for (var e in this._vertexArrayObjects && (this._vertexArrayObjects = {}), 0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices)), this._vertexBuffers) {\n          this._vertexBuffers[e]._rebuild();\n        }\n      }, D.prototype.setAllVerticesData = function (e, t) {\n        e.applyToGeometry(this, t), this.notifyUpdate();\n      }, D.prototype.setVerticesData = function (e, t, i, r) {\n        void 0 === i && (i = !1);\n        var n = new I.VertexBuffer(this._engine, t, e, i, 0 === this._meshes.length, r);\n        this.setVerticesBuffer(n);\n      }, D.prototype.removeVerticesData = function (e) {\n        this._vertexBuffers[e] && (this._vertexBuffers[e].dispose(), delete this._vertexBuffers[e]);\n      }, D.prototype.setVerticesBuffer = function (e, t) {\n        void 0 === t && (t = null);\n        var i = e.getKind();\n\n        if (this._vertexBuffers[i] && this._vertexBuffers[i].dispose(), this._vertexBuffers[i] = e, i === I.VertexBuffer.PositionKind) {\n          var r = e.getData();\n          null != t ? this._totalVertices = t : null != r && (this._totalVertices = r.length / (e.byteStride / 4)), this._updateExtend(r), this._resetPointsArrayCache();\n\n          for (var n = this._meshes, o = n.length, s = 0; s < o; s++) {\n            var a = n[s];\n            a._boundingInfo = new I.BoundingInfo(this._extend.minimum, this._extend.maximum), a._createGlobalSubMesh(!1), a.computeWorldMatrix(!0);\n          }\n        }\n\n        this.notifyUpdate(i), this._vertexArrayObjects && (this._disposeVertexArrayObjects(), this._vertexArrayObjects = {});\n      }, D.prototype.updateVerticesDataDirectly = function (e, t, i, r) {\n        void 0 === r && (r = !1);\n        var n = this.getVertexBuffer(e);\n        n && (n.updateDirectly(t, i, r), this.notifyUpdate(e));\n      }, D.prototype.updateVerticesData = function (e, t, i) {\n        void 0 === i && (i = !1);\n        var r = this.getVertexBuffer(e);\n        r && (r.update(t), e === I.VertexBuffer.PositionKind && this._updateBoundingInfo(i, t), this.notifyUpdate(e));\n      }, D.prototype._updateBoundingInfo = function (e, t) {\n        e && this._updateExtend(t);\n        var i = this._meshes,\n            r = i.length;\n\n        this._resetPointsArrayCache();\n\n        for (var n = 0; n < r; n++) {\n          var o = i[n];\n\n          if (e) {\n            o._boundingInfo = new I.BoundingInfo(this._extend.minimum, this._extend.maximum);\n\n            for (var s = 0; s < o.subMeshes.length; s++) {\n              o.subMeshes[s].refreshBoundingInfo();\n            }\n          }\n        }\n      }, D.prototype._bind = function (e, t) {\n        if (e) {\n          void 0 === t && (t = this._indexBuffer);\n          var i = this.getVertexBuffers();\n          i && (t == this._indexBuffer && this._vertexArrayObjects ? (this._vertexArrayObjects[e.key] || (this._vertexArrayObjects[e.key] = this._engine.recordVertexArrayObject(i, t, e)), this._engine.bindVertexArrayObject(this._vertexArrayObjects[e.key], t)) : this._engine.bindBuffers(i, t, e));\n        }\n      }, D.prototype.getTotalVertices = function () {\n        return this.isReady() ? this._totalVertices : 0;\n      }, D.prototype.getVerticesData = function (e, t, i) {\n        var r = this.getVertexBuffer(e);\n        if (!r) return null;\n        var n = r.getData();\n        if (!n) return null;\n        var o = r.getSize() * I.VertexBuffer.GetTypeByteLength(r.type),\n            s = this._totalVertices * r.getSize();\n\n        if (r.type !== I.VertexBuffer.FLOAT || r.byteStride !== o) {\n          var a = new Array(s);\n          return r.forEach(s, function (e, t) {\n            a[t] = e;\n          }), a;\n        }\n\n        if (!(n instanceof Array || n instanceof Float32Array) || 0 !== r.byteOffset || n.length !== s) {\n          if (n instanceof Array) {\n            var l = r.byteOffset / 4;\n            return I.Tools.Slice(n, l, l + s);\n          }\n\n          if (n instanceof ArrayBuffer) return new Float32Array(n, r.byteOffset, s);\n          l = n.byteOffset + r.byteOffset;\n\n          if (i || t && 1 !== this._meshes.length) {\n            var c = new Float32Array(s),\n                h = new Float32Array(n.buffer, l, s);\n            return c.set(h), c;\n          }\n\n          return new Float32Array(n.buffer, l, s);\n        }\n\n        return i || t && 1 !== this._meshes.length ? I.Tools.Slice(n) : n;\n      }, D.prototype.isVertexBufferUpdatable = function (e) {\n        var t = this._vertexBuffers[e];\n        return !!t && t.isUpdatable();\n      }, D.prototype.getVertexBuffer = function (e) {\n        return this.isReady() ? this._vertexBuffers[e] : null;\n      }, D.prototype.getVertexBuffers = function () {\n        return this.isReady() ? this._vertexBuffers : null;\n      }, D.prototype.isVerticesDataPresent = function (e) {\n        return this._vertexBuffers ? void 0 !== this._vertexBuffers[e] : !!this._delayInfo && -1 !== this._delayInfo.indexOf(e);\n      }, D.prototype.getVerticesDataKinds = function () {\n        var e,\n            t = [];\n        if (!this._vertexBuffers && this._delayInfo) for (e in this._delayInfo) t.push(e);else for (e in this._vertexBuffers) t.push(e);\n        return t;\n      }, D.prototype.updateIndices = function (e, t) {\n        this._indexBuffer && (this._indexBufferIsUpdatable ? this._engine.updateDynamicIndexBuffer(this._indexBuffer, e, t) : this.setIndices(e, null, !0));\n      }, D.prototype.setIndices = function (e, t, i) {\n        void 0 === t && (t = null), void 0 === i && (i = !1), this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._disposeVertexArrayObjects(), this._indices = e, this._indexBufferIsUpdatable = i, 0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, i)), null != t && (this._totalVertices = t);\n\n        for (var r = this._meshes, n = r.length, o = 0; o < n; o++) r[o]._createGlobalSubMesh(!0);\n\n        this.notifyUpdate();\n      }, D.prototype.getTotalIndices = function () {\n        return this.isReady() ? this._indices.length : 0;\n      }, D.prototype.getIndices = function (e, t) {\n        if (!this.isReady()) return null;\n        var i = this._indices;\n\n        if (t || e && 1 !== this._meshes.length) {\n          for (var r = i.length, n = [], o = 0; o < r; o++) n.push(i[o]);\n\n          return n;\n        }\n\n        return i;\n      }, D.prototype.getIndexBuffer = function () {\n        return this.isReady() ? this._indexBuffer : null;\n      }, D.prototype._releaseVertexArrayObject = function (e) {\n        void 0 === e && (e = null), e && this._vertexArrayObjects && this._vertexArrayObjects[e.key] && (this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]), delete this._vertexArrayObjects[e.key]);\n      }, D.prototype.releaseForMesh = function (e, t) {\n        var i = this._meshes,\n            r = i.indexOf(e);\n        -1 !== r && (i.splice(r, 1), e._geometry = null, 0 === i.length && t && this.dispose());\n      }, D.prototype.applyToMesh = function (e) {\n        if (e._geometry !== this) {\n          var t = e._geometry;\n          t && t.releaseForMesh(e);\n          var i = this._meshes;\n          (e._geometry = this)._scene.pushGeometry(this), i.push(e), this.isReady() ? this._applyToMesh(e) : e._boundingInfo = this._boundingInfo;\n        }\n      }, D.prototype._updateExtend = function (e) {\n        void 0 === e && (e = null), e || (e = this.getVerticesData(I.VertexBuffer.PositionKind)), this._extend = I.Tools.ExtractMinAndMax(e, 0, this._totalVertices, this.boundingBias, 3);\n      }, D.prototype._applyToMesh = function (e) {\n        var t = this._meshes.length;\n\n        for (var i in this._vertexBuffers) {\n          1 === t && this._vertexBuffers[i].create();\n\n          var r = this._vertexBuffers[i].getBuffer();\n\n          r && (r.references = t), i === I.VertexBuffer.PositionKind && (this._extend || this._updateExtend(), e._boundingInfo = new I.BoundingInfo(this._extend.minimum, this._extend.maximum), e._createGlobalSubMesh(!1), e._updateBoundingInfo());\n        }\n\n        1 === t && this._indices && 0 < this._indices.length && (this._indexBuffer = this._engine.createIndexBuffer(this._indices)), this._indexBuffer && (this._indexBuffer.references = t), e._syncGeometryWithMorphTargetManager();\n      }, D.prototype.notifyUpdate = function (e) {\n        this.onGeometryUpdated && this.onGeometryUpdated(this, e);\n\n        for (var t = 0, i = this._meshes; t < i.length; t++) {\n          i[t]._markSubMeshesAsAttributesDirty();\n        }\n      }, D.prototype.load = function (e, t) {\n        this.delayLoadState !== I.Engine.DELAYLOADSTATE_LOADING && (this.isReady() ? t && t() : (this.delayLoadState = I.Engine.DELAYLOADSTATE_LOADING, this._queueLoad(e, t)));\n      }, D.prototype._queueLoad = function (n, o) {\n        var s = this;\n        this.delayLoadingFile && (n._addPendingData(this), n._loadFile(this.delayLoadingFile, function (e) {\n          if (s._delayLoadingFunction) {\n            s._delayLoadingFunction(JSON.parse(e), s), s.delayLoadState = I.Engine.DELAYLOADSTATE_LOADED, s._delayInfo = [], n._removePendingData(s);\n\n            for (var t = s._meshes, i = t.length, r = 0; r < i; r++) s._applyToMesh(t[r]);\n\n            o && o();\n          }\n        }, void 0, !0));\n      }, D.prototype.toLeftHanded = function () {\n        var e = this.getIndices(!1);\n\n        if (null != e && 0 < e.length) {\n          for (var t = 0; t < e.length; t += 3) {\n            var i = e[t + 0];\n            e[t + 0] = e[t + 2], e[t + 2] = i;\n          }\n\n          this.setIndices(e);\n        }\n\n        var r = this.getVerticesData(I.VertexBuffer.PositionKind, !1);\n\n        if (null != r && 0 < r.length) {\n          for (t = 0; t < r.length; t += 3) r[t + 2] = -r[t + 2];\n\n          this.setVerticesData(I.VertexBuffer.PositionKind, r, !1);\n        }\n\n        var n = this.getVerticesData(I.VertexBuffer.NormalKind, !1);\n\n        if (null != n && 0 < n.length) {\n          for (t = 0; t < n.length; t += 3) n[t + 2] = -n[t + 2];\n\n          this.setVerticesData(I.VertexBuffer.NormalKind, n, !1);\n        }\n      }, D.prototype._resetPointsArrayCache = function () {\n        this._positions = null;\n      }, D.prototype._generatePointsArray = function () {\n        if (this._positions) return !0;\n        var e = this.getVerticesData(I.VertexBuffer.PositionKind);\n        if (!e || 0 === e.length) return !1;\n        this._positions = [];\n\n        for (var t = 0; t < e.length; t += 3) this._positions.push(I.Vector3.FromArray(e, t));\n\n        return !0;\n      }, D.prototype.isDisposed = function () {\n        return this._isDisposed;\n      }, D.prototype._disposeVertexArrayObjects = function () {\n        if (this._vertexArrayObjects) {\n          for (var e in this._vertexArrayObjects) this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e]);\n\n          this._vertexArrayObjects = {};\n        }\n      }, D.prototype.dispose = function () {\n        var e,\n            t = this._meshes,\n            i = t.length;\n\n        for (e = 0; e < i; e++) this.releaseForMesh(t[e]);\n\n        for (var r in this._meshes = [], this._disposeVertexArrayObjects(), this._vertexBuffers) this._vertexBuffers[r].dispose();\n\n        this._vertexBuffers = {}, this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = I.Engine.DELAYLOADSTATE_NONE, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null, this._scene.removeGeometry(this), this._isDisposed = !0;\n      }, D.prototype.copy = function (e) {\n        var t = new I.VertexData();\n        t.indices = [];\n        var i = this.getIndices();\n        if (i) for (var r = 0; r < i.length; r++) t.indices.push(i[r]);\n        var n,\n            o = !1,\n            s = !1;\n\n        for (n in this._vertexBuffers) {\n          var a = this.getVerticesData(n);\n\n          if (a instanceof Float32Array ? t.set(new Float32Array(a), n) : t.set(a.slice(0), n), !s) {\n            var l = this.getVertexBuffer(n);\n            l && (s = !(o = l.isUpdatable()));\n          }\n        }\n\n        var c = new D(e, this._scene, t, o);\n\n        for (n in c.delayLoadState = this.delayLoadState, c.delayLoadingFile = this.delayLoadingFile, c._delayLoadingFunction = this._delayLoadingFunction, this._delayInfo) c._delayInfo = c._delayInfo || [], c._delayInfo.push(n);\n\n        return c._boundingInfo = new I.BoundingInfo(this._extend.minimum, this._extend.maximum), c;\n      }, D.prototype.serialize = function () {\n        var e = {};\n        return e.id = this.id, e.updatable = this._updatable, I.Tags && I.Tags.HasTags(this) && (e.tags = I.Tags.GetTags(this)), e;\n      }, D.prototype.toNumberArray = function (e) {\n        return Array.isArray(e) ? e : Array.prototype.slice.call(e);\n      }, D.prototype.serializeVerticeData = function () {\n        var e = this.serialize();\n        return this.isVerticesDataPresent(I.VertexBuffer.PositionKind) && (e.positions = this.toNumberArray(this.getVerticesData(I.VertexBuffer.PositionKind)), this.isVertexBufferUpdatable(I.VertexBuffer.PositionKind) && (e.positions._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.NormalKind) && (e.normals = this.toNumberArray(this.getVerticesData(I.VertexBuffer.NormalKind)), this.isVertexBufferUpdatable(I.VertexBuffer.NormalKind) && (e.normals._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.TangentKind) && (e.tangets = this.toNumberArray(this.getVerticesData(I.VertexBuffer.TangentKind)), this.isVertexBufferUpdatable(I.VertexBuffer.TangentKind) && (e.tangets._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.UVKind) && (e.uvs = this.toNumberArray(this.getVerticesData(I.VertexBuffer.UVKind)), this.isVertexBufferUpdatable(I.VertexBuffer.UVKind) && (e.uvs._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.UV2Kind) && (e.uv2s = this.toNumberArray(this.getVerticesData(I.VertexBuffer.UV2Kind)), this.isVertexBufferUpdatable(I.VertexBuffer.UV2Kind) && (e.uv2s._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.UV3Kind) && (e.uv3s = this.toNumberArray(this.getVerticesData(I.VertexBuffer.UV3Kind)), this.isVertexBufferUpdatable(I.VertexBuffer.UV3Kind) && (e.uv3s._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.UV4Kind) && (e.uv4s = this.toNumberArray(this.getVerticesData(I.VertexBuffer.UV4Kind)), this.isVertexBufferUpdatable(I.VertexBuffer.UV4Kind) && (e.uv4s._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.UV5Kind) && (e.uv5s = this.toNumberArray(this.getVerticesData(I.VertexBuffer.UV5Kind)), this.isVertexBufferUpdatable(I.VertexBuffer.UV5Kind) && (e.uv5s._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.UV6Kind) && (e.uv6s = this.toNumberArray(this.getVerticesData(I.VertexBuffer.UV6Kind)), this.isVertexBufferUpdatable(I.VertexBuffer.UV6Kind) && (e.uv6s._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.ColorKind) && (e.colors = this.toNumberArray(this.getVerticesData(I.VertexBuffer.ColorKind)), this.isVertexBufferUpdatable(I.VertexBuffer.ColorKind) && (e.colors._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.MatricesIndicesKind) && (e.matricesIndices = this.toNumberArray(this.getVerticesData(I.VertexBuffer.MatricesIndicesKind)), e.matricesIndices._isExpanded = !0, this.isVertexBufferUpdatable(I.VertexBuffer.MatricesIndicesKind) && (e.matricesIndices._updatable = !0)), this.isVerticesDataPresent(I.VertexBuffer.MatricesWeightsKind) && (e.matricesWeights = this.toNumberArray(this.getVerticesData(I.VertexBuffer.MatricesWeightsKind)), this.isVertexBufferUpdatable(I.VertexBuffer.MatricesWeightsKind) && (e.matricesWeights._updatable = !0)), e.indices = this.toNumberArray(this.getIndices()), e;\n      }, D.ExtractFromMesh = function (e, t) {\n        var i = e._geometry;\n        return i ? i.copy(t) : null;\n      }, D.RandomId = function () {\n        return I.Tools.RandomId();\n      }, D._ImportGeometry = function (e, t) {\n        var i = t.getScene(),\n            r = e.geometryId;\n\n        if (r) {\n          var n = i.getGeometryByID(r);\n          n && n.applyToMesh(t);\n        } else if (e instanceof ArrayBuffer) {\n          var o = t._binaryInfo;\n\n          if (o.positionsAttrDesc && 0 < o.positionsAttrDesc.count) {\n            var s = new Float32Array(e, o.positionsAttrDesc.offset, o.positionsAttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.PositionKind, s, !1);\n          }\n\n          if (o.normalsAttrDesc && 0 < o.normalsAttrDesc.count) {\n            var a = new Float32Array(e, o.normalsAttrDesc.offset, o.normalsAttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.NormalKind, a, !1);\n          }\n\n          if (o.tangetsAttrDesc && 0 < o.tangetsAttrDesc.count) {\n            var l = new Float32Array(e, o.tangetsAttrDesc.offset, o.tangetsAttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.TangentKind, l, !1);\n          }\n\n          if (o.uvsAttrDesc && 0 < o.uvsAttrDesc.count) {\n            var c = new Float32Array(e, o.uvsAttrDesc.offset, o.uvsAttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.UVKind, c, !1);\n          }\n\n          if (o.uvs2AttrDesc && 0 < o.uvs2AttrDesc.count) {\n            var h = new Float32Array(e, o.uvs2AttrDesc.offset, o.uvs2AttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.UV2Kind, h, !1);\n          }\n\n          if (o.uvs3AttrDesc && 0 < o.uvs3AttrDesc.count) {\n            var u = new Float32Array(e, o.uvs3AttrDesc.offset, o.uvs3AttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.UV3Kind, u, !1);\n          }\n\n          if (o.uvs4AttrDesc && 0 < o.uvs4AttrDesc.count) {\n            var d = new Float32Array(e, o.uvs4AttrDesc.offset, o.uvs4AttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.UV4Kind, d, !1);\n          }\n\n          if (o.uvs5AttrDesc && 0 < o.uvs5AttrDesc.count) {\n            var f = new Float32Array(e, o.uvs5AttrDesc.offset, o.uvs5AttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.UV5Kind, f, !1);\n          }\n\n          if (o.uvs6AttrDesc && 0 < o.uvs6AttrDesc.count) {\n            var p = new Float32Array(e, o.uvs6AttrDesc.offset, o.uvs6AttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.UV6Kind, p, !1);\n          }\n\n          if (o.colorsAttrDesc && 0 < o.colorsAttrDesc.count) {\n            var _ = new Float32Array(e, o.colorsAttrDesc.offset, o.colorsAttrDesc.count);\n\n            t.setVerticesData(I.VertexBuffer.ColorKind, _, !1, o.colorsAttrDesc.stride);\n          }\n\n          if (o.matricesIndicesAttrDesc && 0 < o.matricesIndicesAttrDesc.count) {\n            for (var m = new Int32Array(e, o.matricesIndicesAttrDesc.offset, o.matricesIndicesAttrDesc.count), g = [], v = 0; v < m.length; v++) {\n              var y = m[v];\n              g.push(255 & y), g.push((65280 & y) >> 8), g.push((16711680 & y) >> 16), g.push(y >> 24);\n            }\n\n            t.setVerticesData(I.VertexBuffer.MatricesIndicesKind, g, !1);\n          }\n\n          if (o.matricesWeightsAttrDesc && 0 < o.matricesWeightsAttrDesc.count) {\n            var b = new Float32Array(e, o.matricesWeightsAttrDesc.offset, o.matricesWeightsAttrDesc.count);\n            t.setVerticesData(I.VertexBuffer.MatricesWeightsKind, b, !1);\n          }\n\n          if (o.indicesAttrDesc && 0 < o.indicesAttrDesc.count) {\n            var T = new Int32Array(e, o.indicesAttrDesc.offset, o.indicesAttrDesc.count);\n            t.setIndices(T, null);\n          }\n\n          if (o.subMeshesAttrDesc && 0 < o.subMeshesAttrDesc.count) {\n            var E = new Int32Array(e, o.subMeshesAttrDesc.offset, 5 * o.subMeshesAttrDesc.count);\n            t.subMeshes = [];\n\n            for (v = 0; v < o.subMeshesAttrDesc.count; v++) {\n              var x = E[5 * v + 0],\n                  P = E[5 * v + 1],\n                  A = E[5 * v + 2],\n                  S = E[5 * v + 3],\n                  M = E[5 * v + 4];\n              I.SubMesh.AddToMesh(x, P, A, S, M, t);\n            }\n          }\n        } else if (e.positions && e.normals && e.indices) {\n          if (t.setVerticesData(I.VertexBuffer.PositionKind, e.positions, e.positions._updatable), t.setVerticesData(I.VertexBuffer.NormalKind, e.normals, e.normals._updatable), e.tangents && t.setVerticesData(I.VertexBuffer.TangentKind, e.tangents, e.tangents._updatable), e.uvs && t.setVerticesData(I.VertexBuffer.UVKind, e.uvs, e.uvs._updatable), e.uvs2 && t.setVerticesData(I.VertexBuffer.UV2Kind, e.uvs2, e.uvs2._updatable), e.uvs3 && t.setVerticesData(I.VertexBuffer.UV3Kind, e.uvs3, e.uvs3._updatable), e.uvs4 && t.setVerticesData(I.VertexBuffer.UV4Kind, e.uvs4, e.uvs4._updatable), e.uvs5 && t.setVerticesData(I.VertexBuffer.UV5Kind, e.uvs5, e.uvs5._updatable), e.uvs6 && t.setVerticesData(I.VertexBuffer.UV6Kind, e.uvs6, e.uvs6._updatable), e.colors && t.setVerticesData(I.VertexBuffer.ColorKind, I.Color4.CheckColors4(e.colors, e.positions.length / 3), e.colors._updatable), e.matricesIndices) if (e.matricesIndices._isExpanded) delete e.matricesIndices._isExpanded, t.setVerticesData(I.VertexBuffer.MatricesIndicesKind, e.matricesIndices, e.matricesIndices._updatable);else {\n            for (g = [], v = 0; v < e.matricesIndices.length; v++) {\n              var R = e.matricesIndices[v];\n              g.push(255 & R), g.push((65280 & R) >> 8), g.push((16711680 & R) >> 16), g.push(R >> 24);\n            }\n\n            t.setVerticesData(I.VertexBuffer.MatricesIndicesKind, g, e.matricesIndices._updatable);\n          }\n          if (e.matricesIndicesExtra) if (e.matricesIndicesExtra._isExpanded) delete e.matricesIndices._isExpanded, t.setVerticesData(I.VertexBuffer.MatricesIndicesExtraKind, e.matricesIndicesExtra, e.matricesIndicesExtra._updatable);else {\n            for (g = [], v = 0; v < e.matricesIndicesExtra.length; v++) {\n              R = e.matricesIndicesExtra[v];\n              g.push(255 & R), g.push((65280 & R) >> 8), g.push((16711680 & R) >> 16), g.push(R >> 24);\n            }\n\n            t.setVerticesData(I.VertexBuffer.MatricesIndicesExtraKind, g, e.matricesIndicesExtra._updatable);\n          }\n          e.matricesWeights && (D._CleanMatricesWeights(e, t), t.setVerticesData(I.VertexBuffer.MatricesWeightsKind, e.matricesWeights, e.matricesWeights._updatable)), e.matricesWeightsExtra && t.setVerticesData(I.VertexBuffer.MatricesWeightsExtraKind, e.matricesWeightsExtra, e.matricesWeights._updatable), t.setIndices(e.indices, null);\n        }\n\n        if (e.subMeshes) {\n          t.subMeshes = [];\n\n          for (var C = 0; C < e.subMeshes.length; C++) {\n            var O = e.subMeshes[C];\n            I.SubMesh.AddToMesh(O.materialIndex, O.verticesStart, O.verticesCount, O.indexStart, O.indexCount, t);\n          }\n        }\n\n        t._shouldGenerateFlatShading && (t.convertToFlatShadedMesh(), delete t._shouldGenerateFlatShading), t.computeWorldMatrix(!0), i.onMeshImportedObservable.notifyObservers(t);\n      }, D._CleanMatricesWeights = function (e, t) {\n        if (I.SceneLoader.CleanBoneMatrixWeights) {\n          var i = 0;\n\n          if (-1 < e.skeletonId) {\n            var r = t.getScene().getLastSkeletonByID(e.skeletonId);\n\n            if (r) {\n              i = r.bones.length;\n\n              for (var n = t.getVerticesData(I.VertexBuffer.MatricesIndicesKind), o = t.getVerticesData(I.VertexBuffer.MatricesIndicesExtraKind), s = e.matricesWeights, a = e.matricesWeightsExtra, l = e.numBoneInfluencer, c = s.length, h = 0; h < c; h += 4) {\n                for (var u = 0, d = -1, f = 0; f < 4; f++) {\n                  u += p = s[h + f], p < .001 && d < 0 && (d = f);\n                }\n\n                if (a) for (f = 0; f < 4; f++) {\n                  var p;\n                  u += p = a[h + f], p < .001 && d < 0 && (d = f + 4);\n                }\n\n                if ((d < 0 || l - 1 < d) && (d = l - 1), .001 < u) {\n                  var _ = 1 / u;\n\n                  for (f = 0; f < 4; f++) s[h + f] *= _;\n\n                  if (a) for (f = 0; f < 4; f++) a[h + f] *= _;\n                } else 4 <= d ? (a[h + d - 4] = 1 - u, o[h + d - 4] = i) : (s[h + d] = 1 - u, n[h + d] = i);\n              }\n\n              t.setVerticesData(I.VertexBuffer.MatricesIndicesKind, n), e.matricesWeightsExtra && t.setVerticesData(I.VertexBuffer.MatricesIndicesExtraKind, o);\n            }\n          }\n        }\n      }, D.Parse = function (e, t, i) {\n        if (t.getGeometryByID(e.id)) return null;\n        var r = new D(e.id, t, void 0, e.updatable);\n        return I.Tags && I.Tags.AddTagsTo(r, e.tags), e.delayLoadingFile ? (r.delayLoadState = I.Engine.DELAYLOADSTATE_NOTLOADED, r.delayLoadingFile = i + e.delayLoadingFile, r._boundingInfo = new I.BoundingInfo(I.Vector3.FromArray(e.boundingBoxMinimum), I.Vector3.FromArray(e.boundingBoxMaximum)), r._delayInfo = [], e.hasUVs && r._delayInfo.push(I.VertexBuffer.UVKind), e.hasUVs2 && r._delayInfo.push(I.VertexBuffer.UV2Kind), e.hasUVs3 && r._delayInfo.push(I.VertexBuffer.UV3Kind), e.hasUVs4 && r._delayInfo.push(I.VertexBuffer.UV4Kind), e.hasUVs5 && r._delayInfo.push(I.VertexBuffer.UV5Kind), e.hasUVs6 && r._delayInfo.push(I.VertexBuffer.UV6Kind), e.hasColors && r._delayInfo.push(I.VertexBuffer.ColorKind), e.hasMatricesIndices && r._delayInfo.push(I.VertexBuffer.MatricesIndicesKind), e.hasMatricesWeights && r._delayInfo.push(I.VertexBuffer.MatricesWeightsKind), r._delayLoadingFunction = I.VertexData.ImportVertexData) : I.VertexData.ImportVertexData(e, r), t.pushGeometry(r, !0), r;\n      }, D;\n    }(),\n        t = function (o) {\n      function e(e, t, i, r) {\n        void 0 === i && (i = !1), void 0 === r && (r = null);\n        var n = o.call(this, e, t, void 0, !1, r) || this;\n        return n._canBeRegenerated = i, n._beingRegenerated = !0, n.regenerate(), n._beingRegenerated = !1, n;\n      }\n\n      return T(e, o), e.prototype.canBeRegenerated = function () {\n        return this._canBeRegenerated;\n      }, e.prototype.regenerate = function () {\n        this._canBeRegenerated && (this._beingRegenerated = !0, this.setAllVerticesData(this._regenerateVertexData(), !1), this._beingRegenerated = !1);\n      }, e.prototype.asNewGeometry = function (e) {\n        return o.prototype.copy.call(this, e);\n      }, e.prototype.setAllVerticesData = function (e, t) {\n        this._beingRegenerated && o.prototype.setAllVerticesData.call(this, e, !1);\n      }, e.prototype.setVerticesData = function (e, t, i) {\n        this._beingRegenerated && o.prototype.setVerticesData.call(this, e, t, !1);\n      }, e.prototype._regenerateVertexData = function () {\n        throw new Error(\"Abstract method\");\n      }, e.prototype.copy = function (e) {\n        throw new Error(\"Must be overriden in sub-classes.\");\n      }, e.prototype.serialize = function () {\n        var e = o.prototype.serialize.call(this);\n        return e.canBeRegenerated = this.canBeRegenerated(), e;\n      }, e;\n    }(I.Geometry = e),\n        i = function (h) {\n      function t(e, t, i, r, n, o, s, a, l) {\n        void 0 === l && (l = I.Mesh.DEFAULTSIDE);\n        var c = h.call(this, e, t, s, a) || this;\n        return c.pathArray = i, c.closeArray = r, c.closePath = n, c.offset = o, c.side = l, c;\n      }\n\n      return T(t, h), t.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateRibbon({\n          pathArray: this.pathArray,\n          closeArray: this.closeArray,\n          closePath: this.closePath,\n          offset: this.offset,\n          sideOrientation: this.side\n        });\n      }, t.prototype.copy = function (e) {\n        return new t(e, this.getScene(), this.pathArray, this.closeArray, this.closePath, this.offset, this.canBeRegenerated(), void 0, this.side);\n      }, t;\n    }(I._PrimitiveGeometry = t);\n\n    I.RibbonGeometry = i;\n\n    var r = function (a) {\n      function r(e, t, i, r, n, o) {\n        void 0 === n && (n = null), void 0 === o && (o = I.Mesh.DEFAULTSIDE);\n        var s = a.call(this, e, t, r, n) || this;\n        return s.size = i, s.side = o, s;\n      }\n\n      return T(r, a), r.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateBox({\n          size: this.size,\n          sideOrientation: this.side\n        });\n      }, r.prototype.copy = function (e) {\n        return new r(e, this.getScene(), this.size, this.canBeRegenerated(), void 0, this.side);\n      }, r.prototype.serialize = function () {\n        var e = a.prototype.serialize.call(this);\n        return e.size = this.size, e;\n      }, r.Parse = function (e, t) {\n        if (t.getGeometryByID(e.id)) return null;\n        var i = new r(e.id, t, e.size, e.canBeRegenerated, null);\n        return I.Tags && I.Tags.AddTagsTo(i, e.tags), t.pushGeometry(i, !0), i;\n      }, r;\n    }(t);\n\n    I.BoxGeometry = r;\n\n    var n = function (l) {\n      function r(e, t, i, r, n, o, s) {\n        void 0 === o && (o = null), void 0 === s && (s = I.Mesh.DEFAULTSIDE);\n        var a = l.call(this, e, t, n, o) || this;\n        return a.segments = i, a.diameter = r, a.side = s, a;\n      }\n\n      return T(r, l), r.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateSphere({\n          segments: this.segments,\n          diameter: this.diameter,\n          sideOrientation: this.side\n        });\n      }, r.prototype.copy = function (e) {\n        return new r(e, this.getScene(), this.segments, this.diameter, this.canBeRegenerated(), null, this.side);\n      }, r.prototype.serialize = function () {\n        var e = l.prototype.serialize.call(this);\n        return e.segments = this.segments, e.diameter = this.diameter, e;\n      }, r.Parse = function (e, t) {\n        if (t.getGeometryByID(e.id)) return null;\n        var i = new r(e.id, t, e.segments, e.diameter, e.canBeRegenerated, null);\n        return I.Tags && I.Tags.AddTagsTo(i, e.tags), t.pushGeometry(i, !0), i;\n      }, r;\n    }(t);\n\n    I.SphereGeometry = n;\n\n    var o = function (l) {\n      function t(e, t, i, r, n, o, s) {\n        void 0 === o && (o = null), void 0 === s && (s = I.Mesh.DEFAULTSIDE);\n        var a = l.call(this, e, t, n, o) || this;\n        return a.radius = i, a.tessellation = r, a.side = s, a;\n      }\n\n      return T(t, l), t.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateDisc({\n          radius: this.radius,\n          tessellation: this.tessellation,\n          sideOrientation: this.side\n        });\n      }, t.prototype.copy = function (e) {\n        return new t(e, this.getScene(), this.radius, this.tessellation, this.canBeRegenerated(), null, this.side);\n      }, t;\n    }(t);\n\n    I.DiscGeometry = o;\n\n    var s = function (u) {\n      function r(e, t, i, r, n, o, s, a, l, c) {\n        void 0 === s && (s = 1), void 0 === l && (l = null), void 0 === c && (c = I.Mesh.DEFAULTSIDE);\n        var h = u.call(this, e, t, a, l) || this;\n        return h.height = i, h.diameterTop = r, h.diameterBottom = n, h.tessellation = o, h.subdivisions = s, h.side = c, h;\n      }\n\n      return T(r, u), r.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateCylinder({\n          height: this.height,\n          diameterTop: this.diameterTop,\n          diameterBottom: this.diameterBottom,\n          tessellation: this.tessellation,\n          subdivisions: this.subdivisions,\n          sideOrientation: this.side\n        });\n      }, r.prototype.copy = function (e) {\n        return new r(e, this.getScene(), this.height, this.diameterTop, this.diameterBottom, this.tessellation, this.subdivisions, this.canBeRegenerated(), null, this.side);\n      }, r.prototype.serialize = function () {\n        var e = u.prototype.serialize.call(this);\n        return e.height = this.height, e.diameterTop = this.diameterTop, e.diameterBottom = this.diameterBottom, e.tessellation = this.tessellation, e;\n      }, r.Parse = function (e, t) {\n        if (t.getGeometryByID(e.id)) return null;\n        var i = new r(e.id, t, e.height, e.diameterTop, e.diameterBottom, e.tessellation, e.subdivisions, e.canBeRegenerated, null);\n        return I.Tags && I.Tags.AddTagsTo(i, e.tags), t.pushGeometry(i, !0), i;\n      }, r;\n    }(t);\n\n    I.CylinderGeometry = s;\n\n    var a = function (c) {\n      function r(e, t, i, r, n, o, s, a) {\n        void 0 === s && (s = null), void 0 === a && (a = I.Mesh.DEFAULTSIDE);\n        var l = c.call(this, e, t, o, s) || this;\n        return l.diameter = i, l.thickness = r, l.tessellation = n, l.side = a, l;\n      }\n\n      return T(r, c), r.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateTorus({\n          diameter: this.diameter,\n          thickness: this.thickness,\n          tessellation: this.tessellation,\n          sideOrientation: this.side\n        });\n      }, r.prototype.copy = function (e) {\n        return new r(e, this.getScene(), this.diameter, this.thickness, this.tessellation, this.canBeRegenerated(), null, this.side);\n      }, r.prototype.serialize = function () {\n        var e = c.prototype.serialize.call(this);\n        return e.diameter = this.diameter, e.thickness = this.thickness, e.tessellation = this.tessellation, e;\n      }, r.Parse = function (e, t) {\n        if (t.getGeometryByID(e.id)) return null;\n        var i = new r(e.id, t, e.diameter, e.thickness, e.tessellation, e.canBeRegenerated, null);\n        return I.Tags && I.Tags.AddTagsTo(i, e.tags), t.pushGeometry(i, !0), i;\n      }, r;\n    }(t);\n\n    I.TorusGeometry = a;\n\n    var l = function (l) {\n      function r(e, t, i, r, n, o, s) {\n        void 0 === s && (s = null);\n        var a = l.call(this, e, t, o, s) || this;\n        return a.width = i, a.height = r, a.subdivisions = n, a;\n      }\n\n      return T(r, l), r.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateGround({\n          width: this.width,\n          height: this.height,\n          subdivisions: this.subdivisions\n        });\n      }, r.prototype.copy = function (e) {\n        return new r(e, this.getScene(), this.width, this.height, this.subdivisions, this.canBeRegenerated(), null);\n      }, r.prototype.serialize = function () {\n        var e = l.prototype.serialize.call(this);\n        return e.width = this.width, e.height = this.height, e.subdivisions = this.subdivisions, e;\n      }, r.Parse = function (e, t) {\n        if (t.getGeometryByID(e.id)) return null;\n        var i = new r(e.id, t, e.width, e.height, e.subdivisions, e.canBeRegenerated, null);\n        return I.Tags && I.Tags.AddTagsTo(i, e.tags), t.pushGeometry(i, !0), i;\n      }, r;\n    }(t);\n\n    I.GroundGeometry = l;\n\n    var c = function (u) {\n      function t(e, t, i, r, n, o, s, a, l, c) {\n        void 0 === c && (c = null);\n        var h = u.call(this, e, t, l, c) || this;\n        return h.xmin = i, h.zmin = r, h.xmax = n, h.zmax = o, h.subdivisions = s, h.precision = a, h;\n      }\n\n      return T(t, u), t.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateTiledGround({\n          xmin: this.xmin,\n          zmin: this.zmin,\n          xmax: this.xmax,\n          zmax: this.zmax,\n          subdivisions: this.subdivisions,\n          precision: this.precision\n        });\n      }, t.prototype.copy = function (e) {\n        return new t(e, this.getScene(), this.xmin, this.zmin, this.xmax, this.zmax, this.subdivisions, this.precision, this.canBeRegenerated(), null);\n      }, t;\n    }(t);\n\n    I.TiledGroundGeometry = c;\n\n    var h = function (a) {\n      function r(e, t, i, r, n, o) {\n        void 0 === n && (n = null), void 0 === o && (o = I.Mesh.DEFAULTSIDE);\n        var s = a.call(this, e, t, r, n) || this;\n        return s.size = i, s.side = o, s;\n      }\n\n      return T(r, a), r.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreatePlane({\n          size: this.size,\n          sideOrientation: this.side\n        });\n      }, r.prototype.copy = function (e) {\n        return new r(e, this.getScene(), this.size, this.canBeRegenerated(), null, this.side);\n      }, r.prototype.serialize = function () {\n        var e = a.prototype.serialize.call(this);\n        return e.size = this.size, e;\n      }, r.Parse = function (e, t) {\n        if (t.getGeometryByID(e.id)) return null;\n        var i = new r(e.id, t, e.size, e.canBeRegenerated, null);\n        return I.Tags && I.Tags.AddTagsTo(i, e.tags), t.pushGeometry(i, !0), i;\n      }, r;\n    }(t);\n\n    I.PlaneGeometry = h;\n\n    var u = function (d) {\n      function r(e, t, i, r, n, o, s, a, l, c, h) {\n        void 0 === c && (c = null), void 0 === h && (h = I.Mesh.DEFAULTSIDE);\n        var u = d.call(this, e, t, l, c) || this;\n        return u.radius = i, u.tube = r, u.radialSegments = n, u.tubularSegments = o, u.p = s, u.q = a, u.side = h, u;\n      }\n\n      return T(r, d), r.prototype._regenerateVertexData = function () {\n        return I.VertexData.CreateTorusKnot({\n          radius: this.radius,\n          tube: this.tube,\n          radialSegments: this.radialSegments,\n          tubularSegments: this.tubularSegments,\n          p: this.p,\n          q: this.q,\n          sideOrientation: this.side\n        });\n      }, r.prototype.copy = function (e) {\n        return new r(e, this.getScene(), this.radius, this.tube, this.radialSegments, this.tubularSegments, this.p, this.q, this.canBeRegenerated(), null, this.side);\n      }, r.prototype.serialize = function () {\n        var e = d.prototype.serialize.call(this);\n        return e.radius = this.radius, e.tube = this.tube, e.radialSegments = this.radialSegments, e.tubularSegments = this.tubularSegments, e.p = this.p, e.q = this.q, e;\n      }, r.Parse = function (e, t) {\n        if (t.getGeometryByID(e.id)) return null;\n        var i = new r(e.id, t, e.radius, e.tube, e.radialSegments, e.tubularSegments, e.p, e.q, e.canBeRegenerated, null);\n        return I.Tags && I.Tags.AddTagsTo(i, e.tags), t.pushGeometry(i, !0), i;\n      }, r;\n    }(t);\n\n    I.TorusKnotGeometry = u;\n  }($a || ($a = {})), function (i) {\n    var e = function () {\n      function e(e) {\n        void 0 === e && (e = 30), this._enabled = !0, this._rollingFrameTime = new t(e);\n      }\n\n      return e.prototype.sampleFrame = function (e) {\n        if (void 0 === e && (e = i.Tools.Now), this._enabled) {\n          if (null != this._lastFrameTimeMs) {\n            var t = e - this._lastFrameTimeMs;\n\n            this._rollingFrameTime.add(t);\n          }\n\n          this._lastFrameTimeMs = e;\n        }\n      }, Object.defineProperty(e.prototype, \"averageFrameTime\", {\n        get: function () {\n          return this._rollingFrameTime.average;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"averageFrameTimeVariance\", {\n        get: function () {\n          return this._rollingFrameTime.variance;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"instantaneousFrameTime\", {\n        get: function () {\n          return this._rollingFrameTime.history(0);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"averageFPS\", {\n        get: function () {\n          return 1e3 / this._rollingFrameTime.average;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"instantaneousFPS\", {\n        get: function () {\n          var e = this._rollingFrameTime.history(0);\n\n          return 0 === e ? 0 : 1e3 / e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"isSaturated\", {\n        get: function () {\n          return this._rollingFrameTime.isSaturated();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.enable = function () {\n        this._enabled = !0;\n      }, e.prototype.disable = function () {\n        this._enabled = !1, this._lastFrameTimeMs = null;\n      }, Object.defineProperty(e.prototype, \"isEnabled\", {\n        get: function () {\n          return this._enabled;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.reset = function () {\n        this._lastFrameTimeMs = null, this._rollingFrameTime.reset();\n      }, e;\n    }();\n\n    i.PerformanceMonitor = e;\n\n    var t = function () {\n      function e(e) {\n        this._samples = new Array(e), this.reset();\n      }\n\n      return e.prototype.add = function (e) {\n        var t;\n\n        if (this.isSaturated()) {\n          var i = this._samples[this._pos];\n          t = i - this.average, this.average -= t / (this._sampleCount - 1), this._m2 -= t * (i - this.average);\n        } else this._sampleCount++;\n\n        t = e - this.average, this.average += t / this._sampleCount, this._m2 += t * (e - this.average), this.variance = this._m2 / (this._sampleCount - 1), this._samples[this._pos] = e, this._pos++, this._pos %= this._samples.length;\n      }, e.prototype.history = function (e) {\n        if (e >= this._sampleCount || e >= this._samples.length) return 0;\n\n        var t = this._wrapPosition(this._pos - 1);\n\n        return this._samples[this._wrapPosition(t - e)];\n      }, e.prototype.isSaturated = function () {\n        return this._sampleCount >= this._samples.length;\n      }, e.prototype.reset = function () {\n        this.average = 0, this.variance = 0, this._sampleCount = 0, this._pos = 0, this._m2 = 0;\n      }, e.prototype._wrapPosition = function (e) {\n        var t = this._samples.length;\n        return (e % t + t) % t;\n      }, e;\n    }();\n\n    i.RollingAverage = t;\n  }($a || ($a = {})), de = $a || ($a = {}), fe = function () {\n    function u() {}\n\n    return u.BindEyePosition = function (e, t) {\n      t._forcedViewPosition ? e.setVector3(\"vEyePosition\", t._forcedViewPosition) : e.setVector3(\"vEyePosition\", t._mirroredCameraPosition ? t._mirroredCameraPosition : t.activeCamera.globalPosition);\n    }, u.PrepareDefinesForMergedUV = function (e, t, i) {\n      t._needUVs = !0, t[i] = !0, e.getTextureMatrix().isIdentity(!0) ? (t[i + \"DIRECTUV\"] = e.coordinatesIndex + 1, 0 === e.coordinatesIndex ? t.MAINUV1 = !0 : t.MAINUV2 = !0) : t[i + \"DIRECTUV\"] = 0;\n    }, u.BindTextureMatrix = function (e, t, i) {\n      var r = e.getTextureMatrix();\n      r.isIdentity(!0) || t.updateMatrix(i + \"Matrix\", r);\n    }, u.PrepareDefinesForMisc = function (e, t, i, r, n, o, s) {\n      s._areMiscDirty && (s.LOGARITHMICDEPTH = i, s.POINTSIZE = r, s.FOG = t.fogEnabled && e.applyFog && t.fogMode !== de.Scene.FOGMODE_NONE && n, s.NONUNIFORMSCALING = e.nonUniformScaling, s.ALPHATEST = o);\n    }, u.PrepareDefinesForFrameBoundValues = function (e, t, i, r, n) {\n      void 0 === n && (n = null);\n      var o,\n          s,\n          a,\n          l,\n          c = !1;\n      o = null == n ? void 0 !== e.clipPlane && null !== e.clipPlane : n, s = null == n ? void 0 !== e.clipPlane2 && null !== e.clipPlane2 : n, a = null == n ? void 0 !== e.clipPlane3 && null !== e.clipPlane3 : n, l = null == n ? void 0 !== e.clipPlane4 && null !== e.clipPlane4 : n, i.CLIPPLANE !== o && (i.CLIPPLANE = o, c = !0), i.CLIPPLANE2 !== s && (i.CLIPPLANE2 = s, c = !0), i.CLIPPLANE3 !== a && (i.CLIPPLANE3 = a, c = !0), i.CLIPPLANE4 !== l && (i.CLIPPLANE4 = l, c = !0), i.DEPTHPREPASS !== !t.getColorWrite() && (i.DEPTHPREPASS = !i.DEPTHPREPASS, c = !0), i.INSTANCES !== r && (i.INSTANCES = r, c = !0), c && i.markAsUnprocessed();\n    }, u.PrepareDefinesForAttributes = function (e, t, i, r, n, o) {\n      if (void 0 === n && (n = !1), void 0 === o && (o = !0), !t._areAttributesDirty && t._needNormals === t._normals && t._needUVs === t._uvs) return !1;\n\n      if (t._normals = t._needNormals, t._uvs = t._needUVs, t.NORMAL = t._needNormals && e.isVerticesDataPresent(de.VertexBuffer.NormalKind), t._needNormals && e.isVerticesDataPresent(de.VertexBuffer.TangentKind) && (t.TANGENT = !0), t._needUVs ? (t.UV1 = e.isVerticesDataPresent(de.VertexBuffer.UVKind), t.UV2 = e.isVerticesDataPresent(de.VertexBuffer.UV2Kind)) : (t.UV1 = !1, t.UV2 = !1), i) {\n        var s = e.useVertexColors && e.isVerticesDataPresent(de.VertexBuffer.ColorKind);\n        t.VERTEXCOLOR = s, t.VERTEXALPHA = e.hasVertexAlpha && s && o;\n      }\n\n      if (r && (e.useBones && e.computeBonesUsingShaders && e.skeleton ? (t.NUM_BONE_INFLUENCERS = e.numBoneInfluencers, t.BonesPerMesh = e.skeleton.bones.length + 1) : (t.NUM_BONE_INFLUENCERS = 0, t.BonesPerMesh = 0)), n) {\n        var a = e.morphTargetManager;\n        a ? (t.MORPHTARGETS_TANGENT = a.supportsTangents && t.TANGENT, t.MORPHTARGETS_NORMAL = a.supportsNormals && t.NORMAL, t.MORPHTARGETS = 0 < a.numInfluencers, t.NUM_MORPH_INFLUENCERS = a.numInfluencers) : (t.MORPHTARGETS_TANGENT = !1, t.MORPHTARGETS_NORMAL = !1, t.MORPHTARGETS = !1, t.NUM_MORPH_INFLUENCERS = 0);\n      }\n\n      return !0;\n    }, u.PrepareDefinesForLights = function (e, t, i, r, n, o) {\n      if (void 0 === n && (n = 4), void 0 === o && (o = !1), !i._areLightsDirty) return i._needNormals;\n      var s = 0,\n          a = !1,\n          l = !1,\n          c = !1,\n          h = !1,\n          u = !1;\n      if (e.lightsEnabled && !o) for (var d = 0, f = t._lightSources; d < f.length; d++) {\n        var p = f[d];\n\n        switch (a = !0, void 0 === i[\"LIGHT\" + s] && (l = !0), i[\"LIGHT\" + s] = !0, i[\"SPOTLIGHT\" + s] = !1, i[\"HEMILIGHT\" + s] = !1, i[\"POINTLIGHT\" + s] = !1, i[\"DIRLIGHT\" + s] = !1, p.prepareLightSpecificDefines(i, s), i[\"LIGHT_FALLOFF_PHYSICAL\" + s] = !1, i[\"LIGHT_FALLOFF_GLTF\" + s] = !1, i[\"LIGHT_FALLOFF_STANDARD\" + s] = !1, p.falloffType) {\n          case de.Light.FALLOFF_GLTF:\n            i[\"LIGHT_FALLOFF_GLTF\" + s] = !0;\n            break;\n\n          case de.Light.FALLOFF_PHYSICAL:\n            i[\"LIGHT_FALLOFF_PHYSICAL\" + s] = !0;\n            break;\n\n          case de.Light.FALLOFF_STANDARD:\n            i[\"LIGHT_FALLOFF_STANDARD\" + s] = !0;\n        }\n\n        if (r && !p.specular.equalsFloats(0, 0, 0) && (u = !0), i[\"SHADOW\" + s] = !1, i[\"SHADOWPCF\" + s] = !1, i[\"SHADOWPCSS\" + s] = !1, i[\"SHADOWPOISSON\" + s] = !1, i[\"SHADOWESM\" + s] = !1, i[\"SHADOWCUBE\" + s] = !1, i[\"SHADOWLOWQUALITY\" + s] = !1, i[\"SHADOWMEDIUMQUALITY\" + s] = !1, t && t.receiveShadows && e.shadowsEnabled && p.shadowEnabled) {\n          var _ = p.getShadowGenerator();\n\n          if (_) {\n            var m = _.getShadowMap();\n\n            m && m.renderList && 0 < m.renderList.length && (h = !0, _.prepareDefines(i, s));\n          }\n        }\n\n        if (p.lightmapMode != de.Light.LIGHTMAP_DEFAULT ? (c = !0, i[\"LIGHTMAPEXCLUDED\" + s] = !0, i[\"LIGHTMAPNOSPECULAR\" + s] = p.lightmapMode == de.Light.LIGHTMAP_SHADOWSONLY) : (i[\"LIGHTMAPEXCLUDED\" + s] = !1, i[\"LIGHTMAPNOSPECULAR\" + s] = !1), ++s === n) break;\n      }\n      i.SPECULARTERM = u, i.SHADOWS = h;\n\n      for (var g = s; g < n; g++) void 0 !== i[\"LIGHT\" + g] && (i[\"LIGHT\" + g] = !1, i[\"HEMILIGHT\" + s] = !1, i[\"POINTLIGHT\" + s] = !1, i[\"DIRLIGHT\" + s] = !1, i[\"SPOTLIGHT\" + s] = !1, i[\"SHADOW\" + s] = !1);\n\n      var v = e.getEngine().getCaps();\n      return void 0 === i.SHADOWFLOAT && (l = !0), i.SHADOWFLOAT = h && (v.textureFloatRender && v.textureFloatLinearFiltering || v.textureHalfFloatRender && v.textureHalfFloatLinearFiltering), i.LIGHTMAPEXCLUDED = c, l && i.rebuild(), a;\n    }, u.PrepareUniformsAndSamplersList = function (e, t, i, r) {\n      var n;\n      void 0 === r && (r = 4);\n      var o = null;\n\n      if (e.uniformsNames) {\n        var s = e;\n        n = s.uniformsNames, o = s.uniformBuffersNames, t = s.samplers, i = s.defines, r = s.maxSimultaneousLights;\n      } else n = e, t || (t = []);\n\n      for (var a = 0; a < r && i[\"LIGHT\" + a]; a++) n.push(\"vLightData\" + a, \"vLightDiffuse\" + a, \"vLightSpecular\" + a, \"vLightDirection\" + a, \"vLightFalloff\" + a, \"vLightGround\" + a, \"lightMatrix\" + a, \"shadowsInfo\" + a, \"depthValues\" + a), o && o.push(\"Light\" + a), t.push(\"shadowSampler\" + a), t.push(\"depthSampler\" + a), i[\"PROJECTEDLIGHTTEXTURE\" + a] && (t.push(\"projectionLightSampler\" + a), n.push(\"textureProjectionMatrix\" + a));\n\n      i.NUM_MORPH_INFLUENCERS && n.push(\"morphTargetInfluences\");\n    }, u.HandleFallbacksForShadows = function (e, t, i, r) {\n      void 0 === i && (i = 4), void 0 === r && (r = 0);\n\n      for (var n = 0, o = 0; o < i && e[\"LIGHT\" + o]; o++) 0 < o && (n = r + o, t.addFallback(n, \"LIGHT\" + o)), e.SHADOWS || (e[\"SHADOW\" + o] && t.addFallback(r, \"SHADOW\" + o), e[\"SHADOWPCF\" + o] && t.addFallback(r, \"SHADOWPCF\" + o), e[\"SHADOWPCSS\" + o] && t.addFallback(r, \"SHADOWPCSS\" + o), e[\"SHADOWPOISSON\" + o] && t.addFallback(r, \"SHADOWPOISSON\" + o), e[\"SHADOWESM\" + o] && t.addFallback(r, \"SHADOWESM\" + o));\n\n      return n++;\n    }, u.PrepareAttributesForMorphTargets = function (e, t, i) {\n      var r = i.NUM_MORPH_INFLUENCERS;\n      if (0 < r && de.Engine.LastCreatedEngine) for (var n = de.Engine.LastCreatedEngine.getCaps().maxVertexAttribs, o = t.morphTargetManager, s = o && o.supportsNormals && i.NORMAL, a = o && o.supportsTangents && i.TANGENT, l = 0; l < r; l++) e.push(de.VertexBuffer.PositionKind + l), s && e.push(de.VertexBuffer.NormalKind + l), a && e.push(de.VertexBuffer.TangentKind + l), e.length > n && de.Tools.Error(\"Cannot add more vertex attributes for mesh \" + t.name);\n    }, u.PrepareAttributesForBones = function (e, t, i, r) {\n      0 < i.NUM_BONE_INFLUENCERS && (r.addCPUSkinningFallback(0, t), e.push(de.VertexBuffer.MatricesIndicesKind), e.push(de.VertexBuffer.MatricesWeightsKind), 4 < i.NUM_BONE_INFLUENCERS && (e.push(de.VertexBuffer.MatricesIndicesExtraKind), e.push(de.VertexBuffer.MatricesWeightsExtraKind)));\n    }, u.PrepareAttributesForInstances = function (e, t) {\n      t.INSTANCES && (e.push(\"world0\"), e.push(\"world1\"), e.push(\"world2\"), e.push(\"world3\"));\n    }, u.BindLightShadow = function (e, t, i, r, n) {\n      if (e.shadowEnabled && i.receiveShadows) {\n        var o = e.getShadowGenerator();\n        o && o.bindShadowLight(r, n);\n      }\n    }, u.BindLightProperties = function (e, t, i) {\n      e.transferToEffect(t, i + \"\");\n    }, u.BindLights = function (e, t, i, r, n, o) {\n      void 0 === n && (n = 4), void 0 === o && (o = !1);\n\n      for (var s = Math.min(t._lightSources.length, n), a = 0; a < s; a++) {\n        var l = t._lightSources[a],\n            c = a.toString(),\n            h = l.getScaledIntensity();\n        l._uniformBuffer.bindToEffect(i, \"Light\" + a), u.BindLightProperties(l, i, a), l.diffuse.scaleToRef(h, de.Tmp.Color3[0]), l._uniformBuffer.updateColor4(\"vLightDiffuse\", de.Tmp.Color3[0], o ? l.radius : l.range, c), r.SPECULARTERM && (l.specular.scaleToRef(h, de.Tmp.Color3[1]), l._uniformBuffer.updateColor3(\"vLightSpecular\", de.Tmp.Color3[1], c)), e.shadowsEnabled && this.BindLightShadow(l, e, t, c, i), l._uniformBuffer.update();\n      }\n    }, u.BindFogParameters = function (e, t, i, r) {\n      void 0 === r && (r = !1), e.fogEnabled && t.applyFog && e.fogMode !== de.Scene.FOGMODE_NONE && (i.setFloat4(\"vFogInfos\", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), r ? (e.fogColor.toLinearSpaceToRef(this._tempFogColor), i.setColor3(\"vFogColor\", this._tempFogColor)) : i.setColor3(\"vFogColor\", e.fogColor));\n    }, u.BindBonesParameters = function (e, t) {\n      if (t && e && (e.computeBonesUsingShaders && t._bonesComputationForcedToCPU && (e.computeBonesUsingShaders = !1), e.useBones && e.computeBonesUsingShaders && e.skeleton)) {\n        var i = e.skeleton.getTransformMatrices(e);\n        i && t.setMatrices(\"mBones\", i);\n      }\n    }, u.BindMorphTargetParameters = function (e, t) {\n      var i = e.morphTargetManager;\n      e && i && t.setFloatArray(\"morphTargetInfluences\", i.influences);\n    }, u.BindLogDepth = function (e, t, i) {\n      e.LOGARITHMICDEPTH && t.setFloat(\"logarithmicDepthConstant\", 2 / (Math.log(i.activeCamera.maxZ + 1) / Math.LN2));\n    }, u.BindClipPlane = function (e, t) {\n      if (t.clipPlane) {\n        var i = t.clipPlane;\n        e.setFloat4(\"vClipPlane\", i.normal.x, i.normal.y, i.normal.z, i.d);\n      }\n\n      if (t.clipPlane2) {\n        i = t.clipPlane2;\n        e.setFloat4(\"vClipPlane2\", i.normal.x, i.normal.y, i.normal.z, i.d);\n      }\n\n      if (t.clipPlane3) {\n        i = t.clipPlane3;\n        e.setFloat4(\"vClipPlane3\", i.normal.x, i.normal.y, i.normal.z, i.d);\n      }\n\n      if (t.clipPlane4) {\n        i = t.clipPlane4;\n        e.setFloat4(\"vClipPlane4\", i.normal.x, i.normal.y, i.normal.z, i.d);\n      }\n    }, u._tempFogColor = de.Color3.Black(), u;\n  }(), de.MaterialHelper = fe, pe = $a || ($a = {}), _e = function (r) {\n    function e(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i._normalMatrix = new pe.Matrix(), i.storeEffectOnSubMeshes = !0, i;\n    }\n\n    return T(e, r), e.prototype.getEffect = function () {\n      return this._activeEffect;\n    }, e.prototype.isReady = function (e, t) {\n      return !!e && (!e.subMeshes || 0 === e.subMeshes.length || this.isReadyForSubMesh(e, e.subMeshes[0], t));\n    }, e.prototype.bindOnlyWorldMatrix = function (e) {\n      this._activeEffect.setMatrix(\"world\", e);\n    }, e.prototype.bindOnlyNormalMatrix = function (e) {\n      this._activeEffect.setMatrix(\"normalMatrix\", e);\n    }, e.prototype.bind = function (e, t) {\n      t && this.bindForSubMesh(e, t, t.subMeshes[0]);\n    }, e.prototype._afterBind = function (e, t) {\n      void 0 === t && (t = null), r.prototype._afterBind.call(this, e), this.getScene()._cachedEffect = t;\n    }, e.prototype._mustRebind = function (e, t, i) {\n      return void 0 === i && (i = 1), e.isCachedMaterialInvalid(this, t, i);\n    }, e;\n  }(pe.Material), pe.PushMaterial = _e, function (p) {\n    var _ = function (t) {\n      function e() {\n        var e = t.call(this) || this;\n        return e.MAINUV1 = !1, e.MAINUV2 = !1, e.DIFFUSE = !1, e.DIFFUSEDIRECTUV = 0, e.AMBIENT = !1, e.AMBIENTDIRECTUV = 0, e.OPACITY = !1, e.OPACITYDIRECTUV = 0, e.OPACITYRGB = !1, e.REFLECTION = !1, e.EMISSIVE = !1, e.EMISSIVEDIRECTUV = 0, e.SPECULAR = !1, e.SPECULARDIRECTUV = 0, e.BUMP = !1, e.BUMPDIRECTUV = 0, e.PARALLAX = !1, e.PARALLAXOCCLUSION = !1, e.SPECULAROVERALPHA = !1, e.CLIPPLANE = !1, e.CLIPPLANE2 = !1, e.CLIPPLANE3 = !1, e.CLIPPLANE4 = !1, e.ALPHATEST = !1, e.DEPTHPREPASS = !1, e.ALPHAFROMDIFFUSE = !1, e.POINTSIZE = !1, e.FOG = !1, e.SPECULARTERM = !1, e.DIFFUSEFRESNEL = !1, e.OPACITYFRESNEL = !1, e.REFLECTIONFRESNEL = !1, e.REFRACTIONFRESNEL = !1, e.EMISSIVEFRESNEL = !1, e.FRESNEL = !1, e.NORMAL = !1, e.UV1 = !1, e.UV2 = !1, e.VERTEXCOLOR = !1, e.VERTEXALPHA = !1, e.NUM_BONE_INFLUENCERS = 0, e.BonesPerMesh = 0, e.INSTANCES = !1, e.GLOSSINESS = !1, e.ROUGHNESS = !1, e.EMISSIVEASILLUMINATION = !1, e.LINKEMISSIVEWITHDIFFUSE = !1, e.REFLECTIONFRESNELFROMSPECULAR = !1, e.LIGHTMAP = !1, e.LIGHTMAPDIRECTUV = 0, e.OBJECTSPACE_NORMALMAP = !1, e.USELIGHTMAPASSHADOWMAP = !1, e.REFLECTIONMAP_3D = !1, e.REFLECTIONMAP_SPHERICAL = !1, e.REFLECTIONMAP_PLANAR = !1, e.REFLECTIONMAP_CUBIC = !1, e.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, e.REFLECTIONMAP_PROJECTION = !1, e.REFLECTIONMAP_SKYBOX = !1, e.REFLECTIONMAP_SKYBOX_TRANSFORMED = !1, e.REFLECTIONMAP_EXPLICIT = !1, e.REFLECTIONMAP_EQUIRECTANGULAR = !1, e.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, e.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, e.INVERTCUBICMAP = !1, e.LOGARITHMICDEPTH = !1, e.REFRACTION = !1, e.REFRACTIONMAP_3D = !1, e.REFLECTIONOVERALPHA = !1, e.TWOSIDEDLIGHTING = !1, e.SHADOWFLOAT = !1, e.MORPHTARGETS = !1, e.MORPHTARGETS_NORMAL = !1, e.MORPHTARGETS_TANGENT = !1, e.NUM_MORPH_INFLUENCERS = 0, e.NONUNIFORMSCALING = !1, e.PREMULTIPLYALPHA = !1, e.IMAGEPROCESSING = !1, e.VIGNETTE = !1, e.VIGNETTEBLENDMODEMULTIPLY = !1, e.VIGNETTEBLENDMODEOPAQUE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = !1, e.SAMPLER3DBGRMAP = !1, e.IMAGEPROCESSINGPOSTPROCESS = !1, e.IS_REFLECTION_LINEAR = !1, e.IS_REFRACTION_LINEAR = !1, e.EXPOSURE = !1, e.rebuild(), e;\n      }\n\n      return T(e, t), e.prototype.setReflectionMode = function (e) {\n        for (var t = 0, i = [\"REFLECTIONMAP_CUBIC\", \"REFLECTIONMAP_EXPLICIT\", \"REFLECTIONMAP_PLANAR\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_SKYBOX\", \"REFLECTIONMAP_SPHERICAL\", \"REFLECTIONMAP_EQUIRECTANGULAR\", \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\", \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\"]; t < i.length; t++) {\n          var r = i[t];\n          this[r] = r === e;\n        }\n      }, e;\n    }(p.MaterialDefines);\n\n    p.StandardMaterialDefines = _;\n\n    var e = function (r) {\n      function f(e, t) {\n        var i = r.call(this, e, t) || this;\n        return i.ambientColor = new p.Color3(0, 0, 0), i.diffuseColor = new p.Color3(1, 1, 1), i.specularColor = new p.Color3(1, 1, 1), i.emissiveColor = new p.Color3(0, 0, 0), i.specularPower = 64, i._useAlphaFromDiffuseTexture = !1, i._useEmissiveAsIllumination = !1, i._linkEmissiveWithDiffuse = !1, i._useSpecularOverAlpha = !1, i._useReflectionOverAlpha = !1, i._disableLighting = !1, i._useObjectSpaceNormalMap = !1, i._useParallax = !1, i._useParallaxOcclusion = !1, i.parallaxScaleBias = .05, i._roughness = 0, i.indexOfRefraction = .98, i.invertRefractionY = !0, i.alphaCutOff = .4, i._useLightmapAsShadowmap = !1, i._useReflectionFresnelFromSpecular = !1, i._useGlossinessFromSpecularMapAlpha = !1, i._maxSimultaneousLights = 4, i._invertNormalMapX = !1, i._invertNormalMapY = !1, i._twoSidedLighting = !1, i._renderTargets = new p.SmartArray(16), i._worldViewProjectionMatrix = p.Matrix.Zero(), i._globalAmbientColor = new p.Color3(0, 0, 0), i._attachImageProcessingConfiguration(null), i.getRenderTargetTextures = function () {\n          return i._renderTargets.reset(), f.ReflectionTextureEnabled && i._reflectionTexture && i._reflectionTexture.isRenderTarget && i._renderTargets.push(i._reflectionTexture), f.RefractionTextureEnabled && i._refractionTexture && i._refractionTexture.isRenderTarget && i._renderTargets.push(i._refractionTexture), i._renderTargets;\n        }, i;\n      }\n\n      return T(f, r), Object.defineProperty(f.prototype, \"imageProcessingConfiguration\", {\n        get: function () {\n          return this._imageProcessingConfiguration;\n        },\n        set: function (e) {\n          this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), f.prototype._attachImageProcessingConfiguration = function (e) {\n        var t = this;\n        e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingConfiguration = e || this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function (e) {\n          t._markAllSubMeshesAsImageProcessingDirty();\n        })));\n      }, Object.defineProperty(f.prototype, \"cameraColorCurvesEnabled\", {\n        get: function () {\n          return this.imageProcessingConfiguration.colorCurvesEnabled;\n        },\n        set: function (e) {\n          this.imageProcessingConfiguration.colorCurvesEnabled = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f.prototype, \"cameraColorGradingEnabled\", {\n        get: function () {\n          return this.imageProcessingConfiguration.colorGradingEnabled;\n        },\n        set: function (e) {\n          this.imageProcessingConfiguration.colorGradingEnabled = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f.prototype, \"cameraToneMappingEnabled\", {\n        get: function () {\n          return this._imageProcessingConfiguration.toneMappingEnabled;\n        },\n        set: function (e) {\n          this._imageProcessingConfiguration.toneMappingEnabled = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f.prototype, \"cameraExposure\", {\n        get: function () {\n          return this._imageProcessingConfiguration.exposure;\n        },\n        set: function (e) {\n          this._imageProcessingConfiguration.exposure = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f.prototype, \"cameraContrast\", {\n        get: function () {\n          return this._imageProcessingConfiguration.contrast;\n        },\n        set: function (e) {\n          this._imageProcessingConfiguration.contrast = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f.prototype, \"cameraColorGradingTexture\", {\n        get: function () {\n          return this._imageProcessingConfiguration.colorGradingTexture;\n        },\n        set: function (e) {\n          this._imageProcessingConfiguration.colorGradingTexture = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f.prototype, \"cameraColorCurves\", {\n        get: function () {\n          return this._imageProcessingConfiguration.colorCurves;\n        },\n        set: function (e) {\n          this._imageProcessingConfiguration.colorCurves = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f.prototype, \"hasRenderTargetTextures\", {\n        get: function () {\n          return !!(f.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) || !!(f.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), f.prototype.getClassName = function () {\n        return \"StandardMaterial\";\n      }, Object.defineProperty(f.prototype, \"useLogarithmicDepth\", {\n        get: function () {\n          return this._useLogarithmicDepth;\n        },\n        set: function (e) {\n          this._useLogarithmicDepth = e && this.getScene().getEngine().getCaps().fragmentDepthSupported, this._markAllSubMeshesAsMiscDirty();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), f.prototype.needAlphaBlending = function () {\n        return this.alpha < 1 || null != this._opacityTexture || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\n      }, f.prototype.needAlphaTesting = function () {\n        return null != this._diffuseTexture && this._diffuseTexture.hasAlpha;\n      }, f.prototype._shouldUseAlphaFromDiffuseTexture = function () {\n        return null != this._diffuseTexture && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture;\n      }, f.prototype.getAlphaTestTexture = function () {\n        return this._diffuseTexture;\n      }, f.prototype.isReadyForSubMesh = function (e, t, i) {\n        if (void 0 === i && (i = !1), t.effect && this.isFrozen && this._wasPreviouslyReady) return !0;\n        t._materialDefines || (t._materialDefines = new _());\n        var r = this.getScene(),\n            n = t._materialDefines;\n        if (!this.checkReadyOnEveryCall && t.effect && n._renderId === r.getRenderId()) return !0;\n        var o = r.getEngine();\n\n        if (n._needNormals = p.MaterialHelper.PrepareDefinesForLights(r, e, n, !0, this._maxSimultaneousLights, this._disableLighting), n._areTexturesDirty) {\n          if (n._needUVs = !1, n.MAINUV1 = !1, n.MAINUV2 = !1, r.texturesEnabled) {\n            if (this._diffuseTexture && f.DiffuseTextureEnabled) {\n              if (!this._diffuseTexture.isReadyOrNotBlocking()) return !1;\n              p.MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, n, \"DIFFUSE\");\n            } else n.DIFFUSE = !1;\n\n            if (this._ambientTexture && f.AmbientTextureEnabled) {\n              if (!this._ambientTexture.isReadyOrNotBlocking()) return !1;\n              p.MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, n, \"AMBIENT\");\n            } else n.AMBIENT = !1;\n\n            if (this._opacityTexture && f.OpacityTextureEnabled) {\n              if (!this._opacityTexture.isReadyOrNotBlocking()) return !1;\n              p.MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, n, \"OPACITY\"), n.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n            } else n.OPACITY = !1;\n\n            if (this._reflectionTexture && f.ReflectionTextureEnabled) {\n              if (!this._reflectionTexture.isReadyOrNotBlocking()) return !1;\n\n              switch (n._needNormals = !0, n.REFLECTION = !0, n.ROUGHNESS = 0 < this._roughness, n.REFLECTIONOVERALPHA = this._useReflectionOverAlpha, n.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === p.Texture.INVCUBIC_MODE, n.REFLECTIONMAP_3D = this._reflectionTexture.isCube, this._reflectionTexture.coordinatesMode) {\n                case p.Texture.EXPLICIT_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\n                  break;\n\n                case p.Texture.PLANAR_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\n                  break;\n\n                case p.Texture.PROJECTION_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\n                  break;\n\n                case p.Texture.SKYBOX_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_SKYBOX\"), n.REFLECTIONMAP_SKYBOX_TRANSFORMED = !this._reflectionTexture.getReflectionTextureMatrix().isIdentity();\n                  break;\n\n                case p.Texture.SPHERICAL_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\n                  break;\n\n                case p.Texture.EQUIRECTANGULAR_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n                  break;\n\n                case p.Texture.FIXED_EQUIRECTANGULAR_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n                  break;\n\n                case p.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                  n.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n                  break;\n\n                case p.Texture.CUBIC_MODE:\n                case p.Texture.INVCUBIC_MODE:\n                default:\n                  n.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\n              }\n\n              n.USE_LOCAL_REFLECTIONMAP_CUBIC = !!this._reflectionTexture.boundingBoxSize;\n            } else n.REFLECTION = !1;\n\n            if (this._emissiveTexture && f.EmissiveTextureEnabled) {\n              if (!this._emissiveTexture.isReadyOrNotBlocking()) return !1;\n              p.MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, n, \"EMISSIVE\");\n            } else n.EMISSIVE = !1;\n\n            if (this._lightmapTexture && f.LightmapTextureEnabled) {\n              if (!this._lightmapTexture.isReadyOrNotBlocking()) return !1;\n              p.MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, n, \"LIGHTMAP\"), n.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n            } else n.LIGHTMAP = !1;\n\n            if (this._specularTexture && f.SpecularTextureEnabled) {\n              if (!this._specularTexture.isReadyOrNotBlocking()) return !1;\n              p.MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, n, \"SPECULAR\"), n.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\n            } else n.SPECULAR = !1;\n\n            if (r.getEngine().getCaps().standardDerivatives && this._bumpTexture && f.BumpTextureEnabled) {\n              if (!this._bumpTexture.isReady()) return !1;\n              p.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, n, \"BUMP\"), n.PARALLAX = this._useParallax, n.PARALLAXOCCLUSION = this._useParallaxOcclusion, n.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\n            } else n.BUMP = !1;\n\n            if (this._refractionTexture && f.RefractionTextureEnabled) {\n              if (!this._refractionTexture.isReadyOrNotBlocking()) return !1;\n              n._needUVs = !0, n.REFRACTION = !0, n.REFRACTIONMAP_3D = this._refractionTexture.isCube;\n            } else n.REFRACTION = !1;\n\n            n.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\n          } else n.DIFFUSE = !1, n.AMBIENT = !1, n.OPACITY = !1, n.REFLECTION = !1, n.EMISSIVE = !1, n.LIGHTMAP = !1, n.BUMP = !1, n.REFRACTION = !1;\n\n          n.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture(), n.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination, n.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse, n.SPECULAROVERALPHA = this._useSpecularOverAlpha, n.PREMULTIPLYALPHA = this.alphaMode === p.Engine.ALPHA_PREMULTIPLIED || this.alphaMode === p.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF;\n        }\n\n        if (n._areImageProcessingDirty && this._imageProcessingConfiguration) {\n          if (!this._imageProcessingConfiguration.isReady()) return !1;\n          this._imageProcessingConfiguration.prepareDefines(n), n.IS_REFLECTION_LINEAR = null != this.reflectionTexture && !this.reflectionTexture.gammaSpace, n.IS_REFRACTION_LINEAR = null != this.refractionTexture && !this.refractionTexture.gammaSpace;\n        }\n\n        if (n._areFresnelDirty && (f.FresnelEnabled ? (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) && (n.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled, n.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled, n.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled, n.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular, n.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled, n.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled, n._needNormals = !0, n.FRESNEL = !0) : n.FRESNEL = !1), p.MaterialHelper.PrepareDefinesForMisc(e, r, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e), n), p.MaterialHelper.PrepareDefinesForAttributes(e, n, !0, !0, !0), p.MaterialHelper.PrepareDefinesForFrameBoundValues(r, o, n, i), n.isDirty) {\n          n.markAsProcessed(), r.resetCachedMaterial();\n          var s = new p.EffectFallbacks();\n          n.REFLECTION && s.addFallback(0, \"REFLECTION\"), n.SPECULAR && s.addFallback(0, \"SPECULAR\"), n.BUMP && s.addFallback(0, \"BUMP\"), n.PARALLAX && s.addFallback(1, \"PARALLAX\"), n.PARALLAXOCCLUSION && s.addFallback(0, \"PARALLAXOCCLUSION\"), n.SPECULAROVERALPHA && s.addFallback(0, \"SPECULAROVERALPHA\"), n.FOG && s.addFallback(1, \"FOG\"), n.POINTSIZE && s.addFallback(0, \"POINTSIZE\"), n.LOGARITHMICDEPTH && s.addFallback(0, \"LOGARITHMICDEPTH\"), p.MaterialHelper.HandleFallbacksForShadows(n, s, this._maxSimultaneousLights), n.SPECULARTERM && s.addFallback(0, \"SPECULARTERM\"), n.DIFFUSEFRESNEL && s.addFallback(1, \"DIFFUSEFRESNEL\"), n.OPACITYFRESNEL && s.addFallback(2, \"OPACITYFRESNEL\"), n.REFLECTIONFRESNEL && s.addFallback(3, \"REFLECTIONFRESNEL\"), n.EMISSIVEFRESNEL && s.addFallback(4, \"EMISSIVEFRESNEL\"), n.FRESNEL && s.addFallback(4, \"FRESNEL\");\n          var a = [p.VertexBuffer.PositionKind];\n          n.NORMAL && a.push(p.VertexBuffer.NormalKind), n.UV1 && a.push(p.VertexBuffer.UVKind), n.UV2 && a.push(p.VertexBuffer.UV2Kind), n.VERTEXCOLOR && a.push(p.VertexBuffer.ColorKind), p.MaterialHelper.PrepareAttributesForBones(a, e, n, s), p.MaterialHelper.PrepareAttributesForInstances(a, n), p.MaterialHelper.PrepareAttributesForMorphTargets(a, e, n);\n          var l = \"default\",\n              c = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vDiffuseColor\", \"vSpecularColor\", \"vEmissiveColor\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"vDiffuseInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vEmissiveInfos\", \"vSpecularInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\", \"mBones\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"diffuseMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"specularMatrix\", \"bumpMatrix\", \"normalMatrix\", \"lightmapMatrix\", \"refractionMatrix\", \"diffuseLeftColor\", \"diffuseRightColor\", \"opacityParts\", \"reflectionLeftColor\", \"reflectionRightColor\", \"emissiveLeftColor\", \"emissiveRightColor\", \"refractionLeftColor\", \"refractionRightColor\", \"vReflectionPosition\", \"vReflectionSize\", \"logarithmicDepthConstant\", \"vTangentSpaceParams\", \"alphaCutOff\"],\n              h = [\"diffuseSampler\", \"ambientSampler\", \"opacitySampler\", \"reflectionCubeSampler\", \"reflection2DSampler\", \"emissiveSampler\", \"specularSampler\", \"bumpSampler\", \"lightmapSampler\", \"refractionCubeSampler\", \"refraction2DSampler\"],\n              u = [\"Material\", \"Scene\"];\n          p.ImageProcessingConfiguration && (p.ImageProcessingConfiguration.PrepareUniforms(c, n), p.ImageProcessingConfiguration.PrepareSamplers(h, n)), p.MaterialHelper.PrepareUniformsAndSamplersList({\n            uniformsNames: c,\n            uniformBuffersNames: u,\n            samplers: h,\n            defines: n,\n            maxSimultaneousLights: this._maxSimultaneousLights\n          }), this.customShaderNameResolve && (l = this.customShaderNameResolve(l, c, u, h, n));\n          var d = n.toString();\n          t.setEffect(r.getEngine().createEffect(l, {\n            attributes: a,\n            uniformsNames: c,\n            uniformBuffersNames: u,\n            samplers: h,\n            defines: d,\n            fallbacks: s,\n            onCompiled: this.onCompiled,\n            onError: this.onError,\n            indexParameters: {\n              maxSimultaneousLights: this._maxSimultaneousLights,\n              maxSimultaneousMorphTargets: n.NUM_MORPH_INFLUENCERS\n            }\n          }, o), n), this.buildUniformLayout();\n        }\n\n        return !(!t.effect || !t.effect.isReady()) && (n._renderId = r.getRenderId(), this._wasPreviouslyReady = !0);\n      }, f.prototype.buildUniformLayout = function () {\n        this._uniformBuffer.addUniform(\"diffuseLeftColor\", 4), this._uniformBuffer.addUniform(\"diffuseRightColor\", 4), this._uniformBuffer.addUniform(\"opacityParts\", 4), this._uniformBuffer.addUniform(\"reflectionLeftColor\", 4), this._uniformBuffer.addUniform(\"reflectionRightColor\", 4), this._uniformBuffer.addUniform(\"refractionLeftColor\", 4), this._uniformBuffer.addUniform(\"refractionRightColor\", 4), this._uniformBuffer.addUniform(\"emissiveLeftColor\", 4), this._uniformBuffer.addUniform(\"emissiveRightColor\", 4), this._uniformBuffer.addUniform(\"vDiffuseInfos\", 2), this._uniformBuffer.addUniform(\"vAmbientInfos\", 2), this._uniformBuffer.addUniform(\"vOpacityInfos\", 2), this._uniformBuffer.addUniform(\"vReflectionInfos\", 2), this._uniformBuffer.addUniform(\"vReflectionPosition\", 3), this._uniformBuffer.addUniform(\"vReflectionSize\", 3), this._uniformBuffer.addUniform(\"vEmissiveInfos\", 2), this._uniformBuffer.addUniform(\"vLightmapInfos\", 2), this._uniformBuffer.addUniform(\"vSpecularInfos\", 2), this._uniformBuffer.addUniform(\"vBumpInfos\", 3), this._uniformBuffer.addUniform(\"diffuseMatrix\", 16), this._uniformBuffer.addUniform(\"ambientMatrix\", 16), this._uniformBuffer.addUniform(\"opacityMatrix\", 16), this._uniformBuffer.addUniform(\"reflectionMatrix\", 16), this._uniformBuffer.addUniform(\"emissiveMatrix\", 16), this._uniformBuffer.addUniform(\"lightmapMatrix\", 16), this._uniformBuffer.addUniform(\"specularMatrix\", 16), this._uniformBuffer.addUniform(\"bumpMatrix\", 16), this._uniformBuffer.addUniform(\"vTangentSpaceParams\", 2), this._uniformBuffer.addUniform(\"refractionMatrix\", 16), this._uniformBuffer.addUniform(\"vRefractionInfos\", 4), this._uniformBuffer.addUniform(\"vSpecularColor\", 4), this._uniformBuffer.addUniform(\"vEmissiveColor\", 3), this._uniformBuffer.addUniform(\"vDiffuseColor\", 4), this._uniformBuffer.addUniform(\"pointSize\", 1), this._uniformBuffer.create();\n      }, f.prototype.unbind = function () {\n        if (this._activeEffect) {\n          var e = !1;\n          this._reflectionTexture && this._reflectionTexture.isRenderTarget && (this._activeEffect.setTexture(\"reflection2DSampler\", null), e = !0), this._refractionTexture && this._refractionTexture.isRenderTarget && (this._activeEffect.setTexture(\"refraction2DSampler\", null), e = !0), e && this._markAllSubMeshesAsTexturesDirty();\n        }\n\n        r.prototype.unbind.call(this);\n      }, f.prototype.bindForSubMesh = function (e, t, i) {\n        var r = this.getScene(),\n            n = i._materialDefines;\n\n        if (n) {\n          var o = i.effect;\n\n          if (o) {\n            this._activeEffect = o, this.bindOnlyWorldMatrix(e), n.OBJECTSPACE_NORMALMAP && (e.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix));\n\n            var s = this._mustRebind(r, o, t.visibility);\n\n            if (p.MaterialHelper.BindBonesParameters(t, o), s) {\n              if (this._uniformBuffer.bindToEffect(o, \"Material\"), this.bindViewProjection(o), !this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\n                if (f.FresnelEnabled && n.FRESNEL && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (this._uniformBuffer.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power), this._uniformBuffer.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && this._uniformBuffer.updateColor4(\"opacityParts\", new p.Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (this._uniformBuffer.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power), this._uniformBuffer.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (this._uniformBuffer.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power), this._uniformBuffer.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (this._uniformBuffer.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), this._uniformBuffer.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), r.texturesEnabled) {\n                  if (this._diffuseTexture && f.DiffuseTextureEnabled && (this._uniformBuffer.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level), p.MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, \"diffuse\"), this._diffuseTexture.hasAlpha && o.setFloat(\"alphaCutOff\", this.alphaCutOff)), this._ambientTexture && f.AmbientTextureEnabled && (this._uniformBuffer.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level), p.MaterialHelper.BindTextureMatrix(this._ambientTexture, this._uniformBuffer, \"ambient\")), this._opacityTexture && f.OpacityTextureEnabled && (this._uniformBuffer.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), p.MaterialHelper.BindTextureMatrix(this._opacityTexture, this._uniformBuffer, \"opacity\")), this._reflectionTexture && f.ReflectionTextureEnabled && (this._uniformBuffer.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness), this._uniformBuffer.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix()), this._reflectionTexture.boundingBoxSize)) {\n                    var a = this._reflectionTexture;\n                    this._uniformBuffer.updateVector3(\"vReflectionPosition\", a.boundingBoxPosition), this._uniformBuffer.updateVector3(\"vReflectionSize\", a.boundingBoxSize);\n                  }\n\n                  if (this._emissiveTexture && f.EmissiveTextureEnabled && (this._uniformBuffer.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), p.MaterialHelper.BindTextureMatrix(this._emissiveTexture, this._uniformBuffer, \"emissive\")), this._lightmapTexture && f.LightmapTextureEnabled && (this._uniformBuffer.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), p.MaterialHelper.BindTextureMatrix(this._lightmapTexture, this._uniformBuffer, \"lightmap\")), this._specularTexture && f.SpecularTextureEnabled && (this._uniformBuffer.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level), p.MaterialHelper.BindTextureMatrix(this._specularTexture, this._uniformBuffer, \"specular\")), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && f.BumpTextureEnabled && (this._uniformBuffer.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias), p.MaterialHelper.BindTextureMatrix(this._bumpTexture, this._uniformBuffer, \"bump\"), r._mirroredCameraPosition ? this._uniformBuffer.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : this._uniformBuffer.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)), this._refractionTexture && f.RefractionTextureEnabled) {\n                    var l = 1;\n                    this._refractionTexture.isCube || (this._uniformBuffer.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix()), this._refractionTexture.depth && (l = this._refractionTexture.depth)), this._uniformBuffer.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, l, this.invertRefractionY ? -1 : 1);\n                  }\n                }\n\n                this.pointsCloud && this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize), n.SPECULARTERM && this._uniformBuffer.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower), this._uniformBuffer.updateColor3(\"vEmissiveColor\", this.emissiveColor), this._uniformBuffer.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * t.visibility);\n              }\n\n              if (r.texturesEnabled && (this._diffuseTexture && f.DiffuseTextureEnabled && o.setTexture(\"diffuseSampler\", this._diffuseTexture), this._ambientTexture && f.AmbientTextureEnabled && o.setTexture(\"ambientSampler\", this._ambientTexture), this._opacityTexture && f.OpacityTextureEnabled && o.setTexture(\"opacitySampler\", this._opacityTexture), this._reflectionTexture && f.ReflectionTextureEnabled && (this._reflectionTexture.isCube ? o.setTexture(\"reflectionCubeSampler\", this._reflectionTexture) : o.setTexture(\"reflection2DSampler\", this._reflectionTexture)), this._emissiveTexture && f.EmissiveTextureEnabled && o.setTexture(\"emissiveSampler\", this._emissiveTexture), this._lightmapTexture && f.LightmapTextureEnabled && o.setTexture(\"lightmapSampler\", this._lightmapTexture), this._specularTexture && f.SpecularTextureEnabled && o.setTexture(\"specularSampler\", this._specularTexture), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && f.BumpTextureEnabled && o.setTexture(\"bumpSampler\", this._bumpTexture), this._refractionTexture && f.RefractionTextureEnabled)) {\n                l = 1;\n                this._refractionTexture.isCube ? o.setTexture(\"refractionCubeSampler\", this._refractionTexture) : o.setTexture(\"refraction2DSampler\", this._refractionTexture);\n              }\n\n              p.MaterialHelper.BindClipPlane(o, r), r.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), p.MaterialHelper.BindEyePosition(o, r), o.setColor3(\"vAmbientColor\", this._globalAmbientColor);\n            }\n\n            !s && this.isFrozen || (r.lightsEnabled && !this._disableLighting && p.MaterialHelper.BindLights(r, t, o, n, this._maxSimultaneousLights), (r.fogEnabled && t.applyFog && r.fogMode !== p.Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture) && this.bindView(o), p.MaterialHelper.BindFogParameters(r, t, o), n.NUM_MORPH_INFLUENCERS && p.MaterialHelper.BindMorphTargetParameters(t, o), p.MaterialHelper.BindLogDepth(n, o, r), this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._activeEffect)), this._uniformBuffer.update(), this._afterBind(t, this._activeEffect);\n          }\n        }\n      }, f.prototype.getAnimatables = function () {\n        var e = [];\n        return this._diffuseTexture && this._diffuseTexture.animations && 0 < this._diffuseTexture.animations.length && e.push(this._diffuseTexture), this._ambientTexture && this._ambientTexture.animations && 0 < this._ambientTexture.animations.length && e.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && 0 < this._opacityTexture.animations.length && e.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && 0 < this._reflectionTexture.animations.length && e.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && 0 < this._emissiveTexture.animations.length && e.push(this._emissiveTexture), this._specularTexture && this._specularTexture.animations && 0 < this._specularTexture.animations.length && e.push(this._specularTexture), this._bumpTexture && this._bumpTexture.animations && 0 < this._bumpTexture.animations.length && e.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && 0 < this._lightmapTexture.animations.length && e.push(this._lightmapTexture), this._refractionTexture && this._refractionTexture.animations && 0 < this._refractionTexture.animations.length && e.push(this._refractionTexture), e;\n      }, f.prototype.getActiveTextures = function () {\n        var e = r.prototype.getActiveTextures.call(this);\n        return this._diffuseTexture && e.push(this._diffuseTexture), this._ambientTexture && e.push(this._ambientTexture), this._opacityTexture && e.push(this._opacityTexture), this._reflectionTexture && e.push(this._reflectionTexture), this._emissiveTexture && e.push(this._emissiveTexture), this._specularTexture && e.push(this._specularTexture), this._bumpTexture && e.push(this._bumpTexture), this._lightmapTexture && e.push(this._lightmapTexture), this._refractionTexture && e.push(this._refractionTexture), e;\n      }, f.prototype.hasTexture = function (e) {\n        return !!r.prototype.hasTexture.call(this, e) || this._diffuseTexture === e || this._ambientTexture === e || this._opacityTexture === e || this._reflectionTexture === e || this._emissiveTexture === e || this._specularTexture === e || this._bumpTexture === e || this._lightmapTexture === e || this._refractionTexture === e;\n      }, f.prototype.dispose = function (e, t) {\n        t && (this._diffuseTexture && this._diffuseTexture.dispose(), this._ambientTexture && this._ambientTexture.dispose(), this._opacityTexture && this._opacityTexture.dispose(), this._reflectionTexture && this._reflectionTexture.dispose(), this._emissiveTexture && this._emissiveTexture.dispose(), this._specularTexture && this._specularTexture.dispose(), this._bumpTexture && this._bumpTexture.dispose(), this._lightmapTexture && this._lightmapTexture.dispose(), this._refractionTexture && this._refractionTexture.dispose()), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), r.prototype.dispose.call(this, e, t);\n      }, f.prototype.clone = function (e) {\n        var t = this,\n            i = p.SerializationHelper.Clone(function () {\n          return new f(e, t.getScene());\n        }, this);\n        return i.name = e, i.id = e, i;\n      }, f.prototype.serialize = function () {\n        return p.SerializationHelper.Serialize(this);\n      }, f.Parse = function (e, t, i) {\n        return p.SerializationHelper.Parse(function () {\n          return new f(e.name, t);\n        }, e, t, i);\n      }, Object.defineProperty(f, \"DiffuseTextureEnabled\", {\n        get: function () {\n          return f._DiffuseTextureEnabled;\n        },\n        set: function (e) {\n          f._DiffuseTextureEnabled !== e && (f._DiffuseTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"AmbientTextureEnabled\", {\n        get: function () {\n          return f._AmbientTextureEnabled;\n        },\n        set: function (e) {\n          f._AmbientTextureEnabled !== e && (f._AmbientTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"OpacityTextureEnabled\", {\n        get: function () {\n          return f._OpacityTextureEnabled;\n        },\n        set: function (e) {\n          f._OpacityTextureEnabled !== e && (f._OpacityTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"ReflectionTextureEnabled\", {\n        get: function () {\n          return f._ReflectionTextureEnabled;\n        },\n        set: function (e) {\n          f._ReflectionTextureEnabled !== e && (f._ReflectionTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"EmissiveTextureEnabled\", {\n        get: function () {\n          return f._EmissiveTextureEnabled;\n        },\n        set: function (e) {\n          f._EmissiveTextureEnabled !== e && (f._EmissiveTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"SpecularTextureEnabled\", {\n        get: function () {\n          return f._SpecularTextureEnabled;\n        },\n        set: function (e) {\n          f._SpecularTextureEnabled !== e && (f._SpecularTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"BumpTextureEnabled\", {\n        get: function () {\n          return f._BumpTextureEnabled;\n        },\n        set: function (e) {\n          f._BumpTextureEnabled !== e && (f._BumpTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"LightmapTextureEnabled\", {\n        get: function () {\n          return f._LightmapTextureEnabled;\n        },\n        set: function (e) {\n          f._LightmapTextureEnabled !== e && (f._LightmapTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"RefractionTextureEnabled\", {\n        get: function () {\n          return f._RefractionTextureEnabled;\n        },\n        set: function (e) {\n          f._RefractionTextureEnabled !== e && (f._RefractionTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"ColorGradingTextureEnabled\", {\n        get: function () {\n          return f._ColorGradingTextureEnabled;\n        },\n        set: function (e) {\n          f._ColorGradingTextureEnabled !== e && (f._ColorGradingTextureEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.TextureDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(f, \"FresnelEnabled\", {\n        get: function () {\n          return f._FresnelEnabled;\n        },\n        set: function (e) {\n          f._FresnelEnabled !== e && (f._FresnelEnabled = e, p.Engine.MarkAllMaterialsAsDirty(p.Material.FresnelDirtyFlag));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), f._DiffuseTextureEnabled = !0, f._AmbientTextureEnabled = !0, f._OpacityTextureEnabled = !0, f._ReflectionTextureEnabled = !0, f._EmissiveTextureEnabled = !0, f._SpecularTextureEnabled = !0, f._BumpTextureEnabled = !0, f._LightmapTextureEnabled = !0, f._RefractionTextureEnabled = !0, f._ColorGradingTextureEnabled = !0, f._FresnelEnabled = !0, b([p.serializeAsTexture(\"diffuseTexture\")], f.prototype, \"_diffuseTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], f.prototype, \"diffuseTexture\", void 0), b([p.serializeAsTexture(\"ambientTexture\")], f.prototype, \"_ambientTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"ambientTexture\", void 0), b([p.serializeAsTexture(\"opacityTexture\")], f.prototype, \"_opacityTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], f.prototype, \"opacityTexture\", void 0), b([p.serializeAsTexture(\"reflectionTexture\")], f.prototype, \"_reflectionTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"reflectionTexture\", void 0), b([p.serializeAsTexture(\"emissiveTexture\")], f.prototype, \"_emissiveTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"emissiveTexture\", void 0), b([p.serializeAsTexture(\"specularTexture\")], f.prototype, \"_specularTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"specularTexture\", void 0), b([p.serializeAsTexture(\"bumpTexture\")], f.prototype, \"_bumpTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"bumpTexture\", void 0), b([p.serializeAsTexture(\"lightmapTexture\")], f.prototype, \"_lightmapTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"lightmapTexture\", void 0), b([p.serializeAsTexture(\"refractionTexture\")], f.prototype, \"_refractionTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"refractionTexture\", void 0), b([p.serializeAsColor3(\"ambient\")], f.prototype, \"ambientColor\", void 0), b([p.serializeAsColor3(\"diffuse\")], f.prototype, \"diffuseColor\", void 0), b([p.serializeAsColor3(\"specular\")], f.prototype, \"specularColor\", void 0), b([p.serializeAsColor3(\"emissive\")], f.prototype, \"emissiveColor\", void 0), b([p.serialize()], f.prototype, \"specularPower\", void 0), b([p.serialize(\"useAlphaFromDiffuseTexture\")], f.prototype, \"_useAlphaFromDiffuseTexture\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useAlphaFromDiffuseTexture\", void 0), b([p.serialize(\"useEmissiveAsIllumination\")], f.prototype, \"_useEmissiveAsIllumination\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useEmissiveAsIllumination\", void 0), b([p.serialize(\"linkEmissiveWithDiffuse\")], f.prototype, \"_linkEmissiveWithDiffuse\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"linkEmissiveWithDiffuse\", void 0), b([p.serialize(\"useSpecularOverAlpha\")], f.prototype, \"_useSpecularOverAlpha\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useSpecularOverAlpha\", void 0), b([p.serialize(\"useReflectionOverAlpha\")], f.prototype, \"_useReflectionOverAlpha\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useReflectionOverAlpha\", void 0), b([p.serialize(\"disableLighting\")], f.prototype, \"_disableLighting\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], f.prototype, \"disableLighting\", void 0), b([p.serialize(\"useObjectSpaceNormalMap\")], f.prototype, \"_useObjectSpaceNormalMap\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useObjectSpaceNormalMap\", void 0), b([p.serialize(\"useParallax\")], f.prototype, \"_useParallax\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useParallax\", void 0), b([p.serialize(\"useParallaxOcclusion\")], f.prototype, \"_useParallaxOcclusion\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useParallaxOcclusion\", void 0), b([p.serialize()], f.prototype, \"parallaxScaleBias\", void 0), b([p.serialize(\"roughness\")], f.prototype, \"_roughness\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"roughness\", void 0), b([p.serialize()], f.prototype, \"indexOfRefraction\", void 0), b([p.serialize()], f.prototype, \"invertRefractionY\", void 0), b([p.serialize()], f.prototype, \"alphaCutOff\", void 0), b([p.serialize(\"useLightmapAsShadowmap\")], f.prototype, \"_useLightmapAsShadowmap\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useLightmapAsShadowmap\", void 0), b([p.serializeAsFresnelParameters(\"diffuseFresnelParameters\")], f.prototype, \"_diffuseFresnelParameters\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], f.prototype, \"diffuseFresnelParameters\", void 0), b([p.serializeAsFresnelParameters(\"opacityFresnelParameters\")], f.prototype, \"_opacityFresnelParameters\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")], f.prototype, \"opacityFresnelParameters\", void 0), b([p.serializeAsFresnelParameters(\"reflectionFresnelParameters\")], f.prototype, \"_reflectionFresnelParameters\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], f.prototype, \"reflectionFresnelParameters\", void 0), b([p.serializeAsFresnelParameters(\"refractionFresnelParameters\")], f.prototype, \"_refractionFresnelParameters\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], f.prototype, \"refractionFresnelParameters\", void 0), b([p.serializeAsFresnelParameters(\"emissiveFresnelParameters\")], f.prototype, \"_emissiveFresnelParameters\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], f.prototype, \"emissiveFresnelParameters\", void 0), b([p.serialize(\"useReflectionFresnelFromSpecular\")], f.prototype, \"_useReflectionFresnelFromSpecular\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")], f.prototype, \"useReflectionFresnelFromSpecular\", void 0), b([p.serialize(\"useGlossinessFromSpecularMapAlpha\")], f.prototype, \"_useGlossinessFromSpecularMapAlpha\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"useGlossinessFromSpecularMapAlpha\", void 0), b([p.serialize(\"maxSimultaneousLights\")], f.prototype, \"_maxSimultaneousLights\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], f.prototype, \"maxSimultaneousLights\", void 0), b([p.serialize(\"invertNormalMapX\")], f.prototype, \"_invertNormalMapX\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"invertNormalMapX\", void 0), b([p.serialize(\"invertNormalMapY\")], f.prototype, \"_invertNormalMapY\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"invertNormalMapY\", void 0), b([p.serialize(\"twoSidedLighting\")], f.prototype, \"_twoSidedLighting\", void 0), b([p.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], f.prototype, \"twoSidedLighting\", void 0), b([p.serialize()], f.prototype, \"useLogarithmicDepth\", null), f;\n    }(p.PushMaterial);\n\n    p.StandardMaterial = e;\n  }($a || ($a = {})), function (n) {\n    var e = function () {\n      function i() {\n        this.x = n.Vector3.Zero(), this.y = n.Vector3.Zero(), this.z = n.Vector3.Zero(), this.xx = n.Vector3.Zero(), this.yy = n.Vector3.Zero(), this.zz = n.Vector3.Zero(), this.xy = n.Vector3.Zero(), this.yz = n.Vector3.Zero(), this.zx = n.Vector3.Zero();\n      }\n\n      return i.prototype.addAmbient = function (e) {\n        var t = new n.Vector3(e.r, e.g, e.b);\n        this.xx = this.xx.add(t), this.yy = this.yy.add(t), this.zz = this.zz.add(t);\n      }, i.prototype.scale = function (e) {\n        this.x = this.x.scale(e), this.y = this.y.scale(e), this.z = this.z.scale(e), this.xx = this.xx.scale(e), this.yy = this.yy.scale(e), this.zz = this.zz.scale(e), this.yz = this.yz.scale(e), this.zx = this.zx.scale(e), this.xy = this.xy.scale(e);\n      }, i.FromHarmonics = function (e) {\n        var t = new i();\n        return t.x = e.l11.scale(1.02333), t.y = e.l1_1.scale(1.02333), t.z = e.l10.scale(1.02333), t.xx = e.l00.scale(.886277).subtract(e.l20.scale(.247708)).add(e.lL22.scale(.429043)), t.yy = e.l00.scale(.886277).subtract(e.l20.scale(.247708)).subtract(e.lL22.scale(.429043)), t.zz = e.l00.scale(.886277).add(e.l20.scale(.495417)), t.yz = e.l2_1.scale(.858086), t.zx = e.l21.scale(.858086), t.xy = e.l2_2.scale(.858086), t.scale(1 / Math.PI), t;\n      }, i.FromArray = function (e) {\n        var t = new i();\n        return n.Vector3.FromArrayToRef(e[0], 0, t.x), n.Vector3.FromArrayToRef(e[1], 0, t.y), n.Vector3.FromArrayToRef(e[2], 0, t.z), n.Vector3.FromArrayToRef(e[3], 0, t.xx), n.Vector3.FromArrayToRef(e[4], 0, t.yy), n.Vector3.FromArrayToRef(e[5], 0, t.zz), n.Vector3.FromArrayToRef(e[6], 0, t.yz), n.Vector3.FromArrayToRef(e[7], 0, t.zx), n.Vector3.FromArrayToRef(e[8], 0, t.xy), t;\n      }, i;\n    }();\n\n    n.SphericalPolynomial = e;\n\n    var t = function () {\n      function i() {\n        this.l00 = n.Vector3.Zero(), this.l1_1 = n.Vector3.Zero(), this.l10 = n.Vector3.Zero(), this.l11 = n.Vector3.Zero(), this.l2_2 = n.Vector3.Zero(), this.l2_1 = n.Vector3.Zero(), this.l20 = n.Vector3.Zero(), this.l21 = n.Vector3.Zero(), this.lL22 = n.Vector3.Zero();\n      }\n\n      return i.prototype.addLight = function (e, t, i) {\n        var r = new n.Vector3(t.r, t.g, t.b).scale(i);\n        this.l00 = this.l00.add(r.scale(.282095)), this.l1_1 = this.l1_1.add(r.scale(.488603 * e.y)), this.l10 = this.l10.add(r.scale(.488603 * e.z)), this.l11 = this.l11.add(r.scale(.488603 * e.x)), this.l2_2 = this.l2_2.add(r.scale(1.092548 * e.x * e.y)), this.l2_1 = this.l2_1.add(r.scale(1.092548 * e.y * e.z)), this.l21 = this.l21.add(r.scale(1.092548 * e.x * e.z)), this.l20 = this.l20.add(r.scale(.315392 * (3 * e.z * e.z - 1))), this.lL22 = this.lL22.add(r.scale(.546274 * (e.x * e.x - e.y * e.y)));\n      }, i.prototype.scale = function (e) {\n        this.l00 = this.l00.scale(e), this.l1_1 = this.l1_1.scale(e), this.l10 = this.l10.scale(e), this.l11 = this.l11.scale(e), this.l2_2 = this.l2_2.scale(e), this.l2_1 = this.l2_1.scale(e), this.l20 = this.l20.scale(e), this.l21 = this.l21.scale(e), this.lL22 = this.lL22.scale(e);\n      }, i.prototype.convertIncidentRadianceToIrradiance = function () {\n        this.l00 = this.l00.scale(3.141593), this.l1_1 = this.l1_1.scale(2.094395), this.l10 = this.l10.scale(2.094395), this.l11 = this.l11.scale(2.094395), this.l2_2 = this.l2_2.scale(.785398), this.l2_1 = this.l2_1.scale(.785398), this.l20 = this.l20.scale(.785398), this.l21 = this.l21.scale(.785398), this.lL22 = this.lL22.scale(.785398);\n      }, i.prototype.convertIrradianceToLambertianRadiance = function () {\n        this.scale(1 / Math.PI);\n      }, i.FromPolynomial = function (e) {\n        var t = new i();\n        return t.l00 = e.xx.scale(.376127).add(e.yy.scale(.376127)).add(e.zz.scale(.376126)), t.l1_1 = e.y.scale(.977204), t.l10 = e.z.scale(.977204), t.l11 = e.x.scale(.977204), t.l2_2 = e.xy.scale(1.16538), t.l2_1 = e.yz.scale(1.16538), t.l20 = e.zz.scale(1.34567).subtract(e.xx.scale(.672834)).subtract(e.yy.scale(.672834)), t.l21 = e.zx.scale(1.16538), t.lL22 = e.xx.scale(1.16538).subtract(e.yy.scale(1.16538)), t.scale(Math.PI), t;\n      }, i.FromArray = function (e) {\n        var t = new i();\n        return n.Vector3.FromArrayToRef(e[0], 0, t.l00), n.Vector3.FromArrayToRef(e[1], 0, t.l1_1), n.Vector3.FromArrayToRef(e[2], 0, t.l10), n.Vector3.FromArrayToRef(e[3], 0, t.l11), n.Vector3.FromArrayToRef(e[4], 0, t.l2_2), n.Vector3.FromArrayToRef(e[5], 0, t.l2_1), n.Vector3.FromArrayToRef(e[6], 0, t.l20), n.Vector3.FromArrayToRef(e[7], 0, t.l21), n.Vector3.FromArrayToRef(e[8], 0, t.lL22), t;\n      }, i;\n    }();\n\n    n.SphericalHarmonics = t;\n  }($a || ($a = {})), me = $a || ($a = {}), ge = function (e, t, i, r) {\n    this.name = e, this.worldAxisForNormal = t, this.worldAxisForFileX = i, this.worldAxisForFileY = r;\n  }, ve = function () {\n    function e() {}\n\n    return e.ConvertCubeMapTextureToSphericalPolynomial = function (e) {\n      if (!e.isCube) return null;\n      var t,\n          i,\n          r = e.getSize().width,\n          n = e.readPixels(0),\n          o = e.readPixels(1);\n      e.isRenderTarget ? (t = e.readPixels(3), i = e.readPixels(2)) : (t = e.readPixels(2), i = e.readPixels(3));\n      var s = e.readPixels(4),\n          a = e.readPixels(5),\n          l = e.gammaSpace,\n          c = me.Engine.TEXTUREFORMAT_RGBA,\n          h = me.Engine.TEXTURETYPE_UNSIGNED_INT;\n      e.textureType && e.textureType !== me.Engine.TEXTURETYPE_UNSIGNED_INT && (h = me.Engine.TEXTURETYPE_FLOAT);\n      var u = {\n        size: r,\n        right: n,\n        left: o,\n        up: t,\n        down: i,\n        front: s,\n        back: a,\n        format: c,\n        type: h,\n        gammaSpace: l\n      };\n      return this.ConvertCubeMapToSphericalPolynomial(u);\n    }, e.ConvertCubeMapToSphericalPolynomial = function (e) {\n      for (var t = new me.SphericalHarmonics(), i = 0, r = 2 / e.size, n = r, o = .5 * r - 1, s = 0; s < 6; s++) for (var a = this.FileFaces[s], l = e[a.name], c = o, h = e.format === me.Engine.TEXTUREFORMAT_RGBA ? 4 : 3, u = 0; u < e.size; u++) {\n        for (var d = o, f = 0; f < e.size; f++) {\n          var p = a.worldAxisForFileX.scale(d).add(a.worldAxisForFileY.scale(c)).add(a.worldAxisForNormal);\n          p.normalize();\n\n          var _ = Math.pow(1 + d * d + c * c, -1.5),\n              m = l[u * e.size * h + f * h + 0],\n              g = l[u * e.size * h + f * h + 1],\n              v = l[u * e.size * h + f * h + 2];\n\n          e.type === me.Engine.TEXTURETYPE_UNSIGNED_INT && (m /= 255, g /= 255, v /= 255), e.gammaSpace && (m = Math.pow(me.Scalar.Clamp(m), me.ToLinearSpace), g = Math.pow(me.Scalar.Clamp(g), me.ToLinearSpace), v = Math.pow(me.Scalar.Clamp(v), me.ToLinearSpace));\n          var y = new me.Color3(m, g, v);\n          t.addLight(p, y, _), i += _, d += r;\n        }\n\n        c += n;\n      }\n\n      var b = 6 * (4 * Math.PI) / 6 / i;\n      return t.scale(b), t.convertIncidentRadianceToIrradiance(), t.convertIrradianceToLambertianRadiance(), me.SphericalPolynomial.FromHarmonics(t);\n    }, e.FileFaces = [new ge(\"right\", new me.Vector3(1, 0, 0), new me.Vector3(0, 0, -1), new me.Vector3(0, -1, 0)), new ge(\"left\", new me.Vector3(-1, 0, 0), new me.Vector3(0, 0, 1), new me.Vector3(0, -1, 0)), new ge(\"up\", new me.Vector3(0, 1, 0), new me.Vector3(1, 0, 0), new me.Vector3(0, 0, 1)), new ge(\"down\", new me.Vector3(0, -1, 0), new me.Vector3(1, 0, 0), new me.Vector3(0, 0, -1)), new ge(\"front\", new me.Vector3(0, 0, 1), new me.Vector3(1, 0, 0), new me.Vector3(0, -1, 0)), new ge(\"back\", new me.Vector3(0, 0, -1), new me.Vector3(-1, 0, 0), new me.Vector3(0, -1, 0))], e;\n  }(), me.CubeMapToSphericalPolynomialTools = ve, ye = $a || ($a = {}), be = function (t) {\n    function e() {\n      var e = t.call(this) || this;\n      return e.PBR = !0, e.MAINUV1 = !1, e.MAINUV2 = !1, e.UV1 = !1, e.UV2 = !1, e.ALBEDO = !1, e.ALBEDODIRECTUV = 0, e.VERTEXCOLOR = !1, e.AMBIENT = !1, e.AMBIENTDIRECTUV = 0, e.AMBIENTINGRAYSCALE = !1, e.OPACITY = !1, e.VERTEXALPHA = !1, e.OPACITYDIRECTUV = 0, e.OPACITYRGB = !1, e.ALPHATEST = !1, e.DEPTHPREPASS = !1, e.ALPHABLEND = !1, e.ALPHAFROMALBEDO = !1, e.ALPHATESTVALUE = \"0.5\", e.SPECULAROVERALPHA = !1, e.RADIANCEOVERALPHA = !1, e.ALPHAFRESNEL = !1, e.LINEARALPHAFRESNEL = !1, e.PREMULTIPLYALPHA = !1, e.EMISSIVE = !1, e.EMISSIVEDIRECTUV = 0, e.REFLECTIVITY = !1, e.REFLECTIVITYDIRECTUV = 0, e.SPECULARTERM = !1, e.MICROSURFACEFROMREFLECTIVITYMAP = !1, e.MICROSURFACEAUTOMATIC = !1, e.LODBASEDMICROSFURACE = !1, e.MICROSURFACEMAP = !1, e.MICROSURFACEMAPDIRECTUV = 0, e.METALLICWORKFLOW = !1, e.ROUGHNESSSTOREINMETALMAPALPHA = !1, e.ROUGHNESSSTOREINMETALMAPGREEN = !1, e.METALLNESSSTOREINMETALMAPBLUE = !1, e.AOSTOREINMETALMAPRED = !1, e.ENVIRONMENTBRDF = !1, e.NORMAL = !1, e.TANGENT = !1, e.BUMP = !1, e.BUMPDIRECTUV = 0, e.OBJECTSPACE_NORMALMAP = !1, e.PARALLAX = !1, e.PARALLAXOCCLUSION = !1, e.NORMALXYSCALE = !0, e.LIGHTMAP = !1, e.LIGHTMAPDIRECTUV = 0, e.USELIGHTMAPASSHADOWMAP = !1, e.GAMMALIGHTMAP = !1, e.REFLECTION = !1, e.REFLECTIONMAP_3D = !1, e.REFLECTIONMAP_SPHERICAL = !1, e.REFLECTIONMAP_PLANAR = !1, e.REFLECTIONMAP_CUBIC = !1, e.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, e.REFLECTIONMAP_PROJECTION = !1, e.REFLECTIONMAP_SKYBOX = !1, e.REFLECTIONMAP_SKYBOX_TRANSFORMED = !1, e.REFLECTIONMAP_EXPLICIT = !1, e.REFLECTIONMAP_EQUIRECTANGULAR = !1, e.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, e.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, e.INVERTCUBICMAP = !1, e.USESPHERICALFROMREFLECTIONMAP = !1, e.USESPHERICALINVERTEX = !1, e.REFLECTIONMAP_OPPOSITEZ = !1, e.LODINREFLECTIONALPHA = !1, e.GAMMAREFLECTION = !1, e.RGBDREFLECTION = !1, e.RADIANCEOCCLUSION = !1, e.HORIZONOCCLUSION = !1, e.REFRACTION = !1, e.REFRACTIONMAP_3D = !1, e.REFRACTIONMAP_OPPOSITEZ = !1, e.LODINREFRACTIONALPHA = !1, e.GAMMAREFRACTION = !1, e.RGBDREFRACTION = !1, e.LINKREFRACTIONTOTRANSPARENCY = !1, e.INSTANCES = !1, e.NUM_BONE_INFLUENCERS = 0, e.BonesPerMesh = 0, e.NONUNIFORMSCALING = !1, e.MORPHTARGETS = !1, e.MORPHTARGETS_NORMAL = !1, e.MORPHTARGETS_TANGENT = !1, e.NUM_MORPH_INFLUENCERS = 0, e.IMAGEPROCESSING = !1, e.VIGNETTE = !1, e.VIGNETTEBLENDMODEMULTIPLY = !1, e.VIGNETTEBLENDMODEOPAQUE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = !1, e.SAMPLER3DBGRMAP = !1, e.IMAGEPROCESSINGPOSTPROCESS = !1, e.EXPOSURE = !1, e.USEPHYSICALLIGHTFALLOFF = !1, e.USEGLTFLIGHTFALLOFF = !1, e.TWOSIDEDLIGHTING = !1, e.SHADOWFLOAT = !1, e.CLIPPLANE = !1, e.CLIPPLANE2 = !1, e.CLIPPLANE3 = !1, e.CLIPPLANE4 = !1, e.POINTSIZE = !1, e.FOG = !1, e.LOGARITHMICDEPTH = !1, e.FORCENORMALFORWARD = !1, e.SPECULARAA = !1, e.UNLIT = !1, e.rebuild(), e;\n    }\n\n    return T(e, t), e.prototype.reset = function () {\n      t.prototype.reset.call(this), this.ALPHATESTVALUE = \"0.5\", this.PBR = !0;\n    }, e;\n  }(ye.MaterialDefines), Te = function (r) {\n    function p(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i._directIntensity = 1, i._emissiveIntensity = 1, i._environmentIntensity = 1, i._specularIntensity = 1, i._lightingInfos = new ye.Vector4(i._directIntensity, i._emissiveIntensity, i._environmentIntensity, i._specularIntensity), i._disableBumpMap = !1, i._ambientTextureStrength = 1, i._ambientTextureImpactOnAnalyticalLights = ye.PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS, i._ambientColor = new ye.Color3(0, 0, 0), i._albedoColor = new ye.Color3(1, 1, 1), i._reflectivityColor = new ye.Color3(1, 1, 1), i._reflectionColor = new ye.Color3(1, 1, 1), i._emissiveColor = new ye.Color3(0, 0, 0), i._microSurface = .9, i._indexOfRefraction = .66, i._invertRefractionY = !1, i._linkRefractionWithTransparency = !1, i._useLightmapAsShadowmap = !1, i._useHorizonOcclusion = !0, i._useRadianceOcclusion = !0, i._useAlphaFromAlbedoTexture = !1, i._useSpecularOverAlpha = !0, i._useMicroSurfaceFromReflectivityMapAlpha = !1, i._useRoughnessFromMetallicTextureAlpha = !0, i._useRoughnessFromMetallicTextureGreen = !1, i._useMetallnessFromMetallicTextureBlue = !1, i._useAmbientOcclusionFromMetallicTextureRed = !1, i._useAmbientInGrayScale = !1, i._useAutoMicroSurfaceFromReflectivityMap = !1, i._lightFalloff = p.LIGHTFALLOFF_PHYSICAL, i._useRadianceOverAlpha = !0, i._useObjectSpaceNormalMap = !1, i._useParallax = !1, i._useParallaxOcclusion = !1, i._parallaxScaleBias = .05, i._disableLighting = !1, i._maxSimultaneousLights = 4, i._invertNormalMapX = !1, i._invertNormalMapY = !1, i._twoSidedLighting = !1, i._alphaCutOff = .4, i._forceAlphaTest = !1, i._useAlphaFresnel = !1, i._useLinearAlphaFresnel = !1, i._transparencyMode = null, i._environmentBRDFTexture = null, i._forceIrradianceInFragment = !1, i._forceNormalForward = !1, i._enableSpecularAntiAliasing = !1, i._renderTargets = new ye.SmartArray(16), i._globalAmbientColor = new ye.Color3(0, 0, 0), i._unlit = !1, i._attachImageProcessingConfiguration(null), i.getRenderTargetTextures = function () {\n        return i._renderTargets.reset(), ye.StandardMaterial.ReflectionTextureEnabled && i._reflectionTexture && i._reflectionTexture.isRenderTarget && i._renderTargets.push(i._reflectionTexture), ye.StandardMaterial.RefractionTextureEnabled && i._refractionTexture && i._refractionTexture.isRenderTarget && i._renderTargets.push(i._refractionTexture), i._renderTargets;\n      }, i._environmentBRDFTexture = ye.TextureTools.GetEnvironmentBRDFTexture(t), i;\n    }\n\n    return T(p, r), p.prototype._attachImageProcessingConfiguration = function (e) {\n      var t = this;\n      e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingConfiguration = e || this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function (e) {\n        t._markAllSubMeshesAsImageProcessingDirty();\n      })));\n    }, Object.defineProperty(p.prototype, \"hasRenderTargetTextures\", {\n      get: function () {\n        return !!(ye.StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) || !!(ye.StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), p.prototype.getClassName = function () {\n      return \"PBRBaseMaterial\";\n    }, Object.defineProperty(p.prototype, \"useLogarithmicDepth\", {\n      get: function () {\n        return this._useLogarithmicDepth;\n      },\n      set: function (e) {\n        this._useLogarithmicDepth = e && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"transparencyMode\", {\n      get: function () {\n        return this._transparencyMode;\n      },\n      set: function (e) {\n        this._transparencyMode !== e && (this._transparencyMode = e, this._forceAlphaTest = e === ye.PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND, this._markAllSubMeshesAsTexturesAndMiscDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"_disableAlphaBlending\", {\n      get: function () {\n        return this._linkRefractionWithTransparency || this._transparencyMode === ye.PBRMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === ye.PBRMaterial.PBRMATERIAL_ALPHATEST;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), p.prototype.needAlphaBlending = function () {\n      return !this._disableAlphaBlending && (this.alpha < 1 || null != this._opacityTexture || this._shouldUseAlphaFromAlbedoTexture());\n    }, p.prototype.needAlphaBlendingForMesh = function (e) {\n      return !this._disableAlphaBlending && r.prototype.needAlphaBlendingForMesh.call(this, e);\n    }, p.prototype.needAlphaTesting = function () {\n      return !!this._forceAlphaTest || !this._linkRefractionWithTransparency && null != this._albedoTexture && this._albedoTexture.hasAlpha && (null == this._transparencyMode || this._transparencyMode === ye.PBRMaterial.PBRMATERIAL_ALPHATEST);\n    }, p.prototype._shouldUseAlphaFromAlbedoTexture = function () {\n      return null != this._albedoTexture && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== ye.PBRMaterial.PBRMATERIAL_OPAQUE;\n    }, p.prototype.getAlphaTestTexture = function () {\n      return this._albedoTexture;\n    }, p.prototype.isReadyForSubMesh = function (e, t, i) {\n      if (t.effect && this.isFrozen && this._wasPreviouslyReady) return !0;\n      t._materialDefines || (t._materialDefines = new be());\n      var r = t._materialDefines;\n      if (!this.checkReadyOnEveryCall && t.effect && r._renderId === this.getScene().getRenderId()) return !0;\n      var n = this.getScene(),\n          o = n.getEngine();\n\n      if (r._areTexturesDirty && n.texturesEnabled) {\n        if (this._albedoTexture && ye.StandardMaterial.DiffuseTextureEnabled && !this._albedoTexture.isReadyOrNotBlocking()) return !1;\n        if (this._ambientTexture && ye.StandardMaterial.AmbientTextureEnabled && !this._ambientTexture.isReadyOrNotBlocking()) return !1;\n        if (this._opacityTexture && ye.StandardMaterial.OpacityTextureEnabled && !this._opacityTexture.isReadyOrNotBlocking()) return !1;\n\n        var s = this._getReflectionTexture();\n\n        if (s && ye.StandardMaterial.ReflectionTextureEnabled && !s.isReadyOrNotBlocking()) return !1;\n        if (this._lightmapTexture && ye.StandardMaterial.LightmapTextureEnabled && !this._lightmapTexture.isReadyOrNotBlocking()) return !1;\n        if (this._emissiveTexture && ye.StandardMaterial.EmissiveTextureEnabled && !this._emissiveTexture.isReadyOrNotBlocking()) return !1;\n\n        if (ye.StandardMaterial.SpecularTextureEnabled) {\n          if (this._metallicTexture) {\n            if (!this._metallicTexture.isReadyOrNotBlocking()) return !1;\n          } else if (this._reflectivityTexture && !this._reflectivityTexture.isReadyOrNotBlocking()) return !1;\n\n          if (this._microSurfaceTexture && !this._microSurfaceTexture.isReadyOrNotBlocking()) return !1;\n        }\n\n        if (o.getCaps().standardDerivatives && this._bumpTexture && ye.StandardMaterial.BumpTextureEnabled && !this._disableBumpMap && !this._bumpTexture.isReady()) return !1;\n\n        var a = this._getRefractionTexture();\n\n        if (a && ye.StandardMaterial.RefractionTextureEnabled && !a.isReadyOrNotBlocking()) return !1;\n        if (this._environmentBRDFTexture && ye.StandardMaterial.ReflectionTextureEnabled && !this._environmentBRDFTexture.isReady()) return !1;\n      }\n\n      if (r._areImageProcessingDirty && this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) return !1;\n      o.getCaps().standardDerivatives || e.isVerticesDataPresent(ye.VertexBuffer.NormalKind) || (e.createNormals(!0), ye.Tools.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + e.name));\n\n      var l = this._prepareEffect(e, r, this.onCompiled, this.onError, i);\n\n      return l && (n.resetCachedMaterial(), t.setEffect(l, r), this.buildUniformLayout()), !(!t.effect || !t.effect.isReady()) && (r._renderId = n.getRenderId(), this._wasPreviouslyReady = !0);\n    }, p.prototype.isMetallicWorkflow = function () {\n      return !(null == this._metallic && null == this._roughness && !this._metallicTexture);\n    }, p.prototype._prepareEffect = function (e, t, i, r, n, o) {\n      if (void 0 === i && (i = null), void 0 === r && (r = null), void 0 === n && (n = null), void 0 === o && (o = null), this._prepareDefines(e, t, n, o), !t.isDirty) return null;\n      t.markAsProcessed();\n      var s = this.getScene().getEngine(),\n          a = new ye.EffectFallbacks(),\n          l = 0;\n      t.USESPHERICALINVERTEX && a.addFallback(l++, \"USESPHERICALINVERTEX\"), t.FOG && a.addFallback(l, \"FOG\"), t.SPECULARAA && a.addFallback(l, \"SPECULARAA\"), t.POINTSIZE && a.addFallback(l, \"POINTSIZE\"), t.LOGARITHMICDEPTH && a.addFallback(l, \"LOGARITHMICDEPTH\"), t.PARALLAX && a.addFallback(l, \"PARALLAX\"), t.PARALLAXOCCLUSION && a.addFallback(l++, \"PARALLAXOCCLUSION\"), t.ENVIRONMENTBRDF && a.addFallback(l++, \"ENVIRONMENTBRDF\"), t.TANGENT && a.addFallback(l++, \"TANGENT\"), t.BUMP && a.addFallback(l++, \"BUMP\"), l = ye.MaterialHelper.HandleFallbacksForShadows(t, a, this._maxSimultaneousLights, l++), t.SPECULARTERM && a.addFallback(l++, \"SPECULARTERM\"), t.USESPHERICALFROMREFLECTIONMAP && a.addFallback(l++, \"USESPHERICALFROMREFLECTIONMAP\"), t.LIGHTMAP && a.addFallback(l++, \"LIGHTMAP\"), t.NORMAL && a.addFallback(l++, \"NORMAL\"), t.AMBIENT && a.addFallback(l++, \"AMBIENT\"), t.EMISSIVE && a.addFallback(l++, \"EMISSIVE\"), t.VERTEXCOLOR && a.addFallback(l++, \"VERTEXCOLOR\"), 0 < t.NUM_BONE_INFLUENCERS && a.addCPUSkinningFallback(l++, e), t.MORPHTARGETS && a.addFallback(l++, \"MORPHTARGETS\");\n      var c = [ye.VertexBuffer.PositionKind];\n      t.NORMAL && c.push(ye.VertexBuffer.NormalKind), t.TANGENT && c.push(ye.VertexBuffer.TangentKind), t.UV1 && c.push(ye.VertexBuffer.UVKind), t.UV2 && c.push(ye.VertexBuffer.UV2Kind), t.VERTEXCOLOR && c.push(ye.VertexBuffer.ColorKind), ye.MaterialHelper.PrepareAttributesForBones(c, e, t, a), ye.MaterialHelper.PrepareAttributesForInstances(c, t), ye.MaterialHelper.PrepareAttributesForMorphTargets(c, e, t);\n      var h = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vAlbedoColor\", \"vReflectivityColor\", \"vEmissiveColor\", \"vReflectionColor\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"vAlbedoInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vReflectionPosition\", \"vReflectionSize\", \"vEmissiveInfos\", \"vReflectivityInfos\", \"vMicroSurfaceSamplerInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\", \"mBones\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"albedoMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"reflectivityMatrix\", \"normalMatrix\", \"microSurfaceSamplerMatrix\", \"bumpMatrix\", \"lightmapMatrix\", \"refractionMatrix\", \"vLightingIntensity\", \"logarithmicDepthConstant\", \"vSphericalX\", \"vSphericalY\", \"vSphericalZ\", \"vSphericalXX\", \"vSphericalYY\", \"vSphericalZZ\", \"vSphericalXY\", \"vSphericalYZ\", \"vSphericalZX\", \"vReflectionMicrosurfaceInfos\", \"vRefractionMicrosurfaceInfos\", \"vTangentSpaceParams\"],\n          u = [\"albedoSampler\", \"reflectivitySampler\", \"ambientSampler\", \"emissiveSampler\", \"bumpSampler\", \"lightmapSampler\", \"opacitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\", \"microSurfaceSampler\", \"environmentBrdfSampler\"],\n          d = [\"Material\", \"Scene\"];\n      ye.ImageProcessingConfiguration && (ye.ImageProcessingConfiguration.PrepareUniforms(h, t), ye.ImageProcessingConfiguration.PrepareSamplers(u, t)), ye.MaterialHelper.PrepareUniformsAndSamplersList({\n        uniformsNames: h,\n        uniformBuffersNames: d,\n        samplers: u,\n        defines: t,\n        maxSimultaneousLights: this._maxSimultaneousLights\n      });\n      var f = t.toString();\n      return s.createEffect(\"pbr\", {\n        attributes: c,\n        uniformsNames: h,\n        uniformBuffersNames: d,\n        samplers: u,\n        defines: f,\n        fallbacks: a,\n        onCompiled: i,\n        onError: r,\n        indexParameters: {\n          maxSimultaneousLights: this._maxSimultaneousLights,\n          maxSimultaneousMorphTargets: t.NUM_MORPH_INFLUENCERS\n        }\n      }, s);\n    }, p.prototype._prepareDefines = function (e, t, i, r) {\n      void 0 === i && (i = null), void 0 === r && (r = null);\n      var n = this.getScene(),\n          o = n.getEngine();\n\n      if (ye.MaterialHelper.PrepareDefinesForLights(n, e, t, !0, this._maxSimultaneousLights, this._disableLighting), t._needNormals = !0, t.METALLICWORKFLOW = this.isMetallicWorkflow(), t._areTexturesDirty) {\n        if (t._needUVs = !1, n.texturesEnabled) {\n          n.getEngine().getCaps().textureLOD && (t.LODBASEDMICROSFURACE = !0), this._albedoTexture && ye.StandardMaterial.DiffuseTextureEnabled ? ye.MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, t, \"ALBEDO\") : t.ALBEDO = !1, this._ambientTexture && ye.StandardMaterial.AmbientTextureEnabled ? (ye.MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, t, \"AMBIENT\"), t.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale) : t.AMBIENT = !1, this._opacityTexture && ye.StandardMaterial.OpacityTextureEnabled ? (ye.MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, t, \"OPACITY\"), t.OPACITYRGB = this._opacityTexture.getAlphaFromRGB) : t.OPACITY = !1;\n\n          var s = this._getReflectionTexture();\n\n          if (s && ye.StandardMaterial.ReflectionTextureEnabled) {\n            switch (t.REFLECTION = !0, t.GAMMAREFLECTION = s.gammaSpace, t.RGBDREFLECTION = s.isRGBD, t.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !s.invertZ : s.invertZ, t.LODINREFLECTIONALPHA = s.lodLevelInAlpha, s.coordinatesMode === ye.Texture.INVCUBIC_MODE && (t.INVERTCUBICMAP = !0), t.REFLECTIONMAP_3D = s.isCube, s.coordinatesMode) {\n              case ye.Texture.EXPLICIT_MODE:\n                t.REFLECTIONMAP_EXPLICIT = !0;\n                break;\n\n              case ye.Texture.PLANAR_MODE:\n                t.REFLECTIONMAP_PLANAR = !0;\n                break;\n\n              case ye.Texture.PROJECTION_MODE:\n                t.REFLECTIONMAP_PROJECTION = !0;\n                break;\n\n              case ye.Texture.SKYBOX_MODE:\n                t.REFLECTIONMAP_SKYBOX = !0;\n                break;\n\n              case ye.Texture.SPHERICAL_MODE:\n                t.REFLECTIONMAP_SPHERICAL = !0;\n                break;\n\n              case ye.Texture.EQUIRECTANGULAR_MODE:\n                t.REFLECTIONMAP_EQUIRECTANGULAR = !0;\n                break;\n\n              case ye.Texture.FIXED_EQUIRECTANGULAR_MODE:\n                t.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !0;\n                break;\n\n              case ye.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                t.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !0;\n                break;\n\n              case ye.Texture.CUBIC_MODE:\n              case ye.Texture.INVCUBIC_MODE:\n              default:\n                t.REFLECTIONMAP_CUBIC = !0, t.USE_LOCAL_REFLECTIONMAP_CUBIC = !!s.boundingBoxSize;\n            }\n\n            s.coordinatesMode !== ye.Texture.SKYBOX_MODE ? s.sphericalPolynomial && (t.USESPHERICALFROMREFLECTIONMAP = !0, this._forceIrradianceInFragment || n.getEngine().getCaps().maxVaryingVectors <= 8 ? t.USESPHERICALINVERTEX = !1 : t.USESPHERICALINVERTEX = !0) : t.REFLECTIONMAP_SKYBOX_TRANSFORMED = !s.getReflectionTextureMatrix().isIdentity();\n          } else t.REFLECTION = !1, t.REFLECTIONMAP_3D = !1, t.REFLECTIONMAP_SPHERICAL = !1, t.REFLECTIONMAP_PLANAR = !1, t.REFLECTIONMAP_CUBIC = !1, t.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, t.REFLECTIONMAP_PROJECTION = !1, t.REFLECTIONMAP_SKYBOX = !1, t.REFLECTIONMAP_SKYBOX_TRANSFORMED = !1, t.REFLECTIONMAP_EXPLICIT = !1, t.REFLECTIONMAP_EQUIRECTANGULAR = !1, t.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, t.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, t.INVERTCUBICMAP = !1, t.USESPHERICALFROMREFLECTIONMAP = !1, t.USESPHERICALINVERTEX = !1, t.REFLECTIONMAP_OPPOSITEZ = !1, t.LODINREFLECTIONALPHA = !1, t.GAMMAREFLECTION = !1, t.RGBDREFLECTION = !1;\n\n          this._lightmapTexture && ye.StandardMaterial.LightmapTextureEnabled ? (ye.MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, t, \"LIGHTMAP\"), t.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap, t.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace) : t.LIGHTMAP = !1, this._emissiveTexture && ye.StandardMaterial.EmissiveTextureEnabled ? ye.MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, t, \"EMISSIVE\") : t.EMISSIVE = !1, ye.StandardMaterial.SpecularTextureEnabled ? (this._metallicTexture ? (ye.MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, t, \"REFLECTIVITY\"), t.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha, t.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen, t.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue, t.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed) : this._reflectivityTexture ? (ye.MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, t, \"REFLECTIVITY\"), t.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha, t.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap) : t.REFLECTIVITY = !1, this._microSurfaceTexture ? ye.MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, t, \"MICROSURFACEMAP\") : t.MICROSURFACEMAP = !1) : (t.REFLECTIVITY = !1, t.MICROSURFACEMAP = !1), n.getEngine().getCaps().standardDerivatives && this._bumpTexture && ye.StandardMaterial.BumpTextureEnabled && !this._disableBumpMap ? (ye.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, t, \"BUMP\"), this._useParallax && this._albedoTexture && ye.StandardMaterial.DiffuseTextureEnabled ? (t.PARALLAX = !0, t.PARALLAXOCCLUSION = !!this._useParallaxOcclusion) : t.PARALLAX = !1, t.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap) : t.BUMP = !1;\n\n          var a = this._getRefractionTexture();\n\n          a && ye.StandardMaterial.RefractionTextureEnabled ? (t.REFRACTION = !0, t.REFRACTIONMAP_3D = a.isCube, t.GAMMAREFRACTION = a.gammaSpace, t.RGBDREFRACTION = a.isRGBD, t.REFRACTIONMAP_OPPOSITEZ = a.invertZ, t.LODINREFRACTIONALPHA = a.lodLevelInAlpha, this._linkRefractionWithTransparency && (t.LINKREFRACTIONTOTRANSPARENCY = !0)) : t.REFRACTION = !1, this._environmentBRDFTexture && ye.StandardMaterial.ReflectionTextureEnabled ? t.ENVIRONMENTBRDF = !0 : t.ENVIRONMENTBRDF = !1, this._shouldUseAlphaFromAlbedoTexture() ? t.ALPHAFROMALBEDO = !0 : t.ALPHAFROMALBEDO = !1;\n        }\n\n        t.SPECULAROVERALPHA = this._useSpecularOverAlpha, this._lightFalloff === p.LIGHTFALLOFF_STANDARD ? (t.USEPHYSICALLIGHTFALLOFF = !1, t.USEGLTFLIGHTFALLOFF = !1) : this._lightFalloff === p.LIGHTFALLOFF_GLTF ? (t.USEPHYSICALLIGHTFALLOFF = !1, t.USEGLTFLIGHTFALLOFF = !0) : (t.USEPHYSICALLIGHTFALLOFF = !0, t.USEGLTFLIGHTFALLOFF = !1), t.RADIANCEOVERALPHA = this._useRadianceOverAlpha, !this.backFaceCulling && this._twoSidedLighting ? t.TWOSIDEDLIGHTING = !0 : t.TWOSIDEDLIGHTING = !1, t.ALPHATESTVALUE = this._alphaCutOff + (this._alphaCutOff % 1 == 0 ? \".\" : \"\"), t.PREMULTIPLYALPHA = this.alphaMode === ye.Engine.ALPHA_PREMULTIPLIED || this.alphaMode === ye.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF, t.ALPHABLEND = this.needAlphaBlendingForMesh(e), t.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel, t.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel, t.SPECULARAA = n.getEngine().getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\n      }\n\n      t._areImageProcessingDirty && this._imageProcessingConfiguration && this._imageProcessingConfiguration.prepareDefines(t), t.FORCENORMALFORWARD = this._forceNormalForward, t.RADIANCEOCCLUSION = this._useRadianceOcclusion, t.HORIZONOCCLUSION = this._useHorizonOcclusion, t._areMiscDirty && (ye.MaterialHelper.PrepareDefinesForMisc(e, n, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e) || this._forceAlphaTest, t), t.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !e.isVerticesDataPresent(ye.VertexBuffer.NormalKind)), ye.MaterialHelper.PrepareDefinesForFrameBoundValues(n, o, t, !!i, r), ye.MaterialHelper.PrepareDefinesForAttributes(e, t, !0, !0, !0, this._transparencyMode !== ye.PBRMaterial.PBRMATERIAL_OPAQUE);\n    }, p.prototype.forceCompilation = function (e, t, i) {\n      var r = this,\n          n = ae({\n        clipPlane: !1\n      }, i),\n          o = new be(),\n          s = this._prepareEffect(e, o, void 0, void 0, void 0, n.clipPlane);\n\n      s.isReady() ? t && t(this) : s.onCompileObservable.add(function () {\n        t && t(r);\n      });\n    }, p.prototype.buildUniformLayout = function () {\n      this._uniformBuffer.addUniform(\"vAlbedoInfos\", 2), this._uniformBuffer.addUniform(\"vAmbientInfos\", 4), this._uniformBuffer.addUniform(\"vOpacityInfos\", 2), this._uniformBuffer.addUniform(\"vEmissiveInfos\", 2), this._uniformBuffer.addUniform(\"vLightmapInfos\", 2), this._uniformBuffer.addUniform(\"vReflectivityInfos\", 3), this._uniformBuffer.addUniform(\"vMicroSurfaceSamplerInfos\", 2), this._uniformBuffer.addUniform(\"vRefractionInfos\", 4), this._uniformBuffer.addUniform(\"vReflectionInfos\", 2), this._uniformBuffer.addUniform(\"vReflectionPosition\", 3), this._uniformBuffer.addUniform(\"vReflectionSize\", 3), this._uniformBuffer.addUniform(\"vBumpInfos\", 3), this._uniformBuffer.addUniform(\"albedoMatrix\", 16), this._uniformBuffer.addUniform(\"ambientMatrix\", 16), this._uniformBuffer.addUniform(\"opacityMatrix\", 16), this._uniformBuffer.addUniform(\"emissiveMatrix\", 16), this._uniformBuffer.addUniform(\"lightmapMatrix\", 16), this._uniformBuffer.addUniform(\"reflectivityMatrix\", 16), this._uniformBuffer.addUniform(\"microSurfaceSamplerMatrix\", 16), this._uniformBuffer.addUniform(\"bumpMatrix\", 16), this._uniformBuffer.addUniform(\"vTangentSpaceParams\", 2), this._uniformBuffer.addUniform(\"refractionMatrix\", 16), this._uniformBuffer.addUniform(\"reflectionMatrix\", 16), this._uniformBuffer.addUniform(\"vReflectionColor\", 3), this._uniformBuffer.addUniform(\"vAlbedoColor\", 4), this._uniformBuffer.addUniform(\"vLightingIntensity\", 4), this._uniformBuffer.addUniform(\"vRefractionMicrosurfaceInfos\", 3), this._uniformBuffer.addUniform(\"vReflectionMicrosurfaceInfos\", 3), this._uniformBuffer.addUniform(\"vReflectivityColor\", 4), this._uniformBuffer.addUniform(\"vEmissiveColor\", 3), this._uniformBuffer.addUniform(\"pointSize\", 1), this._uniformBuffer.create();\n    }, p.prototype.unbind = function () {\n      this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._uniformBuffer.setTexture(\"reflectionSampler\", null), this._refractionTexture && this._refractionTexture.isRenderTarget && this._uniformBuffer.setTexture(\"refractionSampler\", null), r.prototype.unbind.call(this);\n    }, p.prototype.bindForSubMesh = function (e, t, i) {\n      var r = this.getScene(),\n          n = i._materialDefines;\n\n      if (n) {\n        var o = i.effect;\n\n        if (o) {\n          this._activeEffect = o, this.bindOnlyWorldMatrix(e), n.OBJECTSPACE_NORMALMAP && (e.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix));\n\n          var s = this._mustRebind(r, o, t.visibility);\n\n          ye.MaterialHelper.BindBonesParameters(t, this._activeEffect);\n          var a = null;\n\n          if (s) {\n            this._uniformBuffer.bindToEffect(o, \"Material\"), this.bindViewProjection(o), a = this._getReflectionTexture();\n\n            var l = this._getRefractionTexture();\n\n            if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\n              if (r.texturesEnabled) {\n                if (this._albedoTexture && ye.StandardMaterial.DiffuseTextureEnabled && (this._uniformBuffer.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level), ye.MaterialHelper.BindTextureMatrix(this._albedoTexture, this._uniformBuffer, \"albedo\")), this._ambientTexture && ye.StandardMaterial.AmbientTextureEnabled && (this._uniformBuffer.updateFloat4(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights), ye.MaterialHelper.BindTextureMatrix(this._ambientTexture, this._uniformBuffer, \"ambient\")), this._opacityTexture && ye.StandardMaterial.OpacityTextureEnabled && (this._uniformBuffer.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), ye.MaterialHelper.BindTextureMatrix(this._opacityTexture, this._uniformBuffer, \"opacity\")), a && ye.StandardMaterial.ReflectionTextureEnabled) {\n                  if (this._uniformBuffer.updateMatrix(\"reflectionMatrix\", a.getReflectionTextureMatrix()), this._uniformBuffer.updateFloat2(\"vReflectionInfos\", a.level, 0), a.boundingBoxSize) {\n                    var c = a;\n                    this._uniformBuffer.updateVector3(\"vReflectionPosition\", c.boundingBoxPosition), this._uniformBuffer.updateVector3(\"vReflectionSize\", c.boundingBoxSize);\n                  }\n\n                  var h = a.sphericalPolynomial;\n                  n.USESPHERICALFROMREFLECTIONMAP && h && (this._activeEffect.setFloat3(\"vSphericalX\", h.x.x, h.x.y, h.x.z), this._activeEffect.setFloat3(\"vSphericalY\", h.y.x, h.y.y, h.y.z), this._activeEffect.setFloat3(\"vSphericalZ\", h.z.x, h.z.y, h.z.z), this._activeEffect.setFloat3(\"vSphericalXX_ZZ\", h.xx.x - h.zz.x, h.xx.y - h.zz.y, h.xx.z - h.zz.z), this._activeEffect.setFloat3(\"vSphericalYY_ZZ\", h.yy.x - h.zz.x, h.yy.y - h.zz.y, h.yy.z - h.zz.z), this._activeEffect.setFloat3(\"vSphericalZZ\", h.zz.x, h.zz.y, h.zz.z), this._activeEffect.setFloat3(\"vSphericalXY\", h.xy.x, h.xy.y, h.xy.z), this._activeEffect.setFloat3(\"vSphericalYZ\", h.yz.x, h.yz.y, h.yz.z), this._activeEffect.setFloat3(\"vSphericalZX\", h.zx.x, h.zx.y, h.zx.z)), this._uniformBuffer.updateFloat3(\"vReflectionMicrosurfaceInfos\", a.getSize().width, a.lodGenerationScale, a.lodGenerationOffset);\n                }\n\n                if (this._emissiveTexture && ye.StandardMaterial.EmissiveTextureEnabled && (this._uniformBuffer.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), ye.MaterialHelper.BindTextureMatrix(this._emissiveTexture, this._uniformBuffer, \"emissive\")), this._lightmapTexture && ye.StandardMaterial.LightmapTextureEnabled && (this._uniformBuffer.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), ye.MaterialHelper.BindTextureMatrix(this._lightmapTexture, this._uniformBuffer, \"lightmap\")), ye.StandardMaterial.SpecularTextureEnabled && (this._metallicTexture ? (this._uniformBuffer.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength), ye.MaterialHelper.BindTextureMatrix(this._metallicTexture, this._uniformBuffer, \"reflectivity\")) : this._reflectivityTexture && (this._uniformBuffer.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1), ye.MaterialHelper.BindTextureMatrix(this._reflectivityTexture, this._uniformBuffer, \"reflectivity\")), this._microSurfaceTexture && (this._uniformBuffer.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level), ye.MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, this._uniformBuffer, \"microSurfaceSampler\"))), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && ye.StandardMaterial.BumpTextureEnabled && !this._disableBumpMap && (this._uniformBuffer.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias), ye.MaterialHelper.BindTextureMatrix(this._bumpTexture, this._uniformBuffer, \"bump\"), r._mirroredCameraPosition ? this._uniformBuffer.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : this._uniformBuffer.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)), l && ye.StandardMaterial.RefractionTextureEnabled) {\n                  this._uniformBuffer.updateMatrix(\"refractionMatrix\", l.getReflectionTextureMatrix());\n\n                  var u = 1;\n                  l.isCube || l.depth && (u = l.depth), this._uniformBuffer.updateFloat4(\"vRefractionInfos\", l.level, this._indexOfRefraction, u, this._invertRefractionY ? -1 : 1), this._uniformBuffer.updateFloat3(\"vRefractionMicrosurfaceInfos\", l.getSize().width, l.lodGenerationScale, l.lodGenerationOffset);\n                }\n              }\n\n              this.pointsCloud && this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize), n.METALLICWORKFLOW ? (ye.PBRMaterial._scaledReflectivity.r = void 0 === this._metallic || null === this._metallic ? 1 : this._metallic, ye.PBRMaterial._scaledReflectivity.g = void 0 === this._roughness || null === this._roughness ? 1 : this._roughness, this._uniformBuffer.updateColor4(\"vReflectivityColor\", ye.PBRMaterial._scaledReflectivity, 0)) : this._uniformBuffer.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface), this._uniformBuffer.updateColor3(\"vEmissiveColor\", this._emissiveColor), this._uniformBuffer.updateColor3(\"vReflectionColor\", this._reflectionColor), this._uniformBuffer.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha * t.visibility), this._lightingInfos.x = this._directIntensity, this._lightingInfos.y = this._emissiveIntensity, this._lightingInfos.z = this._environmentIntensity, this._lightingInfos.w = this._specularIntensity, this._uniformBuffer.updateVector4(\"vLightingIntensity\", this._lightingInfos);\n            }\n\n            r.texturesEnabled && (this._albedoTexture && ye.StandardMaterial.DiffuseTextureEnabled && this._uniformBuffer.setTexture(\"albedoSampler\", this._albedoTexture), this._ambientTexture && ye.StandardMaterial.AmbientTextureEnabled && this._uniformBuffer.setTexture(\"ambientSampler\", this._ambientTexture), this._opacityTexture && ye.StandardMaterial.OpacityTextureEnabled && this._uniformBuffer.setTexture(\"opacitySampler\", this._opacityTexture), a && ye.StandardMaterial.ReflectionTextureEnabled && (n.LODBASEDMICROSFURACE ? this._uniformBuffer.setTexture(\"reflectionSampler\", a) : (this._uniformBuffer.setTexture(\"reflectionSampler\", a._lodTextureMid || a), this._uniformBuffer.setTexture(\"reflectionSamplerLow\", a._lodTextureLow || a), this._uniformBuffer.setTexture(\"reflectionSamplerHigh\", a._lodTextureHigh || a))), n.ENVIRONMENTBRDF && this._uniformBuffer.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture), l && ye.StandardMaterial.RefractionTextureEnabled && (n.LODBASEDMICROSFURACE ? this._uniformBuffer.setTexture(\"refractionSampler\", l) : (this._uniformBuffer.setTexture(\"refractionSampler\", l._lodTextureMid || l), this._uniformBuffer.setTexture(\"refractionSamplerLow\", l._lodTextureLow || l), this._uniformBuffer.setTexture(\"refractionSamplerHigh\", l._lodTextureHigh || l))), this._emissiveTexture && ye.StandardMaterial.EmissiveTextureEnabled && this._uniformBuffer.setTexture(\"emissiveSampler\", this._emissiveTexture), this._lightmapTexture && ye.StandardMaterial.LightmapTextureEnabled && this._uniformBuffer.setTexture(\"lightmapSampler\", this._lightmapTexture), ye.StandardMaterial.SpecularTextureEnabled && (this._metallicTexture ? this._uniformBuffer.setTexture(\"reflectivitySampler\", this._metallicTexture) : this._reflectivityTexture && this._uniformBuffer.setTexture(\"reflectivitySampler\", this._reflectivityTexture), this._microSurfaceTexture && this._uniformBuffer.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture)), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && ye.StandardMaterial.BumpTextureEnabled && !this._disableBumpMap && this._uniformBuffer.setTexture(\"bumpSampler\", this._bumpTexture)), ye.MaterialHelper.BindClipPlane(this._activeEffect, r), r.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\n            var d = r._forcedViewPosition ? r._forcedViewPosition : r._mirroredCameraPosition ? r._mirroredCameraPosition : r.activeCamera.globalPosition,\n                f = r.useRightHandedSystem === (null != r._mirroredCameraPosition);\n            o.setFloat4(\"vEyePosition\", d.x, d.y, d.z, f ? -1 : 1), o.setColor3(\"vAmbientColor\", this._globalAmbientColor);\n          }\n\n          !s && this.isFrozen || (r.lightsEnabled && !this._disableLighting && ye.MaterialHelper.BindLights(r, t, this._activeEffect, n, this._maxSimultaneousLights, this._lightFalloff !== p.LIGHTFALLOFF_STANDARD), (r.fogEnabled && t.applyFog && r.fogMode !== ye.Scene.FOGMODE_NONE || a) && this.bindView(o), ye.MaterialHelper.BindFogParameters(r, t, this._activeEffect, !0), n.NUM_MORPH_INFLUENCERS && ye.MaterialHelper.BindMorphTargetParameters(t, this._activeEffect), this._imageProcessingConfiguration.bind(this._activeEffect), ye.MaterialHelper.BindLogDepth(n, this._activeEffect, r)), this._uniformBuffer.update(), this._afterBind(t, this._activeEffect);\n        }\n      }\n    }, p.prototype.getAnimatables = function () {\n      var e = [];\n      return this._albedoTexture && this._albedoTexture.animations && 0 < this._albedoTexture.animations.length && e.push(this._albedoTexture), this._ambientTexture && this._ambientTexture.animations && 0 < this._ambientTexture.animations.length && e.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && 0 < this._opacityTexture.animations.length && e.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && 0 < this._reflectionTexture.animations.length && e.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && 0 < this._emissiveTexture.animations.length && e.push(this._emissiveTexture), this._metallicTexture && this._metallicTexture.animations && 0 < this._metallicTexture.animations.length ? e.push(this._metallicTexture) : this._reflectivityTexture && this._reflectivityTexture.animations && 0 < this._reflectivityTexture.animations.length && e.push(this._reflectivityTexture), this._bumpTexture && this._bumpTexture.animations && 0 < this._bumpTexture.animations.length && e.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && 0 < this._lightmapTexture.animations.length && e.push(this._lightmapTexture), this._refractionTexture && this._refractionTexture.animations && 0 < this._refractionTexture.animations.length && e.push(this._refractionTexture), e;\n    }, p.prototype._getReflectionTexture = function () {\n      return this._reflectionTexture ? this._reflectionTexture : this.getScene().environmentTexture;\n    }, p.prototype._getRefractionTexture = function () {\n      return this._refractionTexture ? this._refractionTexture : this._linkRefractionWithTransparency ? this.getScene().environmentTexture : null;\n    }, p.prototype.dispose = function (e, t) {\n      t && (this._albedoTexture && this._albedoTexture.dispose(), this._ambientTexture && this._ambientTexture.dispose(), this._opacityTexture && this._opacityTexture.dispose(), this._reflectionTexture && this._reflectionTexture.dispose(), this._environmentBRDFTexture && this.getScene()._environmentBRDFTexture !== this._environmentBRDFTexture && this._environmentBRDFTexture.dispose(), this._emissiveTexture && this._emissiveTexture.dispose(), this._metallicTexture && this._metallicTexture.dispose(), this._reflectivityTexture && this._reflectivityTexture.dispose(), this._bumpTexture && this._bumpTexture.dispose(), this._lightmapTexture && this._lightmapTexture.dispose(), this._refractionTexture && this._refractionTexture.dispose()), this._renderTargets.dispose(), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), r.prototype.dispose.call(this, e, t);\n    }, p.LIGHTFALLOFF_PHYSICAL = 0, p.LIGHTFALLOFF_GLTF = 1, p.LIGHTFALLOFF_STANDARD = 2, p._scaledReflectivity = new ye.Color3(), b([ye.serializeAsImageProcessingConfiguration()], p.prototype, \"_imageProcessingConfiguration\", void 0), b([ye.serialize()], p.prototype, \"useLogarithmicDepth\", null), b([ye.serialize()], p.prototype, \"transparencyMode\", null), p;\n  }(ye.PushMaterial), ye.PBRBaseMaterial = Te, Ee = $a || ($a = {}), xe = function (r) {\n    function e(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i.maxSimultaneousLights = 4, i.disableLighting = !1, i.invertNormalMapX = !1, i.invertNormalMapY = !1, i.emissiveColor = new Ee.Color3(0, 0, 0), i.occlusionStrength = 1, i.useLightmapAsShadowmap = !1, i._useAlphaFromAlbedoTexture = !0, i._useAmbientInGrayScale = !0, i;\n    }\n\n    return T(e, r), Object.defineProperty(e.prototype, \"doubleSided\", {\n      get: function () {\n        return this._twoSidedLighting;\n      },\n      set: function (e) {\n        this._twoSidedLighting !== e && (this._twoSidedLighting = e, this.backFaceCulling = !e, this._markAllSubMeshesAsTexturesDirty());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getActiveTextures = function () {\n      var e = r.prototype.getActiveTextures.call(this);\n      return this.environmentTexture && e.push(this.environmentTexture), this.normalTexture && e.push(this.normalTexture), this.emissiveTexture && e.push(this.emissiveTexture), this.occlusionTexture && e.push(this.occlusionTexture), this.lightmapTexture && e.push(this.lightmapTexture), e;\n    }, e.prototype.hasTexture = function (e) {\n      return !!r.prototype.hasTexture.call(this, e) || this.lightmapTexture === e;\n    }, e.prototype.getClassName = function () {\n      return \"PBRBaseSimpleMaterial\";\n    }, b([Ee.serialize(), Ee.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], e.prototype, \"maxSimultaneousLights\", void 0), b([Ee.serialize(), Ee.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], e.prototype, \"disableLighting\", void 0), b([Ee.serializeAsTexture(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectionTexture\")], e.prototype, \"environmentTexture\", void 0), b([Ee.serialize(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], e.prototype, \"invertNormalMapX\", void 0), b([Ee.serialize(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], e.prototype, \"invertNormalMapY\", void 0), b([Ee.serializeAsTexture(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_bumpTexture\")], e.prototype, \"normalTexture\", void 0), b([Ee.serializeAsColor3(\"emissive\"), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], e.prototype, \"emissiveColor\", void 0), b([Ee.serializeAsTexture(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], e.prototype, \"emissiveTexture\", void 0), b([Ee.serialize(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTextureStrength\")], e.prototype, \"occlusionStrength\", void 0), b([Ee.serializeAsTexture(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTexture\")], e.prototype, \"occlusionTexture\", void 0), b([Ee.serialize(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_alphaCutOff\")], e.prototype, \"alphaCutOff\", void 0), b([Ee.serialize()], e.prototype, \"doubleSided\", null), b([Ee.serializeAsTexture(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)], e.prototype, \"lightmapTexture\", void 0), b([Ee.serialize(), Ee.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], e.prototype, \"useLightmapAsShadowmap\", void 0), e;\n  }(Ee.PBRBaseMaterial), Ee.PBRBaseSimpleMaterial = xe, Pe = $a || ($a = {}), Ae = function (r) {\n    function n(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i.directIntensity = 1, i.emissiveIntensity = 1, i.environmentIntensity = 1, i.specularIntensity = 1, i.disableBumpMap = !1, i.ambientTextureStrength = 1, i.ambientTextureImpactOnAnalyticalLights = n.DEFAULT_AO_ON_ANALYTICAL_LIGHTS, i.ambientColor = new Pe.Color3(0, 0, 0), i.albedoColor = new Pe.Color3(1, 1, 1), i.reflectivityColor = new Pe.Color3(1, 1, 1), i.reflectionColor = new Pe.Color3(1, 1, 1), i.emissiveColor = new Pe.Color3(0, 0, 0), i.microSurface = 1, i.indexOfRefraction = .66, i.invertRefractionY = !1, i.linkRefractionWithTransparency = !1, i.useLightmapAsShadowmap = !1, i.useAlphaFromAlbedoTexture = !1, i.forceAlphaTest = !1, i.alphaCutOff = .4, i.useSpecularOverAlpha = !0, i.useMicroSurfaceFromReflectivityMapAlpha = !1, i.useRoughnessFromMetallicTextureAlpha = !0, i.useRoughnessFromMetallicTextureGreen = !1, i.useMetallnessFromMetallicTextureBlue = !1, i.useAmbientOcclusionFromMetallicTextureRed = !1, i.useAmbientInGrayScale = !1, i.useAutoMicroSurfaceFromReflectivityMap = !1, i.useRadianceOverAlpha = !0, i.useObjectSpaceNormalMap = !1, i.useParallax = !1, i.useParallaxOcclusion = !1, i.parallaxScaleBias = .05, i.disableLighting = !1, i.forceIrradianceInFragment = !1, i.maxSimultaneousLights = 4, i.invertNormalMapX = !1, i.invertNormalMapY = !1, i.twoSidedLighting = !1, i.useAlphaFresnel = !1, i.useLinearAlphaFresnel = !1, i.environmentBRDFTexture = null, i.forceNormalForward = !1, i.enableSpecularAntiAliasing = !1, i.useHorizonOcclusion = !0, i.useRadianceOcclusion = !0, i.unlit = !1, i._environmentBRDFTexture = Pe.TextureTools.GetEnvironmentBRDFTexture(t), i;\n    }\n\n    return T(n, r), Object.defineProperty(n.prototype, \"usePhysicalLightFalloff\", {\n      get: function () {\n        return this._lightFalloff === Pe.PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\n      },\n      set: function (e) {\n        e !== this.usePhysicalLightFalloff && (this._markAllSubMeshesAsTexturesDirty(), this._lightFalloff = e ? Pe.PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL : Pe.PBRBaseMaterial.LIGHTFALLOFF_STANDARD);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"useGLTFLightFalloff\", {\n      get: function () {\n        return this._lightFalloff === Pe.PBRBaseMaterial.LIGHTFALLOFF_GLTF;\n      },\n      set: function (e) {\n        e !== this.useGLTFLightFalloff && (this._markAllSubMeshesAsTexturesDirty(), this._lightFalloff = e ? Pe.PBRBaseMaterial.LIGHTFALLOFF_GLTF : Pe.PBRBaseMaterial.LIGHTFALLOFF_STANDARD);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"imageProcessingConfiguration\", {\n      get: function () {\n        return this._imageProcessingConfiguration;\n      },\n      set: function (e) {\n        this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorCurvesEnabled\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorGradingEnabled\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorGradingEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraToneMappingEnabled\", {\n      get: function () {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.toneMappingEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraExposure\", {\n      get: function () {\n        return this._imageProcessingConfiguration.exposure;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.exposure = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraContrast\", {\n      get: function () {\n        return this._imageProcessingConfiguration.contrast;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.contrast = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorGradingTexture\", {\n      get: function () {\n        return this._imageProcessingConfiguration.colorGradingTexture;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.colorGradingTexture = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorCurves\", {\n      get: function () {\n        return this._imageProcessingConfiguration.colorCurves;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.colorCurves = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.prototype.getClassName = function () {\n      return \"PBRMaterial\";\n    }, n.prototype.getActiveTextures = function () {\n      var e = r.prototype.getActiveTextures.call(this);\n      return this._albedoTexture && e.push(this._albedoTexture), this._ambientTexture && e.push(this._ambientTexture), this._opacityTexture && e.push(this._opacityTexture), this._reflectionTexture && e.push(this._reflectionTexture), this._emissiveTexture && e.push(this._emissiveTexture), this._reflectivityTexture && e.push(this._reflectivityTexture), this._metallicTexture && e.push(this._metallicTexture), this._microSurfaceTexture && e.push(this._microSurfaceTexture), this._bumpTexture && e.push(this._bumpTexture), this._lightmapTexture && e.push(this._lightmapTexture), this._refractionTexture && e.push(this._refractionTexture), e;\n    }, n.prototype.hasTexture = function (e) {\n      return !!r.prototype.hasTexture.call(this, e) || this._albedoTexture === e || this._ambientTexture === e || this._opacityTexture === e || this._reflectionTexture === e || this._reflectivityTexture === e || this._metallicTexture === e || this._microSurfaceTexture === e || this._bumpTexture === e || this._lightmapTexture === e || this._refractionTexture === e;\n    }, n.prototype.clone = function (e) {\n      var t = this,\n          i = Pe.SerializationHelper.Clone(function () {\n        return new n(e, t.getScene());\n      }, this);\n      return i.id = e, i.name = e, i;\n    }, n.prototype.serialize = function () {\n      var e = Pe.SerializationHelper.Serialize(this);\n      return e.customType = \"BABYLON.PBRMaterial\", e;\n    }, n.Parse = function (e, t, i) {\n      return Pe.SerializationHelper.Parse(function () {\n        return new n(e.name, t);\n      }, e, t, i);\n    }, n.PBRMATERIAL_OPAQUE = 0, n.PBRMATERIAL_ALPHATEST = 1, n.PBRMATERIAL_ALPHABLEND = 2, n.PBRMATERIAL_ALPHATESTANDBLEND = 3, n.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 1, b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"directIntensity\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"emissiveIntensity\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"environmentIntensity\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"specularIntensity\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"disableBumpMap\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"albedoTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"ambientTexture\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"ambientTextureStrength\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"ambientTextureImpactOnAnalyticalLights\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], n.prototype, \"opacityTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"emissiveTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectivityTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"metallicTexture\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"metallic\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"roughness\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"microSurfaceTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"bumpTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)], n.prototype, \"lightmapTexture\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"refractionTexture\", void 0), b([Pe.serializeAsColor3(\"ambient\"), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"ambientColor\", void 0), b([Pe.serializeAsColor3(\"albedo\"), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"albedoColor\", void 0), b([Pe.serializeAsColor3(\"reflectivity\"), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectivityColor\", void 0), b([Pe.serializeAsColor3(\"reflection\"), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionColor\", void 0), b([Pe.serializeAsColor3(\"emissive\"), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"emissiveColor\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"microSurface\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"indexOfRefraction\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"invertRefractionY\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"linkRefractionWithTransparency\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useLightmapAsShadowmap\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], n.prototype, \"useAlphaFromAlbedoTexture\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], n.prototype, \"forceAlphaTest\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")], n.prototype, \"alphaCutOff\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useSpecularOverAlpha\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useMicroSurfaceFromReflectivityMapAlpha\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useRoughnessFromMetallicTextureAlpha\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useRoughnessFromMetallicTextureGreen\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useMetallnessFromMetallicTextureBlue\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useAmbientOcclusionFromMetallicTextureRed\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useAmbientInGrayScale\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useAutoMicroSurfaceFromReflectivityMap\", void 0), b([Pe.serialize()], n.prototype, \"usePhysicalLightFalloff\", null), b([Pe.serialize()], n.prototype, \"useGLTFLightFalloff\", null), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useRadianceOverAlpha\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useObjectSpaceNormalMap\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useParallax\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useParallaxOcclusion\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"parallaxScaleBias\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], n.prototype, \"disableLighting\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"forceIrradianceInFragment\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], n.prototype, \"maxSimultaneousLights\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"invertNormalMapX\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"invertNormalMapY\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"twoSidedLighting\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useAlphaFresnel\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useLinearAlphaFresnel\", void 0), b([Pe.serializeAsTexture(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"environmentBRDFTexture\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"forceNormalForward\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"enableSpecularAntiAliasing\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useHorizonOcclusion\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useRadianceOcclusion\", void 0), b([Pe.serialize(), Pe.expandToProperty(\"_markAllSubMeshesAsMiscDirty\")], n.prototype, \"unlit\", void 0), n;\n  }(Pe.PBRBaseMaterial), Pe.PBRMaterial = Ae, Se = $a || ($a = {}), Me = function (r) {\n    function n(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i._useRoughnessFromMetallicTextureAlpha = !1, i._useRoughnessFromMetallicTextureGreen = !0, i._useMetallnessFromMetallicTextureBlue = !0, i.metallic = 1, i.roughness = 1, i;\n    }\n\n    return T(n, r), n.prototype.getClassName = function () {\n      return \"PBRMetallicRoughnessMaterial\";\n    }, n.prototype.getActiveTextures = function () {\n      var e = r.prototype.getActiveTextures.call(this);\n      return this.baseTexture && e.push(this.baseTexture), this.metallicRoughnessTexture && e.push(this.metallicRoughnessTexture), e;\n    }, n.prototype.hasTexture = function (e) {\n      return !!r.prototype.hasTexture.call(this, e) || this.baseTexture === e || this.metallicRoughnessTexture === e;\n    }, n.prototype.clone = function (e) {\n      var t = this,\n          i = Se.SerializationHelper.Clone(function () {\n        return new n(e, t.getScene());\n      }, this);\n      return i.id = e, i.name = e, i;\n    }, n.prototype.serialize = function () {\n      var e = Se.SerializationHelper.Serialize(this);\n      return e.customType = \"BABYLON.PBRMetallicRoughnessMaterial\", e;\n    }, n.Parse = function (e, t, i) {\n      return Se.SerializationHelper.Parse(function () {\n        return new n(e.name, t);\n      }, e, t, i);\n    }, b([Se.serializeAsColor3(), Se.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoColor\")], n.prototype, \"baseColor\", void 0), b([Se.serializeAsTexture(), Se.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoTexture\")], n.prototype, \"baseTexture\", void 0), b([Se.serialize(), Se.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"metallic\", void 0), b([Se.serialize(), Se.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"roughness\", void 0), b([Se.serializeAsTexture(), Se.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_metallicTexture\")], n.prototype, \"metallicRoughnessTexture\", void 0), n;\n  }(Se.PBRBaseSimpleMaterial), Se.PBRMetallicRoughnessMaterial = Me, Re = $a || ($a = {}), Ce = function (r) {\n    function n(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i._useMicroSurfaceFromReflectivityMapAlpha = !0, i;\n    }\n\n    return T(n, r), n.prototype.getClassName = function () {\n      return \"PBRSpecularGlossinessMaterial\";\n    }, n.prototype.getActiveTextures = function () {\n      var e = r.prototype.getActiveTextures.call(this);\n      return this.diffuseTexture && e.push(this.diffuseTexture), this.specularGlossinessTexture && e.push(this.specularGlossinessTexture), e;\n    }, n.prototype.hasTexture = function (e) {\n      return !!r.prototype.hasTexture.call(this, e) || this.diffuseTexture === e || this.specularGlossinessTexture === e;\n    }, n.prototype.clone = function (e) {\n      var t = this,\n          i = Re.SerializationHelper.Clone(function () {\n        return new n(e, t.getScene());\n      }, this);\n      return i.id = e, i.name = e, i;\n    }, n.prototype.serialize = function () {\n      var e = Re.SerializationHelper.Serialize(this);\n      return e.customType = \"BABYLON.PBRSpecularGlossinessMaterial\", e;\n    }, n.Parse = function (e, t, i) {\n      return Re.SerializationHelper.Parse(function () {\n        return new n(e.name, t);\n      }, e, t, i);\n    }, b([Re.serializeAsColor3(\"diffuse\"), Re.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoColor\")], n.prototype, \"diffuseColor\", void 0), b([Re.serializeAsTexture(), Re.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoTexture\")], n.prototype, \"diffuseTexture\", void 0), b([Re.serializeAsColor3(\"specular\"), Re.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectivityColor\")], n.prototype, \"specularColor\", void 0), b([Re.serialize(), Re.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_microSurface\")], n.prototype, \"glossiness\", void 0), b([Re.serializeAsTexture(), Re.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectivityTexture\")], n.prototype, \"specularGlossinessTexture\", void 0), n;\n  }(Re.PBRBaseSimpleMaterial), Re.PBRSpecularGlossinessMaterial = Ce, function (s) {\n    s.CameraInputTypes = {};\n\n    var e = function () {\n      function e(e) {\n        this.attached = {}, this.camera = e, this.checkInputs = function () {};\n      }\n\n      return e.prototype.add = function (e) {\n        var t = e.getSimpleName();\n        this.attached[t] ? s.Tools.Warn(\"camera input of type \" + t + \" already exists on camera\") : ((this.attached[t] = e).camera = this.camera, e.checkInputs && (this.checkInputs = this._addCheckInputs(e.checkInputs.bind(e))), this.attachedElement && e.attachControl(this.attachedElement));\n      }, e.prototype.remove = function (e) {\n        for (var t in this.attached) {\n          var i = this.attached[t];\n          i === e && (i.detachControl(this.attachedElement), i.camera = null, delete this.attached[t], this.rebuildInputCheck());\n        }\n      }, e.prototype.removeByType = function (e) {\n        for (var t in this.attached) {\n          var i = this.attached[t];\n          i.getClassName() === e && (i.detachControl(this.attachedElement), i.camera = null, delete this.attached[t], this.rebuildInputCheck());\n        }\n      }, e.prototype._addCheckInputs = function (e) {\n        var t = this.checkInputs;\n        return function () {\n          t(), e();\n        };\n      }, e.prototype.attachInput = function (e) {\n        this.attachedElement && e.attachControl(this.attachedElement, this.noPreventDefault);\n      }, e.prototype.attachElement = function (e, t) {\n        if (void 0 === t && (t = !1), !this.attachedElement) for (var i in t = !s.Camera.ForceAttachControlToAlwaysPreventDefault && t, this.attachedElement = e, this.noPreventDefault = t, this.attached) this.attached[i].attachControl(e, t);\n      }, e.prototype.detachElement = function (e, t) {\n        if (void 0 === t && (t = !1), this.attachedElement === e) {\n          for (var i in this.attached) this.attached[i].detachControl(e), t && (this.attached[i].camera = null);\n\n          this.attachedElement = null;\n        }\n      }, e.prototype.rebuildInputCheck = function () {\n        for (var e in this.checkInputs = function () {}, this.attached) {\n          var t = this.attached[e];\n          t.checkInputs && (this.checkInputs = this._addCheckInputs(t.checkInputs.bind(t)));\n        }\n      }, e.prototype.clear = function () {\n        this.attachedElement && this.detachElement(this.attachedElement, !0), this.attached = {}, this.attachedElement = null, this.checkInputs = function () {};\n      }, e.prototype.serialize = function (e) {\n        var t = {};\n\n        for (var i in this.attached) {\n          var r = this.attached[i],\n              n = s.SerializationHelper.Serialize(r);\n          t[r.getClassName()] = n;\n        }\n\n        e.inputsmgr = t;\n      }, e.prototype.parse = function (e) {\n        var t = e.inputsmgr;\n        if (t) for (var i in this.clear(), t) {\n          if (o = s.CameraInputTypes[i]) {\n            var r = t[i],\n                n = s.SerializationHelper.Parse(function () {\n              return new o();\n            }, r, null);\n            this.add(n);\n          }\n        } else for (var i in this.attached) {\n          var o;\n\n          if (o = s.CameraInputTypes[this.attached[i].getClassName()]) {\n            n = s.SerializationHelper.Parse(function () {\n              return new o();\n            }, e, null);\n            this.remove(this.attached[i]), this.add(n);\n          }\n        }\n      }, e;\n    }();\n\n    s.CameraInputsManager = e;\n  }($a || ($a = {})), Oe = $a || ($a = {}), De = function (o) {\n    function r(e, t, i, r) {\n      void 0 === r && (r = !0);\n      var n = o.call(this, e, t, i, r) || this;\n      return n.cameraDirection = new Oe.Vector3(0, 0, 0), n.cameraRotation = new Oe.Vector2(0, 0), n.rotation = new Oe.Vector3(0, 0, 0), n.speed = 2, n.noRotationConstraint = !1, n.lockedTarget = null, n._currentTarget = Oe.Vector3.Zero(), n._viewMatrix = Oe.Matrix.Zero(), n._camMatrix = Oe.Matrix.Zero(), n._cameraTransformMatrix = Oe.Matrix.Zero(), n._cameraRotationMatrix = Oe.Matrix.Zero(), n._referencePoint = new Oe.Vector3(0, 0, 1), n._transformedReferencePoint = Oe.Vector3.Zero(), n._globalCurrentTarget = Oe.Vector3.Zero(), n._globalCurrentUpVector = Oe.Vector3.Zero(), n._defaultUp = Oe.Vector3.Up(), n._cachedRotationZ = 0, n._cachedQuaternionRotationZ = 0, n;\n    }\n\n    return T(r, o), r.prototype.getFrontPosition = function (e) {\n      this.getWorldMatrix();\n      var t = this.getTarget().subtract(this.position);\n      return t.normalize(), t.scaleInPlace(e), this.globalPosition.add(t);\n    }, r.prototype._getLockedTargetPosition = function () {\n      return this.lockedTarget ? (this.lockedTarget.absolutePosition && this.lockedTarget.computeWorldMatrix(), this.lockedTarget.absolutePosition || this.lockedTarget) : null;\n    }, r.prototype.storeState = function () {\n      return this._storedPosition = this.position.clone(), this._storedRotation = this.rotation.clone(), this.rotationQuaternion && (this._storedRotationQuaternion = this.rotationQuaternion.clone()), o.prototype.storeState.call(this);\n    }, r.prototype._restoreStateValues = function () {\n      return !!o.prototype._restoreStateValues.call(this) && (this.position = this._storedPosition.clone(), this.rotation = this._storedRotation.clone(), this.rotationQuaternion && (this.rotationQuaternion = this._storedRotationQuaternion.clone()), this.cameraDirection.copyFromFloats(0, 0, 0), this.cameraRotation.copyFromFloats(0, 0), !0);\n    }, r.prototype._initCache = function () {\n      o.prototype._initCache.call(this), this._cache.lockedTarget = new Oe.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotation = new Oe.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotationQuaternion = new Oe.Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    }, r.prototype._updateCache = function (e) {\n      e || o.prototype._updateCache.call(this);\n\n      var t = this._getLockedTargetPosition();\n\n      t ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(t) : this._cache.lockedTarget = t.clone() : this._cache.lockedTarget = null, this._cache.rotation.copyFrom(this.rotation), this.rotationQuaternion && this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n    }, r.prototype._isSynchronizedViewMatrix = function () {\n      if (!o.prototype._isSynchronizedViewMatrix.call(this)) return !1;\n\n      var e = this._getLockedTargetPosition();\n\n      return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(e) : !e) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n    }, r.prototype._computeLocalCameraSpeed = function () {\n      var e = this.getEngine();\n      return this.speed * Math.sqrt(e.getDeltaTime() / (100 * e.getFps()));\n    }, r.prototype.setTarget = function (e) {\n      this.upVector.normalize(), this.position.z === e.z && (this.position.z += Oe.Epsilon), Oe.Matrix.LookAtLHToRef(this.position, e, this._defaultUp, this._camMatrix), this._camMatrix.invert(), this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n      var t = e.subtract(this.position);\n      0 <= t.x ? this.rotation.y = -Math.atan(t.z / t.x) + Math.PI / 2 : this.rotation.y = -Math.atan(t.z / t.x) - Math.PI / 2, this.rotation.z = 0, isNaN(this.rotation.x) && (this.rotation.x = 0), isNaN(this.rotation.y) && (this.rotation.y = 0), isNaN(this.rotation.z) && (this.rotation.z = 0), this.rotationQuaternion && Oe.Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n    }, r.prototype.getTarget = function () {\n      return this._currentTarget;\n    }, r.prototype._decideIfNeedsToMove = function () {\n      return 0 < Math.abs(this.cameraDirection.x) || 0 < Math.abs(this.cameraDirection.y) || 0 < Math.abs(this.cameraDirection.z);\n    }, r.prototype._updatePosition = function () {\n      if (this.parent) return this.parent.getWorldMatrix().invertToRef(Oe.Tmp.Matrix[0]), Oe.Vector3.TransformNormalToRef(this.cameraDirection, Oe.Tmp.Matrix[0], Oe.Tmp.Vector3[0]), void this.position.addInPlace(Oe.Tmp.Vector3[0]);\n      this.position.addInPlace(this.cameraDirection);\n    }, r.prototype._checkInputs = function () {\n      var e = this._decideIfNeedsToMove(),\n          t = 0 < Math.abs(this.cameraRotation.x) || 0 < Math.abs(this.cameraRotation.y);\n\n      if (e && this._updatePosition(), t) {\n        if (this.rotation.x += this.cameraRotation.x, this.rotation.y += this.cameraRotation.y, this.rotationQuaternion) this.rotation.lengthSquared() && Oe.Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n\n        if (!this.noRotationConstraint) {\n          var i = Math.PI / 2 * .95;\n          this.rotation.x > i && (this.rotation.x = i), this.rotation.x < -i && (this.rotation.x = -i);\n        }\n      }\n\n      e && (Math.abs(this.cameraDirection.x) < this.speed * Oe.Epsilon && (this.cameraDirection.x = 0), Math.abs(this.cameraDirection.y) < this.speed * Oe.Epsilon && (this.cameraDirection.y = 0), Math.abs(this.cameraDirection.z) < this.speed * Oe.Epsilon && (this.cameraDirection.z = 0), this.cameraDirection.scaleInPlace(this.inertia)), t && (Math.abs(this.cameraRotation.x) < this.speed * Oe.Epsilon && (this.cameraRotation.x = 0), Math.abs(this.cameraRotation.y) < this.speed * Oe.Epsilon && (this.cameraRotation.y = 0), this.cameraRotation.scaleInPlace(this.inertia)), o.prototype._checkInputs.call(this);\n    }, r.prototype._updateCameraRotationMatrix = function () {\n      this.rotationQuaternion ? this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix) : Oe.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n    }, r.prototype._rotateUpVectorWithCameraRotationMatrix = function () {\n      return Oe.Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector), this;\n    }, r.prototype._getViewMatrix = function () {\n      return this.lockedTarget && this.setTarget(this._getLockedTargetPosition()), this._updateCameraRotationMatrix(), this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z ? (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedQuaternionRotationZ = this.rotationQuaternion.z) : this._cachedRotationZ != this.rotation.z && (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedRotationZ = this.rotation.z), Oe.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget), this._computeViewMatrix(this.position, this._currentTarget, this.upVector), this._viewMatrix;\n    }, r.prototype._computeViewMatrix = function (e, t, i) {\n      if (this.parent) {\n        var r = this.parent.getWorldMatrix();\n        Oe.Vector3.TransformCoordinatesToRef(e, r, this._globalPosition), Oe.Vector3.TransformCoordinatesToRef(t, r, this._globalCurrentTarget), Oe.Vector3.TransformNormalToRef(i, r, this._globalCurrentUpVector), this._markSyncedWithParent();\n      } else this._globalPosition.copyFrom(e), this._globalCurrentTarget.copyFrom(t), this._globalCurrentUpVector.copyFrom(i);\n\n      this.getScene().useRightHandedSystem ? Oe.Matrix.LookAtRHToRef(this._globalPosition, this._globalCurrentTarget, this._globalCurrentUpVector, this._viewMatrix) : Oe.Matrix.LookAtLHToRef(this._globalPosition, this._globalCurrentTarget, this._globalCurrentUpVector, this._viewMatrix);\n    }, r.prototype.createRigCamera = function (e, t) {\n      if (this.cameraRigMode !== Oe.Camera.RIG_MODE_NONE) {\n        var i = new r(e, this.position.clone(), this.getScene());\n        return this.cameraRigMode !== Oe.Camera.RIG_MODE_VR && this.cameraRigMode !== Oe.Camera.RIG_MODE_WEBVR || (this.rotationQuaternion || (this.rotationQuaternion = new Oe.Quaternion()), i._cameraRigParams = {}, i.rotationQuaternion = new Oe.Quaternion()), i;\n      }\n\n      return null;\n    }, r.prototype._updateRigCameras = function () {\n      var e = this._rigCameras[0],\n          t = this._rigCameras[1];\n\n      switch (this.cameraRigMode) {\n        case Oe.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n        case Oe.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n        case Oe.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n        case Oe.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n          var i = this.cameraRigMode === Oe.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1,\n              r = this.cameraRigMode === Oe.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n          this._getRigCamPosition(this._cameraRigParams.stereoHalfAngle * i, e.position), this._getRigCamPosition(this._cameraRigParams.stereoHalfAngle * r, t.position), e.setTarget(this.getTarget()), t.setTarget(this.getTarget());\n          break;\n\n        case Oe.Camera.RIG_MODE_VR:\n          e.rotationQuaternion ? (e.rotationQuaternion.copyFrom(this.rotationQuaternion), t.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (e.rotation.copyFrom(this.rotation), t.rotation.copyFrom(this.rotation)), e.position.copyFrom(this.position), t.position.copyFrom(this.position);\n      }\n\n      o.prototype._updateRigCameras.call(this);\n    }, r.prototype._getRigCamPosition = function (e, t) {\n      this._rigCamTransformMatrix || (this._rigCamTransformMatrix = new Oe.Matrix());\n      var i = this.getTarget();\n      Oe.Matrix.Translation(-i.x, -i.y, -i.z).multiplyToRef(Oe.Matrix.RotationY(e), this._rigCamTransformMatrix), this._rigCamTransformMatrix = this._rigCamTransformMatrix.multiply(Oe.Matrix.Translation(i.x, i.y, i.z)), Oe.Vector3.TransformCoordinatesToRef(this.position, this._rigCamTransformMatrix, t);\n    }, r.prototype.getClassName = function () {\n      return \"TargetCamera\";\n    }, b([Oe.serializeAsVector3()], r.prototype, \"rotation\", void 0), b([Oe.serialize()], r.prototype, \"speed\", void 0), b([Oe.serializeAsMeshReference(\"lockedTargetId\")], r.prototype, \"lockedTarget\", void 0), r;\n  }(Oe.Camera), Oe.TargetCamera = De, Ie = $a || ($a = {}), we = function () {\n    function e(e) {\n      void 0 === e && (e = !0), this.touchEnabled = e, this.buttons = [0, 1, 2], this.angularSensibility = 2e3, this.previousPosition = null;\n    }\n\n    return e.prototype.attachControl = function (s, a) {\n      var l = this,\n          c = this.camera.getEngine();\n      this._pointerInput || (this._pointerInput = function (e, t) {\n        var i = e.event;\n\n        if (!c.isInVRExclusivePointerMode && (l.touchEnabled || \"touch\" !== i.pointerType) && (e.type === Ie.PointerEventTypes.POINTERMOVE || -1 !== l.buttons.indexOf(i.button))) {\n          var r = i.srcElement || i.target;\n\n          if (e.type === Ie.PointerEventTypes.POINTERDOWN && r) {\n            try {\n              r.setPointerCapture(i.pointerId);\n            } catch (e) {}\n\n            l.previousPosition = {\n              x: i.clientX,\n              y: i.clientY\n            }, a || (i.preventDefault(), s.focus());\n          } else if (e.type === Ie.PointerEventTypes.POINTERUP && r) {\n            try {\n              r.releasePointerCapture(i.pointerId);\n            } catch (e) {}\n\n            l.previousPosition = null, a || i.preventDefault();\n          } else if (e.type === Ie.PointerEventTypes.POINTERMOVE) {\n            if (!l.previousPosition || c.isPointerLock) return;\n            var n = i.clientX - l.previousPosition.x;\n            l.camera.getScene().useRightHandedSystem && (n *= -1), l.camera.parent && l.camera.parent._getWorldMatrixDeterminant() < 0 && (n *= -1), l.camera.cameraRotation.y += n / l.angularSensibility;\n            var o = i.clientY - l.previousPosition.y;\n            l.camera.cameraRotation.x += o / l.angularSensibility, l.previousPosition = {\n              x: i.clientX,\n              y: i.clientY\n            }, a || i.preventDefault();\n          }\n        }\n      }), this._onMouseMove = function (e) {\n        if (c.isPointerLock && !c.isInVRExclusivePointerMode) {\n          var t = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0;\n          l.camera.getScene().useRightHandedSystem && (t *= -1), l.camera.parent && l.camera.parent._getWorldMatrixDeterminant() < 0 && (t *= -1), l.camera.cameraRotation.y += t / l.angularSensibility;\n          var i = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;\n          l.camera.cameraRotation.x += i / l.angularSensibility, l.previousPosition = null, a || e.preventDefault();\n        }\n      }, this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, Ie.PointerEventTypes.POINTERDOWN | Ie.PointerEventTypes.POINTERUP | Ie.PointerEventTypes.POINTERMOVE), s.addEventListener(\"mousemove\", this._onMouseMove, !1);\n    }, e.prototype.detachControl = function (e) {\n      this._observer && e && (this.camera.getScene().onPointerObservable.remove(this._observer), this._onMouseMove && e.removeEventListener(\"mousemove\", this._onMouseMove), this._observer = null, this._onMouseMove = null, this.previousPosition = null);\n    }, e.prototype.getClassName = function () {\n      return \"FreeCameraMouseInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"mouse\";\n    }, b([Ie.serialize()], e.prototype, \"buttons\", void 0), b([Ie.serialize()], e.prototype, \"angularSensibility\", void 0), e;\n  }(), Ie.FreeCameraMouseInput = we, Ie.CameraInputTypes.FreeCameraMouseInput = we, Le = $a || ($a = {}), Fe = function () {\n    function e() {\n      this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39], this._keys = new Array();\n    }\n\n    return e.prototype.attachControl = function (e, r) {\n      var n = this;\n      this._onCanvasBlurObserver || (this._scene = this.camera.getScene(), this._engine = this._scene.getEngine(), this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function () {\n        n._keys = [];\n      }), this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function (e) {\n        var t,\n            i = e.event;\n        e.type === Le.KeyboardEventTypes.KEYDOWN ? -1 === n.keysUp.indexOf(i.keyCode) && -1 === n.keysDown.indexOf(i.keyCode) && -1 === n.keysLeft.indexOf(i.keyCode) && -1 === n.keysRight.indexOf(i.keyCode) || (-1 === (t = n._keys.indexOf(i.keyCode)) && n._keys.push(i.keyCode), r || i.preventDefault()) : -1 === n.keysUp.indexOf(i.keyCode) && -1 === n.keysDown.indexOf(i.keyCode) && -1 === n.keysLeft.indexOf(i.keyCode) && -1 === n.keysRight.indexOf(i.keyCode) || (0 <= (t = n._keys.indexOf(i.keyCode)) && n._keys.splice(t, 1), r || i.preventDefault());\n      }));\n    }, e.prototype.detachControl = function (e) {\n      this._scene && (this._onKeyboardObserver && this._scene.onKeyboardObservable.remove(this._onKeyboardObserver), this._onCanvasBlurObserver && this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver), this._onKeyboardObserver = null, this._onCanvasBlurObserver = null), this._keys = [];\n    }, e.prototype.checkInputs = function () {\n      if (this._onKeyboardObserver) for (var e = this.camera, t = 0; t < this._keys.length; t++) {\n        var i = this._keys[t],\n            r = e._computeLocalCameraSpeed();\n\n        -1 !== this.keysLeft.indexOf(i) ? e._localDirection.copyFromFloats(-r, 0, 0) : -1 !== this.keysUp.indexOf(i) ? e._localDirection.copyFromFloats(0, 0, r) : -1 !== this.keysRight.indexOf(i) ? e._localDirection.copyFromFloats(r, 0, 0) : -1 !== this.keysDown.indexOf(i) && e._localDirection.copyFromFloats(0, 0, -r), e.getScene().useRightHandedSystem && (e._localDirection.z *= -1), e.getViewMatrix().invertToRef(e._cameraTransformMatrix), Le.Vector3.TransformNormalToRef(e._localDirection, e._cameraTransformMatrix, e._transformedDirection), e.cameraDirection.addInPlace(e._transformedDirection);\n      }\n    }, e.prototype.getClassName = function () {\n      return \"FreeCameraKeyboardMoveInput\";\n    }, e.prototype._onLostFocus = function (e) {\n      this._keys = [];\n    }, e.prototype.getSimpleName = function () {\n      return \"keyboard\";\n    }, b([Le.serialize()], e.prototype, \"keysUp\", void 0), b([Le.serialize()], e.prototype, \"keysDown\", void 0), b([Le.serialize()], e.prototype, \"keysLeft\", void 0), b([Le.serialize()], e.prototype, \"keysRight\", void 0), e;\n  }(), Le.FreeCameraKeyboardMoveInput = Fe, Le.CameraInputTypes.FreeCameraKeyboardMoveInput = Fe, Be = $a || ($a = {}), Ne = function (t) {\n    function e(e) {\n      return t.call(this, e) || this;\n    }\n\n    return T(e, t), e.prototype.addKeyboard = function () {\n      return this.add(new Be.FreeCameraKeyboardMoveInput()), this;\n    }, e.prototype.addMouse = function (e) {\n      return void 0 === e && (e = !0), this.add(new Be.FreeCameraMouseInput(e)), this;\n    }, e.prototype.addDeviceOrientation = function () {\n      return this.add(new Be.FreeCameraDeviceOrientationInput()), this;\n    }, e.prototype.addTouch = function () {\n      return this.add(new Be.FreeCameraTouchInput()), this;\n    }, e.prototype.addVirtualJoystick = function () {\n      return this.add(new Be.FreeCameraVirtualJoystickInput()), this;\n    }, e;\n  }(Be.CameraInputsManager), Be.FreeCameraInputsManager = Ne, function (s) {\n    s.Node.AddNodeConstructor(\"FreeCamera\", function (e, t) {\n      return function () {\n        return new s.UniversalCamera(e, s.Vector3.Zero(), t);\n      };\n    });\n\n    var e = function (o) {\n      function e(e, t, i, r) {\n        void 0 === r && (r = !0);\n        var n = o.call(this, e, t, i, r) || this;\n        return n.ellipsoid = new s.Vector3(.5, 1, .5), n.ellipsoidOffset = new s.Vector3(0, 0, 0), n.checkCollisions = !1, n.applyGravity = !1, n._needMoveForGravity = !1, n._oldPosition = s.Vector3.Zero(), n._diffPosition = s.Vector3.Zero(), n._newPosition = s.Vector3.Zero(), n._collisionMask = -1, n._onCollisionPositionChange = function (e, t, i) {\n          void 0 === i && (i = null), n.getScene().workerCollisions && t.multiplyInPlace(n._collider._radius);\n          var r;\n          r = t, n._newPosition.copyFrom(r), n._newPosition.subtractToRef(n._oldPosition, n._diffPosition), n._diffPosition.length() > s.Engine.CollisionsEpsilon && (n.position.addInPlace(n._diffPosition), n.onCollide && i && n.onCollide(i));\n        }, n.inputs = new s.FreeCameraInputsManager(n), n.inputs.addKeyboard().addMouse(), n;\n      }\n\n      return T(e, o), Object.defineProperty(e.prototype, \"angularSensibility\", {\n        get: function () {\n          var e = this.inputs.attached.mouse;\n          return e ? e.angularSensibility : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.mouse;\n          t && (t.angularSensibility = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"keysUp\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysUp : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysUp = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"keysDown\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysDown : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysDown = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"keysLeft\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysLeft : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysLeft = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"keysRight\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysRight : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysRight = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.attachControl = function (e, t) {\n        this.inputs.attachElement(e, t);\n      }, e.prototype.detachControl = function (e) {\n        this.inputs.detachElement(e), this.cameraDirection = new s.Vector3(0, 0, 0), this.cameraRotation = new s.Vector2(0, 0);\n      }, Object.defineProperty(e.prototype, \"collisionMask\", {\n        get: function () {\n          return this._collisionMask;\n        },\n        set: function (e) {\n          this._collisionMask = isNaN(e) ? -1 : e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype._collideWithWorld = function (e) {\n        (this.parent ? s.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix()) : this.position).subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition), this._oldPosition.addInPlace(this.ellipsoidOffset), this._collider || (this._collider = new s.Collider()), this._collider._radius = this.ellipsoid, this._collider.collisionMask = this._collisionMask;\n        var t = e;\n        this.applyGravity && (t = e.add(this.getScene().gravity)), this.getScene().collisionCoordinator.getNewPosition(this._oldPosition, t, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n      }, e.prototype._checkInputs = function () {\n        this._localDirection || (this._localDirection = s.Vector3.Zero(), this._transformedDirection = s.Vector3.Zero()), this.inputs.checkInputs(), o.prototype._checkInputs.call(this);\n      }, e.prototype._decideIfNeedsToMove = function () {\n        return this._needMoveForGravity || 0 < Math.abs(this.cameraDirection.x) || 0 < Math.abs(this.cameraDirection.y) || 0 < Math.abs(this.cameraDirection.z);\n      }, e.prototype._updatePosition = function () {\n        this.checkCollisions && this.getScene().collisionsEnabled ? this._collideWithWorld(this.cameraDirection) : o.prototype._updatePosition.call(this);\n      }, e.prototype.dispose = function () {\n        this.inputs.clear(), o.prototype.dispose.call(this);\n      }, e.prototype.getClassName = function () {\n        return \"FreeCamera\";\n      }, b([s.serializeAsVector3()], e.prototype, \"ellipsoid\", void 0), b([s.serializeAsVector3()], e.prototype, \"ellipsoidOffset\", void 0), b([s.serialize()], e.prototype, \"checkCollisions\", void 0), b([s.serialize()], e.prototype, \"applyGravity\", void 0), e;\n    }(s.TargetCamera);\n\n    s.FreeCamera = e;\n  }($a || ($a = {})), Ve = $a || ($a = {}), Ue = function () {\n    function e() {\n      this.keysUp = [38], this.keysDown = [40], this.keysLeft = [37], this.keysRight = [39], this.keysReset = [220], this.panningSensibility = 50, this.zoomingSensibility = 25, this.useAltToZoom = !0, this.angularSpeed = .01, this._keys = new Array();\n    }\n\n    return e.prototype.attachControl = function (e, r) {\n      var n = this;\n      this._onCanvasBlurObserver || (this._scene = this.camera.getScene(), this._engine = this._scene.getEngine(), this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(function () {\n        n._keys = [];\n      }), this._onKeyboardObserver = this._scene.onKeyboardObservable.add(function (e) {\n        var t,\n            i = e.event;\n        e.type === Ve.KeyboardEventTypes.KEYDOWN ? (n._ctrlPressed = i.ctrlKey, n._altPressed = i.altKey, (-1 !== n.keysUp.indexOf(i.keyCode) || -1 !== n.keysDown.indexOf(i.keyCode) || -1 !== n.keysLeft.indexOf(i.keyCode) || -1 !== n.keysRight.indexOf(i.keyCode) || -1 !== n.keysReset.indexOf(i.keyCode)) && (-1 === (t = n._keys.indexOf(i.keyCode)) && n._keys.push(i.keyCode), i.preventDefault && (r || i.preventDefault()))) : -1 === n.keysUp.indexOf(i.keyCode) && -1 === n.keysDown.indexOf(i.keyCode) && -1 === n.keysLeft.indexOf(i.keyCode) && -1 === n.keysRight.indexOf(i.keyCode) && -1 === n.keysReset.indexOf(i.keyCode) || (0 <= (t = n._keys.indexOf(i.keyCode)) && n._keys.splice(t, 1), i.preventDefault && (r || i.preventDefault()));\n      }));\n    }, e.prototype.detachControl = function (e) {\n      this._scene && (this._onKeyboardObserver && this._scene.onKeyboardObservable.remove(this._onKeyboardObserver), this._onCanvasBlurObserver && this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver), this._onKeyboardObserver = null, this._onCanvasBlurObserver = null), this._keys = [];\n    }, e.prototype.checkInputs = function () {\n      if (this._onKeyboardObserver) for (var e = this.camera, t = 0; t < this._keys.length; t++) {\n        var i = this._keys[t];\n        -1 !== this.keysLeft.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningX -= 1 / this.panningSensibility : e.inertialAlphaOffset -= this.angularSpeed : -1 !== this.keysUp.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningY += 1 / this.panningSensibility : this._altPressed && this.useAltToZoom ? e.inertialRadiusOffset += 1 / this.zoomingSensibility : e.inertialBetaOffset -= this.angularSpeed : -1 !== this.keysRight.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningX += 1 / this.panningSensibility : e.inertialAlphaOffset += this.angularSpeed : -1 !== this.keysDown.indexOf(i) ? this._ctrlPressed && this.camera._useCtrlForPanning ? e.inertialPanningY -= 1 / this.panningSensibility : this._altPressed && this.useAltToZoom ? e.inertialRadiusOffset -= 1 / this.zoomingSensibility : e.inertialBetaOffset += this.angularSpeed : -1 !== this.keysReset.indexOf(i) && e.useInputToRestoreState && e.restoreState();\n      }\n    }, e.prototype.getClassName = function () {\n      return \"ArcRotateCameraKeyboardMoveInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"keyboard\";\n    }, b([Ve.serialize()], e.prototype, \"keysUp\", void 0), b([Ve.serialize()], e.prototype, \"keysDown\", void 0), b([Ve.serialize()], e.prototype, \"keysLeft\", void 0), b([Ve.serialize()], e.prototype, \"keysRight\", void 0), b([Ve.serialize()], e.prototype, \"keysReset\", void 0), b([Ve.serialize()], e.prototype, \"panningSensibility\", void 0), b([Ve.serialize()], e.prototype, \"zoomingSensibility\", void 0), b([Ve.serialize()], e.prototype, \"useAltToZoom\", void 0), b([Ve.serialize()], e.prototype, \"angularSpeed\", void 0), e;\n  }(), Ve.ArcRotateCameraKeyboardMoveInput = Ue, Ve.CameraInputTypes.ArcRotateCameraKeyboardMoveInput = Ue, ze = $a || ($a = {}), Ge = function () {\n    function e() {\n      this.wheelPrecision = 3, this.wheelDeltaPercentage = 0;\n    }\n\n    return e.prototype.attachControl = function (e, o) {\n      var s = this;\n      this._wheel = function (e, t) {\n        if (e.type === ze.PointerEventTypes.POINTERWHEEL) {\n          var i = e.event,\n              r = 0;\n          if (i.wheelDelta) {\n            if (s.wheelDeltaPercentage) {\n              var n = .01 * i.wheelDelta * s.wheelDeltaPercentage * s.camera.radius;\n              r = 0 < i.wheelDelta ? n / (1 + s.wheelDeltaPercentage) : n * (1 + s.wheelDeltaPercentage);\n            } else r = i.wheelDelta / (40 * s.wheelPrecision);\n          } else i.detail && (r = -i.detail / s.wheelPrecision);\n          r && (s.camera.inertialRadiusOffset += r), i.preventDefault && (o || i.preventDefault());\n        }\n      }, this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, ze.PointerEventTypes.POINTERWHEEL);\n    }, e.prototype.detachControl = function (e) {\n      this._observer && e && (this.camera.getScene().onPointerObservable.remove(this._observer), this._observer = null, this._wheel = null);\n    }, e.prototype.getClassName = function () {\n      return \"ArcRotateCameraMouseWheelInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"mousewheel\";\n    }, b([ze.serialize()], e.prototype, \"wheelPrecision\", void 0), b([ze.serialize()], e.prototype, \"wheelDeltaPercentage\", void 0), e;\n  }(), ze.ArcRotateCameraMouseWheelInput = Ge, ze.CameraInputTypes.ArcRotateCameraMouseWheelInput = Ge, ke = $a || ($a = {}), We = function () {\n    function e() {\n      this.buttons = [0, 1, 2], this.angularSensibilityX = 1e3, this.angularSensibilityY = 1e3, this.pinchPrecision = 12, this.pinchDeltaPercentage = 0, this.panningSensibility = 1e3, this.multiTouchPanning = !0, this.multiTouchPanAndZoom = !0, this.pinchInwards = !0, this._isPanClick = !1;\n    }\n\n    return e.prototype.attachControl = function (g, v) {\n      var y,\n          b = this,\n          T = this.camera.getEngine(),\n          E = null,\n          x = null,\n          P = 0,\n          A = 0,\n          S = 0,\n          M = {\n        x: 0,\n        y: 0,\n        isPaning: !1,\n        isPinching: !1\n      };\n      this._pointerInput = function (e, t) {\n        var i = e.event,\n            r = \"touch\" === e.event.pointerType;\n\n        if (!T.isInVRExclusivePointerMode && (e.type === ke.PointerEventTypes.POINTERMOVE || -1 !== b.buttons.indexOf(i.button))) {\n          var n = i.srcElement || i.target;\n\n          if (e.type === ke.PointerEventTypes.POINTERDOWN && n) {\n            try {\n              n.setPointerCapture(i.pointerId);\n            } catch (e) {}\n\n            b._isPanClick = i.button === b.camera._panningMouseButton, y = {\n              x: i.clientX,\n              y: i.clientY,\n              pointerId: i.pointerId,\n              type: i.pointerType\n            }, null === E ? E = y : null === x && (x = y), v || (i.preventDefault(), g.focus());\n          } else if (e.type === ke.PointerEventTypes.POINTERDOUBLETAP) b.camera.useInputToRestoreState && b.camera.restoreState();else if (e.type === ke.PointerEventTypes.POINTERUP && n) {\n            try {\n              n.releasePointerCapture(i.pointerId);\n            } catch (e) {}\n\n            y = null, P = 0, M.isPaning = !1, M.isPinching = !1, A = S = 0, r || (x = null), T._badOS ? E = x = null : x && E && E.pointerId == i.pointerId ? (E = x, x = null, y = {\n              x: E.x,\n              y: E.y,\n              pointerId: E.pointerId,\n              type: i.pointerType\n            }) : E && x && x.pointerId == i.pointerId ? (x = null, y = {\n              x: E.x,\n              y: E.y,\n              pointerId: E.pointerId,\n              type: i.pointerType\n            }) : E = x = null, v || i.preventDefault();\n          } else if (e.type === ke.PointerEventTypes.POINTERMOVE) if (v || i.preventDefault(), E && null === x && y) {\n            if (0 !== b.panningSensibility && (i.ctrlKey && b.camera._useCtrlForPanning || b._isPanClick)) b.camera.inertialPanningX += -(i.clientX - y.x) / b.panningSensibility, b.camera.inertialPanningY += (i.clientY - y.y) / b.panningSensibility;else {\n              var o = i.clientX - y.x,\n                  s = i.clientY - y.y;\n              b.camera.inertialAlphaOffset -= o / b.angularSensibilityX, b.camera.inertialBetaOffset -= s / b.angularSensibilityY;\n            }\n            y.x = i.clientX, y.y = i.clientY;\n          } else if (E && x) {\n            var a = E.pointerId === i.pointerId ? E : x;\n            a.x = i.clientX, a.y = i.clientY;\n            var l = b.pinchInwards ? 1 : -1,\n                c = E.x - x.x,\n                h = E.y - x.y,\n                u = c * c + h * h,\n                d = Math.sqrt(u);\n            if (0 === P) return A = d, P = u, M.x = (E.x + x.x) / 2, void (M.y = (E.y + x.y) / 2);\n\n            if (b.multiTouchPanAndZoom) {\n              if (b.pinchDeltaPercentage ? b.camera.inertialRadiusOffset += .001 * (u - P) * b.camera.radius * b.pinchDeltaPercentage : b.camera.inertialRadiusOffset += (u - P) / (b.pinchPrecision * ((b.angularSensibilityX + b.angularSensibilityY) / 2) * l), 0 !== b.panningSensibility) {\n                var f = (E.x + x.x) / 2,\n                    p = (E.y + x.y) / 2,\n                    _ = f - M.x,\n                    m = p - M.y;\n\n                M.x = f, M.y = p, b.camera.inertialPanningX += -_ / b.panningSensibility, b.camera.inertialPanningY += m / b.panningSensibility;\n              }\n            } else {\n              if (S++, M.isPinching || S < 20 && Math.abs(d - A) > b.camera.pinchToPanMaxDistance) b.pinchDeltaPercentage ? b.camera.inertialRadiusOffset += .001 * (u - P) * b.camera.radius * b.pinchDeltaPercentage : b.camera.inertialRadiusOffset += (u - P) / (b.pinchPrecision * ((b.angularSensibilityX + b.angularSensibilityY) / 2) * l), M.isPaning = !1, M.isPinching = !0;else if (y && y.pointerId === a.pointerId && 0 !== b.panningSensibility && b.multiTouchPanning) {\n                if (!M.isPaning) return M.isPaning = !0, M.isPinching = !1, M.x = a.x, void (M.y = a.y);\n                b.camera.inertialPanningX += -(a.x - M.x) / b.panningSensibility, b.camera.inertialPanningY += (a.y - M.y) / b.panningSensibility;\n              }\n              y && y.pointerId === i.pointerId && (M.x = a.x, M.y = a.y);\n            }\n\n            P = u;\n          }\n        }\n      }, this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, ke.PointerEventTypes.POINTERDOWN | ke.PointerEventTypes.POINTERUP | ke.PointerEventTypes.POINTERMOVE | ke.PointerEventTypes.POINTERDOUBLETAP), this._onContextMenu = function (e) {\n        e.preventDefault();\n      }, this.camera._useCtrlForPanning || g.addEventListener(\"contextmenu\", this._onContextMenu, !1), this._onLostFocus = function () {\n        E = x = null, P = 0, M.isPaning = !1, M.isPinching = !1, y = null, A = S = 0;\n      }, this._onMouseMove = function (e) {\n        if (T.isPointerLock) {\n          var t = e.movementX || e.mozMovementX || e.webkitMovementX || e.msMovementX || 0,\n              i = e.movementY || e.mozMovementY || e.webkitMovementY || e.msMovementY || 0;\n          b.camera.inertialAlphaOffset -= t / b.angularSensibilityX, b.camera.inertialBetaOffset -= i / b.angularSensibilityY, v || e.preventDefault();\n        }\n      }, this._onGestureStart = function (e) {\n        void 0 !== window.MSGesture && (b._MSGestureHandler || (b._MSGestureHandler = new MSGesture(), b._MSGestureHandler.target = g), b._MSGestureHandler.addPointer(e.pointerId));\n      }, this._onGesture = function (e) {\n        b.camera.radius *= e.scale, e.preventDefault && (v || (e.stopPropagation(), e.preventDefault()));\n      }, g.addEventListener(\"mousemove\", this._onMouseMove, !1), g.addEventListener(\"MSPointerDown\", this._onGestureStart, !1), g.addEventListener(\"MSGestureChange\", this._onGesture, !1), ke.Tools.RegisterTopRootEvents([{\n        name: \"blur\",\n        handler: this._onLostFocus\n      }]);\n    }, e.prototype.detachControl = function (e) {\n      this._onLostFocus && ke.Tools.UnregisterTopRootEvents([{\n        name: \"blur\",\n        handler: this._onLostFocus\n      }]), e && this._observer && (this.camera.getScene().onPointerObservable.remove(this._observer), this._observer = null, this._onContextMenu && e.removeEventListener(\"contextmenu\", this._onContextMenu), this._onMouseMove && e.removeEventListener(\"mousemove\", this._onMouseMove), this._onGestureStart && e.removeEventListener(\"MSPointerDown\", this._onGestureStart), this._onGesture && e.removeEventListener(\"MSGestureChange\", this._onGesture), this._isPanClick = !1, this.pinchInwards = !0, this._onMouseMove = null, this._onGestureStart = null, this._onGesture = null, this._MSGestureHandler = null, this._onLostFocus = null, this._onContextMenu = null);\n    }, e.prototype.getClassName = function () {\n      return \"ArcRotateCameraPointersInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"pointers\";\n    }, b([ke.serialize()], e.prototype, \"buttons\", void 0), b([ke.serialize()], e.prototype, \"angularSensibilityX\", void 0), b([ke.serialize()], e.prototype, \"angularSensibilityY\", void 0), b([ke.serialize()], e.prototype, \"pinchPrecision\", void 0), b([ke.serialize()], e.prototype, \"pinchDeltaPercentage\", void 0), b([ke.serialize()], e.prototype, \"panningSensibility\", void 0), b([ke.serialize()], e.prototype, \"multiTouchPanning\", void 0), b([ke.serialize()], e.prototype, \"multiTouchPanAndZoom\", void 0), e;\n  }(), ke.ArcRotateCameraPointersInput = We, ke.CameraInputTypes.ArcRotateCameraPointersInput = We, He = $a || ($a = {}), Xe = function (t) {\n    function e(e) {\n      return t.call(this, e) || this;\n    }\n\n    return T(e, t), e.prototype.addMouseWheel = function () {\n      return this.add(new He.ArcRotateCameraMouseWheelInput()), this;\n    }, e.prototype.addPointers = function () {\n      return this.add(new He.ArcRotateCameraPointersInput()), this;\n    }, e.prototype.addKeyboard = function () {\n      return this.add(new He.ArcRotateCameraKeyboardMoveInput()), this;\n    }, e.prototype.addVRDeviceOrientation = function () {\n      return this.add(new He.ArcRotateCameraVRDeviceOrientationInput()), this;\n    }, e;\n  }(He.CameraInputsManager), He.ArcRotateCameraInputsManager = Xe, function (l) {\n    l.Node.AddNodeConstructor(\"ArcRotateCamera\", function (e, t) {\n      return function () {\n        return new i(e, 0, 0, 1, l.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (a) {\n      function n(e, t, i, r, n, o, s) {\n        void 0 === s && (s = !0);\n        var c = a.call(this, e, l.Vector3.Zero(), o, s) || this;\n        return c.inertialAlphaOffset = 0, c.inertialBetaOffset = 0, c.inertialRadiusOffset = 0, c.lowerAlphaLimit = null, c.upperAlphaLimit = null, c.lowerBetaLimit = .01, c.upperBetaLimit = Math.PI, c.lowerRadiusLimit = null, c.upperRadiusLimit = null, c.inertialPanningX = 0, c.inertialPanningY = 0, c.pinchToPanMaxDistance = 20, c.panningDistanceLimit = null, c.panningOriginTarget = l.Vector3.Zero(), c.panningInertia = .9, c.zoomOnFactor = 1, c.targetScreenOffset = l.Vector2.Zero(), c.allowUpsideDown = !0, c.useInputToRestoreState = !0, c._viewMatrix = new l.Matrix(), c.panningAxis = new l.Vector3(1, 1, 0), c.onMeshTargetChangedObservable = new l.Observable(), c.checkCollisions = !1, c.collisionRadius = new l.Vector3(.5, .5, .5), c._previousPosition = l.Vector3.Zero(), c._collisionVelocity = l.Vector3.Zero(), c._newPosition = l.Vector3.Zero(), c._computationVector = l.Vector3.Zero(), c._onCollisionPositionChange = function (e, t, i) {\n          void 0 === i && (i = null), c.getScene().workerCollisions && c.checkCollisions && t.multiplyInPlace(c._collider._radius), i ? (c.setPosition(t), c.onCollide && c.onCollide(i)) : c._previousPosition.copyFrom(c.position);\n          var r = Math.cos(c.alpha),\n              n = Math.sin(c.alpha),\n              o = Math.cos(c.beta),\n              s = Math.sin(c.beta);\n          0 === s && (s = 1e-4);\n\n          var a = c._getTargetPosition();\n\n          c._computationVector.copyFromFloats(c.radius * r * s, c.radius * o, c.radius * n * s), a.addToRef(c._computationVector, c._newPosition), c.position.copyFrom(c._newPosition);\n          var l = c.upVector;\n          c.allowUpsideDown && c.beta < 0 && (l = (l = l.clone()).negate()), c._computeViewMatrix(c.position, a, l), c._viewMatrix.m[12] += c.targetScreenOffset.x, c._viewMatrix.m[13] += c.targetScreenOffset.y, c._collisionTriggered = !1;\n        }, c._target = l.Vector3.Zero(), n && c.setTarget(n), c.alpha = t, c.beta = i, c.radius = r, c.getViewMatrix(), c.inputs = new l.ArcRotateCameraInputsManager(c), c.inputs.addKeyboard().addMouseWheel().addPointers(), c;\n      }\n\n      return T(n, a), Object.defineProperty(n.prototype, \"target\", {\n        get: function () {\n          return this._target;\n        },\n        set: function (e) {\n          this.setTarget(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"angularSensibilityX\", {\n        get: function () {\n          var e = this.inputs.attached.pointers;\n          return e ? e.angularSensibilityX : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.pointers;\n          t && (t.angularSensibilityX = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"angularSensibilityY\", {\n        get: function () {\n          var e = this.inputs.attached.pointers;\n          return e ? e.angularSensibilityY : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.pointers;\n          t && (t.angularSensibilityY = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"pinchPrecision\", {\n        get: function () {\n          var e = this.inputs.attached.pointers;\n          return e ? e.pinchPrecision : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.pointers;\n          t && (t.pinchPrecision = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"pinchDeltaPercentage\", {\n        get: function () {\n          var e = this.inputs.attached.pointers;\n          return e ? e.pinchDeltaPercentage : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.pointers;\n          t && (t.pinchDeltaPercentage = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"panningSensibility\", {\n        get: function () {\n          var e = this.inputs.attached.pointers;\n          return e ? e.panningSensibility : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.pointers;\n          t && (t.panningSensibility = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"keysUp\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysUp : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysUp = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"keysDown\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysDown : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysDown = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"keysLeft\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysLeft : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysLeft = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"keysRight\", {\n        get: function () {\n          var e = this.inputs.attached.keyboard;\n          return e ? e.keysRight : [];\n        },\n        set: function (e) {\n          var t = this.inputs.attached.keyboard;\n          t && (t.keysRight = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"wheelPrecision\", {\n        get: function () {\n          var e = this.inputs.attached.mousewheel;\n          return e ? e.wheelPrecision : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.mousewheel;\n          t && (t.wheelPrecision = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"wheelDeltaPercentage\", {\n        get: function () {\n          var e = this.inputs.attached.mousewheel;\n          return e ? e.wheelDeltaPercentage : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.mousewheel;\n          t && (t.wheelDeltaPercentage = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"bouncingBehavior\", {\n        get: function () {\n          return this._bouncingBehavior;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"useBouncingBehavior\", {\n        get: function () {\n          return null != this._bouncingBehavior;\n        },\n        set: function (e) {\n          e !== this.useBouncingBehavior && (e ? (this._bouncingBehavior = new l.BouncingBehavior(), this.addBehavior(this._bouncingBehavior)) : this._bouncingBehavior && (this.removeBehavior(this._bouncingBehavior), this._bouncingBehavior = null));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"framingBehavior\", {\n        get: function () {\n          return this._framingBehavior;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"useFramingBehavior\", {\n        get: function () {\n          return null != this._framingBehavior;\n        },\n        set: function (e) {\n          e !== this.useFramingBehavior && (e ? (this._framingBehavior = new l.FramingBehavior(), this.addBehavior(this._framingBehavior)) : this._framingBehavior && (this.removeBehavior(this._framingBehavior), this._framingBehavior = null));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"autoRotationBehavior\", {\n        get: function () {\n          return this._autoRotationBehavior;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(n.prototype, \"useAutoRotationBehavior\", {\n        get: function () {\n          return null != this._autoRotationBehavior;\n        },\n        set: function (e) {\n          e !== this.useAutoRotationBehavior && (e ? (this._autoRotationBehavior = new l.AutoRotationBehavior(), this.addBehavior(this._autoRotationBehavior)) : this._autoRotationBehavior && (this.removeBehavior(this._autoRotationBehavior), this._autoRotationBehavior = null));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), n.prototype._initCache = function () {\n        a.prototype._initCache.call(this), this._cache._target = new l.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.alpha = void 0, this._cache.beta = void 0, this._cache.radius = void 0, this._cache.targetScreenOffset = l.Vector2.Zero();\n      }, n.prototype._updateCache = function (e) {\n        e || a.prototype._updateCache.call(this), this._cache._target.copyFrom(this._getTargetPosition()), this._cache.alpha = this.alpha, this._cache.beta = this.beta, this._cache.radius = this.radius, this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\n      }, n.prototype._getTargetPosition = function () {\n        if (this._targetHost && this._targetHost.getAbsolutePosition) {\n          var e = this._targetHost.getAbsolutePosition();\n\n          this._targetBoundingCenter ? e.addToRef(this._targetBoundingCenter, this._target) : this._target.copyFrom(e);\n        }\n\n        var t = this._getLockedTargetPosition();\n\n        return t || this._target;\n      }, n.prototype.storeState = function () {\n        return this._storedAlpha = this.alpha, this._storedBeta = this.beta, this._storedRadius = this.radius, this._storedTarget = this._getTargetPosition().clone(), a.prototype.storeState.call(this);\n      }, n.prototype._restoreStateValues = function () {\n        return !!a.prototype._restoreStateValues.call(this) && (this.alpha = this._storedAlpha, this.beta = this._storedBeta, this.radius = this._storedRadius, this.setTarget(this._storedTarget.clone()), this.inertialAlphaOffset = 0, this.inertialBetaOffset = 0, this.inertialRadiusOffset = 0, this.inertialPanningX = 0, !(this.inertialPanningY = 0));\n      }, n.prototype._isSynchronizedViewMatrix = function () {\n        return !!a.prototype._isSynchronizedViewMatrix.call(this) && this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);\n      }, n.prototype.attachControl = function (e, t, i, r) {\n        var n = this;\n        void 0 === i && (i = !0), void 0 === r && (r = 2), this._useCtrlForPanning = i, this._panningMouseButton = r, this.inputs.attachElement(e, t), this._reset = function () {\n          n.inertialAlphaOffset = 0, n.inertialBetaOffset = 0, n.inertialRadiusOffset = 0, n.inertialPanningX = 0, n.inertialPanningY = 0;\n        };\n      }, n.prototype.detachControl = function (e) {\n        this.inputs.detachElement(e), this._reset && this._reset();\n      }, n.prototype._checkInputs = function () {\n        if (!this._collisionTriggered) {\n          if (this.inputs.checkInputs(), 0 !== this.inertialAlphaOffset || 0 !== this.inertialBetaOffset || 0 !== this.inertialRadiusOffset) {\n            var e = this.inertialAlphaOffset;\n            this.beta <= 0 && (e *= -1), this.getScene().useRightHandedSystem && (e *= -1), this.parent && this.parent._getWorldMatrixDeterminant() < 0 && (e *= -1), this.alpha += e, this.beta += this.inertialBetaOffset, this.radius -= this.inertialRadiusOffset, this.inertialAlphaOffset *= this.inertia, this.inertialBetaOffset *= this.inertia, this.inertialRadiusOffset *= this.inertia, Math.abs(this.inertialAlphaOffset) < l.Epsilon && (this.inertialAlphaOffset = 0), Math.abs(this.inertialBetaOffset) < l.Epsilon && (this.inertialBetaOffset = 0), Math.abs(this.inertialRadiusOffset) < this.speed * l.Epsilon && (this.inertialRadiusOffset = 0);\n          }\n\n          if (0 !== this.inertialPanningX || 0 !== this.inertialPanningY) {\n            if (this._localDirection || (this._localDirection = l.Vector3.Zero(), this._transformedDirection = l.Vector3.Zero()), this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY), this._localDirection.multiplyInPlace(this.panningAxis), this._viewMatrix.invertToRef(this._cameraTransformMatrix), l.Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection), this.panningAxis.y || (this._transformedDirection.y = 0), !this._targetHost) if (this.panningDistanceLimit) this._transformedDirection.addInPlace(this._target), l.Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget) <= this.panningDistanceLimit * this.panningDistanceLimit && this._target.copyFrom(this._transformedDirection);else this._target.addInPlace(this._transformedDirection);\n            this.inertialPanningX *= this.panningInertia, this.inertialPanningY *= this.panningInertia, Math.abs(this.inertialPanningX) < this.speed * l.Epsilon && (this.inertialPanningX = 0), Math.abs(this.inertialPanningY) < this.speed * l.Epsilon && (this.inertialPanningY = 0);\n          }\n\n          this._checkLimits(), a.prototype._checkInputs.call(this);\n        }\n      }, n.prototype._checkLimits = function () {\n        null === this.lowerBetaLimit || void 0 === this.lowerBetaLimit ? this.allowUpsideDown && this.beta > Math.PI && (this.beta = this.beta - 2 * Math.PI) : this.beta < this.lowerBetaLimit && (this.beta = this.lowerBetaLimit), null === this.upperBetaLimit || void 0 === this.upperBetaLimit ? this.allowUpsideDown && this.beta < -Math.PI && (this.beta = this.beta + 2 * Math.PI) : this.beta > this.upperBetaLimit && (this.beta = this.upperBetaLimit), null !== this.lowerAlphaLimit && this.alpha < this.lowerAlphaLimit && (this.alpha = this.lowerAlphaLimit), null !== this.upperAlphaLimit && this.alpha > this.upperAlphaLimit && (this.alpha = this.upperAlphaLimit), null !== this.lowerRadiusLimit && this.radius < this.lowerRadiusLimit && (this.radius = this.lowerRadiusLimit), null !== this.upperRadiusLimit && this.radius > this.upperRadiusLimit && (this.radius = this.upperRadiusLimit);\n      }, n.prototype.rebuildAnglesAndRadius = function () {\n        this.position.subtractToRef(this._getTargetPosition(), this._computationVector), this.radius = this._computationVector.length(), 0 === this.radius && (this.radius = 1e-4), this.alpha = Math.acos(this._computationVector.x / Math.sqrt(Math.pow(this._computationVector.x, 2) + Math.pow(this._computationVector.z, 2))), this._computationVector.z < 0 && (this.alpha = 2 * Math.PI - this.alpha), this.beta = Math.acos(this._computationVector.y / this.radius), this._checkLimits();\n      }, n.prototype.setPosition = function (e) {\n        this.position.equals(e) || (this.position.copyFrom(e), this.rebuildAnglesAndRadius());\n      }, n.prototype.setTarget = function (e, t, i) {\n        if (void 0 === t && (t = !1), void 0 === i && (i = !1), e.getBoundingInfo) this._targetBoundingCenter = t ? e.getBoundingInfo().boundingBox.centerWorld.clone() : null, this._targetHost = e, this._target = this._getTargetPosition(), this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);else {\n          var r = e,\n              n = this._getTargetPosition();\n\n          if (n && !i && n.equals(r)) return;\n          this._targetHost = null, this._target = r, this._targetBoundingCenter = null, this.onMeshTargetChangedObservable.notifyObservers(null);\n        }\n        this.rebuildAnglesAndRadius();\n      }, n.prototype._getViewMatrix = function () {\n        var e = Math.cos(this.alpha),\n            t = Math.sin(this.alpha),\n            i = Math.cos(this.beta),\n            r = Math.sin(this.beta);\n        0 === r && (r = 1e-4);\n\n        var n = this._getTargetPosition();\n\n        if (this._computationVector.copyFromFloats(this.radius * e * r, this.radius * i, this.radius * t * r), n.addToRef(this._computationVector, this._newPosition), this.getScene().collisionsEnabled && this.checkCollisions) this._collider || (this._collider = new l.Collider()), this._collider._radius = this.collisionRadius, this._newPosition.subtractToRef(this.position, this._collisionVelocity), this._collisionTriggered = !0, this.getScene().collisionCoordinator.getNewPosition(this.position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);else {\n          this.position.copyFrom(this._newPosition);\n          var o = this.upVector;\n          this.allowUpsideDown && r < 0 && (o = (o = o.clone()).negate()), this._computeViewMatrix(this.position, n, o), this._viewMatrix.m[12] += this.targetScreenOffset.x, this._viewMatrix.m[13] += this.targetScreenOffset.y;\n        }\n        return this._currentTarget = n, this._viewMatrix;\n      }, n.prototype.zoomOn = function (e, t) {\n        void 0 === t && (t = !1), e = e || this.getScene().meshes;\n        var i = l.Mesh.MinMax(e),\n            r = l.Vector3.Distance(i.min, i.max);\n        this.radius = r * this.zoomOnFactor, this.focusOn({\n          min: i.min,\n          max: i.max,\n          distance: r\n        }, t);\n      }, n.prototype.focusOn = function (e, t) {\n        var i, r;\n\n        if (void 0 === t && (t = !1), void 0 === e.min) {\n          var n = e || this.getScene().meshes;\n          i = l.Mesh.MinMax(n), r = l.Vector3.Distance(i.min, i.max);\n        } else {\n          var o = e;\n          r = (i = o).distance;\n        }\n\n        this._target = l.Mesh.Center(i), t || (this.maxZ = 2 * r);\n      }, n.prototype.createRigCamera = function (e, t) {\n        var i = 0;\n\n        switch (this.cameraRigMode) {\n          case l.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n          case l.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n          case l.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n          case l.Camera.RIG_MODE_VR:\n            i = this._cameraRigParams.stereoHalfAngle * (0 === t ? 1 : -1);\n            break;\n\n          case l.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n            i = this._cameraRigParams.stereoHalfAngle * (0 === t ? -1 : 1);\n        }\n\n        var r = new n(e, this.alpha + i, this.beta, this.radius, this._target, this.getScene());\n        return r._cameraRigParams = {}, r;\n      }, n.prototype._updateRigCameras = function () {\n        var e = this._rigCameras[0],\n            t = this._rigCameras[1];\n\n        switch (e.beta = t.beta = this.beta, e.radius = t.radius = this.radius, this.cameraRigMode) {\n          case l.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n          case l.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n          case l.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n          case l.Camera.RIG_MODE_VR:\n            e.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle, t.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\n            break;\n\n          case l.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n            e.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle, t.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\n        }\n\n        a.prototype._updateRigCameras.call(this);\n      }, n.prototype.dispose = function () {\n        this.inputs.clear(), a.prototype.dispose.call(this);\n      }, n.prototype.getClassName = function () {\n        return \"ArcRotateCamera\";\n      }, b([l.serialize()], n.prototype, \"alpha\", void 0), b([l.serialize()], n.prototype, \"beta\", void 0), b([l.serialize()], n.prototype, \"radius\", void 0), b([l.serializeAsVector3(\"target\")], n.prototype, \"_target\", void 0), b([l.serialize()], n.prototype, \"inertialAlphaOffset\", void 0), b([l.serialize()], n.prototype, \"inertialBetaOffset\", void 0), b([l.serialize()], n.prototype, \"inertialRadiusOffset\", void 0), b([l.serialize()], n.prototype, \"lowerAlphaLimit\", void 0), b([l.serialize()], n.prototype, \"upperAlphaLimit\", void 0), b([l.serialize()], n.prototype, \"lowerBetaLimit\", void 0), b([l.serialize()], n.prototype, \"upperBetaLimit\", void 0), b([l.serialize()], n.prototype, \"lowerRadiusLimit\", void 0), b([l.serialize()], n.prototype, \"upperRadiusLimit\", void 0), b([l.serialize()], n.prototype, \"inertialPanningX\", void 0), b([l.serialize()], n.prototype, \"inertialPanningY\", void 0), b([l.serialize()], n.prototype, \"pinchToPanMaxDistance\", void 0), b([l.serialize()], n.prototype, \"panningDistanceLimit\", void 0), b([l.serializeAsVector3()], n.prototype, \"panningOriginTarget\", void 0), b([l.serialize()], n.prototype, \"panningInertia\", void 0), b([l.serialize()], n.prototype, \"zoomOnFactor\", void 0), b([l.serialize()], n.prototype, \"targetScreenOffset\", void 0), b([l.serialize()], n.prototype, \"allowUpsideDown\", void 0), b([l.serialize()], n.prototype, \"useInputToRestoreState\", void 0), n;\n    }(l.TargetCamera);\n\n    l.ArcRotateCamera = i;\n  }($a || ($a = {})), function (o) {\n    o.Node.AddNodeConstructor(\"Light_Type_3\", function (e, t) {\n      return function () {\n        return new i(e, o.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r.groundColor = new o.Color3(0, 0, 0), r.direction = t || o.Vector3.Up(), r;\n      }\n\n      return T(e, n), e.prototype._buildUniformLayout = function () {\n        this._uniformBuffer.addUniform(\"vLightData\", 4), this._uniformBuffer.addUniform(\"vLightDiffuse\", 4), this._uniformBuffer.addUniform(\"vLightSpecular\", 3), this._uniformBuffer.addUniform(\"vLightGround\", 3), this._uniformBuffer.addUniform(\"shadowsInfo\", 3), this._uniformBuffer.addUniform(\"depthValues\", 2), this._uniformBuffer.create();\n      }, e.prototype.getClassName = function () {\n        return \"HemisphericLight\";\n      }, e.prototype.setDirectionToTarget = function (e) {\n        return this.direction = o.Vector3.Normalize(e.subtract(o.Vector3.Zero())), this.direction;\n      }, e.prototype.getShadowGenerator = function () {\n        return null;\n      }, e.prototype.transferToEffect = function (e, t) {\n        var i = o.Vector3.Normalize(this.direction);\n        return this._uniformBuffer.updateFloat4(\"vLightData\", i.x, i.y, i.z, 0, t), this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), t), this;\n      }, e.prototype.computeWorldMatrix = function (e, t) {\n        return this._worldMatrix || (this._worldMatrix = o.Matrix.Identity()), this._worldMatrix;\n      }, e.prototype.getTypeID = function () {\n        return o.Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n      }, e.prototype.prepareLightSpecificDefines = function (e, t) {\n        e[\"HEMILIGHT\" + t] = !0;\n      }, b([o.serializeAsColor3()], e.prototype, \"groundColor\", void 0), b([o.serializeAsVector3()], e.prototype, \"direction\", void 0), e;\n    }(o.Light);\n\n    o.HemisphericLight = i;\n  }($a || ($a = {})), je = $a || ($a = {}), Ye = function (t) {\n    function e() {\n      var e = null !== t && t.apply(this, arguments) || this;\n      return e._needProjectionMatrixCompute = !0, e;\n    }\n\n    return T(e, t), e.prototype._setPosition = function (e) {\n      this._position = e;\n    }, Object.defineProperty(e.prototype, \"position\", {\n      get: function () {\n        return this._position;\n      },\n      set: function (e) {\n        this._setPosition(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._setDirection = function (e) {\n      this._direction = e;\n    }, Object.defineProperty(e.prototype, \"direction\", {\n      get: function () {\n        return this._direction;\n      },\n      set: function (e) {\n        this._setDirection(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"shadowMinZ\", {\n      get: function () {\n        return this._shadowMinZ;\n      },\n      set: function (e) {\n        this._shadowMinZ = e, this.forceProjectionMatrixCompute();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"shadowMaxZ\", {\n      get: function () {\n        return this._shadowMaxZ;\n      },\n      set: function (e) {\n        this._shadowMaxZ = e, this.forceProjectionMatrixCompute();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.computeTransformedInformation = function () {\n      return !(!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition || (this.transformedPosition = je.Vector3.Zero()), je.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), this.direction && (this.transformedDirection || (this.transformedDirection = je.Vector3.Zero()), je.Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection)), !0);\n    }, e.prototype.getDepthScale = function () {\n      return 50;\n    }, e.prototype.getShadowDirection = function (e) {\n      return this.transformedDirection ? this.transformedDirection : this.direction;\n    }, e.prototype.getAbsolutePosition = function () {\n      return this.transformedPosition ? this.transformedPosition : this.position;\n    }, e.prototype.setDirectionToTarget = function (e) {\n      return this.direction = je.Vector3.Normalize(e.subtract(this.position)), this.direction;\n    }, e.prototype.getRotation = function () {\n      this.direction.normalize();\n      var e = je.Vector3.Cross(this.direction, je.Axis.Y),\n          t = je.Vector3.Cross(e, this.direction);\n      return je.Vector3.RotationFromAxis(e, t, this.direction);\n    }, e.prototype.needCube = function () {\n      return !1;\n    }, e.prototype.needProjectionMatrixCompute = function () {\n      return this._needProjectionMatrixCompute;\n    }, e.prototype.forceProjectionMatrixCompute = function () {\n      this._needProjectionMatrixCompute = !0;\n    }, e.prototype._initCache = function () {\n      t.prototype._initCache.call(this), this._cache.position = je.Vector3.Zero();\n    }, e.prototype._isSynchronized = function () {\n      return !!this._cache.position.equals(this.position);\n    }, e.prototype.computeWorldMatrix = function (e) {\n      return !e && this.isSynchronized() ? this._currentRenderId = this.getScene().getRenderId() : (this._updateCache(), this._cache.position.copyFrom(this.position), this._worldMatrix || (this._worldMatrix = je.Matrix.Identity()), je.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this.parent && this.parent.getWorldMatrix && (this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix), this._markSyncedWithParent()), this._worldMatrixDeterminant = this._worldMatrix.determinant()), this._worldMatrix;\n    }, e.prototype.getDepthMinZ = function (e) {\n      return void 0 !== this.shadowMinZ ? this.shadowMinZ : e.minZ;\n    }, e.prototype.getDepthMaxZ = function (e) {\n      return void 0 !== this.shadowMaxZ ? this.shadowMaxZ : e.maxZ;\n    }, e.prototype.setShadowProjectionMatrix = function (e, t, i) {\n      return this.customProjectionMatrixBuilder ? this.customProjectionMatrixBuilder(t, i, e) : this._setDefaultShadowProjectionMatrix(e, t, i), this;\n    }, b([je.serializeAsVector3()], e.prototype, \"position\", null), b([je.serializeAsVector3()], e.prototype, \"direction\", null), b([je.serialize()], e.prototype, \"shadowMinZ\", null), b([je.serialize()], e.prototype, \"shadowMaxZ\", null), e;\n  }(je.Light), je.ShadowLight = Ye, function (o) {\n    o.Node.AddNodeConstructor(\"Light_Type_0\", function (e, t) {\n      return function () {\n        return new i(e, o.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r._shadowAngle = Math.PI / 2, r.position = t, r;\n      }\n\n      return T(e, n), Object.defineProperty(e.prototype, \"shadowAngle\", {\n        get: function () {\n          return this._shadowAngle;\n        },\n        set: function (e) {\n          this._shadowAngle = e, this.forceProjectionMatrixCompute();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"direction\", {\n        get: function () {\n          return this._direction;\n        },\n        set: function (e) {\n          var t = this.needCube();\n          this._direction = e, this.needCube() !== t && this._shadowGenerator && this._shadowGenerator.recreateShadowMap();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.getClassName = function () {\n        return \"PointLight\";\n      }, e.prototype.getTypeID = function () {\n        return o.Light.LIGHTTYPEID_POINTLIGHT;\n      }, e.prototype.needCube = function () {\n        return !this.direction;\n      }, e.prototype.getShadowDirection = function (e) {\n        if (this.direction) return n.prototype.getShadowDirection.call(this, e);\n\n        switch (e) {\n          case 0:\n            return new o.Vector3(1, 0, 0);\n\n          case 1:\n            return new o.Vector3(-1, 0, 0);\n\n          case 2:\n            return new o.Vector3(0, -1, 0);\n\n          case 3:\n            return new o.Vector3(0, 1, 0);\n\n          case 4:\n            return new o.Vector3(0, 0, 1);\n\n          case 5:\n            return new o.Vector3(0, 0, -1);\n        }\n\n        return o.Vector3.Zero();\n      }, e.prototype._setDefaultShadowProjectionMatrix = function (e, t, i) {\n        var r = this.getScene().activeCamera;\n        r && o.Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1, this.getDepthMinZ(r), this.getDepthMaxZ(r), e);\n      }, e.prototype._buildUniformLayout = function () {\n        this._uniformBuffer.addUniform(\"vLightData\", 4), this._uniformBuffer.addUniform(\"vLightDiffuse\", 4), this._uniformBuffer.addUniform(\"vLightSpecular\", 3), this._uniformBuffer.addUniform(\"vLightFalloff\", 4), this._uniformBuffer.addUniform(\"shadowsInfo\", 3), this._uniformBuffer.addUniform(\"depthValues\", 2), this._uniformBuffer.create();\n      }, e.prototype.transferToEffect = function (e, t) {\n        return this.computeTransformedInformation() ? this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0, t) : this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, 0, t), this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, t), this;\n      }, e.prototype.prepareLightSpecificDefines = function (e, t) {\n        e[\"POINTLIGHT\" + t] = !0;\n      }, b([o.serialize()], e.prototype, \"shadowAngle\", null), e;\n    }(o.ShadowLight);\n\n    o.PointLight = i;\n  }($a || ($a = {})), function (u) {\n    u.Node.AddNodeConstructor(\"Light_Type_1\", function (e, t) {\n      return function () {\n        return new i(e, u.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r._shadowFrustumSize = 0, r._shadowOrthoScale = .1, r.autoUpdateExtends = !0, r._orthoLeft = Number.MAX_VALUE, r._orthoRight = Number.MIN_VALUE, r._orthoTop = Number.MIN_VALUE, r._orthoBottom = Number.MAX_VALUE, r.position = t.scale(-1), r.direction = t, r;\n      }\n\n      return T(e, n), Object.defineProperty(e.prototype, \"shadowFrustumSize\", {\n        get: function () {\n          return this._shadowFrustumSize;\n        },\n        set: function (e) {\n          this._shadowFrustumSize = e, this.forceProjectionMatrixCompute();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"shadowOrthoScale\", {\n        get: function () {\n          return this._shadowOrthoScale;\n        },\n        set: function (e) {\n          this._shadowOrthoScale = e, this.forceProjectionMatrixCompute();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.getClassName = function () {\n        return \"DirectionalLight\";\n      }, e.prototype.getTypeID = function () {\n        return u.Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n      }, e.prototype._setDefaultShadowProjectionMatrix = function (e, t, i) {\n        0 < this.shadowFrustumSize ? this._setDefaultFixedFrustumShadowProjectionMatrix(e, t) : this._setDefaultAutoExtendShadowProjectionMatrix(e, t, i);\n      }, e.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function (e, t) {\n        var i = this.getScene().activeCamera;\n        i && u.Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, void 0 !== this.shadowMinZ ? this.shadowMinZ : i.minZ, void 0 !== this.shadowMaxZ ? this.shadowMaxZ : i.maxZ, e);\n      }, e.prototype._setDefaultAutoExtendShadowProjectionMatrix = function (e, t, i) {\n        var r = this.getScene().activeCamera;\n\n        if (r) {\n          if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n            var n = u.Vector3.Zero();\n            this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE;\n\n            for (var o = 0; o < i.length; o++) {\n              var s = i[o];\n              if (s) for (var a = s.getBoundingInfo().boundingBox, l = 0; l < a.vectorsWorld.length; l++) u.Vector3.TransformCoordinatesToRef(a.vectorsWorld[l], t, n), n.x < this._orthoLeft && (this._orthoLeft = n.x), n.y < this._orthoBottom && (this._orthoBottom = n.y), n.x > this._orthoRight && (this._orthoRight = n.x), n.y > this._orthoTop && (this._orthoTop = n.y);\n            }\n          }\n\n          var c = this._orthoRight - this._orthoLeft,\n              h = this._orthoTop - this._orthoBottom;\n          u.Matrix.OrthoOffCenterLHToRef(this._orthoLeft - c * this.shadowOrthoScale, this._orthoRight + c * this.shadowOrthoScale, this._orthoBottom - h * this.shadowOrthoScale, this._orthoTop + h * this.shadowOrthoScale, void 0 !== this.shadowMinZ ? this.shadowMinZ : r.minZ, void 0 !== this.shadowMaxZ ? this.shadowMaxZ : r.maxZ, e);\n        }\n      }, e.prototype._buildUniformLayout = function () {\n        this._uniformBuffer.addUniform(\"vLightData\", 4), this._uniformBuffer.addUniform(\"vLightDiffuse\", 4), this._uniformBuffer.addUniform(\"vLightSpecular\", 3), this._uniformBuffer.addUniform(\"shadowsInfo\", 3), this._uniformBuffer.addUniform(\"depthValues\", 2), this._uniformBuffer.create();\n      }, e.prototype.transferToEffect = function (e, t) {\n        return this.computeTransformedInformation() ? this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, t) : this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, t), this;\n      }, e.prototype.getDepthMinZ = function (e) {\n        return 1;\n      }, e.prototype.getDepthMaxZ = function (e) {\n        return 1;\n      }, e.prototype.prepareLightSpecificDefines = function (e, t) {\n        e[\"DIRLIGHT\" + t] = !0;\n      }, b([u.serialize()], e.prototype, \"shadowFrustumSize\", null), b([u.serialize()], e.prototype, \"shadowOrthoScale\", null), b([u.serialize()], e.prototype, \"autoUpdateExtends\", void 0), e;\n    }(u.ShadowLight);\n\n    u.DirectionalLight = i;\n  }($a || ($a = {})), function (l) {\n    l.Node.AddNodeConstructor(\"Light_Type_2\", function (e, t) {\n      return function () {\n        return new i(e, l.Vector3.Zero(), l.Vector3.Zero(), 0, 0, t);\n      };\n    });\n\n    var i = function (a) {\n      function e(e, t, i, r, n, o) {\n        var s = a.call(this, e, o) || this;\n        return s._innerAngle = 0, s._projectionTextureMatrix = l.Matrix.Zero(), s._projectionTextureLightNear = 1e-6, s._projectionTextureLightFar = 1e3, s._projectionTextureUpDirection = l.Vector3.Up(), s._projectionTextureViewLightDirty = !0, s._projectionTextureProjectionLightDirty = !0, s._projectionTextureDirty = !0, s._projectionTextureViewTargetVector = l.Vector3.Zero(), s._projectionTextureViewLightMatrix = l.Matrix.Zero(), s._projectionTextureProjectionLightMatrix = l.Matrix.Zero(), s._projectionTextureScalingMatrix = l.Matrix.FromValues(.5, 0, 0, 0, 0, .5, 0, 0, 0, 0, .5, 0, .5, .5, .5, 1), s.position = t, s.direction = i, s.angle = r, s.exponent = n, s;\n      }\n\n      return T(e, a), Object.defineProperty(e.prototype, \"angle\", {\n        get: function () {\n          return this._angle;\n        },\n        set: function (e) {\n          this._angle = e, this._cosHalfAngle = Math.cos(.5 * e), this._projectionTextureProjectionLightDirty = !0, this.forceProjectionMatrixCompute(), this._computeAngleValues();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"innerAngle\", {\n        get: function () {\n          return this._innerAngle;\n        },\n        set: function (e) {\n          this._innerAngle = e, this._computeAngleValues();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"shadowAngleScale\", {\n        get: function () {\n          return this._shadowAngleScale;\n        },\n        set: function (e) {\n          this._shadowAngleScale = e, this.forceProjectionMatrixCompute();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"projectionTextureMatrix\", {\n        get: function () {\n          return this._projectionTextureMatrix;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"projectionTextureLightNear\", {\n        get: function () {\n          return this._projectionTextureLightNear;\n        },\n        set: function (e) {\n          this._projectionTextureLightNear = e, this._projectionTextureProjectionLightDirty = !0;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"projectionTextureLightFar\", {\n        get: function () {\n          return this._projectionTextureLightFar;\n        },\n        set: function (e) {\n          this._projectionTextureLightFar = e, this._projectionTextureProjectionLightDirty = !0;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"projectionTextureUpDirection\", {\n        get: function () {\n          return this._projectionTextureUpDirection;\n        },\n        set: function (e) {\n          this._projectionTextureUpDirection = e, this._projectionTextureProjectionLightDirty = !0;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"projectionTexture\", {\n        get: function () {\n          return this._projectionTexture;\n        },\n        set: function (e) {\n          this._projectionTexture = e, this._projectionTextureDirty = !0;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.getClassName = function () {\n        return \"SpotLight\";\n      }, e.prototype.getTypeID = function () {\n        return l.Light.LIGHTTYPEID_SPOTLIGHT;\n      }, e.prototype._setDirection = function (e) {\n        a.prototype._setDirection.call(this, e), this._projectionTextureViewLightDirty = !0;\n      }, e.prototype._setPosition = function (e) {\n        a.prototype._setPosition.call(this, e), this._projectionTextureViewLightDirty = !0;\n      }, e.prototype._setDefaultShadowProjectionMatrix = function (e, t, i) {\n        var r = this.getScene().activeCamera;\n\n        if (r) {\n          this._shadowAngleScale = this._shadowAngleScale || 1;\n          var n = this._shadowAngleScale * this._angle;\n          l.Matrix.PerspectiveFovLHToRef(n, 1, this.getDepthMinZ(r), this.getDepthMaxZ(r), e);\n        }\n      }, e.prototype._computeProjectionTextureViewLightMatrix = function () {\n        this._projectionTextureViewLightDirty = !1, this._projectionTextureDirty = !0, this.position.addToRef(this.direction, this._projectionTextureViewTargetVector), l.Matrix.LookAtLHToRef(this.position, this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);\n      }, e.prototype._computeProjectionTextureProjectionLightMatrix = function () {\n        this._projectionTextureProjectionLightDirty = !1, this._projectionTextureDirty = !0;\n        var e = this.projectionTextureLightFar,\n            t = this.projectionTextureLightNear,\n            i = e / (e - t),\n            r = -i * t,\n            n = 1 / Math.tan(this._angle / 2);\n        l.Matrix.FromValuesToRef(n / 1, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 1, 0, 0, r, 0, this._projectionTextureProjectionLightMatrix);\n      }, e.prototype._computeProjectionTextureMatrix = function () {\n        this._projectionTextureDirty = !1, this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix), this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);\n      }, e.prototype._buildUniformLayout = function () {\n        this._uniformBuffer.addUniform(\"vLightData\", 4), this._uniformBuffer.addUniform(\"vLightDiffuse\", 4), this._uniformBuffer.addUniform(\"vLightSpecular\", 3), this._uniformBuffer.addUniform(\"vLightDirection\", 3), this._uniformBuffer.addUniform(\"vLightFalloff\", 4), this._uniformBuffer.addUniform(\"shadowsInfo\", 3), this._uniformBuffer.addUniform(\"depthValues\", 2), this._uniformBuffer.create();\n      }, e.prototype._computeAngleValues = function () {\n        this._lightAngleScale = 1 / Math.max(.001, Math.cos(.5 * this._innerAngle) - this._cosHalfAngle), this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;\n      }, e.prototype.transferToEffect = function (e, t) {\n        var i;\n        return this.computeTransformedInformation() ? (this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, t), i = l.Vector3.Normalize(this.transformedDirection)) : (this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, this.exponent, t), i = l.Vector3.Normalize(this.direction)), this._uniformBuffer.updateFloat4(\"vLightDirection\", i.x, i.y, i.z, this._cosHalfAngle, t), this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, t), this.projectionTexture && this.projectionTexture.isReady() && (this._projectionTextureViewLightDirty && this._computeProjectionTextureViewLightMatrix(), this._projectionTextureProjectionLightDirty && this._computeProjectionTextureProjectionLightMatrix(), this._projectionTextureDirty && this._computeProjectionTextureMatrix(), e.setMatrix(\"textureProjectionMatrix\" + t, this._projectionTextureMatrix), e.setTexture(\"projectionLightSampler\" + t, this.projectionTexture)), this;\n      }, e.prototype.dispose = function () {\n        a.prototype.dispose.call(this), this._projectionTexture && this._projectionTexture.dispose();\n      }, e.prototype.prepareLightSpecificDefines = function (e, t) {\n        e[\"SPOTLIGHT\" + t] = !0, e[\"PROJECTEDLIGHTTEXTURE\" + t] = !!this.projectionTexture;\n      }, b([l.serialize()], e.prototype, \"angle\", null), b([l.serialize()], e.prototype, \"innerAngle\", null), b([l.serialize()], e.prototype, \"shadowAngleScale\", null), b([l.serialize()], e.prototype, \"exponent\", void 0), b([l.serialize()], e.prototype, \"projectionTextureLightNear\", null), b([l.serialize()], e.prototype, \"projectionTextureLightFar\", null), b([l.serialize()], e.prototype, \"projectionTextureUpDirection\", null), b([l.serializeAsTexture(\"projectedLightTexture\")], e.prototype, \"_projectionTexture\", void 0), e;\n    }(l.ShadowLight);\n\n    l.SpotLight = i;\n  }($a || ($a = {})), Ke = $a || ($a = {}), Qe = function () {\n    this.enableBlending = !1, this.blendingSpeed = .01, this.loopMode = Ke.Animation.ANIMATIONLOOPMODE_CYCLE;\n  }, Ke.AnimationPropertiesOverride = Qe, function (d) {\n    var r = function () {\n      function e(e, t, i) {\n        this.name = e, this.from = t, this.to = i;\n      }\n\n      return e.prototype.clone = function () {\n        return new e(this.name, this.from, this.to);\n      }, e;\n    }();\n\n    d.AnimationRange = r;\n\n    var e = function () {\n      function e(e, t, i) {\n        this.frame = e, this.action = t, this.onlyOnce = i, this.isDone = !1;\n      }\n\n      return e.prototype._clone = function () {\n        return new e(this.frame, this.action, this.onlyOnce);\n      }, e;\n    }();\n\n    d.AnimationEvent = e;\n\n    var E,\n        t,\n        i = function () {\n      function e(e) {\n        this.path = e, this._onchange = new Array(), this.value = 0, this.animations = new Array();\n      }\n\n      return e.prototype.getPoint = function () {\n        var e = this.path.getPointAtLengthPosition(this.value);\n        return new d.Vector3(e.x, 0, e.y);\n      }, e.prototype.moveAhead = function (e) {\n        return void 0 === e && (e = .002), this.move(e), this;\n      }, e.prototype.moveBack = function (e) {\n        return void 0 === e && (e = .002), this.move(-e), this;\n      }, e.prototype.move = function (e) {\n        if (1 < Math.abs(e)) throw \"step size should be less than 1.\";\n        return this.value += e, this.ensureLimits(), this.raiseOnChange(), this;\n      }, e.prototype.ensureLimits = function () {\n        for (; 1 < this.value;) this.value -= 1;\n\n        for (; this.value < 0;) this.value += 1;\n\n        return this;\n      }, e.prototype.raiseOnChange = function () {\n        var t = this;\n        return this._onchange.forEach(function (e) {\n          return e(t);\n        }), this;\n      }, e.prototype.onchange = function (e) {\n        return this._onchange.push(e), this;\n      }, e;\n    }();\n\n    d.PathCursor = i, (t = E = d.AnimationKeyInterpolation || (d.AnimationKeyInterpolation = {}))[t.STEP = 1] = \"STEP\";\n\n    var n = function () {\n      function T(e, t, i, r, n, o) {\n        this.name = e, this.targetProperty = t, this.framePerSecond = i, this.dataType = r, this.loopMode = n, this.enableBlending = o, this._runtimeAnimations = new Array(), this._events = new Array(), this.blendingSpeed = .01, this._ranges = {}, this.targetPropertyPath = t.split(\".\"), this.dataType = r, this.loopMode = void 0 === n ? T.ANIMATIONLOOPMODE_CYCLE : n;\n      }\n\n      return T._PrepareAnimation = function (e, t, i, r, n, o, s, a) {\n        var l = void 0;\n        if (!isNaN(parseFloat(n)) && isFinite(n) ? l = T.ANIMATIONTYPE_FLOAT : n instanceof d.Quaternion ? l = T.ANIMATIONTYPE_QUATERNION : n instanceof d.Vector3 ? l = T.ANIMATIONTYPE_VECTOR3 : n instanceof d.Vector2 ? l = T.ANIMATIONTYPE_VECTOR2 : n instanceof d.Color3 ? l = T.ANIMATIONTYPE_COLOR3 : n instanceof d.Size && (l = T.ANIMATIONTYPE_SIZE), null == l) return null;\n        var c = new T(e, t, i, l, s),\n            h = [{\n          frame: 0,\n          value: n\n        }, {\n          frame: r,\n          value: o\n        }];\n        return c.setKeys(h), void 0 !== a && c.setEasingFunction(a), c;\n      }, T.CreateAnimation = function (e, t, i, r) {\n        var n = new T(e + \"Animation\", e, i, t, T.ANIMATIONLOOPMODE_CONSTANT);\n        return n.setEasingFunction(r), n;\n      }, T.CreateAndStartAnimation = function (e, t, i, r, n, o, s, a, l, c) {\n        var h = T._PrepareAnimation(e, i, r, n, o, s, a, l);\n\n        return h ? t.getScene().beginDirectAnimation(t, [h], 0, n, 1 === h.loopMode, 1, c) : null;\n      }, T.CreateAndStartHierarchyAnimation = function (e, t, i, r, n, o, s, a, l, c, h) {\n        var u = T._PrepareAnimation(e, r, n, o, s, a, l, c);\n\n        return u ? t.getScene().beginDirectHierarchyAnimation(t, i, [u], 0, o, 1 === u.loopMode, 1, h) : null;\n      }, T.CreateMergeAndStartAnimation = function (e, t, i, r, n, o, s, a, l, c) {\n        var h = T._PrepareAnimation(e, i, r, n, o, s, a, l);\n\n        return h ? (t.animations.push(h), t.getScene().beginAnimation(t, 0, n, 1 === h.loopMode, 1, c)) : null;\n      }, T.TransitionTo = function (e, t, i, r, n, o, s, a) {\n        if (void 0 === a && (a = null), s <= 0) return i[e] = t, a && a(), null;\n        var l = n * (s / 1e3);\n        o.setKeys([{\n          frame: 0,\n          value: i[e].clone ? i[e].clone() : i[e]\n        }, {\n          frame: l,\n          value: t\n        }]), i.animations || (i.animations = []), i.animations.push(o);\n        var c = r.beginAnimation(i, 0, l, !1);\n        return c.onAnimationEnd = a, c;\n      }, Object.defineProperty(T.prototype, \"runtimeAnimations\", {\n        get: function () {\n          return this._runtimeAnimations;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T.prototype, \"hasRunningRuntimeAnimations\", {\n        get: function () {\n          for (var e = 0, t = this._runtimeAnimations; e < t.length; e++) {\n            if (!t[e].isStopped) return !0;\n          }\n\n          return !1;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), T.prototype.toString = function (e) {\n        var t = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n\n        if (t += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType], t += \", nKeys: \" + (this._keys ? this._keys.length : \"none\"), t += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\"), e) {\n          t += \", Ranges: {\";\n          var i = !0;\n\n          for (var r in this._ranges) i && (t += \", \", i = !1), t += r;\n\n          t += \"}\";\n        }\n\n        return t;\n      }, T.prototype.addEvent = function (e) {\n        this._events.push(e);\n      }, T.prototype.removeEvents = function (e) {\n        for (var t = 0; t < this._events.length; t++) this._events[t].frame === e && (this._events.splice(t, 1), t--);\n      }, T.prototype.getEvents = function () {\n        return this._events;\n      }, T.prototype.createRange = function (e, t, i) {\n        this._ranges[e] || (this._ranges[e] = new r(e, t, i));\n      }, T.prototype.deleteRange = function (e, t) {\n        void 0 === t && (t = !0);\n        var i = this._ranges[e];\n\n        if (i) {\n          if (t) for (var r = i.from, n = i.to, o = this._keys.length - 1; 0 <= o; o--) this._keys[o].frame >= r && this._keys[o].frame <= n && this._keys.splice(o, 1);\n          this._ranges[e] = null;\n        }\n      }, T.prototype.getRange = function (e) {\n        return this._ranges[e];\n      }, T.prototype.getKeys = function () {\n        return this._keys;\n      }, T.prototype.getHighestFrame = function () {\n        for (var e = 0, t = 0, i = this._keys.length; t < i; t++) e < this._keys[t].frame && (e = this._keys[t].frame);\n\n        return e;\n      }, T.prototype.getEasingFunction = function () {\n        return this._easingFunction;\n      }, T.prototype.setEasingFunction = function (e) {\n        this._easingFunction = e;\n      }, T.prototype.floatInterpolateFunction = function (e, t, i) {\n        return d.Scalar.Lerp(e, t, i);\n      }, T.prototype.floatInterpolateFunctionWithTangents = function (e, t, i, r, n) {\n        return d.Scalar.Hermite(e, t, i, r, n);\n      }, T.prototype.quaternionInterpolateFunction = function (e, t, i) {\n        return d.Quaternion.Slerp(e, t, i);\n      }, T.prototype.quaternionInterpolateFunctionWithTangents = function (e, t, i, r, n) {\n        return d.Quaternion.Hermite(e, t, i, r, n).normalize();\n      }, T.prototype.vector3InterpolateFunction = function (e, t, i) {\n        return d.Vector3.Lerp(e, t, i);\n      }, T.prototype.vector3InterpolateFunctionWithTangents = function (e, t, i, r, n) {\n        return d.Vector3.Hermite(e, t, i, r, n);\n      }, T.prototype.vector2InterpolateFunction = function (e, t, i) {\n        return d.Vector2.Lerp(e, t, i);\n      }, T.prototype.vector2InterpolateFunctionWithTangents = function (e, t, i, r, n) {\n        return d.Vector2.Hermite(e, t, i, r, n);\n      }, T.prototype.sizeInterpolateFunction = function (e, t, i) {\n        return d.Size.Lerp(e, t, i);\n      }, T.prototype.color3InterpolateFunction = function (e, t, i) {\n        return d.Color3.Lerp(e, t, i);\n      }, T.prototype._getKeyValue = function (e) {\n        return \"function\" == typeof e ? e() : e;\n      }, T.prototype._interpolate = function (e, t, i, r, n, o) {\n        if (r === T.ANIMATIONLOOPMODE_CONSTANT && 0 < t) return o.clone ? o.clone() : o;\n        var s = this.getKeys(),\n            a = Math.max(0, Math.min(s.length - 1, Math.floor(s.length * (e - s[0].frame) / (s[s.length - 1].frame - s[0].frame)) - 1));\n        if (s[a].frame >= e) for (; 0 <= a - 1 && s[a].frame >= e;) a--;\n\n        for (var l = a; l < s.length; l++) {\n          var c = s[l + 1];\n\n          if (c.frame >= e) {\n            var h = s[l],\n                u = this._getKeyValue(h.value);\n\n            if (h.interpolation === E.STEP) return u;\n\n            var d = this._getKeyValue(c.value),\n                f = void 0 !== h.outTangent && void 0 !== c.inTangent,\n                p = c.frame - h.frame,\n                _ = (e - h.frame) / p,\n                m = this.getEasingFunction();\n\n            switch (null != m && (_ = m.ease(_)), this.dataType) {\n              case T.ANIMATIONTYPE_FLOAT:\n                var g = f ? this.floatInterpolateFunctionWithTangents(u, h.outTangent * p, d, c.inTangent * p, _) : this.floatInterpolateFunction(u, d, _);\n\n                switch (r) {\n                  case T.ANIMATIONLOOPMODE_CYCLE:\n                  case T.ANIMATIONLOOPMODE_CONSTANT:\n                    return g;\n\n                  case T.ANIMATIONLOOPMODE_RELATIVE:\n                    return n * t + g;\n                }\n\n                break;\n\n              case T.ANIMATIONTYPE_QUATERNION:\n                var v = f ? this.quaternionInterpolateFunctionWithTangents(u, h.outTangent.scale(p), d, c.inTangent.scale(p), _) : this.quaternionInterpolateFunction(u, d, _);\n\n                switch (r) {\n                  case T.ANIMATIONLOOPMODE_CYCLE:\n                  case T.ANIMATIONLOOPMODE_CONSTANT:\n                    return v;\n\n                  case T.ANIMATIONLOOPMODE_RELATIVE:\n                    return v.addInPlace(n.scale(t));\n                }\n\n                return v;\n\n              case T.ANIMATIONTYPE_VECTOR3:\n                var y = f ? this.vector3InterpolateFunctionWithTangents(u, h.outTangent.scale(p), d, c.inTangent.scale(p), _) : this.vector3InterpolateFunction(u, d, _);\n\n                switch (r) {\n                  case T.ANIMATIONLOOPMODE_CYCLE:\n                  case T.ANIMATIONLOOPMODE_CONSTANT:\n                    return y;\n\n                  case T.ANIMATIONLOOPMODE_RELATIVE:\n                    return y.add(n.scale(t));\n                }\n\n              case T.ANIMATIONTYPE_VECTOR2:\n                var b = f ? this.vector2InterpolateFunctionWithTangents(u, h.outTangent.scale(p), d, c.inTangent.scale(p), _) : this.vector2InterpolateFunction(u, d, _);\n\n                switch (r) {\n                  case T.ANIMATIONLOOPMODE_CYCLE:\n                  case T.ANIMATIONLOOPMODE_CONSTANT:\n                    return b;\n\n                  case T.ANIMATIONLOOPMODE_RELATIVE:\n                    return b.add(n.scale(t));\n                }\n\n              case T.ANIMATIONTYPE_SIZE:\n                switch (r) {\n                  case T.ANIMATIONLOOPMODE_CYCLE:\n                  case T.ANIMATIONLOOPMODE_CONSTANT:\n                    return this.sizeInterpolateFunction(u, d, _);\n\n                  case T.ANIMATIONLOOPMODE_RELATIVE:\n                    return this.sizeInterpolateFunction(u, d, _).add(n.scale(t));\n                }\n\n              case T.ANIMATIONTYPE_COLOR3:\n                switch (r) {\n                  case T.ANIMATIONLOOPMODE_CYCLE:\n                  case T.ANIMATIONLOOPMODE_CONSTANT:\n                    return this.color3InterpolateFunction(u, d, _);\n\n                  case T.ANIMATIONLOOPMODE_RELATIVE:\n                    return this.color3InterpolateFunction(u, d, _).add(n.scale(t));\n                }\n\n              case T.ANIMATIONTYPE_MATRIX:\n                switch (r) {\n                  case T.ANIMATIONLOOPMODE_CYCLE:\n                  case T.ANIMATIONLOOPMODE_CONSTANT:\n                    if (T.AllowMatricesInterpolation) return this.matrixInterpolateFunction(u, d, _, i);\n\n                  case T.ANIMATIONLOOPMODE_RELATIVE:\n                    return u;\n                }\n\n            }\n\n            break;\n          }\n        }\n\n        return this._getKeyValue(s[s.length - 1].value);\n      }, T.prototype.matrixInterpolateFunction = function (e, t, i, r) {\n        return T.AllowMatrixDecomposeForInterpolation ? r ? (d.Matrix.DecomposeLerpToRef(e, t, i, r), r) : d.Matrix.DecomposeLerp(e, t, i) : r ? (d.Matrix.LerpToRef(e, t, i, r), r) : d.Matrix.Lerp(e, t, i);\n      }, T.prototype.clone = function () {\n        var e = new T(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n        if (e.enableBlending = this.enableBlending, e.blendingSpeed = this.blendingSpeed, this._keys && e.setKeys(this._keys), this._ranges) for (var t in e._ranges = {}, this._ranges) {\n          var i = this._ranges[t];\n          i && (e._ranges[t] = i.clone());\n        }\n        return e;\n      }, T.prototype.setKeys = function (e) {\n        this._keys = e.slice(0);\n      }, T.prototype.serialize = function () {\n        var e = {};\n        e.name = this.name, e.property = this.targetProperty, e.framePerSecond = this.framePerSecond, e.dataType = this.dataType, e.loopBehavior = this.loopMode, e.enableBlending = this.enableBlending, e.blendingSpeed = this.blendingSpeed;\n        var t = this.dataType;\n        e.keys = [];\n\n        for (var i = this.getKeys(), r = 0; r < i.length; r++) {\n          var n = i[r],\n              o = {};\n\n          switch (o.frame = n.frame, t) {\n            case T.ANIMATIONTYPE_FLOAT:\n              o.values = [n.value];\n              break;\n\n            case T.ANIMATIONTYPE_QUATERNION:\n            case T.ANIMATIONTYPE_MATRIX:\n            case T.ANIMATIONTYPE_VECTOR3:\n            case T.ANIMATIONTYPE_COLOR3:\n              o.values = n.value.asArray();\n          }\n\n          e.keys.push(o);\n        }\n\n        for (var s in e.ranges = [], this._ranges) {\n          var a = this._ranges[s];\n\n          if (a) {\n            var l = {};\n            l.name = s, l.from = a.from, l.to = a.to, e.ranges.push(l);\n          }\n        }\n\n        return e;\n      }, Object.defineProperty(T, \"ANIMATIONTYPE_FLOAT\", {\n        get: function () {\n          return T._ANIMATIONTYPE_FLOAT;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONTYPE_VECTOR3\", {\n        get: function () {\n          return T._ANIMATIONTYPE_VECTOR3;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONTYPE_VECTOR2\", {\n        get: function () {\n          return T._ANIMATIONTYPE_VECTOR2;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONTYPE_SIZE\", {\n        get: function () {\n          return T._ANIMATIONTYPE_SIZE;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONTYPE_QUATERNION\", {\n        get: function () {\n          return T._ANIMATIONTYPE_QUATERNION;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONTYPE_MATRIX\", {\n        get: function () {\n          return T._ANIMATIONTYPE_MATRIX;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONTYPE_COLOR3\", {\n        get: function () {\n          return T._ANIMATIONTYPE_COLOR3;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONLOOPMODE_RELATIVE\", {\n        get: function () {\n          return T._ANIMATIONLOOPMODE_RELATIVE;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONLOOPMODE_CYCLE\", {\n        get: function () {\n          return T._ANIMATIONLOOPMODE_CYCLE;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(T, \"ANIMATIONLOOPMODE_CONSTANT\", {\n        get: function () {\n          return T._ANIMATIONLOOPMODE_CONSTANT;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), T._UniversalLerp = function (e, t, i) {\n        var r = e.constructor;\n        return r.Lerp ? r.Lerp(e, t, i) : r.Slerp ? r.Slerp(e, t, i) : e.toFixed ? e * (1 - i) + i * t : t;\n      }, T.Parse = function (e) {\n        var t,\n            i,\n            r = new T(e.name, e.property, e.framePerSecond, e.dataType, e.loopBehavior),\n            n = e.dataType,\n            o = [];\n\n        for (e.enableBlending && (r.enableBlending = e.enableBlending), e.blendingSpeed && (r.blendingSpeed = e.blendingSpeed), i = 0; i < e.keys.length; i++) {\n          var s,\n              a,\n              l = e.keys[i];\n\n          switch (n) {\n            case T.ANIMATIONTYPE_FLOAT:\n              t = l.values[0], 1 <= l.values.length && (s = l.values[1]), 2 <= l.values.length && (a = l.values[2]);\n              break;\n\n            case T.ANIMATIONTYPE_QUATERNION:\n              if (t = d.Quaternion.FromArray(l.values), 8 <= l.values.length) {\n                var c = d.Quaternion.FromArray(l.values.slice(4, 8));\n                c.equals(d.Quaternion.Zero()) || (s = c);\n              }\n\n              if (12 <= l.values.length) {\n                var h = d.Quaternion.FromArray(l.values.slice(8, 12));\n                h.equals(d.Quaternion.Zero()) || (a = h);\n              }\n\n              break;\n\n            case T.ANIMATIONTYPE_MATRIX:\n              t = d.Matrix.FromArray(l.values);\n              break;\n\n            case T.ANIMATIONTYPE_COLOR3:\n              t = d.Color3.FromArray(l.values);\n              break;\n\n            case T.ANIMATIONTYPE_VECTOR3:\n            default:\n              t = d.Vector3.FromArray(l.values);\n          }\n\n          var u = {};\n          u.frame = l.frame, u.value = t, null != s && (u.inTangent = s), null != a && (u.outTangent = a), o.push(u);\n        }\n\n        if (r.setKeys(o), e.ranges) for (i = 0; i < e.ranges.length; i++) t = e.ranges[i], r.createRange(t.name, t.from, t.to);\n        return r;\n      }, T.AppendSerializedAnimations = function (e, t) {\n        if (e.animations) {\n          t.animations = [];\n\n          for (var i = 0; i < e.animations.length; i++) {\n            var r = e.animations[i];\n            t.animations.push(r.serialize());\n          }\n        }\n      }, T.AllowMatricesInterpolation = !1, T.AllowMatrixDecomposeForInterpolation = !0, T._ANIMATIONTYPE_FLOAT = 0, T._ANIMATIONTYPE_VECTOR3 = 1, T._ANIMATIONTYPE_QUATERNION = 2, T._ANIMATIONTYPE_MATRIX = 3, T._ANIMATIONTYPE_COLOR3 = 4, T._ANIMATIONTYPE_VECTOR2 = 5, T._ANIMATIONTYPE_SIZE = 6, T._ANIMATIONLOOPMODE_RELATIVE = 0, T._ANIMATIONLOOPMODE_CYCLE = 1, T._ANIMATIONLOOPMODE_CONSTANT = 2, T;\n    }();\n\n    d.Animation = n;\n  }($a || ($a = {})), function (l) {\n    var e = function () {};\n\n    l.TargetedAnimation = e;\n\n    var t = function () {\n      function e(e, t) {\n        void 0 === t && (t = null), this.name = e, this._targetedAnimations = new Array(), this._animatables = new Array(), this._from = Number.MAX_VALUE, this._to = -Number.MAX_VALUE, this._speedRatio = 1, this.onAnimationEndObservable = new l.Observable(), this.onAnimationGroupEndObservable = new l.Observable(), this.onAnimationGroupPauseObservable = new l.Observable(), this._scene = t || l.Engine.LastCreatedScene, this._scene.animationGroups.push(this);\n      }\n\n      return Object.defineProperty(e.prototype, \"from\", {\n        get: function () {\n          return this._from;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"to\", {\n        get: function () {\n          return this._to;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"isStarted\", {\n        get: function () {\n          return this._isStarted;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"speedRatio\", {\n        get: function () {\n          return this._speedRatio;\n        },\n        set: function (e) {\n          if (this._speedRatio !== e) {\n            this._speedRatio = e;\n\n            for (var t = 0; t < this._animatables.length; t++) {\n              this._animatables[t].speedRatio = this._speedRatio;\n            }\n          }\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"targetedAnimations\", {\n        get: function () {\n          return this._targetedAnimations;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"animatables\", {\n        get: function () {\n          return this._animatables;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.addTargetedAnimation = function (e, t) {\n        var i = {\n          animation: e,\n          target: t\n        },\n            r = e.getKeys();\n        return this._from > r[0].frame && (this._from = r[0].frame), this._to < r[r.length - 1].frame && (this._to = r[r.length - 1].frame), this._targetedAnimations.push(i), i;\n      }, e.prototype.normalize = function (e, t) {\n        void 0 === e && (e = null), void 0 === t && (t = null), null == e && (e = this._from), null == t && (t = this._to);\n\n        for (var i = 0; i < this._targetedAnimations.length; i++) {\n          var r = this._targetedAnimations[i].animation.getKeys(),\n              n = r[0],\n              o = r[r.length - 1];\n\n          if (n.frame > e) {\n            var s = {\n              frame: e,\n              value: n.value,\n              inTangent: n.inTangent,\n              outTangent: n.outTangent,\n              interpolation: n.interpolation\n            };\n            r.splice(0, 0, s);\n          }\n\n          if (o.frame < t) {\n            s = {\n              frame: t,\n              value: o.value,\n              inTangent: o.outTangent,\n              outTangent: o.outTangent,\n              interpolation: o.interpolation\n            };\n            r.push(s);\n          }\n        }\n\n        return this._from = e, this._to = t, this;\n      }, e.prototype.start = function (i, r, n, o) {\n        var s = this;\n        if (void 0 === i && (i = !1), void 0 === r && (r = 1), this._isStarted || 0 === this._targetedAnimations.length) return this;\n\n        for (var e = function (e) {\n          var t = a._scene.beginDirectAnimation(e.target, [e.animation], void 0 !== n ? n : a._from, void 0 !== o ? o : a._to, i, r);\n\n          t.onAnimationEnd = function () {\n            s.onAnimationEndObservable.notifyObservers(e), s._checkAnimationGroupEnded(t);\n          }, a._animatables.push(t);\n        }, a = this, t = 0, l = this._targetedAnimations; t < l.length; t++) {\n          e(l[t]);\n        }\n\n        return this._speedRatio = r, this._isStarted = !0, this;\n      }, e.prototype.pause = function () {\n        if (!this._isStarted) return this;\n\n        for (var e = 0; e < this._animatables.length; e++) {\n          this._animatables[e].pause();\n        }\n\n        return this.onAnimationGroupPauseObservable.notifyObservers(this), this;\n      }, e.prototype.play = function (e) {\n        if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\n          if (void 0 !== e) for (var t = 0; t < this._animatables.length; t++) {\n            this._animatables[t].loopAnimation = e;\n          }\n          this.restart();\n        } else this.stop(), this.start(e, this._speedRatio);\n\n        return this;\n      }, e.prototype.reset = function () {\n        if (!this._isStarted) return this;\n\n        for (var e = 0; e < this._animatables.length; e++) {\n          this._animatables[e].reset();\n        }\n\n        return this;\n      }, e.prototype.restart = function () {\n        if (!this._isStarted) return this;\n\n        for (var e = 0; e < this._animatables.length; e++) {\n          this._animatables[e].restart();\n        }\n\n        return this;\n      }, e.prototype.stop = function () {\n        if (!this._isStarted) return this;\n\n        for (var e = this._animatables.slice(), t = 0; t < e.length; t++) e[t].stop();\n\n        return this._isStarted = !1, this;\n      }, e.prototype.setWeightForAllAnimatables = function (e) {\n        for (var t = 0; t < this._animatables.length; t++) {\n          this._animatables[t].weight = e;\n        }\n\n        return this;\n      }, e.prototype.syncAllAnimationsWith = function (e) {\n        for (var t = 0; t < this._animatables.length; t++) {\n          this._animatables[t].syncWith(e);\n        }\n\n        return this;\n      }, e.prototype.goToFrame = function (e) {\n        if (!this._isStarted) return this;\n\n        for (var t = 0; t < this._animatables.length; t++) {\n          this._animatables[t].goToFrame(e);\n        }\n\n        return this;\n      }, e.prototype.dispose = function () {\n        this._targetedAnimations = [], this._animatables = [];\n\n        var e = this._scene.animationGroups.indexOf(this);\n\n        -1 < e && this._scene.animationGroups.splice(e, 1);\n      }, e.prototype._checkAnimationGroupEnded = function (e) {\n        var t = this._animatables.indexOf(e);\n\n        -1 < t && this._animatables.splice(t, 1), 0 === this._animatables.length && (this._isStarted = !1, this.onAnimationGroupEndObservable.notifyObservers(this));\n      }, e.Parse = function (e, t) {\n        for (var i = new l.AnimationGroup(e.name, t), r = 0; r < e.targetedAnimations.length; r++) {\n          var n = e.targetedAnimations[r],\n              o = l.Animation.Parse(n.animation),\n              s = n.targetId,\n              a = t.getNodeByID(s);\n          null != a && i.addTargetedAnimation(o, a);\n        }\n\n        return null !== e.from && null !== e.from && i.normalize(e.from, e.to), i;\n      }, e.prototype.getClassName = function () {\n        return \"AnimationGroup\";\n      }, e.prototype.toString = function (e) {\n        var t = \"Name: \" + this.name;\n        return t += \", type: \" + this.getClassName(), e && (t += \", from: \" + this._from, t += \", to: \" + this._to, t += \", isStarted: \" + this._isStarted, t += \", speedRatio: \" + this._speedRatio, t += \", targetedAnimations length: \" + this._targetedAnimations.length, t += \", animatables length: \" + this._animatables), t;\n      }, e;\n    }();\n\n    l.AnimationGroup = t;\n  }($a || ($a = {})), Ze = $a || ($a = {}), qe = Object.freeze(new Ze.Quaternion(0, 0, 0, 0)), Je = Object.freeze(Ze.Vector3.Zero()), $e = Object.freeze(Ze.Vector2.Zero()), et = Object.freeze(Ze.Size.Zero()), tt = Object.freeze(Ze.Color3.Black()), it = function () {\n    function e(e, t, i, r) {\n      var n = this;\n      this._events = new Array(), this._currentFrame = 0, this._originalValue = new Array(), this._offsetsCache = {}, this._highLimitsCache = {}, this._stopped = !1, this._blendingFactor = 0, this._targetPath = \"\", this._weight = 1, this._ratioOffset = 0, this._previousDelay = 0, this._previousRatio = 0, this._animation = t, this._target = e, this._scene = i, this._host = r, t._runtimeAnimations.push(this);\n      var o = t.getEvents();\n      o && 0 < o.length && o.forEach(function (e) {\n        n._events.push(e._clone());\n      });\n    }\n\n    return Object.defineProperty(e.prototype, \"currentFrame\", {\n      get: function () {\n        return this._currentFrame;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"weight\", {\n      get: function () {\n        return this._weight;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"currentValue\", {\n      get: function () {\n        return this._currentValue;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"targetPath\", {\n      get: function () {\n        return this._targetPath;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"target\", {\n      get: function () {\n        return this._activeTarget;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"animation\", {\n      get: function () {\n        return this._animation;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.reset = function (e) {\n      if (void 0 === e && (e = !1), e) if (this._target instanceof Array) for (var t = 0, i = 0, r = this._target; i < r.length; i++) {\n        var n = r[i];\n        void 0 !== this._originalValue[t] && this._setValue(n, this._originalValue[t], -1), t++;\n      } else void 0 !== this._originalValue[0] && this._setValue(this._target, this._originalValue[0], -1);\n      this._offsetsCache = {}, this._highLimitsCache = {}, this._currentFrame = 0, this._blendingFactor = 0, this._originalValue = new Array();\n\n      for (t = 0; t < this._events.length; t++) this._events[t].isDone = !1;\n    }, e.prototype.isStopped = function () {\n      return this._stopped;\n    }, e.prototype.dispose = function () {\n      var e = this._animation.runtimeAnimations.indexOf(this);\n\n      -1 < e && this._animation.runtimeAnimations.splice(e, 1);\n    }, e.prototype._interpolate = function (e, t, i, r, n) {\n      return this._currentFrame = e, this._animation.dataType !== Ze.Animation.ANIMATIONTYPE_MATRIX || this._workValue || (this._workValue = Ze.Matrix.Zero()), this._animation._interpolate(e, t, this._workValue, i, r, n);\n    }, e.prototype.setValue = function (e, t) {\n      if (void 0 === t && (t = 1), this._target instanceof Array) for (var i = 0, r = 0, n = this._target; r < n.length; r++) {\n        var o = n[r];\n        this._setValue(o, e, t, i), i++;\n      } else this._setValue(this._target, e, t);\n    }, e.prototype._setValue = function (e, t, i, r) {\n      var n, o;\n      void 0 === r && (r = 0);\n      var s = this._animation.targetPropertyPath;\n\n      if (1 < s.length) {\n        for (var a = e[s[0]], l = 1; l < s.length - 1; l++) a = a[s[l]];\n\n        n = s[s.length - 1], o = a;\n      } else n = s[0], o = e;\n\n      if (this._targetPath = n, this._activeTarget = o, this._weight = i, void 0 === this._originalValue[r]) {\n        var c = void 0;\n        (c = o.getRestPose && \"_matrix\" === n ? o.getRestPose() : o[n]) && c.clone ? this._originalValue[r] = c.clone() : this._originalValue[r] = c;\n      }\n\n      if ((e && e.animationPropertiesOverride ? e.animationPropertiesOverride.enableBlending : this._animation.enableBlending) && this._blendingFactor <= 1) {\n        if (!this._originalBlendValue) (c = o[n]).clone ? this._originalBlendValue = c.clone() : this._originalBlendValue = c;\n        this._originalBlendValue.m ? Ze.Animation.AllowMatrixDecomposeForInterpolation ? this._currentValue ? Ze.Matrix.DecomposeLerpToRef(this._originalBlendValue, t, this._blendingFactor, this._currentValue) : this._currentValue = Ze.Matrix.DecomposeLerp(this._originalBlendValue, t, this._blendingFactor) : this._currentValue ? Ze.Matrix.LerpToRef(this._originalBlendValue, t, this._blendingFactor, this._currentValue) : this._currentValue = Ze.Matrix.Lerp(this._originalBlendValue, t, this._blendingFactor) : this._currentValue = Ze.Animation._UniversalLerp(this._originalBlendValue, t, this._blendingFactor);\n        var h = e && e.animationPropertiesOverride ? e.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n        this._blendingFactor += h;\n      } else this._currentValue = t;\n\n      -1 !== i ? this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[r]) : o[n] = this._currentValue, e.markAsDirty && e.markAsDirty(this._animation.targetProperty);\n    }, e.prototype._getCorrectLoopMode = function () {\n      return this._target && this._target.animationPropertiesOverride ? this._target.animationPropertiesOverride.loopMode : this._animation.loopMode;\n    }, e.prototype.goToFrame = function (e) {\n      var t = this._animation.getKeys();\n\n      e < t[0].frame ? e = t[0].frame : e > t[t.length - 1].frame && (e = t[t.length - 1].frame);\n\n      var i = this._interpolate(e, 0, this._getCorrectLoopMode());\n\n      this.setValue(i, -1);\n    }, e.prototype._prepareForSpeedRatioChange = function (e) {\n      var t = this._previousDelay * (this._animation.framePerSecond * e) / 1e3;\n      this._ratioOffset = this._previousRatio - t;\n    }, e.prototype.animate = function (e, t, i, r, n, o) {\n      void 0 === o && (o = -1);\n      var s = this._animation.targetPropertyPath;\n      if (!s || s.length < 1) return !(this._stopped = !0);\n\n      var a = !0,\n          l = this._animation.getKeys();\n\n      if (0 !== l[0].frame) {\n        var c = {\n          frame: 0,\n          value: l[0].value\n        };\n        l.splice(0, 0, c);\n      } else if (1 === l.length) {\n        c = {\n          frame: .001,\n          value: l[0].value\n        };\n        l.push(c);\n      }\n\n      (t < l[0].frame || t > l[l.length - 1].frame) && (t = l[0].frame), (i < l[0].frame || i > l[l.length - 1].frame) && (i = l[l.length - 1].frame), t === i && (t > l[0].frame ? t-- : i < l[l.length - 1].frame && i++);\n      var h,\n          u = i - t,\n          d = e * (this._animation.framePerSecond * n) / 1e3 + this._ratioOffset,\n          f = 0;\n      if (this._previousDelay = e, this._previousRatio = d, (t < i && u <= d || i < t && d <= u) && !r) a = !1, f = this._animation._getKeyValue(l[l.length - 1].value);else if (this._getCorrectLoopMode() !== Ze.Animation.ANIMATIONLOOPMODE_CYCLE) {\n        var p = i.toString() + t.toString();\n\n        if (!this._offsetsCache[p]) {\n          var _ = this._interpolate(t, 0, Ze.Animation.ANIMATIONLOOPMODE_CYCLE),\n              m = this._interpolate(i, 0, Ze.Animation.ANIMATIONLOOPMODE_CYCLE);\n\n          switch (this._animation.dataType) {\n            case Ze.Animation.ANIMATIONTYPE_FLOAT:\n              this._offsetsCache[p] = m - _;\n              break;\n\n            case Ze.Animation.ANIMATIONTYPE_QUATERNION:\n              this._offsetsCache[p] = m.subtract(_);\n              break;\n\n            case Ze.Animation.ANIMATIONTYPE_VECTOR3:\n              this._offsetsCache[p] = m.subtract(_);\n\n            case Ze.Animation.ANIMATIONTYPE_VECTOR2:\n              this._offsetsCache[p] = m.subtract(_);\n\n            case Ze.Animation.ANIMATIONTYPE_SIZE:\n              this._offsetsCache[p] = m.subtract(_);\n\n            case Ze.Animation.ANIMATIONTYPE_COLOR3:\n              this._offsetsCache[p] = m.subtract(_);\n          }\n\n          this._highLimitsCache[p] = m;\n        }\n\n        f = this._highLimitsCache[p], h = this._offsetsCache[p];\n      }\n      if (void 0 === h) switch (this._animation.dataType) {\n        case Ze.Animation.ANIMATIONTYPE_FLOAT:\n          h = 0;\n          break;\n\n        case Ze.Animation.ANIMATIONTYPE_QUATERNION:\n          h = qe;\n          break;\n\n        case Ze.Animation.ANIMATIONTYPE_VECTOR3:\n          h = Je;\n          break;\n\n        case Ze.Animation.ANIMATIONTYPE_VECTOR2:\n          h = $e;\n          break;\n\n        case Ze.Animation.ANIMATIONTYPE_SIZE:\n          h = et;\n          break;\n\n        case Ze.Animation.ANIMATIONTYPE_COLOR3:\n          h = tt;\n      }\n      var g = d / u >> 0,\n          v = a ? t + d % u : i;\n\n      if (this._host && this._host.syncRoot) {\n        var y = this._host.syncRoot;\n        v = t + (i - t) * ((y.masterFrame - y.fromFrame) / (y.toFrame - y.fromFrame));\n      }\n\n      var b = this._events;\n      if (0 < u && this.currentFrame > v || u < 0 && this.currentFrame < v) for (var T = 0; T < b.length; T++) b[T].onlyOnce || (b[T].isDone = !1);\n\n      var E = this._interpolate(v, g, this._getCorrectLoopMode(), h, f);\n\n      this.setValue(E, o);\n\n      for (T = 0; T < b.length; T++) if (0 < u && v >= b[T].frame && b[T].frame >= t || u < 0 && v <= b[T].frame && b[T].frame <= t) {\n        var x = b[T];\n        x.isDone || (x.onlyOnce && (b.splice(T, 1), T--), x.isDone = !0, x.action(v));\n      }\n\n      return a || (this._stopped = !0), a;\n    }, e;\n  }(), Ze.RuntimeAnimation = it, rt = $a || ($a = {}), nt = function () {\n    function e(e, t, i, r, n, o, s, a) {\n      void 0 === i && (i = 0), void 0 === r && (r = 100), void 0 === n && (n = !1), void 0 === o && (o = 1), this.target = t, this.fromFrame = i, this.toFrame = r, this.loopAnimation = n, this.onAnimationEnd = s, this._localDelayOffset = null, this._pausedDelay = null, this._runtimeAnimations = new Array(), this._paused = !1, this._speedRatio = 1, this._weight = -1, this.disposeOnEnd = !0, this.animationStarted = !1, this.onAnimationEndObservable = new rt.Observable(), this._scene = e, a && this.appendAnimations(t, a), this._speedRatio = o, e._activeAnimatables.push(this);\n    }\n\n    return Object.defineProperty(e.prototype, \"syncRoot\", {\n      get: function () {\n        return this._syncRoot;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"masterFrame\", {\n      get: function () {\n        return 0 === this._runtimeAnimations.length ? 0 : this._runtimeAnimations[0].currentFrame;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"weight\", {\n      get: function () {\n        return this._weight;\n      },\n      set: function (e) {\n        this._weight = -1 !== e ? Math.min(Math.max(e, 0), 1) : -1;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"speedRatio\", {\n      get: function () {\n        return this._speedRatio;\n      },\n      set: function (e) {\n        for (var t = 0; t < this._runtimeAnimations.length; t++) {\n          this._runtimeAnimations[t]._prepareForSpeedRatioChange(e);\n        }\n\n        this._speedRatio = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.syncWith = function (e) {\n      if (this._syncRoot = e) {\n        var t = this._scene._activeAnimatables.indexOf(this);\n\n        -1 < t && (this._scene._activeAnimatables.splice(t, 1), this._scene._activeAnimatables.push(this));\n      }\n\n      return this;\n    }, e.prototype.getAnimations = function () {\n      return this._runtimeAnimations;\n    }, e.prototype.appendAnimations = function (e, t) {\n      for (var i = 0; i < t.length; i++) {\n        var r = t[i];\n\n        this._runtimeAnimations.push(new rt.RuntimeAnimation(e, r, this._scene, this));\n      }\n    }, e.prototype.getAnimationByTargetProperty = function (e) {\n      for (var t = this._runtimeAnimations, i = 0; i < t.length; i++) if (t[i].animation.targetProperty === e) return t[i].animation;\n\n      return null;\n    }, e.prototype.getRuntimeAnimationByTargetProperty = function (e) {\n      for (var t = this._runtimeAnimations, i = 0; i < t.length; i++) if (t[i].animation.targetProperty === e) return t[i];\n\n      return null;\n    }, e.prototype.reset = function () {\n      for (var e = this._runtimeAnimations, t = 0; t < e.length; t++) e[t].reset(!0);\n\n      this._localDelayOffset = null, this._pausedDelay = null;\n    }, e.prototype.enableBlending = function (e) {\n      for (var t = this._runtimeAnimations, i = 0; i < t.length; i++) t[i].animation.enableBlending = !0, t[i].animation.blendingSpeed = e;\n    }, e.prototype.disableBlending = function () {\n      for (var e = this._runtimeAnimations, t = 0; t < e.length; t++) e[t].animation.enableBlending = !1;\n    }, e.prototype.goToFrame = function (e) {\n      var t = this._runtimeAnimations;\n\n      if (t[0]) {\n        var i = t[0].animation.framePerSecond,\n            r = 1e3 * (e - t[0].currentFrame) / (i * this.speedRatio);\n        null === this._localDelayOffset && (this._localDelayOffset = 0), this._localDelayOffset -= r;\n      }\n\n      for (var n = 0; n < t.length; n++) t[n].goToFrame(e);\n    }, e.prototype.pause = function () {\n      this._paused || (this._paused = !0);\n    }, e.prototype.restart = function () {\n      this._paused = !1;\n    }, e.prototype._raiseOnAnimationEnd = function () {\n      this.onAnimationEnd && this.onAnimationEnd(), this.onAnimationEndObservable.notifyObservers(this);\n    }, e.prototype.stop = function (e, t) {\n      if (e || t) {\n        var i = this._scene._activeAnimatables.indexOf(this);\n\n        if (-1 < i) {\n          for (var r = (o = this._runtimeAnimations).length - 1; 0 <= r; r--) {\n            var n = o[r];\n            e && n.animation.name != e || t && !t(n.target) || (n.dispose(), o.splice(r, 1));\n          }\n\n          0 == o.length && (this._scene._activeAnimatables.splice(i, 1), this._raiseOnAnimationEnd());\n        }\n      } else {\n        if (-1 < (r = this._scene._activeAnimatables.indexOf(this))) {\n          this._scene._activeAnimatables.splice(r, 1);\n\n          var o = this._runtimeAnimations;\n\n          for (r = 0; r < o.length; r++) o[r].dispose();\n\n          this._raiseOnAnimationEnd();\n        }\n      }\n    }, e.prototype.waitAsync = function () {\n      var i = this;\n      return new Promise(function (e, t) {\n        i.onAnimationEndObservable.add(function () {\n          e(i);\n        }, void 0, void 0, i, !0);\n      });\n    }, e.prototype._animate = function (e) {\n      if (this._paused) return this.animationStarted = !1, null === this._pausedDelay && (this._pausedDelay = e), !0;\n      if (null === this._localDelayOffset ? (this._localDelayOffset = e, this._pausedDelay = null) : null !== this._pausedDelay && (this._localDelayOffset += e - this._pausedDelay, this._pausedDelay = null), 0 === this._weight) return !0;\n      var t,\n          i = !1,\n          r = this._runtimeAnimations;\n\n      for (t = 0; t < r.length; t++) {\n        var n = r[t].animate(e - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n        i = i || n;\n      }\n\n      if (!(this.animationStarted = i)) {\n        if (this.disposeOnEnd) for (t = this._scene._activeAnimatables.indexOf(this), this._scene._activeAnimatables.splice(t, 1), t = 0; t < r.length; t++) r[t].dispose();\n        this._raiseOnAnimationEnd(), this.disposeOnEnd && (this.onAnimationEnd = null, this.onAnimationEndObservable.clear());\n      }\n\n      return i;\n    }, e;\n  }(), rt.Animatable = nt, function (t) {\n    var e = function () {\n      function t() {\n        this._easingMode = t.EASINGMODE_EASEIN;\n      }\n\n      return t.prototype.setEasingMode = function (e) {\n        var t = Math.min(Math.max(e, 0), 2);\n        this._easingMode = t;\n      }, t.prototype.getEasingMode = function () {\n        return this._easingMode;\n      }, t.prototype.easeInCore = function (e) {\n        throw new Error(\"You must implement this method\");\n      }, t.prototype.ease = function (e) {\n        switch (this._easingMode) {\n          case t.EASINGMODE_EASEIN:\n            return this.easeInCore(e);\n\n          case t.EASINGMODE_EASEOUT:\n            return 1 - this.easeInCore(1 - e);\n        }\n\n        return .5 <= e ? .5 * (1 - this.easeInCore(2 * (1 - e))) + .5 : .5 * this.easeInCore(2 * e);\n      }, t.EASINGMODE_EASEIN = 0, t.EASINGMODE_EASEOUT = 1, t.EASINGMODE_EASEINOUT = 2, t;\n    }(),\n        i = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.easeInCore = function (e) {\n        return e = Math.max(0, Math.min(1, e)), 1 - Math.sqrt(1 - e * e);\n      }, t;\n    }(t.EasingFunction = e);\n\n    t.CircleEase = i;\n\n    var r = function (i) {\n      function e(e) {\n        void 0 === e && (e = 1);\n        var t = i.call(this) || this;\n        return t.amplitude = e, t;\n      }\n\n      return T(e, i), e.prototype.easeInCore = function (e) {\n        var t = Math.max(0, this.amplitude);\n        return Math.pow(e, 3) - e * t * Math.sin(3.141592653589793 * e);\n      }, e;\n    }(e);\n\n    t.BackEase = r;\n\n    var n = function (r) {\n      function e(e, t) {\n        void 0 === e && (e = 3), void 0 === t && (t = 2);\n        var i = r.call(this) || this;\n        return i.bounces = e, i.bounciness = t, i;\n      }\n\n      return T(e, r), e.prototype.easeInCore = function (e) {\n        var t = Math.max(0, this.bounces),\n            i = this.bounciness;\n        i <= 1 && (i = 1.001);\n        var r = Math.pow(i, t),\n            n = 1 - i,\n            o = (1 - r) / n + .5 * r,\n            s = e * o,\n            a = Math.log(-s * (1 - i) + 1) / Math.log(i),\n            l = Math.floor(a),\n            c = l + 1,\n            h = (1 - Math.pow(i, l)) / (n * o),\n            u = .5 * (h + (1 - Math.pow(i, c)) / (n * o)),\n            d = e - u,\n            f = u - h;\n        return -Math.pow(1 / i, t - l) / (f * f) * (d - f) * (d + f);\n      }, e;\n    }(e);\n\n    t.BounceEase = n;\n\n    var o = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.easeInCore = function (e) {\n        return e * e * e;\n      }, t;\n    }(e);\n\n    t.CubicEase = o;\n\n    var s = function (r) {\n      function e(e, t) {\n        void 0 === e && (e = 3), void 0 === t && (t = 3);\n        var i = r.call(this) || this;\n        return i.oscillations = e, i.springiness = t, i;\n      }\n\n      return T(e, r), e.prototype.easeInCore = function (e) {\n        var t = Math.max(0, this.oscillations),\n            i = Math.max(0, this.springiness);\n        return (0 == i ? e : (Math.exp(i * e) - 1) / (Math.exp(i) - 1)) * Math.sin((6.283185307179586 * t + 1.5707963267948966) * e);\n      }, e;\n    }(e);\n\n    t.ElasticEase = s;\n\n    var a = function (i) {\n      function e(e) {\n        void 0 === e && (e = 2);\n        var t = i.call(this) || this;\n        return t.exponent = e, t;\n      }\n\n      return T(e, i), e.prototype.easeInCore = function (e) {\n        return this.exponent <= 0 ? e : (Math.exp(this.exponent * e) - 1) / (Math.exp(this.exponent) - 1);\n      }, e;\n    }(e);\n\n    t.ExponentialEase = a;\n\n    var l = function (i) {\n      function e(e) {\n        void 0 === e && (e = 2);\n        var t = i.call(this) || this;\n        return t.power = e, t;\n      }\n\n      return T(e, i), e.prototype.easeInCore = function (e) {\n        var t = Math.max(0, this.power);\n        return Math.pow(e, t);\n      }, e;\n    }(e);\n\n    t.PowerEase = l;\n\n    var c = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.easeInCore = function (e) {\n        return e * e;\n      }, t;\n    }(e);\n\n    t.QuadraticEase = c;\n\n    var h = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.easeInCore = function (e) {\n        return e * e * e * e;\n      }, t;\n    }(e);\n\n    t.QuarticEase = h;\n\n    var u = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.easeInCore = function (e) {\n        return e * e * e * e * e;\n      }, t;\n    }(e);\n\n    t.QuinticEase = u;\n\n    var d = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.easeInCore = function (e) {\n        return 1 - Math.sin(1.5707963267948966 * (1 - e));\n      }, t;\n    }(e);\n\n    t.SineEase = d;\n\n    var f = function (o) {\n      function e(e, t, i, r) {\n        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === i && (i = 1), void 0 === r && (r = 1);\n        var n = o.call(this) || this;\n        return n.x1 = e, n.y1 = t, n.x2 = i, n.y2 = r, n;\n      }\n\n      return T(e, o), e.prototype.easeInCore = function (e) {\n        return t.BezierCurve.Interpolate(e, this.x1, this.y1, this.x2, this.y2);\n      }, e;\n    }(e);\n\n    t.BezierCurveEase = f;\n  }($a || ($a = {})), function (t) {\n    var e = function () {\n      function e(e) {\n        this._actionManager = e;\n      }\n\n      return e.prototype.isValid = function () {\n        return !0;\n      }, e.prototype._getProperty = function (e) {\n        return this._actionManager._getProperty(e);\n      }, e.prototype._getEffectiveTarget = function (e, t) {\n        return this._actionManager._getEffectiveTarget(e, t);\n      }, e.prototype.serialize = function () {}, e.prototype._serialize = function (e) {\n        return {\n          type: 2,\n          children: [],\n          name: e.name,\n          properties: e.properties\n        };\n      }, e;\n    }(),\n        i = function (s) {\n      function a(e, t, i, r, n) {\n        void 0 === n && (n = a.IsEqual);\n        var o = s.call(this, e) || this;\n        return o.propertyPath = i, o.value = r, o.operator = n, o._target = t, o._effectiveTarget = o._getEffectiveTarget(t, o.propertyPath), o._property = o._getProperty(o.propertyPath), o;\n      }\n\n      return T(a, s), Object.defineProperty(a, \"IsEqual\", {\n        get: function () {\n          return a._IsEqual;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(a, \"IsDifferent\", {\n        get: function () {\n          return a._IsDifferent;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(a, \"IsGreater\", {\n        get: function () {\n          return a._IsGreater;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(a, \"IsLesser\", {\n        get: function () {\n          return a._IsLesser;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), a.prototype.isValid = function () {\n        switch (this.operator) {\n          case a.IsGreater:\n            return this._effectiveTarget[this._property] > this.value;\n\n          case a.IsLesser:\n            return this._effectiveTarget[this._property] < this.value;\n\n          case a.IsEqual:\n          case a.IsDifferent:\n            var e;\n            return e = this.value.equals ? this.value.equals(this._effectiveTarget[this._property]) : this.value === this._effectiveTarget[this._property], this.operator === a.IsEqual ? e : !e;\n        }\n\n        return !1;\n      }, a.prototype.serialize = function () {\n        return this._serialize({\n          name: \"ValueCondition\",\n          properties: [t.Action._GetTargetProperty(this._target), {\n            name: \"propertyPath\",\n            value: this.propertyPath\n          }, {\n            name: \"value\",\n            value: t.Action._SerializeValueAsString(this.value)\n          }, {\n            name: \"operator\",\n            value: a.GetOperatorName(this.operator)\n          }]\n        });\n      }, a.GetOperatorName = function (e) {\n        switch (e) {\n          case a._IsEqual:\n            return \"IsEqual\";\n\n          case a._IsDifferent:\n            return \"IsDifferent\";\n\n          case a._IsGreater:\n            return \"IsGreater\";\n\n          case a._IsLesser:\n            return \"IsLesser\";\n\n          default:\n            return \"\";\n        }\n      }, a._IsEqual = 0, a._IsDifferent = 1, a._IsGreater = 2, a._IsLesser = 3, a;\n    }(t.Condition = e);\n\n    t.ValueCondition = i;\n\n    var r = function (r) {\n      function e(e, t) {\n        var i = r.call(this, e) || this;\n        return i.predicate = t, i;\n      }\n\n      return T(e, r), e.prototype.isValid = function () {\n        return this.predicate();\n      }, e;\n    }(e);\n\n    t.PredicateCondition = r;\n\n    var n = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e) || this;\n        return r.value = i, r._target = t, r;\n      }\n\n      return T(e, n), e.prototype.isValid = function () {\n        return this._target.state === this.value;\n      }, e.prototype.serialize = function () {\n        return this._serialize({\n          name: \"StateCondition\",\n          properties: [t.Action._GetTargetProperty(this._target), {\n            name: \"value\",\n            value: this.value\n          }]\n        });\n      }, e;\n    }(e);\n\n    t.StateCondition = n;\n  }($a || ($a = {})), ot = $a || ($a = {}), st = function () {\n    function e(e, t) {\n      this.triggerOptions = e, this.onBeforeExecuteObservable = new ot.Observable(), e.parameter ? (this.trigger = e.trigger, this._triggerParameter = e.parameter) : e.trigger ? this.trigger = e.trigger : this.trigger = e, (this._nextActiveAction = this)._condition = t;\n    }\n\n    return e.prototype._prepare = function () {}, e.prototype.getTriggerParameter = function () {\n      return this._triggerParameter;\n    }, e.prototype._executeCurrent = function (e) {\n      if (this._nextActiveAction._condition) {\n        var t = this._nextActiveAction._condition,\n            i = this._actionManager.getScene().getRenderId();\n\n        if (t._evaluationId === i) {\n          if (!t._currentResult) return;\n        } else {\n          if (t._evaluationId = i, !t.isValid()) return void (t._currentResult = !1);\n          t._currentResult = !0;\n        }\n      }\n\n      this.onBeforeExecuteObservable.notifyObservers(this), this._nextActiveAction.execute(e), this.skipToNextActiveAction();\n    }, e.prototype.execute = function (e) {}, e.prototype.skipToNextActiveAction = function () {\n      this._nextActiveAction._child ? (this._nextActiveAction._child._actionManager || (this._nextActiveAction._child._actionManager = this._actionManager), this._nextActiveAction = this._nextActiveAction._child) : this._nextActiveAction = this;\n    }, e.prototype.then = function (e) {\n      return (this._child = e)._actionManager = this._actionManager, e._prepare(), e;\n    }, e.prototype._getProperty = function (e) {\n      return this._actionManager._getProperty(e);\n    }, e.prototype._getEffectiveTarget = function (e, t) {\n      return this._actionManager._getEffectiveTarget(e, t);\n    }, e.prototype.serialize = function (e) {}, e.prototype._serialize = function (e, t) {\n      var i = {\n        type: 1,\n        children: [],\n        name: e.name,\n        properties: e.properties || []\n      };\n\n      if (this._child && this._child.serialize(i), this._condition) {\n        var r = this._condition.serialize();\n\n        return r.children.push(i), t && t.children.push(r), r;\n      }\n\n      return t && t.children.push(i), i;\n    }, e._SerializeValueAsString = function (e) {\n      return \"number\" == typeof e ? e.toString() : \"boolean\" == typeof e ? e ? \"true\" : \"false\" : e instanceof ot.Vector2 ? e.x + \", \" + e.y : e instanceof ot.Vector3 ? e.x + \", \" + e.y + \", \" + e.z : e instanceof ot.Color3 ? e.r + \", \" + e.g + \", \" + e.b : e instanceof ot.Color4 ? e.r + \", \" + e.g + \", \" + e.b + \", \" + e.a : e;\n    }, e._GetTargetProperty = function (e) {\n      return {\n        name: \"target\",\n        targetType: e instanceof ot.Mesh ? \"MeshProperties\" : e instanceof ot.Light ? \"LightProperties\" : e instanceof ot.Camera ? \"CameraProperties\" : \"SceneProperties\",\n        value: e instanceof ot.Scene ? \"Scene\" : e.name\n      };\n    }, e;\n  }(), ot.Action = st, function (S) {\n    var e = function () {\n      function n(e, t, i, r, n, o) {\n        this.source = e, this.pointerX = t, this.pointerY = i, this.meshUnderPointer = r, this.sourceEvent = n, this.additionalData = o;\n      }\n\n      return n.CreateNew = function (e, t, i) {\n        var r = e.getScene();\n        return new n(e, r.pointerX, r.pointerY, r.meshUnderPointer, t, i);\n      }, n.CreateNewFromSprite = function (e, t, i, r) {\n        return new n(e, t.pointerX, t.pointerY, t.meshUnderPointer, i, r);\n      }, n.CreateNewFromScene = function (e, t) {\n        return new n(null, e.pointerX, e.pointerY, e.meshUnderPointer, t);\n      }, n.CreateNewFromPrimitive = function (e, t, i, r) {\n        return new n(e, t.x, t.y, null, i, r);\n      }, n;\n    }();\n\n    S.ActionEvent = e;\n\n    var t = function () {\n      function A(e) {\n        this.actions = new Array(), this.hoverCursor = \"\", this._scene = e || S.Engine.LastCreatedScene, e.actionManagers.push(this);\n      }\n\n      return A.prototype.dispose = function () {\n        for (var e = this._scene.actionManagers.indexOf(this), t = 0; t < this.actions.length; t++) {\n          var i = this.actions[t];\n          A.Triggers[i.trigger]--, 0 === A.Triggers[i.trigger] && delete A.Triggers[i.trigger];\n        }\n\n        -1 < e && this._scene.actionManagers.splice(e, 1);\n      }, A.prototype.getScene = function () {\n        return this._scene;\n      }, A.prototype.hasSpecificTriggers = function (e) {\n        for (var t = 0; t < this.actions.length; t++) {\n          var i = this.actions[t];\n          if (-1 < e.indexOf(i.trigger)) return !0;\n        }\n\n        return !1;\n      }, A.prototype.hasSpecificTriggers2 = function (e, t) {\n        for (var i = 0; i < this.actions.length; i++) {\n          var r = this.actions[i];\n          if (e == r.trigger || t == r.trigger) return !0;\n        }\n\n        return !1;\n      }, A.prototype.hasSpecificTrigger = function (e, t) {\n        for (var i = 0; i < this.actions.length; i++) {\n          var r = this.actions[i];\n\n          if (r.trigger === e) {\n            if (!t) return !0;\n            if (t(r.getTriggerParameter())) return !0;\n          }\n        }\n\n        return !1;\n      }, Object.defineProperty(A.prototype, \"hasPointerTriggers\", {\n        get: function () {\n          for (var e = 0; e < this.actions.length; e++) {\n            var t = this.actions[e];\n            if (t.trigger >= A.OnPickTrigger && t.trigger <= A.OnPointerOutTrigger) return !0;\n          }\n\n          return !1;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(A.prototype, \"hasPickTriggers\", {\n        get: function () {\n          for (var e = 0; e < this.actions.length; e++) {\n            var t = this.actions[e];\n            if (t.trigger >= A.OnPickTrigger && t.trigger <= A.OnPickUpTrigger) return !0;\n          }\n\n          return !1;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(A, \"HasTriggers\", {\n        get: function () {\n          for (var e in A.Triggers) if (A.Triggers.hasOwnProperty(e)) return !0;\n\n          return !1;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(A, \"HasPickTriggers\", {\n        get: function () {\n          for (var e in A.Triggers) if (A.Triggers.hasOwnProperty(e)) {\n            var t = parseInt(e);\n            if (A.OnPickTrigger <= t && t <= A.OnPickUpTrigger) return !0;\n          }\n\n          return !1;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), A.HasSpecificTrigger = function (e) {\n        for (var t in A.Triggers) {\n          if (A.Triggers.hasOwnProperty(t)) if (parseInt(t) === e) return !0;\n        }\n\n        return !1;\n      }, A.prototype.registerAction = function (e) {\n        return e.trigger === A.OnEveryFrameTrigger && this.getScene().actionManager !== this ? (S.Tools.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\"), null) : (this.actions.push(e), A.Triggers[e.trigger] ? A.Triggers[e.trigger]++ : A.Triggers[e.trigger] = 1, e._actionManager = this, e._prepare(), e);\n      }, A.prototype.unregisterAction = function (e) {\n        var t = this.actions.indexOf(e);\n        return -1 !== t && (this.actions.splice(t, 1), A.Triggers[e.trigger] -= 1, 0 === A.Triggers[e.trigger] && delete A.Triggers[e.trigger], delete e._actionManager, !0);\n      }, A.prototype.processTrigger = function (e, t) {\n        for (var i = 0; i < this.actions.length; i++) {\n          var r = this.actions[i];\n\n          if (r.trigger === e) {\n            if (t && (e === A.OnKeyUpTrigger || e === A.OnKeyDownTrigger)) {\n              var n = r.getTriggerParameter();\n\n              if (n && n !== t.sourceEvent.keyCode) {\n                if (!n.toLowerCase) continue;\n                var o = n.toLowerCase();\n\n                if (o !== t.sourceEvent.key) {\n                  var s = t.sourceEvent.charCode ? t.sourceEvent.charCode : t.sourceEvent.keyCode;\n                  if (String.fromCharCode(s).toLowerCase() !== o) continue;\n                }\n              }\n            }\n\n            r._executeCurrent(t);\n          }\n        }\n      }, A.prototype._getEffectiveTarget = function (e, t) {\n        for (var i = t.split(\".\"), r = 0; r < i.length - 1; r++) e = e[i[r]];\n\n        return e;\n      }, A.prototype._getProperty = function (e) {\n        var t = e.split(\".\");\n        return t[t.length - 1];\n      }, A.prototype.serialize = function (e) {\n        for (var t = {\n          children: new Array(),\n          name: e,\n          type: 3,\n          properties: new Array()\n        }, i = 0; i < this.actions.length; i++) {\n          var r = {\n            type: 0,\n            children: new Array(),\n            name: A.GetTriggerName(this.actions[i].trigger),\n            properties: new Array()\n          },\n              n = this.actions[i].triggerOptions;\n          if (n && \"number\" != typeof n) if (n.parameter instanceof S.Node) r.properties.push(S.Action._GetTargetProperty(n.parameter));else {\n            var o = {};\n            S.Tools.DeepCopy(n.parameter, o, [\"mesh\"]), n.parameter && n.parameter.mesh && (o._meshId = n.parameter.mesh.id), r.properties.push({\n              name: \"parameter\",\n              targetType: null,\n              value: o\n            });\n          }\n          this.actions[i].serialize(r), t.children.push(r);\n        }\n\n        return t;\n      }, A.Parse = function (e, t, T) {\n        var E = new A(T);\n        null === t ? T.actionManager = E : t.actionManager = E;\n\n        for (var x = function (e, t, i, r) {\n          if (null === r) {\n            var n = parseFloat(t);\n            return \"true\" === t || \"false\" === t ? \"true\" === t : isNaN(n) ? t : n;\n          }\n\n          for (var o = r.split(\".\"), s = t.split(\",\"), a = 0; a < o.length; a++) i = i[o[a]];\n\n          if (\"boolean\" == typeof i) return \"true\" === s[0];\n          if (\"string\" == typeof i) return s[0];\n          var l = new Array();\n\n          for (a = 0; a < s.length; a++) l.push(parseFloat(s[a]));\n\n          return i instanceof S.Vector3 ? S.Vector3.FromArray(l) : i instanceof S.Vector4 ? S.Vector4.FromArray(l) : i instanceof S.Color3 ? S.Color3.FromArray(l) : i instanceof S.Color4 ? S.Color4.FromArray(l) : parseFloat(s[0]);\n        }, P = function (e, t, i, r, n) {\n          if (void 0 === n && (n = null), !e.detached) {\n            var o = new Array(),\n                s = null,\n                a = null,\n                l = e.combine && 0 < e.combine.length;\n\n            if (2 === e.type ? o.push(E) : o.push(t), l) {\n              for (var c = new Array(), h = 0; h < e.combine.length; h++) P(e.combine[h], A.NothingTrigger, i, r, c);\n\n              o.push(c);\n            } else for (var u = 0; u < e.properties.length; u++) {\n              var d = e.properties[u].value,\n                  f = e.properties[u].name,\n                  p = e.properties[u].targetType;\n              \"target\" === f ? d = s = null !== p && \"SceneProperties\" === p ? T : T.getNodeByName(d) : \"parent\" === f ? d = T.getNodeByName(d) : \"sound\" === f ? T.getSoundByName && (d = T.getSoundByName(d)) : \"propertyPath\" !== f ? d = 2 === e.type && \"operator\" === f ? S.ValueCondition[d] : x(0, d, s, \"value\" === f ? a : null) : a = d, o.push(d);\n            }\n\n            if (null === n ? o.push(i) : o.push(null), \"InterpolateValueAction\" === e.name) {\n              var _ = o[o.length - 2];\n              o[o.length - 1] = _, o[o.length - 2] = i;\n            }\n\n            var m,\n                g,\n                v,\n                y = (m = e.name, g = o, (v = Object.create(S.Tools.Instantiate(\"BABYLON.\" + m).prototype)).constructor.apply(v, g), v);\n\n            if (y instanceof S.Condition && null !== i) {\n              var b = new S.DoNothingAction(t, i);\n              r ? r.then(b) : E.registerAction(b), r = b;\n            }\n\n            null === n ? y instanceof S.Condition ? (i = y, y = r) : (i = null, r ? r.then(y) : E.registerAction(y)) : n.push(y);\n\n            for (u = 0; u < e.children.length; u++) P(e.children[u], t, i, y, null);\n          }\n        }, i = 0; i < e.children.length; i++) {\n          var r,\n              n = e.children[i];\n\n          if (0 < n.properties.length) {\n            var o = n.properties[0].value,\n                s = null === n.properties[0].targetType ? o : T.getMeshByName(o);\n            s._meshId && (s.mesh = T.getMeshByID(s._meshId)), r = {\n              trigger: A[n.name],\n              parameter: s\n            };\n          } else r = A[n.name];\n\n          for (var a = 0; a < n.children.length; a++) n.detached || P(n.children[a], r, null, null);\n        }\n      }, A.GetTriggerName = function (e) {\n        switch (e) {\n          case 0:\n            return \"NothingTrigger\";\n\n          case 1:\n            return \"OnPickTrigger\";\n\n          case 2:\n            return \"OnLeftPickTrigger\";\n\n          case 3:\n            return \"OnRightPickTrigger\";\n\n          case 4:\n            return \"OnCenterPickTrigger\";\n\n          case 5:\n            return \"OnPickDownTrigger\";\n\n          case 6:\n            return \"OnPickUpTrigger\";\n\n          case 7:\n            return \"OnLongPressTrigger\";\n\n          case 8:\n            return \"OnPointerOverTrigger\";\n\n          case 9:\n            return \"OnPointerOutTrigger\";\n\n          case 10:\n            return \"OnEveryFrameTrigger\";\n\n          case 11:\n            return \"OnIntersectionEnterTrigger\";\n\n          case 12:\n            return \"OnIntersectionExitTrigger\";\n\n          case 13:\n            return \"OnKeyDownTrigger\";\n\n          case 14:\n            return \"OnKeyUpTrigger\";\n\n          case 15:\n            return \"OnPickOutTrigger\";\n\n          default:\n            return \"\";\n        }\n      }, A.NothingTrigger = 0, A.OnPickTrigger = 1, A.OnLeftPickTrigger = 2, A.OnRightPickTrigger = 3, A.OnCenterPickTrigger = 4, A.OnPickDownTrigger = 5, A.OnDoublePickTrigger = 6, A.OnPickUpTrigger = 7, A.OnPickOutTrigger = 16, A.OnLongPressTrigger = 8, A.OnPointerOverTrigger = 9, A.OnPointerOutTrigger = 10, A.OnEveryFrameTrigger = 11, A.OnIntersectionEnterTrigger = 12, A.OnIntersectionExitTrigger = 13, A.OnKeyDownTrigger = 14, A.OnKeyUpTrigger = 15, A.Triggers = {}, A;\n    }();\n\n    S.ActionManager = t;\n  }($a || ($a = {})), at = $a || ($a = {}), lt = function (c) {\n    function e(e, t, i, r, n, o, s, a) {\n      void 0 === n && (n = 1e3);\n      var l = c.call(this, e, o) || this;\n      return l.duration = 1e3, l.onInterpolationDoneObservable = new at.Observable(), l.propertyPath = i, l.value = r, l.duration = n, l.stopOtherAnimations = s, l.onInterpolationDone = a, l._target = l._effectiveTarget = t, l;\n    }\n\n    return T(e, c), e.prototype._prepare = function () {\n      this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath);\n    }, e.prototype.execute = function () {\n      var e,\n          t = this,\n          i = this._actionManager.getScene(),\n          r = [{\n        frame: 0,\n        value: this._effectiveTarget[this._property]\n      }, {\n        frame: 100,\n        value: this.value\n      }];\n\n      if (\"number\" == typeof this.value) e = at.Animation.ANIMATIONTYPE_FLOAT;else if (this.value instanceof at.Color3) e = at.Animation.ANIMATIONTYPE_COLOR3;else if (this.value instanceof at.Vector3) e = at.Animation.ANIMATIONTYPE_VECTOR3;else if (this.value instanceof at.Matrix) e = at.Animation.ANIMATIONTYPE_MATRIX;else {\n        if (!(this.value instanceof at.Quaternion)) return void at.Tools.Warn(\"InterpolateValueAction: Unsupported type (\" + typeof this.value + \")\");\n        e = at.Animation.ANIMATIONTYPE_QUATERNION;\n      }\n      var n = new at.Animation(\"InterpolateValueAction\", this._property, 1e3 / this.duration * 100, e, at.Animation.ANIMATIONLOOPMODE_CONSTANT);\n      n.setKeys(r), this.stopOtherAnimations && i.stopAnimation(this._effectiveTarget);\n      i.beginDirectAnimation(this._effectiveTarget, [n], 0, 100, !1, 1, function () {\n        t.onInterpolationDoneObservable.notifyObservers(t), t.onInterpolationDone && t.onInterpolationDone();\n      });\n    }, e.prototype.serialize = function (e) {\n      return c.prototype._serialize.call(this, {\n        name: \"InterpolateValueAction\",\n        properties: [at.Action._GetTargetProperty(this._target), {\n          name: \"propertyPath\",\n          value: this.propertyPath\n        }, {\n          name: \"value\",\n          value: at.Action._SerializeValueAsString(this.value)\n        }, {\n          name: \"duration\",\n          value: at.Action._SerializeValueAsString(this.duration)\n        }, {\n          name: \"stopOtherAnimations\",\n          value: at.Action._SerializeValueAsString(this.stopOtherAnimations) || !1\n        }]\n      }, e);\n    }, e;\n  }(at.Action), at.InterpolateValueAction = lt, function (r) {\n    var e = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e, r) || this;\n        return n.propertyPath = i, n._target = n._effectiveTarget = t, n;\n      }\n\n      return T(e, o), e.prototype._prepare = function () {\n        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath);\n      }, e.prototype.execute = function () {\n        this._effectiveTarget[this._property] = !this._effectiveTarget[this._property];\n      }, e.prototype.serialize = function (e) {\n        return o.prototype._serialize.call(this, {\n          name: \"SwitchBooleanAction\",\n          properties: [r.Action._GetTargetProperty(this._target), {\n            name: \"propertyPath\",\n            value: this.propertyPath\n          }]\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.SwitchBooleanAction = e;\n\n    var t = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e, r) || this;\n        return n.value = i, n._target = t, n;\n      }\n\n      return T(e, o), e.prototype.execute = function () {\n        this._target.state = this.value;\n      }, e.prototype.serialize = function (e) {\n        return o.prototype._serialize.call(this, {\n          name: \"SetStateAction\",\n          properties: [r.Action._GetTargetProperty(this._target), {\n            name: \"value\",\n            value: this.value\n          }]\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.SetStateAction = t;\n\n    var i = function (s) {\n      function e(e, t, i, r, n) {\n        var o = s.call(this, e, n) || this;\n        return o.propertyPath = i, o.value = r, o._target = o._effectiveTarget = t, o;\n      }\n\n      return T(e, s), e.prototype._prepare = function () {\n        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath);\n      }, e.prototype.execute = function () {\n        this._effectiveTarget[this._property] = this.value, this._target.markAsDirty && this._target.markAsDirty(this._property);\n      }, e.prototype.serialize = function (e) {\n        return s.prototype._serialize.call(this, {\n          name: \"SetValueAction\",\n          properties: [r.Action._GetTargetProperty(this._target), {\n            name: \"propertyPath\",\n            value: this.propertyPath\n          }, {\n            name: \"value\",\n            value: r.Action._SerializeValueAsString(this.value)\n          }]\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.SetValueAction = i;\n\n    var n = function (s) {\n      function e(e, t, i, r, n) {\n        var o = s.call(this, e, n) || this;\n        return o.propertyPath = i, o.value = r, o._target = o._effectiveTarget = t, o;\n      }\n\n      return T(e, s), e.prototype._prepare = function () {\n        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath), this._property = this._getProperty(this.propertyPath), \"number\" != typeof this._effectiveTarget[this._property] && r.Tools.Warn(\"Warning: IncrementValueAction can only be used with number values\");\n      }, e.prototype.execute = function () {\n        this._effectiveTarget[this._property] += this.value, this._target.markAsDirty && this._target.markAsDirty(this._property);\n      }, e.prototype.serialize = function (e) {\n        return s.prototype._serialize.call(this, {\n          name: \"IncrementValueAction\",\n          properties: [r.Action._GetTargetProperty(this._target), {\n            name: \"propertyPath\",\n            value: this.propertyPath\n          }, {\n            name: \"value\",\n            value: r.Action._SerializeValueAsString(this.value)\n          }]\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.IncrementValueAction = n;\n\n    var o = function (a) {\n      function e(e, t, i, r, n, o) {\n        var s = a.call(this, e, o) || this;\n        return s.from = i, s.to = r, s.loop = n, s._target = t, s;\n      }\n\n      return T(e, a), e.prototype._prepare = function () {}, e.prototype.execute = function () {\n        this._actionManager.getScene().beginAnimation(this._target, this.from, this.to, this.loop);\n      }, e.prototype.serialize = function (e) {\n        return a.prototype._serialize.call(this, {\n          name: \"PlayAnimationAction\",\n          properties: [r.Action._GetTargetProperty(this._target), {\n            name: \"from\",\n            value: String(this.from)\n          }, {\n            name: \"to\",\n            value: String(this.to)\n          }, {\n            name: \"loop\",\n            value: r.Action._SerializeValueAsString(this.loop) || !1\n          }]\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.PlayAnimationAction = o;\n\n    var s = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r._target = t, r;\n      }\n\n      return T(e, n), e.prototype._prepare = function () {}, e.prototype.execute = function () {\n        this._actionManager.getScene().stopAnimation(this._target);\n      }, e.prototype.serialize = function (e) {\n        return n.prototype._serialize.call(this, {\n          name: \"StopAnimationAction\",\n          properties: [r.Action._GetTargetProperty(this._target)]\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.StopAnimationAction = s;\n\n    var a = function (i) {\n      function e(e, t) {\n        return void 0 === e && (e = r.ActionManager.NothingTrigger), i.call(this, e, t) || this;\n      }\n\n      return T(e, i), e.prototype.execute = function () {}, e.prototype.serialize = function (e) {\n        return i.prototype._serialize.call(this, {\n          name: \"DoNothingAction\",\n          properties: []\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.DoNothingAction = a;\n\n    var l = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r.children = t, r;\n      }\n\n      return T(e, n), e.prototype._prepare = function () {\n        for (var e = 0; e < this.children.length; e++) this.children[e]._actionManager = this._actionManager, this.children[e]._prepare();\n      }, e.prototype.execute = function (e) {\n        for (var t = 0; t < this.children.length; t++) this.children[t].execute(e);\n      }, e.prototype.serialize = function (e) {\n        for (var t = n.prototype._serialize.call(this, {\n          name: \"CombineAction\",\n          properties: [],\n          combine: []\n        }, e), i = 0; i < this.children.length; i++) t.combine.push(this.children[i].serialize(null));\n\n        return t;\n      }, e;\n    }(r.Action);\n\n    r.CombineAction = l;\n\n    var c = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r.func = t, r;\n      }\n\n      return T(e, n), e.prototype.execute = function (e) {\n        this.func(e);\n      }, e;\n    }(r.Action);\n\n    r.ExecuteCodeAction = c;\n\n    var h = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e, r) || this;\n        return n._target = t, n._parent = i, n;\n      }\n\n      return T(e, o), e.prototype._prepare = function () {}, e.prototype.execute = function () {\n        if (this._target.parent !== this._parent) {\n          var e = this._parent.getWorldMatrix().clone();\n\n          e.invert(), this._target.position = r.Vector3.TransformCoordinates(this._target.position, e), this._target.parent = this._parent;\n        }\n      }, e.prototype.serialize = function (e) {\n        return o.prototype._serialize.call(this, {\n          name: \"SetParentAction\",\n          properties: [r.Action._GetTargetProperty(this._target), r.Action._GetTargetProperty(this._parent)]\n        }, e);\n      }, e;\n    }(r.Action);\n\n    r.SetParentAction = h;\n  }($a || ($a = {})), ct = $a || ($a = {}), ht = function () {\n    function e(e, t, i, r, n, o, s) {\n      if (void 0 === o && (o = .01), void 0 === s && (s = ct.Texture.TRILINEAR_SAMPLINGMODE), this.name = e, this.sprites = new Array(), this.renderingGroupId = 0, this.layerMask = 268435455, this.fogEnabled = !0, this.isPickable = !1, this.onDisposeObservable = new ct.Observable(), this._vertexBuffers = {}, n._getComponent(ct.SceneComponentConstants.NAME_SPRITE) || n._addComponent(new ct.SpriteSceneComponent(n)), this._capacity = i, this._spriteTexture = new ct.Texture(t, n, !0, !1, s), this._spriteTexture.wrapU = ct.Texture.CLAMP_ADDRESSMODE, this._spriteTexture.wrapV = ct.Texture.CLAMP_ADDRESSMODE, r.width && r.height) this.cellWidth = r.width, this.cellHeight = r.height;else {\n        if (void 0 === r) return;\n        this.cellWidth = r, this.cellHeight = r;\n      }\n      this._epsilon = o, this._scene = n, this._scene.spriteManagers.push(this);\n\n      for (var a = [], l = 0, c = 0; c < i; c++) a.push(l), a.push(l + 1), a.push(l + 2), a.push(l), a.push(l + 2), a.push(l + 3), l += 4;\n\n      this._indexBuffer = n.getEngine().createIndexBuffer(a), this._vertexData = new Float32Array(16 * i * 4), this._buffer = new ct.Buffer(n.getEngine(), this._vertexData, !0, 16);\n\n      var h = this._buffer.createVertexBuffer(ct.VertexBuffer.PositionKind, 0, 4),\n          u = this._buffer.createVertexBuffer(\"options\", 4, 4),\n          d = this._buffer.createVertexBuffer(\"cellInfo\", 8, 4),\n          f = this._buffer.createVertexBuffer(ct.VertexBuffer.ColorKind, 12, 4);\n\n      this._vertexBuffers[ct.VertexBuffer.PositionKind] = h, this._vertexBuffers.options = u, this._vertexBuffers.cellInfo = d, this._vertexBuffers[ct.VertexBuffer.ColorKind] = f, this._effectBase = this._scene.getEngine().createEffect(\"sprites\", [ct.VertexBuffer.PositionKind, \"options\", \"cellInfo\", ct.VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], \"\"), this._effectFog = this._scene.getEngine().createEffect(\"sprites\", [ct.VertexBuffer.PositionKind, \"options\", \"cellInfo\", ct.VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], \"#define FOG\");\n    }\n\n    return Object.defineProperty(e.prototype, \"onDispose\", {\n      set: function (e) {\n        this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"texture\", {\n      get: function () {\n        return this._spriteTexture;\n      },\n      set: function (e) {\n        this._spriteTexture = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._appendSpriteVertex = function (e, t, i, r, n) {\n      var o = 16 * e;\n      0 === i ? i = this._epsilon : 1 === i && (i = 1 - this._epsilon), 0 === r ? r = this._epsilon : 1 === r && (r = 1 - this._epsilon), this._vertexData[o] = t.position.x, this._vertexData[o + 1] = t.position.y, this._vertexData[o + 2] = t.position.z, this._vertexData[o + 3] = t.angle, this._vertexData[o + 4] = t.width, this._vertexData[o + 5] = t.height, this._vertexData[o + 6] = i, this._vertexData[o + 7] = r, this._vertexData[o + 8] = t.invertU ? 1 : 0, this._vertexData[o + 9] = t.invertV ? 1 : 0;\n      var s = t.cellIndex / n >> 0;\n      this._vertexData[o + 10] = t.cellIndex - s * n, this._vertexData[o + 11] = s, this._vertexData[o + 12] = t.color.r, this._vertexData[o + 13] = t.color.g, this._vertexData[o + 14] = t.color.b, this._vertexData[o + 15] = t.color.a;\n    }, e.prototype.intersects = function (e, t, i, r) {\n      for (var n = Math.min(this._capacity, this.sprites.length), o = ct.Vector3.Zero(), s = ct.Vector3.Zero(), a = Number.MAX_VALUE, l = null, c = ct.Vector3.Zero(), h = t.getViewMatrix(), u = 0; u < n; u++) {\n        var d = this.sprites[u];\n\n        if (d) {\n          if (i) {\n            if (!i(d)) continue;\n          } else if (!d.isPickable) continue;\n\n          if (ct.Vector3.TransformCoordinatesToRef(d.position, h, c), o.copyFromFloats(c.x - d.width / 2, c.y - d.height / 2, c.z), s.copyFromFloats(c.x + d.width / 2, c.y + d.height / 2, c.z), e.intersectsBoxMinMax(o, s)) {\n            var f = ct.Vector3.Distance(c, e.origin);\n            if (f < a && (a = f, l = d, r)) break;\n          }\n        }\n      }\n\n      if (l) {\n        var p = new ct.PickingInfo();\n        return p.hit = !0, p.pickedSprite = l, p.distance = a, p;\n      }\n\n      return null;\n    }, e.prototype.render = function () {\n      if (this._effectBase.isReady() && this._effectFog.isReady() && this._spriteTexture && this._spriteTexture.isReady()) {\n        for (var e = this._scene.getEngine(), t = this._spriteTexture.getBaseSize(), i = e.getDeltaTime(), r = Math.min(this._capacity, this.sprites.length), n = t.width / this.cellWidth, o = 0, s = 0; s < r; s++) {\n          var a = this.sprites[s];\n          a && a.isVisible && (a._animate(i), this._appendSpriteVertex(o++, a, 0, 0, n), this._appendSpriteVertex(o++, a, 1, 0, n), this._appendSpriteVertex(o++, a, 1, 1, n), this._appendSpriteVertex(o++, a, 0, 1, n));\n        }\n\n        this._buffer.update(this._vertexData);\n\n        var l = this._effectBase;\n        this._scene.fogEnabled && this._scene.fogMode !== ct.Scene.FOGMODE_NONE && this.fogEnabled && (l = this._effectFog), e.enableEffect(l);\n\n        var c = this._scene.getViewMatrix();\n\n        l.setTexture(\"diffuseSampler\", this._spriteTexture), l.setMatrix(\"view\", c), l.setMatrix(\"projection\", this._scene.getProjectionMatrix()), l.setFloat2(\"textureInfos\", this.cellWidth / t.width, this.cellHeight / t.height), this._scene.fogEnabled && this._scene.fogMode !== ct.Scene.FOGMODE_NONE && this.fogEnabled && (l.setFloat4(\"vFogInfos\", this._scene.fogMode, this._scene.fogStart, this._scene.fogEnd, this._scene.fogDensity), l.setColor3(\"vFogColor\", this._scene.fogColor)), e.bindBuffers(this._vertexBuffers, this._indexBuffer, l), e.setDepthFunctionToLessOrEqual(), l.setBool(\"alphaTest\", !0), e.setColorWrite(!1), e.drawElementsType(ct.Material.TriangleFillMode, 0, o / 4 * 6), e.setColorWrite(!0), l.setBool(\"alphaTest\", !1), e.setAlphaMode(ct.Engine.ALPHA_COMBINE), e.drawElementsType(ct.Material.TriangleFillMode, 0, o / 4 * 6), e.setAlphaMode(ct.Engine.ALPHA_DISABLE);\n      }\n    }, e.prototype.dispose = function () {\n      this._buffer && (this._buffer.dispose(), this._buffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this._spriteTexture && (this._spriteTexture.dispose(), this._spriteTexture = null);\n\n      var e = this._scene.spriteManagers.indexOf(this);\n\n      this._scene.spriteManagers.splice(e, 1), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear();\n    }, e;\n  }(), ct.SpriteManager = ht, ut = $a || ($a = {}), dt = function () {\n    function e(e, t) {\n      this.name = e, this.color = new ut.Color4(1, 1, 1, 1), this.width = 1, this.height = 1, this.angle = 0, this.cellIndex = 0, this.invertU = 0, this.invertV = 0, this.animations = new Array(), this.isPickable = !1, this._animationStarted = !1, this._loopAnimation = !1, this._fromIndex = 0, this._toIndex = 0, this._delay = 0, this._direction = 1, this._time = 0, this.isVisible = !0, this._manager = t, this._manager.sprites.push(this), this.position = ut.Vector3.Zero();\n    }\n\n    return Object.defineProperty(e.prototype, \"size\", {\n      get: function () {\n        return this.width;\n      },\n      set: function (e) {\n        this.width = e, this.height = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.playAnimation = function (e, t, i, r, n) {\n      this._fromIndex = e, this._toIndex = t, this._loopAnimation = i, this._delay = r, this._animationStarted = !0, this._direction = e < t ? 1 : -1, this.cellIndex = e, this._time = 0, this._onAnimationEnd = n;\n    }, e.prototype.stopAnimation = function () {\n      this._animationStarted = !1;\n    }, e.prototype._animate = function (e) {\n      this._animationStarted && (this._time += e, this._time > this._delay && (this._time = this._time % this._delay, this.cellIndex += this._direction, this.cellIndex > this._toIndex && (this._loopAnimation ? this.cellIndex = this._fromIndex : (this.cellIndex = this._toIndex, this._animationStarted = !1, this._onAnimationEnd && this._onAnimationEnd(), this.disposeWhenFinishedAnimating && this.dispose()))));\n    }, e.prototype.dispose = function () {\n      for (var e = 0; e < this._manager.sprites.length; e++) this._manager.sprites[e] == this && this._manager.sprites.splice(e, 1);\n    }, e;\n  }(), ut.Sprite = dt, function (l) {\n    l.Scene.prototype._internalPickSprites = function (e, t, i, r) {\n      if (!l.PickingInfo) return null;\n      var n = null;\n\n      if (!r) {\n        if (!this.activeCamera) return null;\n        r = this.activeCamera;\n      }\n\n      if (0 < this.spriteManagers.length) for (var o = 0; o < this.spriteManagers.length; o++) {\n        var s = this.spriteManagers[o];\n\n        if (s.isPickable) {\n          var a = s.intersects(e, r, t, i);\n          if (a && a.hit && (i || null == n || !(a.distance >= n.distance)) && (n = a, i)) break;\n        }\n      }\n      return n || new l.PickingInfo();\n    }, l.Scene.prototype.pickSprite = function (e, t, i, r, n) {\n      return this.createPickingRayInCameraSpaceToRef(e, t, this._tempSpritePickingRay, n), this._internalPickSprites(this._tempSpritePickingRay, i, r, n);\n    }, l.Scene.prototype.pickSpriteWithRay = function (e, t, i, r) {\n      if (!this._tempSpritePickingRay) return null;\n\n      if (!r) {\n        if (!this.activeCamera) return null;\n        r = this.activeCamera;\n      }\n\n      return l.Ray.TransformToRef(e, r.getViewMatrix(), this._tempSpritePickingRay), this._internalPickSprites(this._tempSpritePickingRay, t, i, r);\n    }, l.Scene.prototype.setPointerOverSprite = function (e) {\n      this._pointerOverSprite !== e && (this._pointerOverSprite && this._pointerOverSprite.actionManager && this._pointerOverSprite.actionManager.processTrigger(l.ActionManager.OnPointerOutTrigger, l.ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this)), this._pointerOverSprite = e, this._pointerOverSprite && this._pointerOverSprite.actionManager && this._pointerOverSprite.actionManager.processTrigger(l.ActionManager.OnPointerOverTrigger, l.ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this)));\n    }, l.Scene.prototype.getPointerOverSprite = function () {\n      return this._pointerOverSprite;\n    };\n\n    var e = function () {\n      function e(e) {\n        this.name = l.SceneComponentConstants.NAME_SPRITE, this.scene = e, this.scene.spriteManagers = new Array(), this.scene._tempSpritePickingRay = l.Ray ? l.Ray.Zero() : null, this.scene.onBeforeSpritesRenderingObservable = new l.Observable(), this.scene.onAfterSpritesRenderingObservable = new l.Observable(), this._spritePredicate = function (e) {\n          return !!e.actionManager && e.isPickable && e.actionManager.hasPointerTriggers;\n        };\n      }\n\n      return e.prototype.register = function () {\n        this.scene._pointerMoveStage.registerStep(l.SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove), this.scene._pointerDownStage.registerStep(l.SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown), this.scene._pointerUpStage.registerStep(l.SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n      }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {\n        this.scene.onBeforeSpritesRenderingObservable.clear(), this.scene.onAfterSpritesRenderingObservable.clear();\n\n        for (var e = this.scene.spriteManagers; e.length;) e[0].dispose();\n      }, e.prototype._pickSpriteButKeepRay = function (e, t, i, r, n) {\n        var o = this.scene.pickSprite(t, i, this._spritePredicate, r, n);\n        return o && (o.ray = e ? e.ray : null), o;\n      }, e.prototype._pointerMove = function (e, t, i, r, n) {\n        var o = this.scene;\n        return r ? o.setPointerOverSprite(null) : (i = this._pickSpriteButKeepRay(i, e, t, !1, o.cameraToUseForPointers || void 0)) && i.hit && i.pickedSprite ? (o.setPointerOverSprite(i.pickedSprite), o._pointerOverSprite && o._pointerOverSprite.actionManager && o._pointerOverSprite.actionManager.hoverCursor ? n.style.cursor = o._pointerOverSprite.actionManager.hoverCursor : n.style.cursor = o.hoverCursor) : o.setPointerOverSprite(null), i;\n      }, e.prototype._pointerDown = function (e, t, i, r) {\n        var n = this.scene;\n\n        if (n._pickedDownSprite = null, 0 < n.spriteManagers.length && (i = n.pickSprite(e, t, this._spritePredicate, !1, n.cameraToUseForPointers || void 0)) && i.hit && i.pickedSprite && i.pickedSprite.actionManager) {\n          switch (n._pickedDownSprite = i.pickedSprite, r.button) {\n            case 0:\n              i.pickedSprite.actionManager.processTrigger(l.ActionManager.OnLeftPickTrigger, l.ActionEvent.CreateNewFromSprite(i.pickedSprite, n, r));\n              break;\n\n            case 1:\n              i.pickedSprite.actionManager.processTrigger(l.ActionManager.OnCenterPickTrigger, l.ActionEvent.CreateNewFromSprite(i.pickedSprite, n, r));\n              break;\n\n            case 2:\n              i.pickedSprite.actionManager.processTrigger(l.ActionManager.OnRightPickTrigger, l.ActionEvent.CreateNewFromSprite(i.pickedSprite, n, r));\n          }\n\n          i.pickedSprite.actionManager && i.pickedSprite.actionManager.processTrigger(l.ActionManager.OnPickDownTrigger, l.ActionEvent.CreateNewFromSprite(i.pickedSprite, n, r));\n        }\n\n        return i;\n      }, e.prototype._pointerUp = function (e, t, i, r) {\n        var n = this.scene;\n\n        if (0 < n.spriteManagers.length) {\n          var o = n.pickSprite(e, t, this._spritePredicate, !1, n.cameraToUseForPointers || void 0);\n          o && (o.hit && o.pickedSprite && o.pickedSprite.actionManager && (o.pickedSprite.actionManager.processTrigger(l.ActionManager.OnPickUpTrigger, l.ActionEvent.CreateNewFromSprite(o.pickedSprite, n, r)), o.pickedSprite.actionManager && (this.scene._isPointerSwiping() || o.pickedSprite.actionManager.processTrigger(l.ActionManager.OnPickTrigger, l.ActionEvent.CreateNewFromSprite(o.pickedSprite, n, r)))), n._pickedDownSprite && n._pickedDownSprite.actionManager && n._pickedDownSprite !== o.pickedSprite && n._pickedDownSprite.actionManager.processTrigger(l.ActionManager.OnPickOutTrigger, l.ActionEvent.CreateNewFromSprite(n._pickedDownSprite, n, r)));\n        }\n\n        return i;\n      }, e;\n    }();\n\n    l.SpriteSceneComponent = e;\n  }($a || ($a = {})), function (_) {\n    var e = function (e, t, i) {\n      this.bu = e, this.bv = t, this.distance = i, this.faceId = 0, this.subMeshId = 0;\n    };\n\n    _.IntersectionInfo = e;\n\n    var t = function () {\n      function e() {\n        this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1, this.subMeshId = 0, this.pickedSprite = null, this.originMesh = null, this.ray = null;\n      }\n\n      return e.prototype.getNormal = function (e, t) {\n        if (void 0 === e && (e = !1), void 0 === t && (t = !0), !this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(_.VertexBuffer.NormalKind)) return null;\n        var i,\n            r = this.pickedMesh.getIndices();\n        if (!r) return null;\n\n        if (t) {\n          var n = this.pickedMesh.getVerticesData(_.VertexBuffer.NormalKind),\n              o = _.Vector3.FromArray(n, 3 * r[3 * this.faceId]),\n              s = _.Vector3.FromArray(n, 3 * r[3 * this.faceId + 1]),\n              a = _.Vector3.FromArray(n, 3 * r[3 * this.faceId + 2]);\n\n          o = o.scale(this.bu), s = s.scale(this.bv), a = a.scale(1 - this.bu - this.bv), i = new _.Vector3(o.x + s.x + a.x, o.y + s.y + a.y, o.z + s.z + a.z);\n        } else {\n          var l = this.pickedMesh.getVerticesData(_.VertexBuffer.PositionKind),\n              c = _.Vector3.FromArray(l, 3 * r[3 * this.faceId]),\n              h = _.Vector3.FromArray(l, 3 * r[3 * this.faceId + 1]),\n              u = _.Vector3.FromArray(l, 3 * r[3 * this.faceId + 2]),\n              d = c.subtract(h),\n              f = u.subtract(h);\n\n          i = _.Vector3.Cross(d, f);\n        }\n\n        if (e) {\n          var p = this.pickedMesh.getWorldMatrix();\n          this.pickedMesh.nonUniformScaling && (_.Tmp.Matrix[0].copyFrom(p), (p = _.Tmp.Matrix[0]).setTranslationFromFloats(0, 0, 0), p.invert(), p.transposeToRef(_.Tmp.Matrix[1]), p = _.Tmp.Matrix[1]), i = _.Vector3.TransformNormal(i, p);\n        }\n\n        return i.normalize(), i;\n      }, e.prototype.getTextureCoordinates = function () {\n        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(_.VertexBuffer.UVKind)) return null;\n        var e = this.pickedMesh.getIndices();\n        if (!e) return null;\n        var t = this.pickedMesh.getVerticesData(_.VertexBuffer.UVKind);\n        if (!t) return null;\n\n        var i = _.Vector2.FromArray(t, 2 * e[3 * this.faceId]),\n            r = _.Vector2.FromArray(t, 2 * e[3 * this.faceId + 1]),\n            n = _.Vector2.FromArray(t, 2 * e[3 * this.faceId + 2]);\n\n        return i = i.scale(1 - this.bu - this.bv), r = r.scale(this.bu), n = n.scale(this.bv), new _.Vector2(i.x + r.x + n.x, i.y + r.y + n.y);\n      }, e;\n    }();\n\n    _.PickingInfo = t;\n  }($a || ($a = {})), ft = $a || ($a = {}), pt = function () {\n    function T(e, t, i) {\n      void 0 === i && (i = Number.MAX_VALUE), this.origin = e, this.direction = t, this.length = i;\n    }\n\n    return T.prototype.intersectsBoxMinMax = function (e, t) {\n      var i,\n          r,\n          n,\n          o,\n          s = 0,\n          a = Number.MAX_VALUE;\n\n      if (Math.abs(this.direction.x) < 1e-7) {\n        if (this.origin.x < e.x || this.origin.x > t.x) return !1;\n      } else if (i = 1 / this.direction.x, r = (e.x - this.origin.x) * i, (n = (t.x - this.origin.x) * i) === -1 / 0 && (n = 1 / 0), n < r && (o = r, r = n, n = o), s = Math.max(r, s), (a = Math.min(n, a)) < s) return !1;\n\n      if (Math.abs(this.direction.y) < 1e-7) {\n        if (this.origin.y < e.y || this.origin.y > t.y) return !1;\n      } else if (i = 1 / this.direction.y, r = (e.y - this.origin.y) * i, (n = (t.y - this.origin.y) * i) === -1 / 0 && (n = 1 / 0), n < r && (o = r, r = n, n = o), s = Math.max(r, s), (a = Math.min(n, a)) < s) return !1;\n\n      if (Math.abs(this.direction.z) < 1e-7) {\n        if (this.origin.z < e.z || this.origin.z > t.z) return !1;\n      } else if (i = 1 / this.direction.z, r = (e.z - this.origin.z) * i, (n = (t.z - this.origin.z) * i) === -1 / 0 && (n = 1 / 0), n < r && (o = r, r = n, n = o), s = Math.max(r, s), (a = Math.min(n, a)) < s) return !1;\n\n      return !0;\n    }, T.prototype.intersectsBox = function (e) {\n      return this.intersectsBoxMinMax(e.minimum, e.maximum);\n    }, T.prototype.intersectsSphere = function (e) {\n      var t = e.center.x - this.origin.x,\n          i = e.center.y - this.origin.y,\n          r = e.center.z - this.origin.z,\n          n = t * t + i * i + r * r,\n          o = e.radius * e.radius;\n      if (n <= o) return !0;\n      var s = t * this.direction.x + i * this.direction.y + r * this.direction.z;\n      return !(s < 0) && n - s * s <= o;\n    }, T.prototype.intersectsTriangle = function (e, t, i) {\n      this._edge1 || (this._edge1 = ft.Vector3.Zero(), this._edge2 = ft.Vector3.Zero(), this._pvec = ft.Vector3.Zero(), this._tvec = ft.Vector3.Zero(), this._qvec = ft.Vector3.Zero()), t.subtractToRef(e, this._edge1), i.subtractToRef(e, this._edge2), ft.Vector3.CrossToRef(this.direction, this._edge2, this._pvec);\n      var r = ft.Vector3.Dot(this._edge1, this._pvec);\n      if (0 === r) return null;\n      var n = 1 / r;\n      this.origin.subtractToRef(e, this._tvec);\n      var o = ft.Vector3.Dot(this._tvec, this._pvec) * n;\n      if (o < 0 || 1 < o) return null;\n      ft.Vector3.CrossToRef(this._tvec, this._edge1, this._qvec);\n      var s = ft.Vector3.Dot(this.direction, this._qvec) * n;\n      if (s < 0 || 1 < o + s) return null;\n      var a = ft.Vector3.Dot(this._edge2, this._qvec) * n;\n      return a > this.length ? null : new ft.IntersectionInfo(o, s, a);\n    }, T.prototype.intersectsPlane = function (e) {\n      var t,\n          i = ft.Vector3.Dot(e.normal, this.direction);\n      if (Math.abs(i) < 9.99999997475243e-7) return null;\n      var r = ft.Vector3.Dot(e.normal, this.origin);\n      return (t = (-e.d - r) / i) < 0 ? t < -9.99999997475243e-7 ? null : 0 : t;\n    }, T.prototype.intersectsMesh = function (e, t) {\n      var i = ft.Tmp.Matrix[0];\n      return e.getWorldMatrix().invertToRef(i), this._tmpRay ? T.TransformToRef(this, i, this._tmpRay) : this._tmpRay = T.Transform(this, i), e.intersects(this._tmpRay, t);\n    }, T.prototype.intersectsMeshes = function (e, t, i) {\n      i ? i.length = 0 : i = [];\n\n      for (var r = 0; r < e.length; r++) {\n        var n = this.intersectsMesh(e[r], t);\n        n.hit && i.push(n);\n      }\n\n      return i.sort(this._comparePickingInfo), i;\n    }, T.prototype._comparePickingInfo = function (e, t) {\n      return e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : 0;\n    }, T.prototype.intersectionSegment = function (e, t, i) {\n      var r,\n          n,\n          o,\n          s,\n          a = this.origin.add(this.direction.multiplyByFloats(T.rayl, T.rayl, T.rayl)),\n          l = t.subtract(e),\n          c = a.subtract(this.origin),\n          h = e.subtract(this.origin),\n          u = ft.Vector3.Dot(l, l),\n          d = ft.Vector3.Dot(l, c),\n          f = ft.Vector3.Dot(c, c),\n          p = ft.Vector3.Dot(l, h),\n          _ = ft.Vector3.Dot(c, h),\n          m = u * f - d * d,\n          g = m,\n          v = m;\n\n      m < T.smallnum ? (n = 0, g = 1, s = _, v = f) : (s = u * _ - d * p, (n = d * _ - f * p) < 0 ? (n = 0, s = _, v = f) : g < n && (n = g, s = _ + d, v = f)), s < 0 ? -p < (s = 0) ? n = 0 : u < -p ? n = g : (n = -p, g = u) : v < s && (s = v, -p + d < 0 ? n = 0 : u < -p + d ? n = g : (n = -p + d, g = u)), r = Math.abs(n) < T.smallnum ? 0 : n / g, o = Math.abs(s) < T.smallnum ? 0 : s / v;\n      var y = c.multiplyByFloats(o, o, o),\n          b = h.add(l.multiplyByFloats(r, r, r)).subtract(y);\n      return 0 < o && o <= this.length && b.lengthSquared() < i * i ? y.length() : -1;\n    }, T.prototype.update = function (e, t, i, r, n, o, s) {\n      return ft.Vector3.UnprojectFloatsToRef(e, t, 0, i, r, n, o, s, this.origin), ft.Vector3.UnprojectFloatsToRef(e, t, 1, i, r, n, o, s, ft.Tmp.Vector3[0]), ft.Tmp.Vector3[0].subtractToRef(this.origin, this.direction), this.direction.normalize(), this;\n    }, T.Zero = function () {\n      return new T(ft.Vector3.Zero(), ft.Vector3.Zero());\n    }, T.CreateNew = function (e, t, i, r, n, o, s) {\n      return T.Zero().update(e, t, i, r, n, o, s);\n    }, T.CreateNewFromTo = function (e, t, i) {\n      void 0 === i && (i = ft.Matrix.Identity());\n      var r = t.subtract(e),\n          n = Math.sqrt(r.x * r.x + r.y * r.y + r.z * r.z);\n      return r.normalize(), T.Transform(new T(e, r, n), i);\n    }, T.Transform = function (e, t) {\n      var i = new T(new ft.Vector3(0, 0, 0), new ft.Vector3(0, 0, 0));\n      return T.TransformToRef(e, t, i), i;\n    }, T.TransformToRef = function (e, t, i) {\n      ft.Vector3.TransformCoordinatesToRef(e.origin, t, i.origin), ft.Vector3.TransformNormalToRef(e.direction, t, i.direction), i.length = e.length;\n      var r = i.direction,\n          n = r.length();\n\n      if (0 !== n && 1 !== n) {\n        var o = 1 / n;\n        r.x *= o, r.y *= o, r.z *= o, i.length *= n;\n      }\n    }, T.smallnum = 1e-8, T.rayl = 1e9, T;\n  }(), ft.Ray = pt, _t = $a || ($a = {}), mt = {\n    root: 0,\n    found: !1\n  }, gt = function (e, t, i, r) {\n    mt.root = 0, mt.found = !1;\n    var n = t * t - 4 * e * i;\n    if (n < 0) return mt;\n    var o = Math.sqrt(n),\n        s = (-t - o) / (2 * e),\n        a = (-t + o) / (2 * e);\n\n    if (a < s) {\n      var l = a;\n      a = s, s = l;\n    }\n\n    return 0 < s && s < r ? (mt.root = s, mt.found = !0) : 0 < a && a < r && (mt.root = a, mt.found = !0), mt;\n  }, vt = function () {\n    function e() {\n      this._collisionPoint = _t.Vector3.Zero(), this._planeIntersectionPoint = _t.Vector3.Zero(), this._tempVector = _t.Vector3.Zero(), this._tempVector2 = _t.Vector3.Zero(), this._tempVector3 = _t.Vector3.Zero(), this._tempVector4 = _t.Vector3.Zero(), this._edge = _t.Vector3.Zero(), this._baseToVertex = _t.Vector3.Zero(), this._destinationPoint = _t.Vector3.Zero(), this._slidePlaneNormal = _t.Vector3.Zero(), this._displacementVector = _t.Vector3.Zero(), this._radius = _t.Vector3.One(), this._retry = 0, this._basePointWorld = _t.Vector3.Zero(), this._velocityWorld = _t.Vector3.Zero(), this._normalizedVelocity = _t.Vector3.Zero(), this._collisionMask = -1;\n    }\n\n    return Object.defineProperty(e.prototype, \"collisionMask\", {\n      get: function () {\n        return this._collisionMask;\n      },\n      set: function (e) {\n        this._collisionMask = isNaN(e) ? -1 : e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"slidePlaneNormal\", {\n      get: function () {\n        return this._slidePlaneNormal;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._initialize = function (e, t, i) {\n      this._velocity = t, _t.Vector3.NormalizeToRef(t, this._normalizedVelocity), (this._basePoint = e).multiplyToRef(this._radius, this._basePointWorld), t.multiplyToRef(this._radius, this._velocityWorld), this._velocityWorldLength = this._velocityWorld.length(), this._epsilon = i, this.collisionFound = !1;\n    }, e.prototype._checkPointInTriangle = function (e, t, i, r, n) {\n      t.subtractToRef(e, this._tempVector), i.subtractToRef(e, this._tempVector2), _t.Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n\n      var o = _t.Vector3.Dot(this._tempVector4, n);\n\n      return !(o < 0) && (r.subtractToRef(e, this._tempVector3), _t.Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4), !((o = _t.Vector3.Dot(this._tempVector4, n)) < 0) && (_t.Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4), 0 <= (o = _t.Vector3.Dot(this._tempVector4, n))));\n    }, e.prototype._canDoCollision = function (e, t, i, r) {\n      var n,\n          o,\n          s,\n          a,\n          l = _t.Vector3.Distance(this._basePointWorld, e),\n          c = Math.max(this._radius.x, this._radius.y, this._radius.z);\n\n      return !(l > this._velocityWorldLength + c + t) && (n = i, o = r, s = this._basePointWorld, a = this._velocityWorldLength + c, !(n.x > s.x + a || s.x - a > o.x || n.y > s.y + a || s.y - a > o.y || n.z > s.z + a || s.z - a > o.z));\n    }, e.prototype._testTriangle = function (e, t, i, r, n, o) {\n      var s,\n          a = !1;\n      t || (t = []), t[e] || (t[e] = new _t.Plane(0, 0, 0, 0), t[e].copyFromPoints(i, r, n));\n      var l = t[e];\n\n      if (o || l.isFrontFacingTo(this._normalizedVelocity, 0)) {\n        var c = l.signedDistanceTo(this._basePoint),\n            h = _t.Vector3.Dot(l.normal, this._velocity);\n\n        if (0 == h) {\n          if (1 <= Math.abs(c)) return;\n          a = !0, s = 0;\n        } else {\n          var u = (1 - c) / h;\n\n          if (u < (s = (-1 - c) / h)) {\n            var d = u;\n            u = s, s = d;\n          }\n\n          if (1 < s || u < 0) return;\n          s < 0 && (s = 0), 1 < s && (s = 1);\n        }\n\n        this._collisionPoint.copyFromFloats(0, 0, 0);\n\n        var f = !1,\n            p = 1;\n\n        if (a || (this._basePoint.subtractToRef(l.normal, this._planeIntersectionPoint), this._velocity.scaleToRef(s, this._tempVector), this._planeIntersectionPoint.addInPlace(this._tempVector), this._checkPointInTriangle(this._planeIntersectionPoint, i, r, n, l.normal) && (f = !0, p = s, this._collisionPoint.copyFrom(this._planeIntersectionPoint))), !f) {\n          var _ = this._velocity.lengthSquared(),\n              m = _;\n\n          this._basePoint.subtractToRef(i, this._tempVector);\n\n          var g = 2 * _t.Vector3.Dot(this._velocity, this._tempVector),\n              v = this._tempVector.lengthSquared() - 1,\n              y = gt(m, g, v, p);\n\n          y.found && (p = y.root, f = !0, this._collisionPoint.copyFrom(i)), this._basePoint.subtractToRef(r, this._tempVector), g = 2 * _t.Vector3.Dot(this._velocity, this._tempVector), v = this._tempVector.lengthSquared() - 1, (y = gt(m, g, v, p)).found && (p = y.root, f = !0, this._collisionPoint.copyFrom(r)), this._basePoint.subtractToRef(n, this._tempVector), g = 2 * _t.Vector3.Dot(this._velocity, this._tempVector), v = this._tempVector.lengthSquared() - 1, (y = gt(m, g, v, p)).found && (p = y.root, f = !0, this._collisionPoint.copyFrom(n)), r.subtractToRef(i, this._edge), i.subtractToRef(this._basePoint, this._baseToVertex);\n\n          var b = this._edge.lengthSquared(),\n              T = _t.Vector3.Dot(this._edge, this._velocity),\n              E = _t.Vector3.Dot(this._edge, this._baseToVertex);\n\n          if (m = b * -_ + T * T, g = b * (2 * _t.Vector3.Dot(this._velocity, this._baseToVertex)) - 2 * T * E, v = b * (1 - this._baseToVertex.lengthSquared()) + E * E, (y = gt(m, g, v, p)).found) {\n            var x = (T * y.root - E) / b;\n            0 <= x && x <= 1 && (p = y.root, f = !0, this._edge.scaleInPlace(x), i.addToRef(this._edge, this._collisionPoint));\n          }\n\n          n.subtractToRef(r, this._edge), r.subtractToRef(this._basePoint, this._baseToVertex), b = this._edge.lengthSquared(), T = _t.Vector3.Dot(this._edge, this._velocity), E = _t.Vector3.Dot(this._edge, this._baseToVertex), m = b * -_ + T * T, g = b * (2 * _t.Vector3.Dot(this._velocity, this._baseToVertex)) - 2 * T * E, v = b * (1 - this._baseToVertex.lengthSquared()) + E * E, (y = gt(m, g, v, p)).found && 0 <= (x = (T * y.root - E) / b) && x <= 1 && (p = y.root, f = !0, this._edge.scaleInPlace(x), r.addToRef(this._edge, this._collisionPoint)), i.subtractToRef(n, this._edge), n.subtractToRef(this._basePoint, this._baseToVertex), b = this._edge.lengthSquared(), T = _t.Vector3.Dot(this._edge, this._velocity), E = _t.Vector3.Dot(this._edge, this._baseToVertex), m = b * -_ + T * T, g = b * (2 * _t.Vector3.Dot(this._velocity, this._baseToVertex)) - 2 * T * E, v = b * (1 - this._baseToVertex.lengthSquared()) + E * E, (y = gt(m, g, v, p)).found && 0 <= (x = (T * y.root - E) / b) && x <= 1 && (p = y.root, f = !0, this._edge.scaleInPlace(x), n.addToRef(this._edge, this._collisionPoint));\n        }\n\n        if (f) {\n          var P = p * this._velocity.length();\n\n          (!this.collisionFound || P < this._nearestDistance) && (this.intersectionPoint ? this.intersectionPoint.copyFrom(this._collisionPoint) : this.intersectionPoint = this._collisionPoint.clone(), this._nearestDistance = P, this.collisionFound = !0);\n        }\n      }\n    }, e.prototype._collide = function (e, t, i, r, n, o, s) {\n      for (var a = r; a < n; a += 3) {\n        var l = t[i[a] - o],\n            c = t[i[a + 1] - o],\n            h = t[i[a + 2] - o];\n\n        this._testTriangle(a, e, h, c, l, s);\n      }\n    }, e.prototype._getResponse = function (e, t) {\n      e.addToRef(t, this._destinationPoint), t.scaleInPlace(this._nearestDistance / t.length()), this._basePoint.addToRef(t, e), e.subtractToRef(this.intersectionPoint, this._slidePlaneNormal), this._slidePlaneNormal.normalize(), this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector), e.addInPlace(this._displacementVector), this.intersectionPoint.addInPlace(this._displacementVector), this._slidePlaneNormal.scaleInPlace(_t.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint)), this._destinationPoint.subtractInPlace(this._slidePlaneNormal), this._destinationPoint.subtractToRef(this.intersectionPoint, t);\n    }, e;\n  }(), _t.Collider = vt, function (h) {\n    var l, e, s, t;\n    h.CollisionWorker = \"\", (e = l = h.WorkerTaskType || (h.WorkerTaskType = {}))[e.INIT = 0] = \"INIT\", e[e.UPDATE = 1] = \"UPDATE\", e[e.COLLIDE = 2] = \"COLLIDE\", (t = s = h.WorkerReplyType || (h.WorkerReplyType = {}))[t.SUCCESS = 0] = \"SUCCESS\", t[t.UNKNOWN_ERROR = 1] = \"UNKNOWN_ERROR\";\n\n    var i = function () {\n      function t() {\n        var o = this;\n        this._scaledPosition = h.Vector3.Zero(), this._scaledVelocity = h.Vector3.Zero(), this.onMeshUpdated = function (e) {\n          o._addUpdateMeshesList[e.uniqueId] = t.SerializeMesh(e);\n        }, this.onGeometryUpdated = function (e) {\n          o._addUpdateGeometriesList[e.id] = t.SerializeGeometry(e);\n        }, this._afterRender = function () {\n          if (o._init && !(0 == o._toRemoveGeometryArray.length && 0 == o._toRemoveMeshesArray.length && 0 == Object.keys(o._addUpdateGeometriesList).length && 0 == Object.keys(o._addUpdateMeshesList).length || 4 < o._runningUpdated)) {\n            ++o._runningUpdated;\n            var e = {\n              updatedMeshes: o._addUpdateMeshesList,\n              updatedGeometries: o._addUpdateGeometriesList,\n              removedGeometries: o._toRemoveGeometryArray,\n              removedMeshes: o._toRemoveMeshesArray\n            },\n                t = {\n              payload: e,\n              taskType: l.UPDATE\n            },\n                i = [];\n\n            for (var r in e.updatedGeometries) e.updatedGeometries.hasOwnProperty(r) && (i.push(t.payload.updatedGeometries[r].indices.buffer), i.push(t.payload.updatedGeometries[r].normals.buffer), i.push(t.payload.updatedGeometries[r].positions.buffer));\n\n            o._worker.postMessage(t, i), o._addUpdateMeshesList = {}, o._addUpdateGeometriesList = {}, o._toRemoveGeometryArray = [], o._toRemoveMeshesArray = [];\n          }\n        }, this._onMessageFromWorker = function (e) {\n          var t = e.data;\n          if (t.error == s.SUCCESS) switch (t.taskType) {\n            case l.INIT:\n              o._init = !0, o._scene.meshes.forEach(function (e) {\n                o.onMeshAdded(e);\n              }), o._scene.getGeometries().forEach(function (e) {\n                o.onGeometryAdded(e);\n              });\n              break;\n\n            case l.UPDATE:\n              o._runningUpdated--;\n              break;\n\n            case l.COLLIDE:\n              var i = t.payload;\n              if (!o._collisionsCallbackArray[i.collisionId]) return;\n              var r = o._collisionsCallbackArray[i.collisionId];\n\n              if (r) {\n                var n = o._scene.getMeshByUniqueID(i.collidedMeshUniqueId);\n\n                n && r(i.collisionId, h.Vector3.FromArray(i.newPosition), n);\n              }\n\n              o._collisionsCallbackArray[i.collisionId] = null;\n          } else h.Tools.Warn(\"error returned from worker!\");\n        }, this._collisionsCallbackArray = [], this._init = !1, this._runningUpdated = 0, this._addUpdateMeshesList = {}, this._addUpdateGeometriesList = {}, this._toRemoveGeometryArray = [], this._toRemoveMeshesArray = [];\n      }\n\n      return t.prototype.getNewPosition = function (e, t, i, r, n, o, s) {\n        if (this._init && !this._collisionsCallbackArray[s] && !this._collisionsCallbackArray[s + 1e5]) {\n          e.divideToRef(i._radius, this._scaledPosition), t.divideToRef(i._radius, this._scaledVelocity), this._collisionsCallbackArray[s] = o;\n          var a = {\n            payload: {\n              collider: {\n                position: this._scaledPosition.asArray(),\n                velocity: this._scaledVelocity.asArray(),\n                radius: i._radius.asArray()\n              },\n              collisionId: s,\n              excludedMeshUniqueId: n ? n.uniqueId : null,\n              maximumRetry: r\n            },\n            taskType: l.COLLIDE\n          };\n\n          this._worker.postMessage(a);\n        }\n      }, t.prototype.init = function (e) {\n        this._scene = e, this._scene.registerAfterRender(this._afterRender);\n        var t = h.WorkerIncluded ? h.Engine.CodeRepository + \"Collisions/babylon.collisionWorker.js\" : URL.createObjectURL(new Blob([h.CollisionWorker], {\n          type: \"application/javascript\"\n        }));\n        this._worker = new Worker(t), this._worker.onmessage = this._onMessageFromWorker;\n        var i = {\n          payload: {},\n          taskType: l.INIT\n        };\n\n        this._worker.postMessage(i);\n      }, t.prototype.destroy = function () {\n        this._scene.unregisterAfterRender(this._afterRender), this._worker.terminate();\n      }, t.prototype.onMeshAdded = function (e) {\n        e.registerAfterWorldMatrixUpdate(this.onMeshUpdated), this.onMeshUpdated(e);\n      }, t.prototype.onMeshRemoved = function (e) {\n        this._toRemoveMeshesArray.push(e.uniqueId);\n      }, t.prototype.onGeometryAdded = function (e) {\n        e.onGeometryUpdated = this.onGeometryUpdated, this.onGeometryUpdated(e);\n      }, t.prototype.onGeometryDeleted = function (e) {\n        this._toRemoveGeometryArray.push(e.id);\n      }, t.SerializeMesh = function (e) {\n        var t = [];\n        e.subMeshes && (t = e.subMeshes.map(function (e, t) {\n          var i = e.getBoundingInfo();\n          return {\n            position: t,\n            verticesStart: e.verticesStart,\n            verticesCount: e.verticesCount,\n            indexStart: e.indexStart,\n            indexCount: e.indexCount,\n            hasMaterial: !!e.getMaterial(),\n            sphereCenter: i.boundingSphere.centerWorld.asArray(),\n            sphereRadius: i.boundingSphere.radiusWorld,\n            boxMinimum: i.boundingBox.minimumWorld.asArray(),\n            boxMaximum: i.boundingBox.maximumWorld.asArray()\n          };\n        }));\n        var i = null;\n        if (e instanceof h.Mesh) i = (r = e.geometry) ? r.id : null;else if (e instanceof h.InstancedMesh) {\n          var r;\n          i = (r = e.sourceMesh && e.sourceMesh.geometry) ? r.id : null;\n        }\n        var n = e.getBoundingInfo();\n        return {\n          uniqueId: e.uniqueId,\n          id: e.id,\n          name: e.name,\n          geometryId: i,\n          sphereCenter: n.boundingSphere.centerWorld.asArray(),\n          sphereRadius: n.boundingSphere.radiusWorld,\n          boxMinimum: n.boundingBox.minimumWorld.asArray(),\n          boxMaximum: n.boundingBox.maximumWorld.asArray(),\n          worldMatrixFromCache: e.worldMatrixFromCache.asArray(),\n          subMeshes: t,\n          checkCollisions: e.checkCollisions\n        };\n      }, t.SerializeGeometry = function (e) {\n        return {\n          id: e.id,\n          positions: new Float32Array(e.getVerticesData(h.VertexBuffer.PositionKind) || []),\n          normals: new Float32Array(e.getVerticesData(h.VertexBuffer.NormalKind) || []),\n          indices: new Uint32Array(e.getIndices() || [])\n        };\n      }, t;\n    }();\n\n    h.CollisionCoordinatorWorker = i;\n\n    var r = function () {\n      function e() {\n        this._scaledPosition = h.Vector3.Zero(), this._scaledVelocity = h.Vector3.Zero(), this._finalPosition = h.Vector3.Zero();\n      }\n\n      return e.prototype.getNewPosition = function (e, t, i, r, n, o, s) {\n        e.divideToRef(i._radius, this._scaledPosition), t.divideToRef(i._radius, this._scaledVelocity), i.collidedMesh = null, i._retry = 0, i._initialVelocity = this._scaledVelocity, i._initialPosition = this._scaledPosition, this._collideWithWorld(this._scaledPosition, this._scaledVelocity, i, r, this._finalPosition, n), this._finalPosition.multiplyInPlace(i._radius), o(s, this._finalPosition, i.collidedMesh);\n      }, e.prototype.init = function (e) {\n        this._scene = e;\n      }, e.prototype.destroy = function () {}, e.prototype.onMeshAdded = function (e) {}, e.prototype.onMeshUpdated = function (e) {}, e.prototype.onMeshRemoved = function (e) {}, e.prototype.onGeometryAdded = function (e) {}, e.prototype.onGeometryUpdated = function (e) {}, e.prototype.onGeometryDeleted = function (e) {}, e.prototype._collideWithWorld = function (e, t, i, r, n, o) {\n        void 0 === o && (o = null);\n        var s = 10 * h.Engine.CollisionsEpsilon;\n        if (i._retry >= r) n.copyFrom(e);else {\n          var a = o ? o.collisionMask : i.collisionMask;\n\n          i._initialize(e, t, s);\n\n          for (var l = 0; l < this._scene.meshes.length; l++) {\n            var c = this._scene.meshes[l];\n            c.isEnabled() && c.checkCollisions && c.subMeshes && c !== o && 0 != (a & c.collisionGroup) && c._checkCollision(i);\n          }\n\n          i.collisionFound ? (0 === t.x && 0 === t.y && 0 === t.z || i._getResponse(e, t), t.length() <= s ? n.copyFrom(e) : (i._retry++, this._collideWithWorld(e, t, i, r, n, o))) : e.addToRef(t, n);\n        }\n      }, e;\n    }();\n\n    h.CollisionCoordinatorLegacy = r;\n  }($a || ($a = {})), yt = $a || ($a = {}), bt = function () {\n    function t(e) {\n      this.particleSystem = e, this.position = yt.Vector3.Zero(), this.direction = yt.Vector3.Zero(), this.color = new yt.Color4(0, 0, 0, 0), this.colorStep = new yt.Color4(0, 0, 0, 0), this.lifeTime = 1, this.age = 0, this.size = 0, this.scale = new yt.Vector2(1, 1), this.angle = 0, this.angularSpeed = 0, this.cellIndex = 0, this._attachedSubEmitters = null, this._currentColor1 = new yt.Color4(0, 0, 0, 0), this._currentColor2 = new yt.Color4(0, 0, 0, 0), this._currentSize1 = 0, this._currentSize2 = 0, this._currentAngularSpeed1 = 0, this._currentAngularSpeed2 = 0, this._currentVelocity1 = 0, this._currentVelocity2 = 0, this._currentLimitVelocity1 = 0, this._currentLimitVelocity2 = 0, this._currentDrag1 = 0, this._currentDrag2 = 0, this.id = t._Count++, this.particleSystem.isAnimationSheetEnabled && this.updateCellInfoFromSystem();\n    }\n\n    return t.prototype.updateCellInfoFromSystem = function () {\n      this.cellIndex = this.particleSystem.startSpriteCellID;\n    }, t.prototype.updateCellIndex = function () {\n      var e = this.age,\n          t = this.particleSystem.spriteCellChangeSpeed;\n      this.particleSystem.spriteRandomStartCell && (void 0 === this._randomCellOffset && (this._randomCellOffset = Math.random() * this.lifeTime), 0 === t ? (t = 1, e = this._randomCellOffset) : e += this._randomCellOffset);\n      var i = this._initialEndSpriteCellID - this._initialStartSpriteCellID,\n          r = yt.Scalar.Clamp(e * t % this.lifeTime / this.lifeTime);\n      this.cellIndex = this._initialStartSpriteCellID + r * i | 0;\n    }, t.prototype._inheritParticleInfoToSubEmitter = function (e) {\n      if (e.particleSystem.emitter.position) {\n        var t = e.particleSystem.emitter;\n        t.position.copyFrom(this.position), e.inheritDirection && (t.position.subtractToRef(this.direction, yt.Tmp.Vector3[0]), t.lookAt(yt.Tmp.Vector3[0], 0, Math.PI / 2));\n      } else {\n        e.particleSystem.emitter.copyFrom(this.position);\n      }\n\n      this.direction.scaleToRef(e.inheritedVelocityAmount / 2, yt.Tmp.Vector3[0]), e.particleSystem._inheritedVelocityOffset.copyFrom(yt.Tmp.Vector3[0]);\n    }, t.prototype._inheritParticleInfoToSubEmitters = function () {\n      var t = this;\n      this._attachedSubEmitters && 0 < this._attachedSubEmitters.length && this._attachedSubEmitters.forEach(function (e) {\n        t._inheritParticleInfoToSubEmitter(e);\n      });\n    }, t.prototype._reset = function () {\n      this.age = 0, this._currentColorGradient = null, this._currentSizeGradient = null, this._currentAngularSpeedGradient = null, this._currentVelocityGradient = null, this._currentLimitVelocityGradient = null, this._currentDragGradient = null, this.cellIndex = this.particleSystem.startSpriteCellID, this._randomCellOffset = void 0;\n    }, t.prototype.copyTo = function (e) {\n      e.position.copyFrom(this.position), this._initialDirection ? e._initialDirection ? e._initialDirection.copyFrom(this._initialDirection) : e._initialDirection = this._initialDirection.clone() : e._initialDirection = null, e.direction.copyFrom(this.direction), e.color.copyFrom(this.color), e.colorStep.copyFrom(this.colorStep), e.lifeTime = this.lifeTime, e.age = this.age, e._randomCellOffset = this._randomCellOffset, e.size = this.size, e.scale.copyFrom(this.scale), e.angle = this.angle, e.angularSpeed = this.angularSpeed, e.particleSystem = this.particleSystem, e.cellIndex = this.cellIndex, e.id = this.id, e._attachedSubEmitters = this._attachedSubEmitters, this._currentColorGradient && (e._currentColorGradient = this._currentColorGradient, e._currentColor1.copyFrom(this._currentColor1), e._currentColor2.copyFrom(this._currentColor2)), this._currentSizeGradient && (e._currentSizeGradient = this._currentSizeGradient, e._currentSize1 = this._currentSize1, e._currentSize2 = this._currentSize2), this._currentAngularSpeedGradient && (e._currentAngularSpeedGradient = this._currentAngularSpeedGradient, e._currentAngularSpeed1 = this._currentAngularSpeed1, e._currentAngularSpeed2 = this._currentAngularSpeed2), this._currentVelocityGradient && (e._currentVelocityGradient = this._currentVelocityGradient, e._currentVelocity1 = this._currentVelocity1, e._currentVelocity2 = this._currentVelocity2), this._currentLimitVelocityGradient && (e._currentLimitVelocityGradient = this._currentLimitVelocityGradient, e._currentLimitVelocity1 = this._currentLimitVelocity1, e._currentLimitVelocity2 = this._currentLimitVelocity2), this._currentDragGradient && (e._currentDragGradient = this._currentDragGradient, e._currentDrag1 = this._currentDrag1, e._currentDrag2 = this._currentDrag2), this.particleSystem.isAnimationSheetEnabled && (e._initialStartSpriteCellID = this._initialStartSpriteCellID, e._initialEndSpriteCellID = this._initialEndSpriteCellID), this.particleSystem.useRampGradients && e.remapData.copyFrom(this.remapData), this._randomNoiseCoordinates1 && (e._randomNoiseCoordinates1 ? (e._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1), e._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2)) : (e._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone(), e._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone()));\n    }, t._Count = 0, t;\n  }(), yt.Particle = bt, Tt = $a || ($a = {}), Et = function () {\n    function e(e) {\n      this.animations = [], this.renderingGroupId = 0, this.emitter = null, this.emitRate = 10, this.manualEmitCount = -1, this.updateSpeed = .01, this.targetStopDuration = 0, this.disposeOnStop = !1, this.minEmitPower = 1, this.maxEmitPower = 1, this.minLifeTime = 1, this.maxLifeTime = 1, this.minSize = 1, this.maxSize = 1, this.minScaleX = 1, this.maxScaleX = 1, this.minScaleY = 1, this.maxScaleY = 1, this.minInitialRotation = 0, this.maxInitialRotation = 0, this.minAngularSpeed = 0, this.maxAngularSpeed = 0, this.layerMask = 268435455, this.customShader = null, this.preventAutoStart = !1, this.noiseStrength = new Tt.Vector3(10, 10, 10), this.onAnimationEnd = null, this.blendMode = Tt.ParticleSystem.BLENDMODE_ONEONE, this.forceDepthWrite = !1, this.preWarmCycles = 0, this.preWarmStepOffset = 1, this.spriteCellChangeSpeed = 1, this.startSpriteCellID = 0, this.endSpriteCellID = 0, this.spriteCellWidth = 0, this.spriteCellHeight = 0, this.spriteRandomStartCell = !1, this.translationPivot = new Tt.Vector2(0, 0), this.beginAnimationOnStart = !1, this.beginAnimationFrom = 0, this.beginAnimationTo = 60, this.beginAnimationLoop = !1, this.gravity = Tt.Vector3.Zero(), this._colorGradients = null, this._sizeGradients = null, this._lifeTimeGradients = null, this._angularSpeedGradients = null, this._velocityGradients = null, this._limitVelocityGradients = null, this._dragGradients = null, this._emitRateGradients = null, this._startSizeGradients = null, this._rampGradients = null, this._colorRemapGradients = null, this._alphaRemapGradients = null, this.startDelay = 0, this.limitVelocityDamping = .4, this.color1 = new Tt.Color4(1, 1, 1, 1), this.color2 = new Tt.Color4(1, 1, 1, 1), this.colorDead = new Tt.Color4(0, 0, 0, 1), this.textureMask = new Tt.Color4(1, 1, 1, 1), this._isSubEmitter = !1, this.billboardMode = Tt.ParticleSystem.BILLBOARDMODE_ALL, this._isBillboardBased = !0, this._imageProcessingConfigurationDefines = new Tt.ImageProcessingConfigurationDefines(), this.id = e, this.name = e;\n    }\n\n    return Object.defineProperty(e.prototype, \"isAnimationSheetEnabled\", {\n      get: function () {\n        return this._isAnimationSheetEnabled;\n      },\n      set: function (e) {\n        this._isAnimationSheetEnabled != e && (this._isAnimationSheetEnabled = e, this._reset());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getScene = function () {\n      return this._scene;\n    }, e.prototype._hasTargetStopDurationDependantGradient = function () {\n      return this._startSizeGradients && 0 < this._startSizeGradients.length || this._emitRateGradients && 0 < this._emitRateGradients.length || this._lifeTimeGradients && 0 < this._lifeTimeGradients.length;\n    }, e.prototype.getDragGradients = function () {\n      return this._dragGradients;\n    }, e.prototype.getLimitVelocityGradients = function () {\n      return this._limitVelocityGradients;\n    }, e.prototype.getColorGradients = function () {\n      return this._colorGradients;\n    }, e.prototype.getSizeGradients = function () {\n      return this._sizeGradients;\n    }, e.prototype.getColorRemapGradients = function () {\n      return this._colorRemapGradients;\n    }, e.prototype.getAlphaRemapGradients = function () {\n      return this._alphaRemapGradients;\n    }, e.prototype.getLifeTimeGradients = function () {\n      return this._lifeTimeGradients;\n    }, e.prototype.getAngularSpeedGradients = function () {\n      return this._angularSpeedGradients;\n    }, e.prototype.getVelocityGradients = function () {\n      return this._velocityGradients;\n    }, e.prototype.getStartSizeGradients = function () {\n      return this._startSizeGradients;\n    }, e.prototype.getEmitRateGradients = function () {\n      return this._emitRateGradients;\n    }, Object.defineProperty(e.prototype, \"direction1\", {\n      get: function () {\n        return this.particleEmitterType.direction1 ? this.particleEmitterType.direction1 : Tt.Vector3.Zero();\n      },\n      set: function (e) {\n        this.particleEmitterType.direction1 && (this.particleEmitterType.direction1 = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"direction2\", {\n      get: function () {\n        return this.particleEmitterType.direction2 ? this.particleEmitterType.direction2 : Tt.Vector3.Zero();\n      },\n      set: function (e) {\n        this.particleEmitterType.direction2 && (this.particleEmitterType.direction2 = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"minEmitBox\", {\n      get: function () {\n        return this.particleEmitterType.minEmitBox ? this.particleEmitterType.minEmitBox : Tt.Vector3.Zero();\n      },\n      set: function (e) {\n        this.particleEmitterType.minEmitBox && (this.particleEmitterType.minEmitBox = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"maxEmitBox\", {\n      get: function () {\n        return this.particleEmitterType.maxEmitBox ? this.particleEmitterType.maxEmitBox : Tt.Vector3.Zero();\n      },\n      set: function (e) {\n        this.particleEmitterType.maxEmitBox && (this.particleEmitterType.maxEmitBox = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isBillboardBased\", {\n      get: function () {\n        return this._isBillboardBased;\n      },\n      set: function (e) {\n        this._isBillboardBased !== e && (this._isBillboardBased = e, this._reset());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"imageProcessingConfiguration\", {\n      get: function () {\n        return this._imageProcessingConfiguration;\n      },\n      set: function (e) {\n        this._attachImageProcessingConfiguration(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._attachImageProcessingConfiguration = function (e) {\n      e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration = e || this._scene.imageProcessingConfiguration);\n    }, e.prototype._reset = function () {}, e.prototype._removeGradientAndTexture = function (e, t, i) {\n      if (!t) return this;\n\n      for (var r = 0, n = 0, o = t; n < o.length; n++) {\n        if (o[n].gradient === e) {\n          t.splice(r, 1);\n          break;\n        }\n\n        r++;\n      }\n\n      return i && i.dispose(), this;\n    }, e.prototype.createPointEmitter = function (e, t) {\n      var i = new Tt.PointParticleEmitter();\n      return i.direction1 = e, i.direction2 = t, this.particleEmitterType = i;\n    }, e.prototype.createHemisphericEmitter = function (e, t) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1);\n      var i = new Tt.HemisphericParticleEmitter(e, t);\n      return this.particleEmitterType = i;\n    }, e.prototype.createSphereEmitter = function (e, t) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1);\n      var i = new Tt.SphereParticleEmitter(e, t);\n      return this.particleEmitterType = i;\n    }, e.prototype.createDirectedSphereEmitter = function (e, t, i) {\n      void 0 === e && (e = 1), void 0 === t && (t = new Tt.Vector3(0, 1, 0)), void 0 === i && (i = new Tt.Vector3(0, 1, 0));\n      var r = new Tt.SphereDirectedParticleEmitter(e, t, i);\n      return this.particleEmitterType = r;\n    }, e.prototype.createCylinderEmitter = function (e, t, i, r) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === i && (i = 1), void 0 === r && (r = 0);\n      var n = new Tt.CylinderParticleEmitter(e, t, i, r);\n      return this.particleEmitterType = n;\n    }, e.prototype.createDirectedCylinderEmitter = function (e, t, i, r, n) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === i && (i = 1), void 0 === r && (r = new Tt.Vector3(0, 1, 0)), void 0 === n && (n = new Tt.Vector3(0, 1, 0));\n      var o = new Tt.CylinderDirectedParticleEmitter(e, t, i, r, n);\n      return this.particleEmitterType = o;\n    }, e.prototype.createConeEmitter = function (e, t) {\n      void 0 === e && (e = 1), void 0 === t && (t = Math.PI / 4);\n      var i = new Tt.ConeParticleEmitter(e, t);\n      return this.particleEmitterType = i;\n    }, e.prototype.createBoxEmitter = function (e, t, i, r) {\n      var n = new Tt.BoxParticleEmitter();\n      return this.particleEmitterType = n, this.direction1 = e, this.direction2 = t, this.minEmitBox = i, this.maxEmitBox = r, n;\n    }, e.BLENDMODE_ONEONE = 0, e.BLENDMODE_STANDARD = 1, e.BLENDMODE_ADD = 2, e.BLENDMODE_MULTIPLY = 3, e.BLENDMODE_MULTIPLYADD = 4, e;\n  }(), Tt.BaseParticleSystem = Et, xt = $a || ($a = {}), Pt = function (s) {\n    function _(e, t, i, r, n, o) {\n      void 0 === r && (r = null), void 0 === n && (n = !1), void 0 === o && (o = .01);\n\n      var _ = s.call(this, e) || this;\n\n      return _._inheritedVelocityOffset = new xt.Vector3(), _.onDisposeObservable = new xt.Observable(), _._particles = new Array(), _._stockParticles = new Array(), _._newPartsExcess = 0, _._vertexBuffers = {}, _._scaledColorStep = new xt.Color4(0, 0, 0, 0), _._colorDiff = new xt.Color4(0, 0, 0, 0), _._scaledDirection = xt.Vector3.Zero(), _._scaledGravity = xt.Vector3.Zero(), _._currentRenderId = -1, _._useInstancing = !1, _._started = !1, _._stopped = !1, _._actualFrame = 0, _._currentEmitRate1 = 0, _._currentEmitRate2 = 0, _._currentStartSize1 = 0, _._currentStartSize2 = 0, _._rawTextureWidth = 256, _._useRampGradients = !1, _._disposeEmitterOnDispose = !1, _.recycleParticle = function (e) {\n        var t = _._particles.pop();\n\n        t !== e && t.copyTo(e), _._stockParticles.push(t);\n      }, _._createParticle = function () {\n        var i;\n\n        if (0 !== _._stockParticles.length ? (i = _._stockParticles.pop())._reset() : i = new xt.Particle(_), _._subEmitters && 0 < _._subEmitters.length) {\n          var e = _._subEmitters[Math.floor(Math.random() * _._subEmitters.length)];\n\n          i._attachedSubEmitters = [], e.forEach(function (e) {\n            if (e.type === xt.SubEmitterType.ATTACHED) {\n              var t = e.clone();\n              i._attachedSubEmitters.push(t), t.particleSystem.start();\n            }\n          });\n        }\n\n        return i;\n      }, _._emitFromParticle = function (i) {\n        if (_._subEmitters && 0 !== _._subEmitters.length) {\n          var e = Math.floor(Math.random() * _._subEmitters.length);\n\n          _._subEmitters[e].forEach(function (e) {\n            if (e.type === xt.SubEmitterType.END) {\n              var t = e.clone();\n              i._inheritParticleInfoToSubEmitter(t), (t.particleSystem._rootParticleSystem = _).activeSubSystems.push(t.particleSystem), t.particleSystem.start();\n            }\n          });\n        }\n      }, _._capacity = t, _._epsilon = o, _._isAnimationSheetEnabled = n, _._scene = i || xt.Engine.LastCreatedScene, _._attachImageProcessingConfiguration(null), _._customEffect = r, _._scene.particleSystems.push(_), _._useInstancing = _._scene.getEngine().getCaps().instancedArrays, _._createIndexBuffer(), _._createVertexBuffers(), _.particleEmitterType = new xt.BoxParticleEmitter(), _.updateFunction = function (h) {\n        var u = null,\n            d = null;\n        _.noiseTexture && (u = _.noiseTexture.getSize(), d = _.noiseTexture.getContent());\n\n        for (var f, e = function () {\n          f = h[p];\n          var e = _._scaledUpdateSpeed,\n              t = f.age;\n\n          if (f.age += e, f.age > f.lifeTime) {\n            var i = f.age - t;\n            e = (f.lifeTime - t) * e / i, f.age = f.lifeTime;\n          }\n\n          var r = f.age / f.lifeTime;\n          _._colorGradients && 0 < _._colorGradients.length ? xt.Tools.GetCurrentGradient(r, _._colorGradients, function (e, t, i) {\n            e !== f._currentColorGradient && (f._currentColor1.copyFrom(f._currentColor2), t.getColorToRef(f._currentColor2), f._currentColorGradient = e), xt.Color4.LerpToRef(f._currentColor1, f._currentColor2, i, f.color);\n          }) : (f.colorStep.scaleToRef(e, _._scaledColorStep), f.color.addInPlace(_._scaledColorStep), f.color.a < 0 && (f.color.a = 0)), _._angularSpeedGradients && 0 < _._angularSpeedGradients.length && xt.Tools.GetCurrentGradient(r, _._angularSpeedGradients, function (e, t, i) {\n            e !== f._currentAngularSpeedGradient && (f._currentAngularSpeed1 = f._currentAngularSpeed2, f._currentAngularSpeed2 = t.getFactor(), f._currentAngularSpeedGradient = e), f.angularSpeed = xt.Scalar.Lerp(f._currentAngularSpeed1, f._currentAngularSpeed2, i);\n          }), f.angle += f.angularSpeed * e;\n          var n = e;\n\n          if (_._velocityGradients && 0 < _._velocityGradients.length && xt.Tools.GetCurrentGradient(r, _._velocityGradients, function (e, t, i) {\n            e !== f._currentVelocityGradient && (f._currentVelocity1 = f._currentVelocity2, f._currentVelocity2 = t.getFactor(), f._currentVelocityGradient = e), n *= xt.Scalar.Lerp(f._currentVelocity1, f._currentVelocity2, i);\n          }), f.direction.scaleToRef(n, _._scaledDirection), _._limitVelocityGradients && 0 < _._limitVelocityGradients.length && xt.Tools.GetCurrentGradient(r, _._limitVelocityGradients, function (e, t, i) {\n            e !== f._currentLimitVelocityGradient && (f._currentLimitVelocity1 = f._currentLimitVelocity2, f._currentLimitVelocity2 = t.getFactor(), f._currentLimitVelocityGradient = e), xt.Scalar.Lerp(f._currentLimitVelocity1, f._currentLimitVelocity2, i) < f.direction.length() && f.direction.scaleInPlace(_.limitVelocityDamping);\n          }), _._dragGradients && 0 < _._dragGradients.length && xt.Tools.GetCurrentGradient(r, _._dragGradients, function (e, t, i) {\n            e !== f._currentDragGradient && (f._currentDrag1 = f._currentDrag2, f._currentDrag2 = t.getFactor(), f._currentDragGradient = e);\n            var r = xt.Scalar.Lerp(f._currentDrag1, f._currentDrag2, i);\n\n            _._scaledDirection.scaleInPlace(1 - r);\n          }), f.position.addInPlace(_._scaledDirection), d && u) {\n            var o = _._fetchR(f._randomNoiseCoordinates1.x, f._randomNoiseCoordinates1.y, u.width, u.height, d),\n                s = _._fetchR(f._randomNoiseCoordinates1.z, f._randomNoiseCoordinates2.x, u.width, u.height, d),\n                a = _._fetchR(f._randomNoiseCoordinates2.y, f._randomNoiseCoordinates2.z, u.width, u.height, d),\n                l = xt.Tmp.Vector3[0],\n                c = xt.Tmp.Vector3[1];\n\n            l.copyFromFloats((2 * o - 1) * _.noiseStrength.x, (2 * s - 1) * _.noiseStrength.y, (2 * a - 1) * _.noiseStrength.z), l.scaleToRef(e, c), f.direction.addInPlace(c);\n          }\n\n          if (_.gravity.scaleToRef(e, _._scaledGravity), f.direction.addInPlace(_._scaledGravity), _._sizeGradients && 0 < _._sizeGradients.length && xt.Tools.GetCurrentGradient(r, _._sizeGradients, function (e, t, i) {\n            e !== f._currentSizeGradient && (f._currentSize1 = f._currentSize2, f._currentSize2 = t.getFactor(), f._currentSizeGradient = e), f.size = xt.Scalar.Lerp(f._currentSize1, f._currentSize2, i);\n          }), _._useRampGradients && (_._colorRemapGradients && 0 < _._colorRemapGradients.length && xt.Tools.GetCurrentGradient(r, _._colorRemapGradients, function (e, t, i) {\n            var r = xt.Scalar.Lerp(e.factor1, t.factor1, i),\n                n = xt.Scalar.Lerp(e.factor2, t.factor2, i);\n            f.remapData.x = r, f.remapData.y = n - r;\n          }), _._alphaRemapGradients && 0 < _._alphaRemapGradients.length && xt.Tools.GetCurrentGradient(r, _._alphaRemapGradients, function (e, t, i) {\n            var r = xt.Scalar.Lerp(e.factor1, t.factor1, i),\n                n = xt.Scalar.Lerp(e.factor2, t.factor2, i);\n            f.remapData.z = r, f.remapData.w = n - r;\n          })), _._isAnimationSheetEnabled && f.updateCellIndex(), f._inheritParticleInfoToSubEmitters(), f.age >= f.lifeTime) return _._emitFromParticle(f), f._attachedSubEmitters && (f._attachedSubEmitters.forEach(function (e) {\n            e.particleSystem.disposeOnStop = !0, e.particleSystem.stop();\n          }), f._attachedSubEmitters = null), _.recycleParticle(f), p--, \"continue\";\n        }, p = 0; p < h.length; p++) e();\n      }, _;\n    }\n\n    return T(_, s), Object.defineProperty(_.prototype, \"onDispose\", {\n      set: function (e) {\n        this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(_.prototype, \"useRampGradients\", {\n      get: function () {\n        return this._useRampGradients;\n      },\n      set: function (e) {\n        this._useRampGradients !== e && (this._useRampGradients = e, this._resetEffect());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(_.prototype, \"particles\", {\n      get: function () {\n        return this._particles;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), _.prototype.getClassName = function () {\n      return \"ParticleSystem\";\n    }, _.prototype._addFactorGradient = function (e, t, i, r) {\n      var n = new xt.FactorGradient();\n      n.gradient = t, n.factor1 = i, n.factor2 = r, e.push(n), e.sort(function (e, t) {\n        return e.gradient < t.gradient ? -1 : e.gradient > t.gradient ? 1 : 0;\n      });\n    }, _.prototype._removeFactorGradient = function (e, t) {\n      if (e) for (var i = 0, r = 0, n = e; r < n.length; r++) {\n        if (n[r].gradient === t) {\n          e.splice(i, 1);\n          break;\n        }\n\n        i++;\n      }\n    }, _.prototype.addLifeTimeGradient = function (e, t, i) {\n      return this._lifeTimeGradients || (this._lifeTimeGradients = []), this._addFactorGradient(this._lifeTimeGradients, e, t, i), this;\n    }, _.prototype.removeLifeTimeGradient = function (e) {\n      return this._removeFactorGradient(this._lifeTimeGradients, e), this;\n    }, _.prototype.addSizeGradient = function (e, t, i) {\n      return this._sizeGradients || (this._sizeGradients = []), this._addFactorGradient(this._sizeGradients, e, t, i), this;\n    }, _.prototype.removeSizeGradient = function (e) {\n      return this._removeFactorGradient(this._sizeGradients, e), this;\n    }, _.prototype.addColorRemapGradient = function (e, t, i) {\n      return this._colorRemapGradients || (this._colorRemapGradients = []), this._addFactorGradient(this._colorRemapGradients, e, t, i), this;\n    }, _.prototype.removeColorRemapGradient = function (e) {\n      return this._removeFactorGradient(this._colorRemapGradients, e), this;\n    }, _.prototype.addAlphaRemapGradient = function (e, t, i) {\n      return this._alphaRemapGradients || (this._alphaRemapGradients = []), this._addFactorGradient(this._alphaRemapGradients, e, t, i), this;\n    }, _.prototype.removeAlphaRemapGradient = function (e) {\n      return this._removeFactorGradient(this._alphaRemapGradients, e), this;\n    }, _.prototype.addAngularSpeedGradient = function (e, t, i) {\n      return this._angularSpeedGradients || (this._angularSpeedGradients = []), this._addFactorGradient(this._angularSpeedGradients, e, t, i), this;\n    }, _.prototype.removeAngularSpeedGradient = function (e) {\n      return this._removeFactorGradient(this._angularSpeedGradients, e), this;\n    }, _.prototype.addVelocityGradient = function (e, t, i) {\n      return this._velocityGradients || (this._velocityGradients = []), this._addFactorGradient(this._velocityGradients, e, t, i), this;\n    }, _.prototype.removeVelocityGradient = function (e) {\n      return this._removeFactorGradient(this._velocityGradients, e), this;\n    }, _.prototype.addLimitVelocityGradient = function (e, t, i) {\n      return this._limitVelocityGradients || (this._limitVelocityGradients = []), this._addFactorGradient(this._limitVelocityGradients, e, t, i), this;\n    }, _.prototype.removeLimitVelocityGradient = function (e) {\n      return this._removeFactorGradient(this._limitVelocityGradients, e), this;\n    }, _.prototype.addDragGradient = function (e, t, i) {\n      return this._dragGradients || (this._dragGradients = []), this._addFactorGradient(this._dragGradients, e, t, i), this;\n    }, _.prototype.removeDragGradient = function (e) {\n      return this._removeFactorGradient(this._dragGradients, e), this;\n    }, _.prototype.addEmitRateGradient = function (e, t, i) {\n      return this._emitRateGradients || (this._emitRateGradients = []), this._addFactorGradient(this._emitRateGradients, e, t, i), this;\n    }, _.prototype.removeEmitRateGradient = function (e) {\n      return this._removeFactorGradient(this._emitRateGradients, e), this;\n    }, _.prototype.addStartSizeGradient = function (e, t, i) {\n      return this._startSizeGradients || (this._startSizeGradients = []), this._addFactorGradient(this._startSizeGradients, e, t, i), this;\n    }, _.prototype.removeStartSizeGradient = function (e) {\n      return this._removeFactorGradient(this._emitRateGradients, e), this;\n    }, _.prototype._createRampGradientTexture = function () {\n      if (this._rampGradients && this._rampGradients.length && !this._rampGradientsTexture) {\n        for (var r = new Uint8Array(4 * this._rawTextureWidth), n = xt.Tmp.Color3[0], o = 0; o < this._rawTextureWidth; o++) {\n          var e = o / this._rawTextureWidth;\n          xt.Tools.GetCurrentGradient(e, this._rampGradients, function (e, t, i) {\n            xt.Color3.LerpToRef(e.color, t.color, i, n), r[4 * o] = 255 * n.r, r[4 * o + 1] = 255 * n.g, r[4 * o + 2] = 255 * n.b, r[4 * o + 3] = 255;\n          });\n        }\n\n        this._rampGradientsTexture = xt.RawTexture.CreateRGBATexture(r, this._rawTextureWidth, 1, this._scene, !1, !1, xt.Texture.NEAREST_SAMPLINGMODE);\n      }\n    }, _.prototype.getRampGradients = function () {\n      return this._rampGradients;\n    }, _.prototype.addRampGradient = function (e, t) {\n      this._rampGradients || (this._rampGradients = []);\n      var i = new xt.Color3Gradient();\n      return i.gradient = e, i.color = t, this._rampGradients.push(i), this._rampGradients.sort(function (e, t) {\n        return e.gradient < t.gradient ? -1 : e.gradient > t.gradient ? 1 : 0;\n      }), this._rampGradientsTexture && (this._rampGradientsTexture.dispose(), this._rampGradientsTexture = null), this._createRampGradientTexture(), this;\n    }, _.prototype.removeRampGradient = function (e) {\n      return this._removeGradientAndTexture(e, this._rampGradients, this._rampGradientsTexture), this._rampGradientsTexture = null, this._rampGradients && 0 < this._rampGradients.length && this._createRampGradientTexture(), this;\n    }, _.prototype.addColorGradient = function (e, t, i) {\n      this._colorGradients || (this._colorGradients = []);\n      var r = new xt.ColorGradient();\n      return r.gradient = e, r.color1 = t, r.color2 = i, this._colorGradients.push(r), this._colorGradients.sort(function (e, t) {\n        return e.gradient < t.gradient ? -1 : e.gradient > t.gradient ? 1 : 0;\n      }), this;\n    }, _.prototype.removeColorGradient = function (e) {\n      if (!this._colorGradients) return this;\n\n      for (var t = 0, i = 0, r = this._colorGradients; i < r.length; i++) {\n        if (r[i].gradient === e) {\n          this._colorGradients.splice(t, 1);\n\n          break;\n        }\n\n        t++;\n      }\n\n      return this;\n    }, _.prototype._fetchR = function (e, t, i, r, n) {\n      return n[4 * (((e = .5 * Math.abs(e) + .5) * i % i | 0) + ((t = .5 * Math.abs(t) + .5) * r % r | 0) * i)] / 255;\n    }, _.prototype._reset = function () {\n      this._resetEffect();\n    }, _.prototype._resetEffect = function () {\n      this._vertexBuffer && (this._vertexBuffer.dispose(), this._vertexBuffer = null), this._spriteBuffer && (this._spriteBuffer.dispose(), this._spriteBuffer = null), this._createVertexBuffers();\n    }, _.prototype._createVertexBuffers = function () {\n      this._vertexBufferSize = this._useInstancing ? 10 : 12, this._isAnimationSheetEnabled && (this._vertexBufferSize += 1), this._isBillboardBased && this.billboardMode !== _.BILLBOARDMODE_STRETCHED || (this._vertexBufferSize += 3), this._useRampGradients && (this._vertexBufferSize += 4);\n\n      var e = this._scene.getEngine();\n\n      this._vertexData = new Float32Array(this._capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4)), this._vertexBuffer = new xt.Buffer(e, this._vertexData, !0, this._vertexBufferSize);\n\n      var t = 0,\n          i = this._vertexBuffer.createVertexBuffer(xt.VertexBuffer.PositionKind, t, 3, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[xt.VertexBuffer.PositionKind] = i, t += 3;\n\n      var r = this._vertexBuffer.createVertexBuffer(xt.VertexBuffer.ColorKind, t, 4, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers[xt.VertexBuffer.ColorKind] = r, t += 4;\n\n      var n = this._vertexBuffer.createVertexBuffer(\"angle\", t, 1, this._vertexBufferSize, this._useInstancing);\n\n      this._vertexBuffers.angle = n, t += 1;\n\n      var o,\n          s = this._vertexBuffer.createVertexBuffer(\"size\", t, 2, this._vertexBufferSize, this._useInstancing);\n\n      if (this._vertexBuffers.size = s, t += 2, this._isAnimationSheetEnabled) {\n        var a = this._vertexBuffer.createVertexBuffer(\"cellIndex\", t, 1, this._vertexBufferSize, this._useInstancing);\n\n        this._vertexBuffers.cellIndex = a, t += 1;\n      }\n\n      if (!this._isBillboardBased || this.billboardMode === _.BILLBOARDMODE_STRETCHED) {\n        var l = this._vertexBuffer.createVertexBuffer(\"direction\", t, 3, this._vertexBufferSize, this._useInstancing);\n\n        this._vertexBuffers.direction = l, t += 3;\n      }\n\n      if (this._useRampGradients) {\n        var c = this._vertexBuffer.createVertexBuffer(\"remapData\", t, 4, this._vertexBufferSize, this._useInstancing);\n\n        this._vertexBuffers.remapData = c, t += 4;\n      }\n\n      if (this._useInstancing) {\n        var h = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n        this._spriteBuffer = new xt.Buffer(e, h, !1, 2), o = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n      } else o = this._vertexBuffer.createVertexBuffer(\"offset\", t, 2, this._vertexBufferSize, this._useInstancing), t += 2;\n\n      this._vertexBuffers.offset = o;\n    }, _.prototype._createIndexBuffer = function () {\n      if (!this._useInstancing) {\n        for (var e = [], t = 0, i = 0; i < this._capacity; i++) e.push(t), e.push(t + 1), e.push(t + 2), e.push(t), e.push(t + 2), e.push(t + 3), t += 4;\n\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(e);\n      }\n    }, _.prototype.getCapacity = function () {\n      return this._capacity;\n    }, _.prototype.isAlive = function () {\n      return this._alive;\n    }, _.prototype.isStarted = function () {\n      return this._started;\n    }, _.prototype._prepareSubEmitterInternalArray = function () {\n      var t = this;\n      this._subEmitters = new Array(), this.subEmitters && this.subEmitters.forEach(function (e) {\n        e instanceof _ ? t._subEmitters.push([new xt.SubEmitter(e)]) : e instanceof xt.SubEmitter ? t._subEmitters.push([e]) : e instanceof Array && t._subEmitters.push(e);\n      });\n    }, _.prototype.start = function (e) {\n      var t = this;\n      if (void 0 === e && (e = this.startDelay), !this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n      if (e) setTimeout(function () {\n        t.start(0);\n      }, e);else {\n        if (this._prepareSubEmitterInternalArray(), this._started = !0, this._stopped = !1, this._actualFrame = 0, this._subEmitters && 0 != this._subEmitters.length && (this.activeSubSystems = new Array()), this._emitRateGradients && (0 < this._emitRateGradients.length && (this._currentEmitRateGradient = this._emitRateGradients[0], this._currentEmitRate1 = this._currentEmitRateGradient.getFactor(), this._currentEmitRate2 = this._currentEmitRate1), 1 < this._emitRateGradients.length && (this._currentEmitRate2 = this._emitRateGradients[1].getFactor())), this._startSizeGradients && (0 < this._startSizeGradients.length && (this._currentStartSizeGradient = this._startSizeGradients[0], this._currentStartSize1 = this._currentStartSizeGradient.getFactor(), this._currentStartSize2 = this._currentStartSize1), 1 < this._startSizeGradients.length && (this._currentStartSize2 = this._startSizeGradients[1].getFactor())), this.preWarmCycles) {\n          this.emitter instanceof xt.AbstractMesh && this.emitter.computeWorldMatrix(!0);\n          var i = this.noiseTexture;\n          if (i && i.onGeneratedObservable) i.onGeneratedObservable.addOnce(function () {\n            setTimeout(function () {\n              for (var e = 0; e < t.preWarmCycles; e++) t.animate(!0), i.render();\n            });\n          });else for (var r = 0; r < this.preWarmCycles; r++) this.animate(!0);\n        }\n\n        this.beginAnimationOnStart && this.animations && 0 < this.animations.length && this.getScene().beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n      }\n    }, _.prototype.stop = function (e) {\n      void 0 === e && (e = !0), this._stopped = !0, e && this._stopSubEmitters();\n    }, _.prototype.reset = function () {\n      this._stockParticles = [], this._particles = [];\n    }, _.prototype._appendParticleVertex = function (e, t, i, r) {\n      var n = e * this._vertexBufferSize;\n      this._vertexData[n++] = t.position.x, this._vertexData[n++] = t.position.y, this._vertexData[n++] = t.position.z, this._vertexData[n++] = t.color.r, this._vertexData[n++] = t.color.g, this._vertexData[n++] = t.color.b, this._vertexData[n++] = t.color.a, this._vertexData[n++] = t.angle, this._vertexData[n++] = t.scale.x * t.size, this._vertexData[n++] = t.scale.y * t.size, this._isAnimationSheetEnabled && (this._vertexData[n++] = t.cellIndex), this._isBillboardBased ? this.billboardMode === _.BILLBOARDMODE_STRETCHED && (this._vertexData[n++] = t.direction.x, this._vertexData[n++] = t.direction.y, this._vertexData[n++] = t.direction.z) : t._initialDirection ? (this._vertexData[n++] = t._initialDirection.x, this._vertexData[n++] = t._initialDirection.y, this._vertexData[n++] = t._initialDirection.z) : (this._vertexData[n++] = t.direction.x, this._vertexData[n++] = t.direction.y, this._vertexData[n++] = t.direction.z), this._useRampGradients && (this._vertexData[n++] = t.remapData.x, this._vertexData[n++] = t.remapData.y, this._vertexData[n++] = t.remapData.z, this._vertexData[n++] = t.remapData.w), this._useInstancing || (this._isAnimationSheetEnabled && (0 === i ? i = this._epsilon : 1 === i && (i = 1 - this._epsilon), 0 === r ? r = this._epsilon : 1 === r && (r = 1 - this._epsilon)), this._vertexData[n++] = i, this._vertexData[n++] = r);\n    }, _.prototype._stopSubEmitters = function () {\n      this.activeSubSystems && (this.activeSubSystems.forEach(function (e) {\n        e.stop(!0);\n      }), this.activeSubSystems = new Array());\n    }, _.prototype._removeFromRoot = function () {\n      if (this._rootParticleSystem) {\n        var e = this._rootParticleSystem.activeSubSystems.indexOf(this);\n\n        -1 !== e && this._rootParticleSystem.activeSubSystems.splice(e, 1), this._rootParticleSystem = null;\n      }\n    }, _.prototype._update = function (e) {\n      var c,\n          n = this;\n\n      if (this._alive = 0 < this._particles.length, this.emitter.position) {\n        var t = this.emitter;\n        this._emitterWorldMatrix = t.getWorldMatrix();\n      } else {\n        var i = this.emitter;\n        this._emitterWorldMatrix = xt.Matrix.Translation(i.x, i.y, i.z);\n      }\n\n      this.updateFunction(this._particles);\n\n      for (var r, o = function () {\n        if (s._particles.length === s._capacity) return \"break\";\n        c = s._createParticle(), s._particles.push(c);\n        var e = xt.Scalar.RandomRange(s.minEmitPower, s.maxEmitPower);\n\n        if (s.startPositionFunction ? s.startPositionFunction(s._emitterWorldMatrix, c.position, c) : s.particleEmitterType.startPositionFunction(s._emitterWorldMatrix, c.position, c), s.startDirectionFunction ? s.startDirectionFunction(s._emitterWorldMatrix, c.direction, c) : s.particleEmitterType.startDirectionFunction(s._emitterWorldMatrix, c.direction, c), 0 === e ? c._initialDirection ? c._initialDirection.copyFrom(c.direction) : c._initialDirection = c.direction.clone() : c._initialDirection = null, c.direction.scaleInPlace(e), s.targetStopDuration && s._lifeTimeGradients && 0 < s._lifeTimeGradients.length) {\n          var l = xt.Scalar.Clamp(s._actualFrame / s.targetStopDuration);\n          xt.Tools.GetCurrentGradient(l, s._lifeTimeGradients, function (e, t, i) {\n            var r = e,\n                n = t,\n                o = r.getFactor(),\n                s = n.getFactor(),\n                a = (l - r.gradient) / (n.gradient - r.gradient);\n            c.lifeTime = xt.Scalar.Lerp(o, s, a);\n          });\n        } else c.lifeTime = xt.Scalar.RandomRange(s.minLifeTime, s.maxLifeTime);\n\n        if (s._sizeGradients && 0 !== s._sizeGradients.length ? (c._currentSizeGradient = s._sizeGradients[0], c._currentSize1 = c._currentSizeGradient.getFactor(), c.size = c._currentSize1, 1 < s._sizeGradients.length ? c._currentSize2 = s._sizeGradients[1].getFactor() : c._currentSize2 = c._currentSize1) : c.size = xt.Scalar.RandomRange(s.minSize, s.maxSize), c.scale.copyFromFloats(xt.Scalar.RandomRange(s.minScaleX, s.maxScaleX), xt.Scalar.RandomRange(s.minScaleY, s.maxScaleY)), s._startSizeGradients && s._startSizeGradients[0] && s.targetStopDuration) {\n          var t = s._actualFrame / s.targetStopDuration;\n          xt.Tools.GetCurrentGradient(t, s._startSizeGradients, function (e, t, i) {\n            e !== n._currentStartSizeGradient && (n._currentStartSize1 = n._currentStartSize2, n._currentStartSize2 = t.getFactor(), n._currentStartSizeGradient = e);\n            var r = xt.Scalar.Lerp(n._currentStartSize1, n._currentStartSize2, i);\n            c.scale.scaleInPlace(r);\n          });\n        }\n\n        s._angularSpeedGradients && 0 !== s._angularSpeedGradients.length ? (c._currentAngularSpeedGradient = s._angularSpeedGradients[0], c.angularSpeed = c._currentAngularSpeedGradient.getFactor(), c._currentAngularSpeed1 = c.angularSpeed, 1 < s._angularSpeedGradients.length ? c._currentAngularSpeed2 = s._angularSpeedGradients[1].getFactor() : c._currentAngularSpeed2 = c._currentAngularSpeed1) : c.angularSpeed = xt.Scalar.RandomRange(s.minAngularSpeed, s.maxAngularSpeed), c.angle = xt.Scalar.RandomRange(s.minInitialRotation, s.maxInitialRotation), s._velocityGradients && 0 < s._velocityGradients.length && (c._currentVelocityGradient = s._velocityGradients[0], c._currentVelocity1 = c._currentVelocityGradient.getFactor(), 1 < s._velocityGradients.length ? c._currentVelocity2 = s._velocityGradients[1].getFactor() : c._currentVelocity2 = c._currentVelocity1), s._limitVelocityGradients && 0 < s._limitVelocityGradients.length && (c._currentLimitVelocityGradient = s._limitVelocityGradients[0], c._currentLimitVelocity1 = c._currentLimitVelocityGradient.getFactor(), 1 < s._limitVelocityGradients.length ? c._currentLimitVelocity2 = s._limitVelocityGradients[1].getFactor() : c._currentLimitVelocity2 = c._currentLimitVelocity1), s._dragGradients && 0 < s._dragGradients.length && (c._currentDragGradient = s._dragGradients[0], c._currentDrag1 = c._currentDragGradient.getFactor(), 1 < s._dragGradients.length ? c._currentDrag2 = s._dragGradients[1].getFactor() : c._currentDrag2 = c._currentDrag1), s._colorGradients && 0 !== s._colorGradients.length ? (c._currentColorGradient = s._colorGradients[0], c._currentColorGradient.getColorToRef(c.color), c._currentColor1.copyFrom(c.color), 1 < s._colorGradients.length ? s._colorGradients[1].getColorToRef(c._currentColor2) : c._currentColor2.copyFrom(c.color)) : (r = xt.Scalar.RandomRange(0, 1), xt.Color4.LerpToRef(s.color1, s.color2, r, c.color), s.colorDead.subtractToRef(c.color, s._colorDiff), s._colorDiff.scaleToRef(1 / c.lifeTime, c.colorStep)), s._isAnimationSheetEnabled && (c._initialStartSpriteCellID = s.startSpriteCellID, c._initialEndSpriteCellID = s.endSpriteCellID), c.direction.addInPlace(s._inheritedVelocityOffset), s._useRampGradients && (c.remapData = new xt.Vector4(0, 1, 0, 1)), s.noiseTexture && (c._randomNoiseCoordinates1 ? (c._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random()), c._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random())) : (c._randomNoiseCoordinates1 = new xt.Vector3(Math.random(), Math.random(), Math.random()), c._randomNoiseCoordinates2 = new xt.Vector3(Math.random(), Math.random(), Math.random()))), c._inheritParticleInfoToSubEmitters();\n      }, s = this, a = 0; a < e; a++) {\n        if (\"break\" === o()) break;\n      }\n    }, _._GetAttributeNamesOrOptions = function (e, t, i) {\n      void 0 === e && (e = !1), void 0 === t && (t = !1), void 0 === i && (i = !1);\n      var r = [xt.VertexBuffer.PositionKind, xt.VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n      return e && r.push(\"cellIndex\"), t || r.push(\"direction\"), i && r.push(\"remapData\"), r;\n    }, _._GetEffectCreationOptions = function (e) {\n      void 0 === e && (e = !1);\n      var t = [\"invView\", \"view\", \"projection\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n      return e && t.push(\"particlesInfos\"), t;\n    }, _.prototype._getEffect = function (e) {\n      if (this._customEffect) return this._customEffect;\n      var t = [];\n      if (this._scene.clipPlane && t.push(\"#define CLIPPLANE\"), this._scene.clipPlane2 && t.push(\"#define CLIPPLANE2\"), this._scene.clipPlane3 && t.push(\"#define CLIPPLANE3\"), this._scene.clipPlane4 && t.push(\"#define CLIPPLANE4\"), this._isAnimationSheetEnabled && t.push(\"#define ANIMATESHEET\"), e === _.BLENDMODE_MULTIPLY && t.push(\"#define BLENDMULTIPLYMODE\"), this._useRampGradients && t.push(\"#define RAMPGRADIENT\"), this._isBillboardBased) switch (t.push(\"#define BILLBOARD\"), this.billboardMode) {\n        case _.BILLBOARDMODE_Y:\n          t.push(\"#define BILLBOARDY\");\n          break;\n\n        case _.BILLBOARDMODE_STRETCHED:\n          t.push(\"#define BILLBOARDSTRETCHED\");\n      }\n      this._imageProcessingConfiguration && (this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines), t.push(this._imageProcessingConfigurationDefines.toString()));\n      var i = t.join(\"\\n\");\n\n      if (this._cachedDefines !== i) {\n        this._cachedDefines = i;\n\n        var r = _._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== _.BILLBOARDMODE_STRETCHED, this._useRampGradients),\n            n = _._GetEffectCreationOptions(this._isAnimationSheetEnabled),\n            o = [\"diffuseSampler\", \"rampSampler\"];\n\n        xt.ImageProcessingConfiguration && (xt.ImageProcessingConfiguration.PrepareUniforms(n, this._imageProcessingConfigurationDefines), xt.ImageProcessingConfiguration.PrepareSamplers(o, this._imageProcessingConfigurationDefines)), this._effect = this._scene.getEngine().createEffect(\"particles\", r, n, o, i);\n      }\n\n      return this._effect;\n    }, _.prototype.animate = function (e) {\n      var r = this;\n\n      if (void 0 === e && (e = !1), this._started) {\n        if (!e) {\n          if (!this.isReady()) return;\n          if (this._currentRenderId === this._scene.getRenderId()) return;\n          this._currentRenderId = this._scene.getRenderId();\n        }\n\n        var t;\n        if (this._scaledUpdateSpeed = this.updateSpeed * (e ? this.preWarmStepOffset : this._scene.getAnimationRatio()), -1 < this.manualEmitCount) t = this.manualEmitCount, this._newPartsExcess = 0, this.manualEmitCount = 0;else {\n          var n = this.emitRate;\n\n          if (this._emitRateGradients && 0 < this._emitRateGradients.length && this.targetStopDuration) {\n            var i = this._actualFrame / this.targetStopDuration;\n            xt.Tools.GetCurrentGradient(i, this._emitRateGradients, function (e, t, i) {\n              e !== r._currentEmitRateGradient && (r._currentEmitRate1 = r._currentEmitRate2, r._currentEmitRate2 = t.getFactor(), r._currentEmitRateGradient = e), n = xt.Scalar.Lerp(r._currentEmitRate1, r._currentEmitRate2, i);\n            });\n          }\n\n          t = n * this._scaledUpdateSpeed >> 0, this._newPartsExcess += n * this._scaledUpdateSpeed - t;\n        }\n\n        if (1 < this._newPartsExcess && (t += this._newPartsExcess >> 0, this._newPartsExcess -= this._newPartsExcess >> 0), this._alive = !1, this._stopped ? t = 0 : (this._actualFrame += this._scaledUpdateSpeed, this.targetStopDuration && this._actualFrame >= this.targetStopDuration && this.stop()), this._update(t), this._stopped && (this._alive || (this._started = !1, this.onAnimationEnd && this.onAnimationEnd(), this.disposeOnStop && this._scene._toBeDisposed.push(this))), !e) {\n          for (var o = 0, s = 0; s < this._particles.length; s++) {\n            var a = this._particles[s];\n            this._appendParticleVertices(o, a), o += this._useInstancing ? 1 : 4;\n          }\n\n          this._vertexBuffer && this._vertexBuffer.update(this._vertexData);\n        }\n\n        0 === this.manualEmitCount && this.disposeOnStop && this.stop();\n      }\n    }, _.prototype._appendParticleVertices = function (e, t) {\n      this._appendParticleVertex(e++, t, 0, 0), this._useInstancing || (this._appendParticleVertex(e++, t, 1, 0), this._appendParticleVertex(e++, t, 1, 1), this._appendParticleVertex(e++, t, 0, 1));\n    }, _.prototype.rebuild = function () {\n      this._createIndexBuffer(), this._vertexBuffer && this._vertexBuffer._rebuild();\n    }, _.prototype.isReady = function () {\n      if (!(this.emitter && this._imageProcessingConfiguration.isReady() && this.particleTexture && this.particleTexture.isReady())) return !1;\n\n      if (this.blendMode !== _.BLENDMODE_MULTIPLYADD) {\n        if (!this._getEffect(this.blendMode).isReady()) return !1;\n      } else {\n        if (!this._getEffect(_.BLENDMODE_MULTIPLY).isReady()) return !1;\n        if (!this._getEffect(_.BLENDMODE_ADD).isReady()) return !1;\n      }\n\n      return !0;\n    }, _.prototype._render = function (e) {\n      var t = this._getEffect(e),\n          i = this._scene.getEngine();\n\n      i.enableEffect(t);\n\n      var r = this._scene.getViewMatrix();\n\n      if (t.setTexture(\"diffuseSampler\", this.particleTexture), t.setMatrix(\"view\", r), t.setMatrix(\"projection\", this._scene.getProjectionMatrix()), this._isAnimationSheetEnabled && this.particleTexture) {\n        var n = this.particleTexture.getBaseSize();\n        t.setFloat3(\"particlesInfos\", this.spriteCellWidth / n.width, this.spriteCellHeight / n.height, n.width / this.spriteCellWidth);\n      }\n\n      if (t.setVector2(\"translationPivot\", this.translationPivot), t.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a), this._isBillboardBased) {\n        var o = this._scene.activeCamera;\n        t.setVector3(\"eyePosition\", o.globalPosition);\n      }\n\n      if (this._rampGradientsTexture && t.setTexture(\"rampSampler\", this._rampGradientsTexture), this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4) {\n        var s = r.clone();\n        s.invert(), t.setMatrix(\"invView\", s), xt.MaterialHelper.BindClipPlane(t, this._scene);\n      }\n\n      switch (i.bindBuffers(this._vertexBuffers, this._indexBuffer, t), this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(t), e) {\n        case _.BLENDMODE_ADD:\n          i.setAlphaMode(xt.Engine.ALPHA_ADD);\n          break;\n\n        case _.BLENDMODE_ONEONE:\n          i.setAlphaMode(xt.Engine.ALPHA_ONEONE);\n          break;\n\n        case _.BLENDMODE_STANDARD:\n          i.setAlphaMode(xt.Engine.ALPHA_COMBINE);\n          break;\n\n        case _.BLENDMODE_MULTIPLY:\n          i.setAlphaMode(xt.Engine.ALPHA_MULTIPLY);\n      }\n\n      return this._useInstancing ? i.drawArraysType(xt.Material.TriangleFanDrawMode, 0, 4, this._particles.length) : i.drawElementsType(xt.Material.TriangleFillMode, 0, 6 * this._particles.length), this._particles.length;\n    }, _.prototype.render = function () {\n      if (!this.isReady() || !this._particles.length) return 0;\n\n      var e = this._scene.getEngine();\n\n      e.setState(!1), this.forceDepthWrite && e.setDepthWrite(!0);\n      var t = 0;\n      return this.blendMode === _.BLENDMODE_MULTIPLYADD && (t = this._render(_.BLENDMODE_MULTIPLY) + this._render(_.BLENDMODE_ADD)), t = this._render(this.blendMode), e.unbindInstanceAttributes(), e.setAlphaMode(xt.Engine.ALPHA_DISABLE), t;\n    }, _.prototype.dispose = function (e) {\n      if (void 0 === e && (e = !0), this._vertexBuffer && (this._vertexBuffer.dispose(), this._vertexBuffer = null), this._spriteBuffer && (this._spriteBuffer.dispose(), this._spriteBuffer = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), e && this.particleTexture && (this.particleTexture.dispose(), this.particleTexture = null), e && this.noiseTexture && (this.noiseTexture.dispose(), this.noiseTexture = null), this._rampGradientsTexture && (this._rampGradientsTexture.dispose(), this._rampGradientsTexture = null), this._removeFromRoot(), this._subEmitters && this._subEmitters.length) {\n        for (var t = 0; t < this._subEmitters.length; t++) for (var i = 0, r = this._subEmitters[t]; i < r.length; i++) {\n          r[i].dispose();\n        }\n\n        this._subEmitters = [], this.subEmitters = [];\n      }\n\n      this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose && this.emitter.dispose(!0), -1 < (t = this._scene.particleSystems.indexOf(this)) && this._scene.particleSystems.splice(t, 1), this._scene._activeParticleSystems.dispose(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.reset();\n    }, _.prototype.clone = function (e, t) {\n      var i = null,\n          r = null;\n\n      if (null != this.customShader) {\n        var n = 0 < (r = this.customShader).shaderOptions.defines.length ? r.shaderOptions.defines.join(\"\\n\") : \"\";\n        i = this._scene.getEngine().createEffectForParticles(r.shaderPath.fragmentElement, r.shaderOptions.uniforms, r.shaderOptions.samplers, n);\n      } else this._customEffect && (i = this._customEffect);\n\n      var o = new _(e, this._capacity, this._scene, i);\n      return o.customShader = r, xt.Tools.DeepCopy(this, o, [\"particles\", \"customShader\", \"noiseTexture\"]), void 0 === t && (t = this.emitter), o.noiseTexture = this.noiseTexture, o.emitter = t, this.particleTexture && (o.particleTexture = new xt.Texture(this.particleTexture.url, this._scene)), this._colorGradients && this._colorGradients.forEach(function (e) {\n        o.addColorGradient(e.gradient, e.color1, e.color2);\n      }), this._dragGradients && this._dragGradients.forEach(function (e) {\n        o.addDragGradient(e.gradient, e.factor1, e.factor2);\n      }), this._angularSpeedGradients && this._angularSpeedGradients.forEach(function (e) {\n        o.addAngularSpeedGradient(e.gradient, e.factor1, e.factor2);\n      }), this._emitRateGradients && this._emitRateGradients.forEach(function (e) {\n        o.addEmitRateGradient(e.gradient, e.factor1, e.factor2);\n      }), this._lifeTimeGradients && this._lifeTimeGradients.forEach(function (e) {\n        o.addLifeTimeGradient(e.gradient, e.factor1, e.factor2);\n      }), this._limitVelocityGradients && this._limitVelocityGradients.forEach(function (e) {\n        o.addLimitVelocityGradient(e.gradient, e.factor1, e.factor2);\n      }), this._sizeGradients && this._sizeGradients.forEach(function (e) {\n        o.addSizeGradient(e.gradient, e.factor1, e.factor2);\n      }), this._startSizeGradients && this._startSizeGradients.forEach(function (e) {\n        o.addStartSizeGradient(e.gradient, e.factor1, e.factor2);\n      }), this._velocityGradients && this._velocityGradients.forEach(function (e) {\n        o.addVelocityGradient(e.gradient, e.factor1, e.factor2);\n      }), this._rampGradients && this._rampGradients.forEach(function (e) {\n        o.addRampGradient(e.gradient, e.color);\n      }), this._colorRemapGradients && this._colorRemapGradients.forEach(function (e) {\n        o.addColorRemapGradient(e.gradient, e.factor1, e.factor2);\n      }), this._alphaRemapGradients && this._alphaRemapGradients.forEach(function (e) {\n        o.addAlphaRemapGradient(e.gradient, e.factor1, e.factor2);\n      }), this.preventAutoStart || o.start(), o;\n    }, _.prototype.serialize = function () {\n      var e = {};\n\n      if (_._Serialize(e, this), e.textureMask = this.textureMask.asArray(), e.customShader = this.customShader, e.preventAutoStart = this.preventAutoStart, this.subEmitters) {\n        e.subEmitters = [], this._subEmitters || this._prepareSubEmitterInternalArray();\n\n        for (var t = 0, i = this._subEmitters; t < i.length; t++) {\n          for (var r = [], n = 0, o = i[t]; n < o.length; n++) {\n            var s = o[n];\n            r.push(s.serialize());\n          }\n\n          e.subEmitters.push(r);\n        }\n      }\n\n      return e;\n    }, _._Serialize = function (e, t) {\n      if (e.name = t.name, e.id = t.id, e.capacity = t.getCapacity(), t.emitter.position) {\n        var i = t.emitter;\n        e.emitterId = i.id;\n      } else {\n        var r = t.emitter;\n        e.emitter = r.asArray();\n      }\n\n      t.particleEmitterType && (e.particleEmitterType = t.particleEmitterType.serialize()), t.particleTexture && (e.textureName = t.particleTexture.name, e.invertY = t.particleTexture._invertY), xt.Animation.AppendSerializedAnimations(t, e), e.beginAnimationOnStart = t.beginAnimationOnStart, e.beginAnimationFrom = t.beginAnimationFrom, e.beginAnimationTo = t.beginAnimationTo, e.beginAnimationLoop = t.beginAnimationLoop, e.startDelay = t.startDelay, e.renderingGroupId = t.renderingGroupId, e.isBillboardBased = t.isBillboardBased, e.billboardMode = t.billboardMode, e.minAngularSpeed = t.minAngularSpeed, e.maxAngularSpeed = t.maxAngularSpeed, e.minSize = t.minSize, e.maxSize = t.maxSize, e.minScaleX = t.minScaleX, e.maxScaleX = t.maxScaleX, e.minScaleY = t.minScaleY, e.maxScaleY = t.maxScaleY, e.minEmitPower = t.minEmitPower, e.maxEmitPower = t.maxEmitPower, e.minLifeTime = t.minLifeTime, e.maxLifeTime = t.maxLifeTime, e.emitRate = t.emitRate, e.gravity = t.gravity.asArray(), e.noiseStrength = t.noiseStrength.asArray(), e.color1 = t.color1.asArray(), e.color2 = t.color2.asArray(), e.colorDead = t.colorDead.asArray(), e.updateSpeed = t.updateSpeed, e.targetStopDuration = t.targetStopDuration, e.blendMode = t.blendMode, e.preWarmCycles = t.preWarmCycles, e.preWarmStepOffset = t.preWarmStepOffset, e.minInitialRotation = t.minInitialRotation, e.maxInitialRotation = t.maxInitialRotation, e.startSpriteCellID = t.startSpriteCellID, e.endSpriteCellID = t.endSpriteCellID, e.spriteCellChangeSpeed = t.spriteCellChangeSpeed, e.spriteCellWidth = t.spriteCellWidth, e.spriteCellHeight = t.spriteCellHeight, e.spriteRandomStartCell = t.spriteRandomStartCell, e.isAnimationSheetEnabled = t.isAnimationSheetEnabled;\n      var n = t.getColorGradients();\n\n      if (n) {\n        e.colorGradients = [];\n\n        for (var o = 0, s = n; o < s.length; o++) {\n          var a = s[o],\n              l = {\n            gradient: a.gradient,\n            color1: a.color1.asArray()\n          };\n          a.color2 && (l.color2 = a.color2.asArray()), e.colorGradients.push(l);\n        }\n      }\n\n      var c = t.getRampGradients();\n\n      if (c) {\n        e.rampGradients = [];\n\n        for (var h = 0, u = c; h < u.length; h++) {\n          var d = u[h];\n          l = {\n            gradient: d.gradient,\n            color: d.color.asArray()\n          };\n          e.rampGradients.push(l);\n        }\n\n        e.useRampGradients = t.useRampGradients;\n      }\n\n      var f = t.getColorRemapGradients();\n\n      if (f) {\n        e.colorRemapGradients = [];\n\n        for (var p = 0, _ = f; p < _.length; p++) {\n          var m = _[p];\n          l = {\n            gradient: m.gradient,\n            factor1: m.factor1\n          };\n          void 0 !== m.factor2 && (l.factor2 = m.factor2), e.colorRemapGradients.push(l);\n        }\n      }\n\n      var g = t.getAlphaRemapGradients();\n\n      if (g) {\n        e.alphaRemapGradients = [];\n\n        for (var v = 0, y = g; v < y.length; v++) {\n          var b = y[v];\n          l = {\n            gradient: b.gradient,\n            factor1: b.factor1\n          };\n          void 0 !== b.factor2 && (l.factor2 = b.factor2), e.alphaRemapGradients.push(l);\n        }\n      }\n\n      var T = t.getSizeGradients();\n\n      if (T) {\n        e.sizeGradients = [];\n\n        for (var E = 0, x = T; E < x.length; E++) {\n          var P = x[E];\n          l = {\n            gradient: P.gradient,\n            factor1: P.factor1\n          };\n          void 0 !== P.factor2 && (l.factor2 = P.factor2), e.sizeGradients.push(l);\n        }\n      }\n\n      var A = t.getAngularSpeedGradients();\n\n      if (A) {\n        e.angularSpeedGradients = [];\n\n        for (var S = 0, M = A; S < M.length; S++) {\n          var R = M[S];\n          l = {\n            gradient: R.gradient,\n            factor1: R.factor1\n          };\n          void 0 !== R.factor2 && (l.factor2 = R.factor2), e.angularSpeedGradients.push(l);\n        }\n      }\n\n      var C = t.getVelocityGradients();\n\n      if (C) {\n        e.velocityGradients = [];\n\n        for (var O = 0, D = C; O < D.length; O++) {\n          var I = D[O];\n          l = {\n            gradient: I.gradient,\n            factor1: I.factor1\n          };\n          void 0 !== I.factor2 && (l.factor2 = I.factor2), e.velocityGradients.push(l);\n        }\n      }\n\n      var w = t.getDragGradients();\n\n      if (w) {\n        e.dragyGradients = [];\n\n        for (var L = 0, F = w; L < F.length; L++) {\n          var B = F[L];\n          l = {\n            gradient: B.gradient,\n            factor1: B.factor1\n          };\n          void 0 !== B.factor2 && (l.factor2 = B.factor2), e.dragGradients.push(l);\n        }\n      }\n\n      var N = t.getEmitRateGradients();\n\n      if (N) {\n        e.emitRateGradients = [];\n\n        for (var V = 0, U = N; V < U.length; V++) {\n          var z = U[V];\n          l = {\n            gradient: z.gradient,\n            factor1: z.factor1\n          };\n          void 0 !== z.factor2 && (l.factor2 = z.factor2), e.emitRateGradients.push(l);\n        }\n      }\n\n      var G = t.getStartSizeGradients();\n\n      if (G) {\n        e.startSizeGradients = [];\n\n        for (var k = 0, W = G; k < W.length; k++) {\n          var H = W[k];\n          l = {\n            gradient: H.gradient,\n            factor1: H.factor1\n          };\n          void 0 !== H.factor2 && (l.factor2 = H.factor2), e.startSizeGradients.push(l);\n        }\n      }\n\n      var X = t.getLifeTimeGradients();\n\n      if (X) {\n        e.lifeTimeGradients = [];\n\n        for (var j = 0, Y = X; j < Y.length; j++) {\n          var K = Y[j];\n          l = {\n            gradient: K.gradient,\n            factor1: K.factor1\n          };\n          void 0 !== K.factor2 && (l.factor2 = K.factor2), e.lifeTimeGradients.push(l);\n        }\n      }\n\n      var Q = t.getLimitVelocityGradients();\n\n      if (Q) {\n        e.limitVelocityGradients = [];\n\n        for (var Z = 0, q = Q; Z < q.length; Z++) {\n          var J = q[Z];\n          l = {\n            gradient: J.gradient,\n            factor1: J.factor1\n          };\n          void 0 !== J.factor2 && (l.factor2 = J.factor2), e.limitVelocityGradients.push(l);\n        }\n\n        e.limitVelocityDamping = t.limitVelocityDamping;\n      }\n\n      t.noiseTexture && (e.noiseTexture = t.noiseTexture.serialize());\n    }, _._Parse = function (e, t, i, r) {\n      if (e.textureName && (t.particleTexture = new xt.Texture(r + e.textureName, i, !1, void 0 === e.invertY || e.invertY), t.particleTexture.name = e.textureName), e.emitterId || 0 === e.emitterId || void 0 !== e.emitter ? e.emitterId ? t.emitter = i.getLastMeshByID(e.emitterId) : t.emitter = xt.Vector3.FromArray(e.emitter) : t.emitter = xt.Vector3.Zero(), void 0 !== e.renderingGroupId && (t.renderingGroupId = e.renderingGroupId), void 0 !== e.isBillboardBased && (t.isBillboardBased = e.isBillboardBased), void 0 !== e.billboardMode && (t.billboardMode = e.billboardMode), e.animations) {\n        for (var n = 0; n < e.animations.length; n++) {\n          var o = e.animations[n];\n          t.animations.push(xt.Animation.Parse(o));\n        }\n\n        t.beginAnimationOnStart = e.beginAnimationOnStart, t.beginAnimationFrom = e.beginAnimationFrom, t.beginAnimationTo = e.beginAnimationTo, t.beginAnimationLoop = e.beginAnimationLoop;\n      }\n\n      if (e.autoAnimate && i.beginAnimation(t, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), t.startDelay = 0 | e.startDelay, t.minAngularSpeed = e.minAngularSpeed, t.maxAngularSpeed = e.maxAngularSpeed, t.minSize = e.minSize, t.maxSize = e.maxSize, e.minScaleX && (t.minScaleX = e.minScaleX, t.maxScaleX = e.maxScaleX, t.minScaleY = e.minScaleY, t.maxScaleY = e.maxScaleY), void 0 !== e.preWarmCycles && (t.preWarmCycles = e.preWarmCycles, t.preWarmStepOffset = e.preWarmStepOffset), void 0 !== e.minInitialRotation && (t.minInitialRotation = e.minInitialRotation, t.maxInitialRotation = e.maxInitialRotation), t.minLifeTime = e.minLifeTime, t.maxLifeTime = e.maxLifeTime, t.minEmitPower = e.minEmitPower, t.maxEmitPower = e.maxEmitPower, t.emitRate = e.emitRate, t.gravity = xt.Vector3.FromArray(e.gravity), e.noiseStrength && (t.noiseStrength = xt.Vector3.FromArray(e.noiseStrength)), t.color1 = xt.Color4.FromArray(e.color1), t.color2 = xt.Color4.FromArray(e.color2), t.colorDead = xt.Color4.FromArray(e.colorDead), t.updateSpeed = e.updateSpeed, t.targetStopDuration = e.targetStopDuration, t.blendMode = e.blendMode, e.colorGradients) for (var s = 0, a = e.colorGradients; s < a.length; s++) {\n        var l = a[s];\n        t.addColorGradient(l.gradient, xt.Color4.FromArray(l.color1), l.color2 ? xt.Color4.FromArray(l.color2) : void 0);\n      }\n\n      if (e.rampGradients) {\n        for (var c = 0, h = e.rampGradients; c < h.length; c++) {\n          var u = h[c];\n          t.addRampGradient(u.gradient, xt.Color3.FromArray(u.color));\n        }\n\n        t.useRampGradients = e.useRampGradients;\n      }\n\n      if (e.colorRemapGradients) for (var d = 0, f = e.colorRemapGradients; d < f.length; d++) {\n        var p = f[d];\n        t.addColorRemapGradient(p.gradient, void 0 !== p.factor1 ? p.factor1 : p.factor, p.factor2);\n      }\n      if (e.alphaRemapGradients) for (var _ = 0, m = e.alphaRemapGradients; _ < m.length; _++) {\n        var g = m[_];\n        t.addAlphaRemapGradient(g.gradient, void 0 !== g.factor1 ? g.factor1 : g.factor, g.factor2);\n      }\n      if (e.sizeGradients) for (var v = 0, y = e.sizeGradients; v < y.length; v++) {\n        var b = y[v];\n        t.addSizeGradient(b.gradient, void 0 !== b.factor1 ? b.factor1 : b.factor, b.factor2);\n      }\n      if (e.sizeGradients) for (var T = 0, E = e.sizeGradients; T < E.length; T++) {\n        b = E[T];\n        t.addSizeGradient(b.gradient, void 0 !== b.factor1 ? b.factor1 : b.factor, b.factor2);\n      }\n      if (e.angularSpeedGradients) for (var x = 0, P = e.angularSpeedGradients; x < P.length; x++) {\n        var A = P[x];\n        t.addAngularSpeedGradient(A.gradient, void 0 !== A.factor1 ? A.factor1 : A.factor, A.factor2);\n      }\n      if (e.velocityGradients) for (var S = 0, M = e.velocityGradients; S < M.length; S++) {\n        var R = M[S];\n        t.addVelocityGradient(R.gradient, void 0 !== R.factor1 ? R.factor1 : R.factor, R.factor2);\n      }\n      if (e.dragGradients) for (var C = 0, O = e.dragGradients; C < O.length; C++) {\n        var D = O[C];\n        t.addDragGradient(D.gradient, void 0 !== D.factor1 ? D.factor1 : D.factor, D.factor2);\n      }\n      if (e.emitRateGradients) for (var I = 0, w = e.emitRateGradients; I < w.length; I++) {\n        var L = w[I];\n        t.addEmitRateGradient(L.gradient, void 0 !== L.factor1 ? L.factor1 : L.factor, L.factor2);\n      }\n      if (e.startSizeGradients) for (var F = 0, B = e.startSizeGradients; F < B.length; F++) {\n        var N = B[F];\n        t.addStartSizeGradient(N.gradient, void 0 !== N.factor1 ? N.factor1 : N.factor, N.factor2);\n      }\n      if (e.lifeTimeGradients) for (var V = 0, U = e.lifeTimeGradients; V < U.length; V++) {\n        var z = U[V];\n        t.addLifeTimeGradient(z.gradient, void 0 !== z.factor1 ? z.factor1 : z.factor, z.factor2);\n      }\n\n      if (e.limitVelocityGradients) {\n        for (var G = 0, k = e.limitVelocityGradients; G < k.length; G++) {\n          var W = k[G];\n          t.addLimitVelocityGradient(W.gradient, void 0 !== W.factor1 ? W.factor1 : W.factor, W.factor2);\n        }\n\n        t.limitVelocityDamping = e.limitVelocityDamping;\n      }\n\n      var H;\n\n      if (e.noiseTexture && (t.noiseTexture = xt.ProceduralTexture.Parse(e.noiseTexture, i, r)), e.particleEmitterType) {\n        switch (e.particleEmitterType.type) {\n          case \"SphereParticleEmitter\":\n            H = new xt.SphereParticleEmitter();\n            break;\n\n          case \"SphereDirectedParticleEmitter\":\n            H = new xt.SphereDirectedParticleEmitter();\n            break;\n\n          case \"ConeEmitter\":\n          case \"ConeParticleEmitter\":\n            H = new xt.ConeParticleEmitter();\n            break;\n\n          case \"CylinderParticleEmitter\":\n            H = new xt.CylinderParticleEmitter();\n            break;\n\n          case \"HemisphericParticleEmitter\":\n            H = new xt.HemisphericParticleEmitter();\n            break;\n\n          case \"BoxEmitter\":\n          case \"BoxParticleEmitter\":\n          default:\n            H = new xt.BoxParticleEmitter();\n        }\n\n        H.parse(e.particleEmitterType);\n      } else (H = new xt.BoxParticleEmitter()).parse(e);\n\n      t.particleEmitterType = H, t.startSpriteCellID = e.startSpriteCellID, t.endSpriteCellID = e.endSpriteCellID, t.spriteCellWidth = e.spriteCellWidth, t.spriteCellHeight = e.spriteCellHeight, t.spriteCellChangeSpeed = e.spriteCellChangeSpeed, t.spriteRandomStartCell = e.spriteRandomStartCell;\n    }, _.Parse = function (e, t, i, r) {\n      void 0 === r && (r = !1);\n      var n = e.name,\n          o = null,\n          s = null;\n\n      if (e.customShader) {\n        var a = 0 < (s = e.customShader).shaderOptions.defines.length ? s.shaderOptions.defines.join(\"\\n\") : \"\";\n        o = t.getEngine().createEffectForParticles(s.shaderPath.fragmentElement, s.shaderOptions.uniforms, s.shaderOptions.samplers, a);\n      }\n\n      var l = new _(n, e.capacity, t, o, e.isAnimationSheetEnabled);\n\n      if (l.customShader = s, e.id && (l.id = e.id), e.subEmitters) {\n        l.subEmitters = [];\n\n        for (var c = 0, h = e.subEmitters; c < h.length; c++) {\n          for (var u = [], d = 0, f = h[c]; d < f.length; d++) {\n            var p = f[d];\n            u.push(xt.SubEmitter.Parse(p, t, i));\n          }\n\n          l.subEmitters.push(u);\n        }\n      }\n\n      return _._Parse(e, l, t, i), l.textureMask = xt.Color4.FromArray(e.textureMask), e.preventAutoStart && (l.preventAutoStart = e.preventAutoStart), r || l.preventAutoStart || l.start(), l;\n    }, _.BILLBOARDMODE_Y = 2, _.BILLBOARDMODE_ALL = 7, _.BILLBOARDMODE_STRETCHED = 8, _;\n  }(xt.BaseParticleSystem), xt.ParticleSystem = Pt, At = $a || ($a = {}), St = function () {\n    function t() {\n      this.direction1 = new At.Vector3(0, 1, 0), this.direction2 = new At.Vector3(0, 1, 0), this.minEmitBox = new At.Vector3(-.5, -.5, -.5), this.maxEmitBox = new At.Vector3(.5, .5, .5);\n    }\n\n    return t.prototype.startDirectionFunction = function (e, t, i) {\n      var r = At.Scalar.RandomRange(this.direction1.x, this.direction2.x),\n          n = At.Scalar.RandomRange(this.direction1.y, this.direction2.y),\n          o = At.Scalar.RandomRange(this.direction1.z, this.direction2.z);\n      At.Vector3.TransformNormalFromFloatsToRef(r, n, o, e, t);\n    }, t.prototype.startPositionFunction = function (e, t, i) {\n      var r = At.Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x),\n          n = At.Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y),\n          o = At.Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);\n      At.Vector3.TransformCoordinatesFromFloatsToRef(r, n, o, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t();\n      return At.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setVector3(\"direction1\", this.direction1), e.setVector3(\"direction2\", this.direction2), e.setVector3(\"minEmitBox\", this.minEmitBox), e.setVector3(\"maxEmitBox\", this.maxEmitBox);\n    }, t.prototype.getEffectDefines = function () {\n      return \"#define BOXEMITTER\";\n    }, t.prototype.getClassName = function () {\n      return \"BoxParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = {};\n      return e.type = this.getClassName(), e.direction1 = this.direction1.asArray(), e.direction2 = this.direction2.asArray(), e.minEmitBox = this.minEmitBox.asArray(), e.maxEmitBox = this.maxEmitBox.asArray(), e;\n    }, t.prototype.parse = function (e) {\n      At.Vector3.FromArrayToRef(e.direction1, 0, this.direction1), At.Vector3.FromArrayToRef(e.direction2, 0, this.direction2), At.Vector3.FromArrayToRef(e.minEmitBox, 0, this.minEmitBox), At.Vector3.FromArrayToRef(e.maxEmitBox, 0, this.maxEmitBox);\n    }, t;\n  }(), At.BoxParticleEmitter = St, Mt = $a || ($a = {}), Rt = function () {\n    function t(e, t, i, r) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === i && (i = 1), void 0 === r && (r = 0), this.radius = e, this.height = t, this.radiusRange = i, this.directionRandomizer = r;\n    }\n\n    return t.prototype.startDirectionFunction = function (e, t, i) {\n      var r = i.position.subtract(e.getTranslation()).normalize(),\n          n = Mt.Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2),\n          o = Math.atan2(r.x, r.z);\n      o += Mt.Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer, r.y = n, r.x = Math.sin(o), r.z = Math.cos(o), r.normalize(), Mt.Vector3.TransformNormalFromFloatsToRef(r.x, r.y, r.z, e, t);\n    }, t.prototype.startPositionFunction = function (e, t, i) {\n      var r = Mt.Scalar.RandomRange(-this.height / 2, this.height / 2),\n          n = Mt.Scalar.RandomRange(0, 2 * Math.PI),\n          o = Mt.Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1),\n          s = Math.sqrt(o) * this.radius,\n          a = s * Math.cos(n),\n          l = s * Math.sin(n);\n      Mt.Vector3.TransformCoordinatesFromFloatsToRef(a, r, l, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t(this.radius, this.directionRandomizer);\n      return Mt.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setFloat(\"radius\", this.radius), e.setFloat(\"height\", this.height), e.setFloat(\"radiusRange\", this.radiusRange), e.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }, t.prototype.getEffectDefines = function () {\n      return \"#define CYLINDEREMITTER\";\n    }, t.prototype.getClassName = function () {\n      return \"CylinderParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = {};\n      return e.type = this.getClassName(), e.radius = this.radius, e.height = this.height, e.radiusRange = this.radiusRange, e.directionRandomizer = this.directionRandomizer, e;\n    }, t.prototype.parse = function (e) {\n      this.radius = e.radius, this.height = e.height, this.radiusRange = e.radiusRange, this.directionRandomizer = e.directionRandomizer;\n    }, t;\n  }(), Ct = function (s) {\n    function t(e, t, i, r, n) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === i && (i = 1), void 0 === r && (r = new Mt.Vector3(0, 1, 0)), void 0 === n && (n = new Mt.Vector3(0, 1, 0));\n      var o = s.call(this, e, t, i) || this;\n      return o.direction1 = r, o.direction2 = n, o;\n    }\n\n    return T(t, s), t.prototype.startDirectionFunction = function (e, t, i) {\n      var r = Mt.Scalar.RandomRange(this.direction1.x, this.direction2.x),\n          n = Mt.Scalar.RandomRange(this.direction1.y, this.direction2.y),\n          o = Mt.Scalar.RandomRange(this.direction1.z, this.direction2.z);\n      Mt.Vector3.TransformNormalFromFloatsToRef(r, n, o, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\n      return Mt.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setFloat(\"radius\", this.radius), e.setFloat(\"height\", this.height), e.setFloat(\"radiusRange\", this.radiusRange), e.setVector3(\"direction1\", this.direction1), e.setVector3(\"direction2\", this.direction2);\n    }, t.prototype.getEffectDefines = function () {\n      return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\n    }, t.prototype.getClassName = function () {\n      return \"CylinderDirectedParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = s.prototype.serialize.call(this);\n      return e.direction1 = this.direction1.asArray(), e.direction2 = this.direction2.asArray(), e;\n    }, t.prototype.parse = function (e) {\n      s.prototype.parse.call(this, e), this.direction1.copyFrom(e.direction1), this.direction2.copyFrom(e.direction2);\n    }, t;\n  }(Mt.CylinderParticleEmitter = Rt), Mt.CylinderDirectedParticleEmitter = Ct, Ot = $a || ($a = {}), Dt = function () {\n    function t(e, t, i) {\n      void 0 === e && (e = 1), void 0 === t && (t = Math.PI), void 0 === i && (i = 0), this.directionRandomizer = i, this.radiusRange = 1, this.heightRange = 1, this.emitFromSpawnPointOnly = !1, this.angle = t, this.radius = e;\n    }\n\n    return Object.defineProperty(t.prototype, \"radius\", {\n      get: function () {\n        return this._radius;\n      },\n      set: function (e) {\n        this._radius = e, this._buildHeight();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"angle\", {\n      get: function () {\n        return this._angle;\n      },\n      set: function (e) {\n        this._angle = e, this._buildHeight();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.prototype._buildHeight = function () {\n      0 !== this._angle ? this._height = this._radius / Math.tan(this._angle / 2) : this._height = 1;\n    }, t.prototype.startDirectionFunction = function (e, t, i) {\n      if (1 === Math.abs(Math.cos(this._angle))) Ot.Vector3.TransformNormalFromFloatsToRef(0, 1, 0, e, t);else {\n        var r = i.position.subtract(e.getTranslation()).normalize(),\n            n = Ot.Scalar.RandomRange(0, this.directionRandomizer),\n            o = Ot.Scalar.RandomRange(0, this.directionRandomizer),\n            s = Ot.Scalar.RandomRange(0, this.directionRandomizer);\n        r.x += n, r.y += o, r.z += s, r.normalize(), Ot.Vector3.TransformNormalFromFloatsToRef(r.x, r.y, r.z, e, t);\n      }\n    }, t.prototype.startPositionFunction = function (e, t, i) {\n      var r,\n          n = Ot.Scalar.RandomRange(0, 2 * Math.PI);\n      r = this.emitFromSpawnPointOnly ? 1e-4 : 1 - (r = Ot.Scalar.RandomRange(0, this.heightRange)) * r;\n      var o = this._radius - Ot.Scalar.RandomRange(0, this._radius * this.radiusRange),\n          s = (o *= r) * Math.sin(n),\n          a = o * Math.cos(n),\n          l = r * this._height;\n      Ot.Vector3.TransformCoordinatesFromFloatsToRef(s, l, a, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t(this._radius, this._angle, this.directionRandomizer);\n      return Ot.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setFloat2(\"radius\", this._radius, this.radiusRange), e.setFloat(\"coneAngle\", this._angle), e.setFloat2(\"height\", this._height, this.heightRange), e.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }, t.prototype.getEffectDefines = function () {\n      var e = \"#define CONEEMITTER\";\n      return this.emitFromSpawnPointOnly && (e += \"\\n#define CONEEMITTERSPAWNPOINT\"), e;\n    }, t.prototype.getClassName = function () {\n      return \"ConeParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = {};\n      return e.type = this.getClassName(), e.radius = this._radius, e.angle = this._angle, e.directionRandomizer = this.directionRandomizer, e;\n    }, t.prototype.parse = function (e) {\n      this.radius = e.radius, this.angle = e.angle, this.directionRandomizer = e.directionRandomizer;\n    }, t;\n  }(), Ot.ConeParticleEmitter = Dt, It = $a || ($a = {}), wt = function () {\n    function t(e, t, i) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === i && (i = 0), this.radius = e, this.radiusRange = t, this.directionRandomizer = i;\n    }\n\n    return t.prototype.startDirectionFunction = function (e, t, i) {\n      var r = i.position.subtract(e.getTranslation()).normalize(),\n          n = It.Scalar.RandomRange(0, this.directionRandomizer),\n          o = It.Scalar.RandomRange(0, this.directionRandomizer),\n          s = It.Scalar.RandomRange(0, this.directionRandomizer);\n      r.x += n, r.y += o, r.z += s, r.normalize(), It.Vector3.TransformNormalFromFloatsToRef(r.x, r.y, r.z, e, t);\n    }, t.prototype.startPositionFunction = function (e, t, i) {\n      var r = this.radius - It.Scalar.RandomRange(0, this.radius * this.radiusRange),\n          n = It.Scalar.RandomRange(0, 1),\n          o = It.Scalar.RandomRange(0, 2 * Math.PI),\n          s = Math.acos(2 * n - 1),\n          a = r * Math.cos(o) * Math.sin(s),\n          l = r * Math.cos(s),\n          c = r * Math.sin(o) * Math.sin(s);\n      It.Vector3.TransformCoordinatesFromFloatsToRef(a, l, c, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t(this.radius, this.directionRandomizer);\n      return It.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setFloat(\"radius\", this.radius), e.setFloat(\"radiusRange\", this.radiusRange), e.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }, t.prototype.getEffectDefines = function () {\n      return \"#define SPHEREEMITTER\";\n    }, t.prototype.getClassName = function () {\n      return \"SphereParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = {};\n      return e.type = this.getClassName(), e.radius = this.radius, e.radiusRange = this.radiusRange, e.directionRandomizer = this.directionRandomizer, e;\n    }, t.prototype.parse = function (e) {\n      this.radius = e.radius, this.radiusRange = e.radiusRange, this.directionRandomizer = e.directionRandomizer;\n    }, t;\n  }(), Lt = function (n) {\n    function t(e, t, i) {\n      void 0 === e && (e = 1), void 0 === t && (t = new It.Vector3(0, 1, 0)), void 0 === i && (i = new It.Vector3(0, 1, 0));\n      var r = n.call(this, e) || this;\n      return r.direction1 = t, r.direction2 = i, r;\n    }\n\n    return T(t, n), t.prototype.startDirectionFunction = function (e, t, i) {\n      var r = It.Scalar.RandomRange(this.direction1.x, this.direction2.x),\n          n = It.Scalar.RandomRange(this.direction1.y, this.direction2.y),\n          o = It.Scalar.RandomRange(this.direction1.z, this.direction2.z);\n      It.Vector3.TransformNormalFromFloatsToRef(r, n, o, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t(this.radius, this.direction1, this.direction2);\n      return It.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setFloat(\"radius\", this.radius), e.setFloat(\"radiusRange\", this.radiusRange), e.setVector3(\"direction1\", this.direction1), e.setVector3(\"direction2\", this.direction2);\n    }, t.prototype.getEffectDefines = function () {\n      return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\n    }, t.prototype.getClassName = function () {\n      return \"SphereDirectedParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = n.prototype.serialize.call(this);\n      return e.direction1 = this.direction1.asArray(), e.direction2 = this.direction2.asArray(), e;\n    }, t.prototype.parse = function (e) {\n      n.prototype.parse.call(this, e), this.direction1.copyFrom(e.direction1), this.direction2.copyFrom(e.direction2);\n    }, t;\n  }(It.SphereParticleEmitter = wt), It.SphereDirectedParticleEmitter = Lt, Ft = $a || ($a = {}), Bt = function () {\n    function t(e, t, i) {\n      void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === i && (i = 0), this.radius = e, this.radiusRange = t, this.directionRandomizer = i;\n    }\n\n    return t.prototype.startDirectionFunction = function (e, t, i) {\n      var r = i.position.subtract(e.getTranslation()).normalize(),\n          n = Ft.Scalar.RandomRange(0, this.directionRandomizer),\n          o = Ft.Scalar.RandomRange(0, this.directionRandomizer),\n          s = Ft.Scalar.RandomRange(0, this.directionRandomizer);\n      r.x += n, r.y += o, r.z += s, r.normalize(), Ft.Vector3.TransformNormalFromFloatsToRef(r.x, r.y, r.z, e, t);\n    }, t.prototype.startPositionFunction = function (e, t, i) {\n      var r = this.radius - Ft.Scalar.RandomRange(0, this.radius * this.radiusRange),\n          n = Ft.Scalar.RandomRange(0, 1),\n          o = Ft.Scalar.RandomRange(0, 2 * Math.PI),\n          s = Math.acos(2 * n - 1),\n          a = r * Math.cos(o) * Math.sin(s),\n          l = r * Math.cos(s),\n          c = r * Math.sin(o) * Math.sin(s);\n      Ft.Vector3.TransformCoordinatesFromFloatsToRef(a, Math.abs(l), c, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t(this.radius, this.directionRandomizer);\n      return Ft.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setFloat(\"radius\", this.radius), e.setFloat(\"radiusRange\", this.radiusRange), e.setFloat(\"directionRandomizer\", this.directionRandomizer);\n    }, t.prototype.getEffectDefines = function () {\n      return \"#define HEMISPHERICEMITTER\";\n    }, t.prototype.getClassName = function () {\n      return \"HemisphericParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = {};\n      return e.type = this.getClassName(), e.radius = this.radius, e.radiusRange = this.radiusRange, e.directionRandomizer = this.directionRandomizer, e;\n    }, t.prototype.parse = function (e) {\n      this.radius = e.radius, this.radiusRange = e.radiusRange, this.directionRandomizer = e.directionRandomizer;\n    }, t;\n  }(), Ft.HemisphericParticleEmitter = Bt, Nt = $a || ($a = {}), Vt = function () {\n    function t() {\n      this.direction1 = new Nt.Vector3(0, 1, 0), this.direction2 = new Nt.Vector3(0, 1, 0);\n    }\n\n    return t.prototype.startDirectionFunction = function (e, t, i) {\n      var r = Nt.Scalar.RandomRange(this.direction1.x, this.direction2.x),\n          n = Nt.Scalar.RandomRange(this.direction1.y, this.direction2.y),\n          o = Nt.Scalar.RandomRange(this.direction1.z, this.direction2.z);\n      Nt.Vector3.TransformNormalFromFloatsToRef(r, n, o, e, t);\n    }, t.prototype.startPositionFunction = function (e, t, i) {\n      Nt.Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, e, t);\n    }, t.prototype.clone = function () {\n      var e = new t();\n      return Nt.Tools.DeepCopy(this, e), e;\n    }, t.prototype.applyToShader = function (e) {\n      e.setVector3(\"direction1\", this.direction1), e.setVector3(\"direction2\", this.direction2);\n    }, t.prototype.getEffectDefines = function () {\n      return \"#define POINTEMITTER\";\n    }, t.prototype.getClassName = function () {\n      return \"PointParticleEmitter\";\n    }, t.prototype.serialize = function () {\n      var e = {};\n      return e.type = this.getClassName(), e.direction1 = this.direction1.asArray(), e.direction2 = this.direction2.asArray(), e;\n    }, t.prototype.parse = function (e) {\n      Nt.Vector3.FromArrayToRef(e.direction1, 0, this.direction1), Nt.Vector3.FromArrayToRef(e.direction2, 0, this.direction2);\n    }, t;\n  }(), Nt.PointParticleEmitter = Vt, (Ut = $a || ($a = {})).AbstractScene.AddParser(Ut.SceneComponentConstants.NAME_PARTICLESYSTEM, function (e, t, i, r) {\n    var n = Ut.AbstractScene.GetIndividualParser(Ut.SceneComponentConstants.NAME_PARTICLESYSTEM);\n    if (n && void 0 !== e.particleSystems && null !== e.particleSystems) for (var o = 0, s = e.particleSystems.length; o < s; o++) {\n      var a = e.particleSystems[o];\n      i.particleSystems.push(n(a, t, r));\n    }\n  }), Ut.AbstractScene.AddIndividualParser(Ut.SceneComponentConstants.NAME_PARTICLESYSTEM, function (e, t, i) {\n    return e.activeParticleCount ? Ut.GPUParticleSystem.Parse(e, t, i) : Ut.ParticleSystem.Parse(e, t, i);\n  }), Ut.Engine.prototype.createEffectForParticles = function (e, t, i, r, n, o, s) {\n    void 0 === t && (t = []), void 0 === i && (i = []), void 0 === r && (r = \"\");\n\n    var a = Ut.ParticleSystem._GetAttributeNamesOrOptions(),\n        l = Ut.ParticleSystem._GetEffectCreationOptions();\n\n    return -1 === r.indexOf(\" BILLBOARD\") && (r += \"\\n#define BILLBOARD\\n\"), -1 === i.indexOf(\"diffuseSampler\") && i.push(\"diffuseSampler\"), this.createEffect({\n      vertex: \"particles\",\n      fragmentElement: e\n    }, a, l.concat(t), i, r, n, o, s);\n  }, Ut.Mesh.prototype.getEmittedParticleSystems = function () {\n    for (var e = new Array(), t = 0; t < this.getScene().particleSystems.length; t++) {\n      var i = this.getScene().particleSystems[t];\n      i.emitter === this && e.push(i);\n    }\n\n    return e;\n  }, Ut.Mesh.prototype.getHierarchyEmittedParticleSystems = function () {\n    var e = new Array(),\n        t = this.getDescendants();\n    t.push(this);\n\n    for (var i = 0; i < this.getScene().particleSystems.length; i++) {\n      var r = this.getScene().particleSystems[i],\n          n = r.emitter;\n      n.position && -1 !== t.indexOf(n) && e.push(r);\n    }\n\n    return e;\n  }, function (s) {\n    var t, e;\n    (e = t = s.SubEmitterType || (s.SubEmitterType = {}))[e.ATTACHED = 0] = \"ATTACHED\", e[e.END = 1] = \"END\";\n\n    var i = function () {\n      function o(e) {\n        this.particleSystem = e, this.type = t.END, this.inheritDirection = !1, this.inheritedVelocityAmount = 0, e.emitter && e.emitter.dispose || (e.emitter = new s.AbstractMesh(\"SubemitterSystemEmitter\", e.getScene())), e.onDisposeObservable.add(function () {\n          e.emitter && e.emitter.dispose && e.emitter.dispose();\n        });\n      }\n\n      return o.prototype.clone = function () {\n        var e = this.particleSystem.emitter;\n        e ? e instanceof s.Vector3 ? e = e.clone() : e instanceof s.AbstractMesh && ((e = new s.Mesh(\"\", e.getScene())).isVisible = !1) : e = new s.Vector3();\n        var t = new o(this.particleSystem.clone(\"\", e));\n        return t.type = this.type, t.inheritDirection = this.inheritDirection, t.inheritedVelocityAmount = this.inheritedVelocityAmount, t.particleSystem._disposeEmitterOnDispose = !0, t.particleSystem.disposeOnStop = !0, t;\n      }, o.prototype.serialize = function () {\n        var e = {};\n        return e.type = this.type, e.inheritDirection = this.inheritDirection, e.inheritedVelocityAmount = this.inheritedVelocityAmount, e.particleSystem = this.particleSystem.serialize(), e;\n      }, o.Parse = function (e, t, i) {\n        var r = e.particleSystem,\n            n = new o(s.ParticleSystem.Parse(r, t, i));\n        return n.type = e.type, n.inheritDirection = e.inheritDirection, n.inheritedVelocityAmount = e.inheritedVelocityAmount, n.particleSystem._isSubEmitter = !0, n;\n      }, o.prototype.dispose = function () {\n        this.particleSystem.dispose();\n      }, o;\n    }();\n\n    s.SubEmitter = i;\n  }($a || ($a = {})), zt = $a || ($a = {}), Gt = function (o) {\n    function c(e, t, i, r) {\n      void 0 === r && (r = {});\n      var n = o.call(this, e, t) || this;\n      return n._textures = {}, n._textureArrays = {}, n._floats = {}, n._ints = {}, n._floatsArrays = {}, n._colors3 = {}, n._colors3Arrays = {}, n._colors4 = {}, n._vectors2 = {}, n._vectors3 = {}, n._vectors4 = {}, n._matrices = {}, n._matrices3x3 = {}, n._matrices2x2 = {}, n._vectors2Arrays = {}, n._vectors3Arrays = {}, n._cachedWorldViewMatrix = new zt.Matrix(), n._shaderPath = i, n._options = ae({\n        needAlphaBlending: !1,\n        needAlphaTesting: !1,\n        attributes: [\"position\", \"normal\", \"uv\"],\n        uniforms: [\"worldViewProjection\"],\n        uniformBuffers: [],\n        samplers: [],\n        defines: []\n      }, r), n;\n    }\n\n    return T(c, o), c.prototype.getClassName = function () {\n      return \"ShaderMaterial\";\n    }, c.prototype.needAlphaBlending = function () {\n      return this.alpha < 1 || this._options.needAlphaBlending;\n    }, c.prototype.needAlphaTesting = function () {\n      return this._options.needAlphaTesting;\n    }, c.prototype._checkUniform = function (e) {\n      -1 === this._options.uniforms.indexOf(e) && this._options.uniforms.push(e);\n    }, c.prototype.setTexture = function (e, t) {\n      return -1 === this._options.samplers.indexOf(e) && this._options.samplers.push(e), this._textures[e] = t, this;\n    }, c.prototype.setTextureArray = function (e, t) {\n      return -1 === this._options.samplers.indexOf(e) && this._options.samplers.push(e), this._checkUniform(e), this._textureArrays[e] = t, this;\n    }, c.prototype.setFloat = function (e, t) {\n      return this._checkUniform(e), this._floats[e] = t, this;\n    }, c.prototype.setInt = function (e, t) {\n      return this._checkUniform(e), this._ints[e] = t, this;\n    }, c.prototype.setFloats = function (e, t) {\n      return this._checkUniform(e), this._floatsArrays[e] = t, this;\n    }, c.prototype.setColor3 = function (e, t) {\n      return this._checkUniform(e), this._colors3[e] = t, this;\n    }, c.prototype.setColor3Array = function (e, t) {\n      return this._checkUniform(e), this._colors3Arrays[e] = t.reduce(function (e, t) {\n        return t.toArray(e, e.length), e;\n      }, []), this;\n    }, c.prototype.setColor4 = function (e, t) {\n      return this._checkUniform(e), this._colors4[e] = t, this;\n    }, c.prototype.setVector2 = function (e, t) {\n      return this._checkUniform(e), this._vectors2[e] = t, this;\n    }, c.prototype.setVector3 = function (e, t) {\n      return this._checkUniform(e), this._vectors3[e] = t, this;\n    }, c.prototype.setVector4 = function (e, t) {\n      return this._checkUniform(e), this._vectors4[e] = t, this;\n    }, c.prototype.setMatrix = function (e, t) {\n      return this._checkUniform(e), this._matrices[e] = t, this;\n    }, c.prototype.setMatrix3x3 = function (e, t) {\n      return this._checkUniform(e), this._matrices3x3[e] = t, this;\n    }, c.prototype.setMatrix2x2 = function (e, t) {\n      return this._checkUniform(e), this._matrices2x2[e] = t, this;\n    }, c.prototype.setArray2 = function (e, t) {\n      return this._checkUniform(e), this._vectors2Arrays[e] = t, this;\n    }, c.prototype.setArray3 = function (e, t) {\n      return this._checkUniform(e), this._vectors3Arrays[e] = t, this;\n    }, c.prototype._checkCache = function (e, t, i) {\n      return !t || (this._effect && this._effect.defines.indexOf(\"#define INSTANCES\"), !1);\n    }, c.prototype.isReady = function (e, t) {\n      var i = this.getScene(),\n          r = i.getEngine();\n      if (!this.checkReadyOnEveryCall && this._renderId === i.getRenderId() && this._checkCache(i, e, t)) return !0;\n\n      for (var n = [], o = [], s = new zt.EffectFallbacks(), a = 0; a < this._options.defines.length; a++) n.push(this._options.defines[a]);\n\n      for (a = 0; a < this._options.attributes.length; a++) o.push(this._options.attributes[a]);\n\n      for (var l in e && e.isVerticesDataPresent(zt.VertexBuffer.ColorKind) && (o.push(zt.VertexBuffer.ColorKind), n.push(\"#define VERTEXCOLOR\")), t && (n.push(\"#define INSTANCES\"), zt.MaterialHelper.PrepareAttributesForInstances(o, n)), e && e.useBones && e.computeBonesUsingShaders && e.skeleton ? (o.push(zt.VertexBuffer.MatricesIndicesKind), o.push(zt.VertexBuffer.MatricesWeightsKind), 4 < e.numBoneInfluencers && (o.push(zt.VertexBuffer.MatricesIndicesExtraKind), o.push(zt.VertexBuffer.MatricesWeightsExtraKind)), n.push(\"#define NUM_BONE_INFLUENCERS \" + e.numBoneInfluencers), n.push(\"#define BonesPerMesh \" + (e.skeleton.bones.length + 1)), s.addCPUSkinningFallback(0, e), -1 === this._options.uniforms.indexOf(\"mBones\") && this._options.uniforms.push(\"mBones\")) : n.push(\"#define NUM_BONE_INFLUENCERS 0\"), this._textures) if (!this._textures[l].isReady()) return !1;\n\n      e && this._shouldTurnAlphaTestOn(e) && n.push(\"#define ALPHATEST\");\n      var c = this._effect,\n          h = n.join(\"\\n\");\n      return this._effect = r.createEffect(this._shaderPath, {\n        attributes: o,\n        uniformsNames: this._options.uniforms,\n        uniformBuffersNames: this._options.uniformBuffers,\n        samplers: this._options.samplers,\n        defines: h,\n        fallbacks: s,\n        onCompiled: this.onCompiled,\n        onError: this.onError\n      }, r), !!this._effect.isReady() && (c !== this._effect && i.resetCachedMaterial(), this._renderId = i.getRenderId(), !0);\n    }, c.prototype.bindOnlyWorldMatrix = function (e) {\n      var t = this.getScene();\n      this._effect && (-1 !== this._options.uniforms.indexOf(\"world\") && this._effect.setMatrix(\"world\", e), -1 !== this._options.uniforms.indexOf(\"worldView\") && (e.multiplyToRef(t.getViewMatrix(), this._cachedWorldViewMatrix), this._effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix)), -1 !== this._options.uniforms.indexOf(\"worldViewProjection\") && this._effect.setMatrix(\"worldViewProjection\", e.multiply(t.getTransformMatrix())));\n    }, c.prototype.bind = function (e, t) {\n      if (this.bindOnlyWorldMatrix(e), this._effect && this.getScene().getCachedMaterial() !== this) {\n        var i;\n\n        for (i in -1 !== this._options.uniforms.indexOf(\"view\") && this._effect.setMatrix(\"view\", this.getScene().getViewMatrix()), -1 !== this._options.uniforms.indexOf(\"projection\") && this._effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix()), -1 !== this._options.uniforms.indexOf(\"viewProjection\") && this._effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix()), zt.MaterialHelper.BindBonesParameters(t, this._effect), this._textures) this._effect.setTexture(i, this._textures[i]);\n\n        for (i in this._textureArrays) this._effect.setTextureArray(i, this._textureArrays[i]);\n\n        for (i in this._ints) this._effect.setInt(i, this._ints[i]);\n\n        for (i in this._floats) this._effect.setFloat(i, this._floats[i]);\n\n        for (i in this._floatsArrays) this._effect.setArray(i, this._floatsArrays[i]);\n\n        for (i in this._colors3) this._effect.setColor3(i, this._colors3[i]);\n\n        for (i in this._colors3Arrays) this._effect.setArray3(i, this._colors3Arrays[i]);\n\n        for (i in this._colors4) {\n          var r = this._colors4[i];\n\n          this._effect.setFloat4(i, r.r, r.g, r.b, r.a);\n        }\n\n        for (i in this._vectors2) this._effect.setVector2(i, this._vectors2[i]);\n\n        for (i in this._vectors3) this._effect.setVector3(i, this._vectors3[i]);\n\n        for (i in this._vectors4) this._effect.setVector4(i, this._vectors4[i]);\n\n        for (i in this._matrices) this._effect.setMatrix(i, this._matrices[i]);\n\n        for (i in this._matrices3x3) this._effect.setMatrix3x3(i, this._matrices3x3[i]);\n\n        for (i in this._matrices2x2) this._effect.setMatrix2x2(i, this._matrices2x2[i]);\n\n        for (i in this._vectors2Arrays) this._effect.setArray2(i, this._vectors2Arrays[i]);\n\n        for (i in this._vectors3Arrays) this._effect.setArray3(i, this._vectors3Arrays[i]);\n      }\n\n      this._afterBind(t);\n    }, c.prototype.getActiveTextures = function () {\n      var e = o.prototype.getActiveTextures.call(this);\n\n      for (var t in this._textures) e.push(this._textures[t]);\n\n      for (var t in this._textureArrays) for (var i = this._textureArrays[t], r = 0; r < i.length; r++) e.push(i[r]);\n\n      return e;\n    }, c.prototype.hasTexture = function (e) {\n      if (o.prototype.hasTexture.call(this, e)) return !0;\n\n      for (var t in this._textures) if (this._textures[t] === e) return !0;\n\n      for (var t in this._textureArrays) for (var i = this._textureArrays[t], r = 0; r < i.length; r++) if (i[r] === e) return !0;\n\n      return !1;\n    }, c.prototype.clone = function (e) {\n      return new c(e, this.getScene(), this._shaderPath, this._options);\n    }, c.prototype.dispose = function (e, t) {\n      if (t) {\n        var i;\n\n        for (i in this._textures) this._textures[i].dispose();\n\n        for (i in this._textureArrays) for (var r = this._textureArrays[i], n = 0; n < r.length; n++) r[n].dispose();\n      }\n\n      this._textures = {}, o.prototype.dispose.call(this, e, t);\n    }, c.prototype.serialize = function () {\n      var e,\n          t = zt.SerializationHelper.Serialize(this);\n\n      for (e in t.customType = \"BABYLON.ShaderMaterial\", t.options = this._options, t.shaderPath = this._shaderPath, t.textures = {}, this._textures) t.textures[e] = this._textures[e].serialize();\n\n      for (e in t.textureArrays = {}, this._textureArrays) {\n        t.textureArrays[e] = [];\n\n        for (var i = this._textureArrays[e], r = 0; r < i.length; r++) t.textureArrays[e].push(i[r].serialize());\n      }\n\n      for (e in t.floats = {}, this._floats) t.floats[e] = this._floats[e];\n\n      for (e in t.FloatArrays = {}, this._floatsArrays) t.FloatArrays[e] = this._floatsArrays[e];\n\n      for (e in t.colors3 = {}, this._colors3) t.colors3[e] = this._colors3[e].asArray();\n\n      for (e in t.colors3Arrays = {}, this._colors3Arrays) t.colors3Arrays[e] = this._colors3Arrays[e];\n\n      for (e in t.colors4 = {}, this._colors4) t.colors4[e] = this._colors4[e].asArray();\n\n      for (e in t.vectors2 = {}, this._vectors2) t.vectors2[e] = this._vectors2[e].asArray();\n\n      for (e in t.vectors3 = {}, this._vectors3) t.vectors3[e] = this._vectors3[e].asArray();\n\n      for (e in t.vectors4 = {}, this._vectors4) t.vectors4[e] = this._vectors4[e].asArray();\n\n      for (e in t.matrices = {}, this._matrices) t.matrices[e] = this._matrices[e].asArray();\n\n      for (e in t.matrices3x3 = {}, this._matrices3x3) t.matrices3x3[e] = this._matrices3x3[e];\n\n      for (e in t.matrices2x2 = {}, this._matrices2x2) t.matrices2x2[e] = this._matrices2x2[e];\n\n      for (e in t.vectors2Arrays = {}, this._vectors2Arrays) t.vectors2Arrays[e] = this._vectors2Arrays[e];\n\n      for (e in t.vectors3Arrays = {}, this._vectors3Arrays) t.vectors3Arrays[e] = this._vectors3Arrays[e];\n\n      return t;\n    }, c.Parse = function (e, t, i) {\n      var r,\n          n = zt.SerializationHelper.Parse(function () {\n        return new c(e.name, t, e.shaderPath, e.options);\n      }, e, t, i);\n\n      for (r in e.textures) n.setTexture(r, zt.Texture.Parse(e.textures[r], t, i));\n\n      for (r in e.textureArrays) {\n        for (var o = e.textureArrays[r], s = new Array(), a = 0; a < o.length; a++) s.push(zt.Texture.Parse(o[a], t, i));\n\n        n.setTextureArray(r, s);\n      }\n\n      for (r in e.floats) n.setFloat(r, e.floats[r]);\n\n      for (r in e.floatsArrays) n.setFloats(r, e.floatsArrays[r]);\n\n      for (r in e.colors3) n.setColor3(r, zt.Color3.FromArray(e.colors3[r]));\n\n      for (r in e.colors3Arrays) {\n        var l = e.colors3Arrays[r].reduce(function (e, t, i) {\n          return i % 3 == 0 ? e.push([t]) : e[e.length - 1].push(t), e;\n        }, []).map(function (e) {\n          return zt.Color3.FromArray(e);\n        });\n        n.setColor3Array(r, l);\n      }\n\n      for (r in e.colors4) n.setColor4(r, zt.Color4.FromArray(e.colors4[r]));\n\n      for (r in e.vectors2) n.setVector2(r, zt.Vector2.FromArray(e.vectors2[r]));\n\n      for (r in e.vectors3) n.setVector3(r, zt.Vector3.FromArray(e.vectors3[r]));\n\n      for (r in e.vectors4) n.setVector4(r, zt.Vector4.FromArray(e.vectors4[r]));\n\n      for (r in e.matrices) n.setMatrix(r, zt.Matrix.FromArray(e.matrices[r]));\n\n      for (r in e.matrices3x3) n.setMatrix3x3(r, e.matrices3x3[r]);\n\n      for (r in e.matrices2x2) n.setMatrix2x2(r, e.matrices2x2[r]);\n\n      for (r in e.vectors2Arrays) n.setArray2(r, e.vectors2Arrays[r]);\n\n      for (r in e.vectors3Arrays) n.setArray3(r, e.vectors3Arrays[r]);\n\n      return n;\n    }, c;\n  }(zt.Material), zt.ShaderMaterial = Gt, kt = $a || ($a = {}), Wt = function (r) {\n    function n(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i.generateOctree = !1, i;\n    }\n\n    return T(n, r), n.prototype.getClassName = function () {\n      return \"GroundMesh\";\n    }, Object.defineProperty(n.prototype, \"subdivisions\", {\n      get: function () {\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"subdivisionsX\", {\n      get: function () {\n        return this._subdivisionsX;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"subdivisionsY\", {\n      get: function () {\n        return this._subdivisionsY;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.prototype.optimize = function (e, t) {\n      void 0 === t && (t = 32), this._subdivisionsX = e, this._subdivisionsY = e, this.subdivide(e);\n      this.createOrUpdateSubmeshesOctree && this.createOrUpdateSubmeshesOctree(t);\n    }, n.prototype.getHeightAtCoordinates = function (e, t) {\n      var i = this.getWorldMatrix(),\n          r = kt.Tmp.Matrix[5];\n      i.invertToRef(r);\n      var n = kt.Tmp.Vector3[8];\n      if (kt.Vector3.TransformCoordinatesFromFloatsToRef(e, 0, t, r, n), e = n.x, t = n.z, e < this._minX || e > this._maxX || t < this._minZ || t > this._maxZ) return this.position.y;\n      this._heightQuads && 0 != this._heightQuads.length || (this._initHeightQuads(), this._computeHeightQuads());\n\n      var o = this._getFacetAt(e, t),\n          s = -(o.x * e + o.z * t + o.w) / o.y;\n\n      return kt.Vector3.TransformCoordinatesFromFloatsToRef(0, s, 0, i, n), n.y;\n    }, n.prototype.getNormalAtCoordinates = function (e, t) {\n      var i = new kt.Vector3(0, 1, 0);\n      return this.getNormalAtCoordinatesToRef(e, t, i), i;\n    }, n.prototype.getNormalAtCoordinatesToRef = function (e, t, i) {\n      var r = this.getWorldMatrix(),\n          n = kt.Tmp.Matrix[5];\n      r.invertToRef(n);\n      var o = kt.Tmp.Vector3[8];\n      if (kt.Vector3.TransformCoordinatesFromFloatsToRef(e, 0, t, n, o), e = o.x, t = o.z, e < this._minX || e > this._maxX || t < this._minZ || t > this._maxZ) return this;\n      this._heightQuads && 0 != this._heightQuads.length || (this._initHeightQuads(), this._computeHeightQuads());\n\n      var s = this._getFacetAt(e, t);\n\n      return kt.Vector3.TransformNormalFromFloatsToRef(s.x, s.y, s.z, r, i), this;\n    }, n.prototype.updateCoordinateHeights = function () {\n      return this._heightQuads && 0 != this._heightQuads.length || this._initHeightQuads(), this._computeHeightQuads(), this;\n    }, n.prototype._getFacetAt = function (e, t) {\n      var i = Math.floor((e + this._maxX) * this._subdivisionsX / this._width),\n          r = Math.floor(-(t + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY),\n          n = this._heightQuads[r * this._subdivisionsX + i];\n      return t < n.slope.x * e + n.slope.y ? n.facet1 : n.facet2;\n    }, n.prototype._initHeightQuads = function () {\n      var e = this._subdivisionsX,\n          t = this._subdivisionsY;\n      this._heightQuads = new Array();\n\n      for (var i = 0; i < t; i++) for (var r = 0; r < e; r++) {\n        var n = {\n          slope: kt.Vector2.Zero(),\n          facet1: new kt.Vector4(0, 0, 0, 0),\n          facet2: new kt.Vector4(0, 0, 0, 0)\n        };\n        this._heightQuads[i * e + r] = n;\n      }\n\n      return this;\n    }, n.prototype._computeHeightQuads = function () {\n      var e = this.getVerticesData(kt.VertexBuffer.PositionKind);\n      if (!e) return this;\n\n      for (var t = kt.Tmp.Vector3[3], i = kt.Tmp.Vector3[2], r = kt.Tmp.Vector3[1], n = kt.Tmp.Vector3[0], o = kt.Tmp.Vector3[4], s = kt.Tmp.Vector3[5], a = kt.Tmp.Vector3[6], l = kt.Tmp.Vector3[7], c = kt.Tmp.Vector3[8], h = 0, u = 0, d = 0, f = 0, p = 0, _ = 0, m = 0, g = this._subdivisionsX, v = this._subdivisionsY, y = 0; y < v; y++) for (var b = 0; b < g; b++) {\n        h = 3 * b, u = y * (g + 1) * 3, d = (y + 1) * (g + 1) * 3, t.x = e[u + h], t.y = e[u + h + 1], t.z = e[u + h + 2], i.x = e[u + h + 3], i.y = e[u + h + 4], i.z = e[u + h + 5], r.x = e[d + h], r.y = e[d + h + 1], r.z = e[d + h + 2], n.x = e[d + h + 3], n.y = e[d + h + 4], n.z = e[d + h + 5], f = (n.z - t.z) / (n.x - t.x), p = t.z - f * t.x, i.subtractToRef(t, o), r.subtractToRef(t, s), n.subtractToRef(t, a), kt.Vector3.CrossToRef(a, s, l), kt.Vector3.CrossToRef(o, a, c), l.normalize(), c.normalize(), _ = -(l.x * t.x + l.y * t.y + l.z * t.z), m = -(c.x * i.x + c.y * i.y + c.z * i.z);\n        var T = this._heightQuads[y * g + b];\n        T.slope.copyFromFloats(f, p), T.facet1.copyFromFloats(l.x, l.y, l.z, _), T.facet2.copyFromFloats(c.x, c.y, c.z, m);\n      }\n\n      return this;\n    }, n.prototype.serialize = function (e) {\n      r.prototype.serialize.call(this, e), e.subdivisionsX = this._subdivisionsX, e.subdivisionsY = this._subdivisionsY, e.minX = this._minX, e.maxX = this._maxX, e.minZ = this._minZ, e.maxZ = this._maxZ, e.width = this._width, e.height = this._height;\n    }, n.Parse = function (e, t) {\n      var i = new n(e.name, t);\n      return i._subdivisionsX = e.subdivisionsX || 1, i._subdivisionsY = e.subdivisionsY || 1, i._minX = e.minX, i._maxX = e.maxX, i._minZ = e.minZ, i._maxZ = e.maxZ, i._width = e.width, i._height = e.height, i;\n    }, n;\n  }(kt.Mesh), kt.GroundMesh = Wt, Ht = $a || ($a = {}), Xt = function (r) {\n    function e(e, t) {\n      var i = r.call(this, e, t.getScene()) || this;\n      return t.instances.push(i), i._sourceMesh = t, i.position.copyFrom(t.position), i.rotation.copyFrom(t.rotation), i.scaling.copyFrom(t.scaling), t.rotationQuaternion && (i.rotationQuaternion = t.rotationQuaternion.clone()), i.infiniteDistance = t.infiniteDistance, i.setPivotMatrix(t.getPivotMatrix()), i.refreshBoundingInfo(), i._syncSubMeshes(), i;\n    }\n\n    return T(e, r), e.prototype.getClassName = function () {\n      return \"InstancedMesh\";\n    }, Object.defineProperty(e.prototype, \"receiveShadows\", {\n      get: function () {\n        return this._sourceMesh.receiveShadows;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"material\", {\n      get: function () {\n        return this._sourceMesh.material;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"visibility\", {\n      get: function () {\n        return this._sourceMesh.visibility;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"skeleton\", {\n      get: function () {\n        return this._sourceMesh.skeleton;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"renderingGroupId\", {\n      get: function () {\n        return this._sourceMesh.renderingGroupId;\n      },\n      set: function (e) {\n        this._sourceMesh && e !== this._sourceMesh.renderingGroupId && Ht.Tools.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getTotalVertices = function () {\n      return this._sourceMesh.getTotalVertices();\n    }, Object.defineProperty(e.prototype, \"sourceMesh\", {\n      get: function () {\n        return this._sourceMesh;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.isReady = function (e) {\n      return void 0 === e && (e = !1), this._sourceMesh.isReady(e, !0);\n    }, e.prototype.getVerticesData = function (e, t) {\n      return this._sourceMesh.getVerticesData(e, t);\n    }, e.prototype.setVerticesData = function (e, t, i, r) {\n      return this.sourceMesh && this.sourceMesh.setVerticesData(e, t, i, r), this.sourceMesh;\n    }, e.prototype.updateVerticesData = function (e, t, i, r) {\n      return this.sourceMesh && this.sourceMesh.updateVerticesData(e, t, i, r), this.sourceMesh;\n    }, e.prototype.setIndices = function (e, t) {\n      return void 0 === t && (t = null), this.sourceMesh && this.sourceMesh.setIndices(e, t), this.sourceMesh;\n    }, e.prototype.isVerticesDataPresent = function (e) {\n      return this._sourceMesh.isVerticesDataPresent(e);\n    }, e.prototype.getIndices = function () {\n      return this._sourceMesh.getIndices();\n    }, Object.defineProperty(e.prototype, \"_positions\", {\n      get: function () {\n        return this._sourceMesh._positions;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.refreshBoundingInfo = function () {\n      var e = this._sourceMesh.getBoundingInfo();\n\n      return this._boundingInfo = new Ht.BoundingInfo(e.minimum.clone(), e.maximum.clone()), this._updateBoundingInfo(), this;\n    }, e.prototype._preActivate = function () {\n      return this._currentLOD && this._currentLOD._preActivate(), this;\n    }, e.prototype._activate = function (e) {\n      return this._currentLOD && this._currentLOD._registerInstanceForRenderId(this, e), this;\n    }, e.prototype.getLOD = function (e) {\n      if (!e) return this;\n      var t = this.getBoundingInfo();\n      return this._currentLOD = this.sourceMesh.getLOD(e, t.boundingSphere), this._currentLOD === this.sourceMesh ? this : this._currentLOD;\n    }, e.prototype._syncSubMeshes = function () {\n      if (this.releaseSubMeshes(), this._sourceMesh.subMeshes) for (var e = 0; e < this._sourceMesh.subMeshes.length; e++) this._sourceMesh.subMeshes[e].clone(this, this._sourceMesh);\n      return this;\n    }, e.prototype._generatePointsArray = function () {\n      return this._sourceMesh._generatePointsArray();\n    }, e.prototype.clone = function (e, t, i) {\n      var r = this._sourceMesh.createInstance(e);\n\n      if (Ht.Tools.DeepCopy(this, r, [\"name\", \"subMeshes\", \"uniqueId\"], []), this.refreshBoundingInfo(), t && (r.parent = t), !i) for (var n = 0; n < this.getScene().meshes.length; n++) {\n        var o = this.getScene().meshes[n];\n        o.parent === this && o.clone(o.name, r);\n      }\n      return r.computeWorldMatrix(!0), r;\n    }, e.prototype.dispose = function (e, t) {\n      void 0 === t && (t = !1);\n\n      var i = this._sourceMesh.instances.indexOf(this);\n\n      this._sourceMesh.instances.splice(i, 1), r.prototype.dispose.call(this, e, t);\n    }, e;\n  }(Ht.AbstractMesh), Ht.InstancedMesh = Xt, jt = $a || ($a = {}), Yt = function (c) {\n    function r(e, t, i, r, n, o, s) {\n      void 0 === t && (t = null), void 0 === i && (i = null);\n      var a = c.call(this, e, t, i, r, n) || this;\n      a.useVertexColor = o, a.useVertexAlpha = s, a.color = new jt.Color3(1, 1, 1), a.alpha = 1, r && (a.color = r.color.clone(), a.alpha = r.alpha, a.useVertexColor = r.useVertexColor, a.useVertexAlpha = r.useVertexAlpha), a._intersectionThreshold = .1;\n      var l = {\n        attributes: [jt.VertexBuffer.PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\n        uniforms: [\"world\", \"viewProjection\"],\n        needAlphaBlending: !0,\n        defines: []\n      };\n      return !1 === s && (l.needAlphaBlending = !1), o ? (l.defines.push(\"#define VERTEXCOLOR\"), l.attributes.push(jt.VertexBuffer.ColorKind)) : l.uniforms.push(\"color\"), a._colorShader = new jt.ShaderMaterial(\"colorShader\", a.getScene(), \"color\", l), a;\n    }\n\n    return T(r, c), Object.defineProperty(r.prototype, \"intersectionThreshold\", {\n      get: function () {\n        return this._intersectionThreshold;\n      },\n      set: function (e) {\n        this._intersectionThreshold !== e && (this._intersectionThreshold = e, this.geometry && (this.geometry.boundingBias = new jt.Vector2(0, e)));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype.getClassName = function () {\n      return \"LinesMesh\";\n    }, Object.defineProperty(r.prototype, \"material\", {\n      get: function () {\n        return this._colorShader;\n      },\n      set: function (e) {},\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"checkCollisions\", {\n      get: function () {\n        return !1;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype._bind = function (e, t, i) {\n      return this._geometry && (this._geometry._bind(this._colorShader.getEffect()), this.useVertexColor || this._colorShader.setColor4(\"color\", this.color.toColor4(this.alpha))), this;\n    }, r.prototype._draw = function (e, t, i) {\n      return this._geometry && this._geometry.getVertexBuffers() && (this._unIndexed || this._geometry.getIndexBuffer()) && this.getScene().getEngine().drawElementsType(jt.Material.LineListDrawMode, e.indexStart, e.indexCount, i), this;\n    }, r.prototype.dispose = function (e) {\n      this._colorShader.dispose(), c.prototype.dispose.call(this, e);\n    }, r.prototype.clone = function (e, t, i) {\n      return new r(e, this.getScene(), t, this, i);\n    }, r;\n  }(jt.Mesh), jt.LinesMesh = Yt, Kt = $a || ($a = {}), Qt = function () {\n    function e() {\n      this._count = 0, this._data = {};\n    }\n\n    return e.prototype.copyFrom = function (e) {\n      var i = this;\n      this.clear(), e.forEach(function (e, t) {\n        return i.add(e, t);\n      });\n    }, e.prototype.get = function (e) {\n      var t = this._data[e];\n      if (void 0 !== t) return t;\n    }, e.prototype.getOrAddWithFactory = function (e, t) {\n      var i = this.get(e);\n      return void 0 !== i || (i = t(e)) && this.add(e, i), i;\n    }, e.prototype.getOrAdd = function (e, t) {\n      var i = this.get(e);\n      return void 0 !== i ? i : (this.add(e, t), t);\n    }, e.prototype.contains = function (e) {\n      return void 0 !== this._data[e];\n    }, e.prototype.add = function (e, t) {\n      return void 0 === this._data[e] && (this._data[e] = t, ++this._count, !0);\n    }, e.prototype.set = function (e, t) {\n      return void 0 !== this._data[e] && (this._data[e] = t, !0);\n    }, e.prototype.getAndRemove = function (e) {\n      var t = this.get(e);\n      return void 0 !== t ? (delete this._data[e], --this._count, t) : null;\n    }, e.prototype.remove = function (e) {\n      return !!this.contains(e) && (delete this._data[e], --this._count, !0);\n    }, e.prototype.clear = function () {\n      this._data = {}, this._count = 0;\n    }, Object.defineProperty(e.prototype, \"count\", {\n      get: function () {\n        return this._count;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.forEach = function (e) {\n      for (var t in this._data) {\n        e(t, this._data[t]);\n      }\n    }, e.prototype.first = function (e) {\n      for (var t in this._data) {\n        var i = e(t, this._data[t]);\n        if (i) return i;\n      }\n\n      return null;\n    }, e;\n  }(), Kt.StringDictionary = Qt, Zt = $a || ($a = {}), qt = Zt.Debug || (Zt.Debug = {}), Jt = function () {\n    function e(e, t, i, r, n) {\n      void 0 === r && (r = !0), void 0 === n && (n = 1), this.skeleton = e, this.mesh = t, this.autoUpdateBonesMatrices = r, this.renderingGroupId = n, this.color = Zt.Color3.White(), this._debugLines = new Array(), this._isEnabled = !1, this._scene = i, this.update(), this._renderFunction = this.update.bind(this);\n    }\n\n    return Object.defineProperty(e.prototype, \"isEnabled\", {\n      get: function () {\n        return this._isEnabled;\n      },\n      set: function (e) {\n        this._isEnabled !== e && ((this._isEnabled = e) ? this._scene.registerBeforeRender(this._renderFunction) : this._scene.unregisterBeforeRender(this._renderFunction));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._getBonePosition = function (e, t, i, r, n, o) {\n      void 0 === r && (r = 0), void 0 === n && (n = 0), void 0 === o && (o = 0);\n      var s = Zt.Tmp.Matrix[0],\n          a = t.getParent();\n\n      if (s.copyFrom(t.getLocalMatrix()), 0 !== r || 0 !== n || 0 !== o) {\n        var l = Zt.Tmp.Matrix[1];\n        Zt.Matrix.IdentityToRef(l), l.m[12] = r, l.m[13] = n, l.m[14] = o, l.multiplyToRef(s, s);\n      }\n\n      a && s.multiplyToRef(a.getAbsoluteTransform(), s), s.multiplyToRef(i, s), e.x = s.m[12], e.y = s.m[13], e.z = s.m[14];\n    }, e.prototype._getLinesForBonesWithLength = function (e, t) {\n      for (var i = e.length, r = this.mesh.position, n = 0; n < i; n++) {\n        var o = e[n],\n            s = this._debugLines[n];\n        s || (s = [Zt.Vector3.Zero(), Zt.Vector3.Zero()], this._debugLines[n] = s), this._getBonePosition(s[0], o, t), this._getBonePosition(s[1], o, t, 0, o.length, 0), s[0].subtractInPlace(r), s[1].subtractInPlace(r);\n      }\n    }, e.prototype._getLinesForBonesNoLength = function (e, t) {\n      for (var i = e.length, r = 0, n = this.mesh.position, o = i - 1; 0 <= o; o--) {\n        var s = e[o],\n            a = s.getParent();\n\n        if (a) {\n          var l = this._debugLines[r];\n          l || (l = [Zt.Vector3.Zero(), Zt.Vector3.Zero()], this._debugLines[r] = l), s.getAbsolutePositionToRef(this.mesh, l[0]), a.getAbsolutePositionToRef(this.mesh, l[1]), l[0].subtractInPlace(n), l[1].subtractInPlace(n), r++;\n        }\n      }\n    }, e.prototype.update = function () {\n      this.autoUpdateBonesMatrices && this.skeleton.computeAbsoluteTransforms(), void 0 === this.skeleton.bones[0].length ? this._getLinesForBonesNoLength(this.skeleton.bones, this.mesh.getWorldMatrix()) : this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix()), this._debugMesh ? Zt.MeshBuilder.CreateLineSystem(\"\", {\n        lines: this._debugLines,\n        updatable: !0,\n        instance: this._debugMesh\n      }, this._scene) : (this._debugMesh = Zt.MeshBuilder.CreateLineSystem(\"\", {\n        lines: this._debugLines,\n        updatable: !0,\n        instance: null\n      }, this._scene), this._debugMesh.renderingGroupId = this.renderingGroupId), this._debugMesh.position.copyFrom(this.mesh.position), this._debugMesh.color = this.color;\n    }, e.prototype.dispose = function () {\n      this._debugMesh && (this.isEnabled = !1, this._debugMesh.dispose(), this._debugMesh = null);\n    }, e;\n  }(), qt.SkeletonViewer = Jt, $t = $a || ($a = {}), ei = $t.Debug || ($t.Debug = {}), ti = function () {\n    function e(e, t) {\n      void 0 === t && (t = 1), this._xline = [$t.Vector3.Zero(), $t.Vector3.Zero()], this._yline = [$t.Vector3.Zero(), $t.Vector3.Zero()], this._zline = [$t.Vector3.Zero(), $t.Vector3.Zero()], this.scaleLines = 1, this.scaleLines = t, this._xmesh = $t.Mesh.CreateLines(\"xline\", this._xline, e, !0), this._ymesh = $t.Mesh.CreateLines(\"yline\", this._yline, e, !0), this._zmesh = $t.Mesh.CreateLines(\"zline\", this._zline, e, !0), this._xmesh.renderingGroupId = 2, this._ymesh.renderingGroupId = 2, this._zmesh.renderingGroupId = 2, this._xmesh.material.checkReadyOnlyOnce = !0, this._xmesh.color = new $t.Color3(1, 0, 0), this._ymesh.material.checkReadyOnlyOnce = !0, this._ymesh.color = new $t.Color3(0, 1, 0), this._zmesh.material.checkReadyOnlyOnce = !0, this._zmesh.color = new $t.Color3(0, 0, 1), this.scene = e;\n    }\n\n    return e.prototype.update = function (e, t, i, r) {\n      var n = this.scaleLines;\n      this._xmesh && this._xmesh.position.copyFrom(e), this._ymesh && this._ymesh.position.copyFrom(e), this._zmesh && this._zmesh.position.copyFrom(e);\n      var o = this._xline[1];\n      o.x = t.x * n, o.y = t.y * n, o.z = t.z * n, $t.Mesh.CreateLines(\"\", this._xline, null, !1, this._xmesh), (o = this._yline[1]).x = i.x * n, o.y = i.y * n, o.z = i.z * n, $t.Mesh.CreateLines(\"\", this._yline, null, !1, this._ymesh), (o = this._zline[1]).x = r.x * n, o.y = r.y * n, o.z = r.z * n, $t.Mesh.CreateLines(\"\", this._zline, null, !1, this._zmesh);\n    }, e.prototype.dispose = function () {\n      this._xmesh && this._xmesh.dispose(), this._ymesh && this._ymesh.dispose(), this._zmesh && this._zmesh.dispose(), this._xmesh = null, this._ymesh = null, this._zmesh = null, this.scene = null;\n    }, e;\n  }(), ei.AxesViewer = ti, ii = $a || ($a = {}), ri = ii.Debug || (ii.Debug = {}), ni = function (o) {\n    function e(e, t, i, r) {\n      void 0 === r && (r = 1);\n      var n = o.call(this, e, r) || this;\n      return n.pos = ii.Vector3.Zero(), n.xaxis = ii.Vector3.Zero(), n.yaxis = ii.Vector3.Zero(), n.zaxis = ii.Vector3.Zero(), n.mesh = i, n.bone = t, n;\n    }\n\n    return T(e, o), e.prototype.update = function () {\n      if (this.mesh && this.bone) {\n        var e = this.bone;\n        e.getAbsolutePositionToRef(this.mesh, this.pos), e.getDirectionToRef(ii.Axis.X, this.mesh, this.xaxis), e.getDirectionToRef(ii.Axis.Y, this.mesh, this.yaxis), e.getDirectionToRef(ii.Axis.Z, this.mesh, this.zaxis), o.prototype.update.call(this, this.pos, this.xaxis, this.yaxis, this.zaxis);\n      }\n    }, e.prototype.dispose = function () {\n      this.mesh && (this.mesh = null, this.bone = null, o.prototype.dispose.call(this));\n    }, e;\n  }(ri.AxesViewer), ri.BoneAxesViewer = ni, oi = $a || ($a = {}), si = function () {\n    function n(e) {\n      this.ray = e;\n    }\n\n    return n.CreateAndShow = function (e, t, i) {\n      var r = new n(e);\n      return r.show(t, i), r;\n    }, n.prototype.show = function (e, t) {\n      if (!this._renderFunction && this.ray) {\n        var i = this.ray;\n        this._renderFunction = this._render.bind(this), this._scene = e, this._renderPoints = [i.origin, i.origin.add(i.direction.scale(i.length))], this._renderLine = oi.Mesh.CreateLines(\"ray\", this._renderPoints, e, !0), this._renderFunction && this._scene.registerBeforeRender(this._renderFunction);\n      }\n\n      t && this._renderLine && this._renderLine.color.copyFrom(t);\n    }, n.prototype.hide = function () {\n      this._renderFunction && this._scene && (this._scene.unregisterBeforeRender(this._renderFunction), this._scene = null, this._renderFunction = null, this._renderLine && (this._renderLine.dispose(), this._renderLine = null), this._renderPoints = []);\n    }, n.prototype._render = function () {\n      var e = this.ray;\n\n      if (e) {\n        var t = this._renderPoints[1],\n            i = Math.min(e.length, 1e6);\n        t.copyFrom(e.direction), t.scaleInPlace(i), t.addInPlace(e.origin), oi.Mesh.CreateLines(\"ray\", this._renderPoints, this._scene, !0, this._renderLine);\n      }\n    }, n.prototype.attachToMesh = function (e, t, i, r) {\n      this._attachedToMesh = e;\n      var n = this.ray;\n      n && (n.direction || (n.direction = oi.Vector3.Zero()), n.origin || (n.origin = oi.Vector3.Zero()), r && (n.length = r), i || (i = oi.Vector3.Zero()), t || (t = new oi.Vector3(0, 0, -1)), this._meshSpaceDirection ? (this._meshSpaceDirection.copyFrom(t), this._meshSpaceOrigin.copyFrom(i)) : (this._meshSpaceDirection = t.clone(), this._meshSpaceOrigin = i.clone()), this._updateToMeshFunction || (this._updateToMeshFunction = this._updateToMesh.bind(this), this._attachedToMesh.getScene().registerBeforeRender(this._updateToMeshFunction)), this._updateToMesh());\n    }, n.prototype.detachFromMesh = function () {\n      this._attachedToMesh && (this._updateToMeshFunction && this._attachedToMesh.getScene().unregisterBeforeRender(this._updateToMeshFunction), this._attachedToMesh = null, this._updateToMeshFunction = null);\n    }, n.prototype._updateToMesh = function () {\n      var e = this.ray;\n      this._attachedToMesh && e && (this._attachedToMesh._isDisposed ? this.detachFromMesh() : (this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, e.direction), oi.Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), e.origin)));\n    }, n.prototype.dispose = function () {\n      this.hide(), this.detachFromMesh(), this.ray = null;\n    }, n;\n  }(), oi.RayHelper = si, function (i) {\n    Object.defineProperty(i.Scene.prototype, \"debugLayer\", {\n      get: function () {\n        return this._debugLayer || (this._debugLayer = new e(this)), this._debugLayer;\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n\n    var e = function () {\n      function t(e) {\n        var t = this;\n        this.BJSINSPECTOR = \"undefined\" != typeof INSPECTOR ? INSPECTOR : void 0, this.onPropertyChangedObservable = new i.Observable(), this._scene = e, this._scene.onDisposeObservable.add(function () {\n          t._scene._debugLayer && t._scene._debugLayer.hide();\n        });\n      }\n\n      return t.prototype._createInspector = function (e) {\n        void 0 === e && (e = {});\n        var t = e.popup || !1,\n            i = e.initialTab || 0,\n            r = e.parentElement || null;\n        this._inspector || (this.BJSINSPECTOR = this.BJSINSPECTOR || \"undefined\" != typeof INSPECTOR ? INSPECTOR : void 0, this._inspector = new this.BJSINSPECTOR.Inspector(this._scene, t, i, r, e.newColors));\n      }, t.prototype.isVisible = function () {\n        return !!this._inspector;\n      }, t.prototype.hide = function () {\n        if (this._inspector) {\n          try {\n            this._inspector.dispose();\n          } catch (e) {}\n\n          this.onPropertyChangedObservable.clear(), this._inspector = null;\n        }\n      }, t.prototype.show = function (e) {\n        void 0 === e && (e = {}), void 0 === this.BJSINSPECTOR ? i.Tools.LoadScript(t.InspectorURL, this._createInspector.bind(this, e)) : this._createInspector(e);\n      }, t.prototype.getActiveTab = function () {\n        return this._inspector ? this._inspector.getActiveTabIndex() : -1;\n      }, t.InspectorURL = \"https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js\", t;\n    }();\n\n    i.DebugLayer = e;\n  }($a || ($a = {})), ai = $a || ($a = {}), li = ai.Debug || (ai.Debug = {}), ci = function () {\n    function e(e) {\n      this._impostors = [], this._meshes = [], this._numMeshes = 0, this._scene = e || ai.Engine.LastCreatedScene;\n\n      var t = this._scene.getPhysicsEngine();\n\n      t && (this._physicsEnginePlugin = t.getPhysicsPlugin());\n    }\n\n    return e.prototype._updateDebugMeshes = function () {\n      for (var e = this._physicsEnginePlugin, t = 0; t < this._numMeshes; t++) {\n        var i = this._impostors[t];\n        if (i) if (i.isDisposed) this.hideImpostor(this._impostors[t--]);else {\n          var r = this._meshes[t];\n          r && e && e.syncMeshWithImpostor(r, i);\n        }\n      }\n    }, e.prototype.showImpostor = function (e) {\n      if (this._scene) {\n        for (var t = 0; t < this._numMeshes; t++) if (this._impostors[t] == e) return;\n\n        var i = this._getDebugMesh(e, this._scene);\n\n        i && (this._impostors[this._numMeshes] = e, this._meshes[this._numMeshes] = i, 0 === this._numMeshes && (this._renderFunction = this._updateDebugMeshes.bind(this), this._scene.registerBeforeRender(this._renderFunction)), this._numMeshes++);\n      }\n    }, e.prototype.hideImpostor = function (e) {\n      if (e && this._scene) {\n        for (var t = !1, i = 0; i < this._numMeshes; i++) if (this._impostors[i] == e) {\n          var r = this._meshes[i];\n          if (!r) continue;\n          this._scene.removeMesh(r), r.dispose(), this._numMeshes--, 0 < this._numMeshes ? (this._meshes[i] = this._meshes[this._numMeshes], this._impostors[i] = this._impostors[this._numMeshes], this._meshes[this._numMeshes] = null, this._impostors[this._numMeshes] = null) : (this._meshes[0] = null, this._impostors[0] = null), t = !0;\n          break;\n        }\n\n        t && 0 === this._numMeshes && this._scene.unregisterBeforeRender(this._renderFunction);\n      }\n    }, e.prototype._getDebugMaterial = function (e) {\n      return this._debugMaterial || (this._debugMaterial = new ai.StandardMaterial(\"\", e), this._debugMaterial.wireframe = !0), this._debugMaterial;\n    }, e.prototype._getDebugBoxMesh = function (e) {\n      return this._debugBoxMesh || (this._debugBoxMesh = ai.MeshBuilder.CreateBox(\"physicsBodyBoxViewMesh\", {\n        size: 1\n      }, e), this._debugBoxMesh.renderingGroupId = 1, this._debugBoxMesh.rotationQuaternion = ai.Quaternion.Identity(), this._debugBoxMesh.material = this._getDebugMaterial(e), e.removeMesh(this._debugBoxMesh)), this._debugBoxMesh.createInstance(\"physicsBodyBoxViewInstance\");\n    }, e.prototype._getDebugSphereMesh = function (e) {\n      return this._debugSphereMesh || (this._debugSphereMesh = ai.MeshBuilder.CreateSphere(\"physicsBodySphereViewMesh\", {\n        diameter: 1\n      }, e), this._debugSphereMesh.renderingGroupId = 1, this._debugSphereMesh.rotationQuaternion = ai.Quaternion.Identity(), this._debugSphereMesh.material = this._getDebugMaterial(e), e.removeMesh(this._debugSphereMesh)), this._debugSphereMesh.createInstance(\"physicsBodyBoxViewInstance\");\n    }, e.prototype._getDebugMesh = function (e, t) {\n      var i = null;\n      if (e.type == ai.PhysicsImpostor.BoxImpostor) i = this._getDebugBoxMesh(t), e.getBoxSizeToRef(i.scaling);else if (e.type == ai.PhysicsImpostor.SphereImpostor) {\n        i = this._getDebugSphereMesh(t);\n        var r = e.getRadius();\n        i.scaling.x = 2 * r, i.scaling.y = 2 * r, i.scaling.z = 2 * r;\n      }\n      return i;\n    }, e.prototype.dispose = function () {\n      for (var e = 0; e < this._numMeshes; e++) this.hideImpostor(this._impostors[e]);\n\n      this._debugBoxMesh && this._debugBoxMesh.dispose(), this._debugSphereMesh && this._debugSphereMesh.dispose(), this._debugMaterial && this._debugMaterial.dispose(), this._impostors.length = 0, this._scene = null, this._physicsEnginePlugin = null;\n    }, e;\n  }(), li.PhysicsViewer = ci, function (l) {\n    Object.defineProperty(l.Scene.prototype, \"forceShowBoundingBoxes\", {\n      get: function () {\n        return this._forceShowBoundingBoxes || !1;\n      },\n      set: function (e) {\n        (this._forceShowBoundingBoxes = e) && this.getBoundingBoxRenderer();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), l.Scene.prototype.getBoundingBoxRenderer = function () {\n      return this._boundingBoxRenderer || (this._boundingBoxRenderer = new e(this)), this._boundingBoxRenderer;\n    }, Object.defineProperty(l.AbstractMesh.prototype, \"showBoundingBox\", {\n      get: function () {\n        return this._showBoundingBox || !1;\n      },\n      set: function (e) {\n        (this._showBoundingBox = e) && this.getScene().getBoundingBoxRenderer();\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n\n    var e = function () {\n      function e(e) {\n        this.name = l.SceneComponentConstants.NAME_BOUNDINGBOXRENDERER, this.frontColor = new l.Color3(1, 1, 1), this.backColor = new l.Color3(.1, .1, .1), this.showBackLines = !0, this.renderList = new l.SmartArray(32), this._vertexBuffers = {}, (this.scene = e)._addComponent(this);\n      }\n\n      return e.prototype.register = function () {\n        this.scene._beforeEvaluateActiveMeshStage.registerStep(l.SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset), this.scene._activeMeshStage.registerStep(l.SceneComponentConstants.STEP_ACTIVEMESH_BOUNDINGBOXRENDERER, this, this._activeMesh), this.scene._evaluateSubMeshStage.registerStep(l.SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh), this.scene._afterRenderingGroupDrawStage.registerStep(l.SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n      }, e.prototype._evaluateSubMesh = function (e, t) {\n        if (e.showSubMeshesBoundingBox) {\n          var i = t.getBoundingInfo();\n          null != i && (i.boundingBox._tag = e.renderingGroupId, this.renderList.push(i.boundingBox));\n        }\n      }, e.prototype._activeMesh = function (e, t) {\n        if (e.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n          var i = e.getBoundingInfo();\n          i.boundingBox._tag = t.renderingGroupId, this.renderList.push(i.boundingBox);\n        }\n      }, e.prototype._prepareRessources = function () {\n        if (!this._colorShader) {\n          this._colorShader = new l.ShaderMaterial(\"colorShader\", this.scene, \"color\", {\n            attributes: [l.VertexBuffer.PositionKind],\n            uniforms: [\"world\", \"viewProjection\", \"color\"]\n          });\n          var e = this.scene.getEngine(),\n              t = l.VertexData.CreateBox({\n            size: 1\n          });\n          this._vertexBuffers[l.VertexBuffer.PositionKind] = new l.VertexBuffer(e, t.positions, l.VertexBuffer.PositionKind, !1), this._createIndexBuffer();\n        }\n      }, e.prototype._createIndexBuffer = function () {\n        var e = this.scene.getEngine();\n        this._indexBuffer = e.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n      }, e.prototype.rebuild = function () {\n        var e = this._vertexBuffers[l.VertexBuffer.PositionKind];\n        e && e._rebuild(), this._createIndexBuffer();\n      }, e.prototype.reset = function () {\n        this.renderList.reset();\n      }, e.prototype.render = function (e) {\n        if (0 !== this.renderList.length && (this._prepareRessources(), this._colorShader.isReady())) {\n          var t = this.scene.getEngine();\n          t.setDepthWrite(!1), this._colorShader._preBind();\n\n          for (var i = 0; i < this.renderList.length; i++) {\n            var r = this.renderList.data[i];\n\n            if (r._tag === e) {\n              var n = r.minimum,\n                  o = r.maximum.subtract(n),\n                  s = n.add(o.scale(.5)),\n                  a = l.Matrix.Scaling(o.x, o.y, o.z).multiply(l.Matrix.Translation(s.x, s.y, s.z)).multiply(r.getWorldMatrix());\n              t.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect()), this.showBackLines && (t.setDepthFunctionToGreaterOrEqual(), this.scene.resetCachedMaterial(), this._colorShader.setColor4(\"color\", this.backColor.toColor4()), this._colorShader.bind(a), t.drawElementsType(l.Material.LineListDrawMode, 0, 24)), t.setDepthFunctionToLess(), this.scene.resetCachedMaterial(), this._colorShader.setColor4(\"color\", this.frontColor.toColor4()), this._colorShader.bind(a), t.drawElementsType(l.Material.LineListDrawMode, 0, 24);\n            }\n          }\n\n          this._colorShader.unbind(), t.setDepthFunctionToLessOrEqual(), t.setDepthWrite(!0);\n        }\n      }, e.prototype.renderOcclusionBoundingBox = function (e) {\n        if (this._prepareRessources(), this._colorShader.isReady() && e._boundingInfo) {\n          var t = this.scene.getEngine();\n          t.setDepthWrite(!1), t.setColorWrite(!1), this._colorShader._preBind();\n          var i = e._boundingInfo.boundingBox,\n              r = i.minimum,\n              n = i.maximum.subtract(r),\n              o = r.add(n.scale(.5)),\n              s = l.Matrix.Scaling(n.x, n.y, n.z).multiply(l.Matrix.Translation(o.x, o.y, o.z)).multiply(i.getWorldMatrix());\n          t.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect()), t.setDepthFunctionToLess(), this.scene.resetCachedMaterial(), this._colorShader.bind(s), t.drawElementsType(l.Material.LineListDrawMode, 0, 24), this._colorShader.unbind(), t.setDepthFunctionToLessOrEqual(), t.setDepthWrite(!0), t.setColorWrite(!0);\n        }\n      }, e.prototype.dispose = function () {\n        if (this._colorShader) {\n          this.renderList.dispose(), this._colorShader.dispose();\n          var e = this._vertexBuffers[l.VertexBuffer.PositionKind];\n          e && (e.dispose(), this._vertexBuffers[l.VertexBuffer.PositionKind] = null), this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n        }\n      }, e;\n    }();\n\n    l.BoundingBoxRenderer = e;\n  }($a || ($a = {})), (hi = $a || ($a = {})).Engine.prototype.createTransformFeedback = function () {\n    return this._gl.createTransformFeedback();\n  }, hi.Engine.prototype.deleteTransformFeedback = function (e) {\n    this._gl.deleteTransformFeedback(e);\n  }, hi.Engine.prototype.bindTransformFeedback = function (e) {\n    this._gl.bindTransformFeedback(this._gl.TRANSFORM_FEEDBACK, e);\n  }, hi.Engine.prototype.beginTransformFeedback = function (e) {\n    void 0 === e && (e = !0), this._gl.beginTransformFeedback(e ? this._gl.POINTS : this._gl.TRIANGLES);\n  }, hi.Engine.prototype.endTransformFeedback = function () {\n    this._gl.endTransformFeedback();\n  }, hi.Engine.prototype.setTranformFeedbackVaryings = function (e, t) {\n    this._gl.transformFeedbackVaryings(e, t, this._gl.INTERLEAVED_ATTRIBS);\n  }, hi.Engine.prototype.bindTransformFeedbackBuffer = function (e) {\n    this._gl.bindBufferBase(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, e);\n  }, ui = $a || ($a = {}), di = function (h) {\n    function o(e, t, i, r) {\n      void 0 === r && (r = !1);\n      var n = h.call(this, e) || this;\n      n.layerMask = 268435455, n._accumulatedCount = 0, n._targetIndex = 0, n._currentRenderId = -1, n._started = !1, n._stopped = !1, n._timeDelta = 0, n._attributesStrideSize = 21, n._actualFrame = 0, n._rawTextureWidth = 256, n.onDisposeObservable = new ui.Observable(), n.forceDepthWrite = !1, n._preWarmDone = !1, n._scene = i || ui.Engine.LastCreatedScene, n._attachImageProcessingConfiguration(null), n._engine = n._scene.getEngine(), t.randomTextureSize || delete t.randomTextureSize;\n      var o = ae({\n        capacity: 5e4,\n        randomTextureSize: n._engine.getCaps().maxTextureSize\n      }, t),\n          s = t;\n      isFinite(s) && (o.capacity = s), n._capacity = o.capacity, n._activeCount = o.capacity, n._currentActiveCount = 0, n._isAnimationSheetEnabled = r, n._scene.particleSystems.push(n), n._updateEffectOptions = {\n        attributes: [\"position\", \"age\", \"life\", \"seed\", \"size\", \"color\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\", \"cellStartOffset\", \"noiseCoordinates1\", \"noiseCoordinates2\"],\n        uniformsNames: [\"currentCount\", \"timeDelta\", \"emitterWM\", \"lifeTime\", \"color1\", \"color2\", \"sizeRange\", \"scaleRange\", \"gravity\", \"emitPower\", \"direction1\", \"direction2\", \"minEmitBox\", \"maxEmitBox\", \"radius\", \"directionRandomizer\", \"height\", \"coneAngle\", \"stopFactor\", \"angleRange\", \"radiusRange\", \"cellInfos\", \"noiseStrength\", \"limitVelocityDamping\"],\n        uniformBuffersNames: [],\n        samplers: [\"randomSampler\", \"randomSampler2\", \"sizeGradientSampler\", \"angularSpeedGradientSampler\", \"velocityGradientSampler\", \"limitVelocityGradientSampler\", \"noiseSampler\", \"dragGradientSampler\"],\n        defines: \"\",\n        fallbacks: null,\n        onCompiled: null,\n        onError: null,\n        indexParameters: null,\n        maxSimultaneousLights: 0,\n        transformFeedbackVaryings: []\n      }, n.particleEmitterType = new ui.BoxParticleEmitter();\n\n      for (var a = Math.min(n._engine.getCaps().maxTextureSize, o.randomTextureSize), l = [], c = 0; c < a; ++c) l.push(Math.random()), l.push(Math.random()), l.push(Math.random()), l.push(Math.random());\n\n      n._randomTexture = new ui.RawTexture(new Float32Array(l), a, 1, ui.Engine.TEXTUREFORMAT_RGBA, n._scene, !1, !1, ui.Texture.NEAREST_SAMPLINGMODE, ui.Engine.TEXTURETYPE_FLOAT), n._randomTexture.wrapU = ui.Texture.WRAP_ADDRESSMODE, n._randomTexture.wrapV = ui.Texture.WRAP_ADDRESSMODE, l = [];\n\n      for (c = 0; c < a; ++c) l.push(Math.random()), l.push(Math.random()), l.push(Math.random()), l.push(Math.random());\n\n      return n._randomTexture2 = new ui.RawTexture(new Float32Array(l), a, 1, ui.Engine.TEXTUREFORMAT_RGBA, n._scene, !1, !1, ui.Texture.NEAREST_SAMPLINGMODE, ui.Engine.TEXTURETYPE_FLOAT), n._randomTexture2.wrapU = ui.Texture.WRAP_ADDRESSMODE, n._randomTexture2.wrapV = ui.Texture.WRAP_ADDRESSMODE, n._randomTextureSize = a, n;\n    }\n\n    return T(o, h), Object.defineProperty(o, \"IsSupported\", {\n      get: function () {\n        return !!ui.Engine.LastCreatedEngine && 1 < ui.Engine.LastCreatedEngine.webGLVersion;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), o.prototype.getCapacity = function () {\n      return this._capacity;\n    }, Object.defineProperty(o.prototype, \"activeParticleCount\", {\n      get: function () {\n        return this._activeCount;\n      },\n      set: function (e) {\n        this._activeCount = Math.min(e, this._capacity);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), o.prototype.isReady = function () {\n      return this._updateEffect ? !!(this.emitter && this._updateEffect.isReady() && this._imageProcessingConfiguration.isReady() && this._renderEffect.isReady() && this.particleTexture && this.particleTexture.isReady()) : (this._recreateUpdateEffect(), this._recreateRenderEffect(), !1);\n    }, o.prototype.isStarted = function () {\n      return this._started;\n    }, o.prototype.start = function (e) {\n      var t = this;\n      if (void 0 === e && (e = this.startDelay), !this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n      e ? setTimeout(function () {\n        t.start(0);\n      }, e) : (this._started = !0, this._stopped = !1, this._preWarmDone = !1, this.beginAnimationOnStart && this.animations && 0 < this.animations.length && this.getScene().beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop));\n    }, o.prototype.stop = function () {\n      this._stopped = !0;\n    }, o.prototype.reset = function () {\n      this._releaseBuffers(), this._releaseVAOs(), this._currentActiveCount = 0, this._targetIndex = 0;\n    }, o.prototype.getClassName = function () {\n      return \"GPUParticleSystem\";\n    }, o.prototype._removeGradientAndTexture = function (e, t, i) {\n      return h.prototype._removeGradientAndTexture.call(this, e, t, i), this._releaseBuffers(), this;\n    }, o.prototype.addColorGradient = function (e, t, i) {\n      this._colorGradients || (this._colorGradients = []);\n      var r = new ui.ColorGradient();\n      return r.gradient = e, r.color1 = t, this._colorGradients.push(r), this._colorGradients.sort(function (e, t) {\n        return e.gradient < t.gradient ? -1 : e.gradient > t.gradient ? 1 : 0;\n      }), this._colorGradientsTexture && (this._colorGradientsTexture.dispose(), this._colorGradientsTexture = null), this._releaseBuffers(), this;\n    }, o.prototype.removeColorGradient = function (e) {\n      return this._removeGradientAndTexture(e, this._colorGradients, this._colorGradientsTexture), this._colorGradientsTexture = null, this;\n    }, o.prototype._addFactorGradient = function (e, t, i) {\n      var r = new ui.FactorGradient();\n      r.gradient = t, r.factor1 = i, e.push(r), e.sort(function (e, t) {\n        return e.gradient < t.gradient ? -1 : e.gradient > t.gradient ? 1 : 0;\n      }), this._releaseBuffers();\n    }, o.prototype.addSizeGradient = function (e, t) {\n      return this._sizeGradients || (this._sizeGradients = []), this._addFactorGradient(this._sizeGradients, e, t), this._sizeGradientsTexture && (this._sizeGradientsTexture.dispose(), this._sizeGradientsTexture = null), this._releaseBuffers(), this;\n    }, o.prototype.removeSizeGradient = function (e) {\n      return this._removeGradientAndTexture(e, this._sizeGradients, this._sizeGradientsTexture), this._sizeGradientsTexture = null, this;\n    }, o.prototype.addAngularSpeedGradient = function (e, t) {\n      return this._angularSpeedGradients || (this._angularSpeedGradients = []), this._addFactorGradient(this._angularSpeedGradients, e, t), this._angularSpeedGradientsTexture && (this._angularSpeedGradientsTexture.dispose(), this._angularSpeedGradientsTexture = null), this._releaseBuffers(), this;\n    }, o.prototype.removeAngularSpeedGradient = function (e) {\n      return this._removeGradientAndTexture(e, this._angularSpeedGradients, this._angularSpeedGradientsTexture), this._angularSpeedGradientsTexture = null, this;\n    }, o.prototype.addVelocityGradient = function (e, t) {\n      return this._velocityGradients || (this._velocityGradients = []), this._addFactorGradient(this._velocityGradients, e, t), this._velocityGradientsTexture && (this._velocityGradientsTexture.dispose(), this._velocityGradientsTexture = null), this._releaseBuffers(), this;\n    }, o.prototype.removeVelocityGradient = function (e) {\n      return this._removeGradientAndTexture(e, this._velocityGradients, this._velocityGradientsTexture), this._velocityGradientsTexture = null, this;\n    }, o.prototype.addLimitVelocityGradient = function (e, t) {\n      return this._limitVelocityGradients || (this._limitVelocityGradients = []), this._addFactorGradient(this._limitVelocityGradients, e, t), this._limitVelocityGradientsTexture && (this._limitVelocityGradientsTexture.dispose(), this._limitVelocityGradientsTexture = null), this._releaseBuffers(), this;\n    }, o.prototype.removeLimitVelocityGradient = function (e) {\n      return this._removeGradientAndTexture(e, this._limitVelocityGradients, this._limitVelocityGradientsTexture), this._limitVelocityGradientsTexture = null, this;\n    }, o.prototype.addDragGradient = function (e, t) {\n      return this._dragGradients || (this._dragGradients = []), this._addFactorGradient(this._dragGradients, e, t), this._dragGradientsTexture && (this._dragGradientsTexture.dispose(), this._dragGradientsTexture = null), this._releaseBuffers(), this;\n    }, o.prototype.removeDragGradient = function (e) {\n      return this._removeGradientAndTexture(e, this._dragGradients, this._dragGradientsTexture), this._dragGradientsTexture = null, this;\n    }, o.prototype.addEmitRateGradient = function (e, t, i) {\n      return this;\n    }, o.prototype.removeEmitRateGradient = function (e) {\n      return this;\n    }, o.prototype.addStartSizeGradient = function (e, t, i) {\n      return this;\n    }, o.prototype.removeStartSizeGradient = function (e) {\n      return this;\n    }, o.prototype.addColorRemapGradient = function (e, t, i) {\n      return this;\n    }, o.prototype.removeColorRemapGradient = function (e) {\n      return this;\n    }, o.prototype.addAlphaRemapGradient = function (e, t, i) {\n      return this;\n    }, o.prototype.removeAlphaRemapGradient = function (e) {\n      return this;\n    }, o.prototype.addRampGradient = function (e, t) {\n      return this;\n    }, o.prototype.removeRampGradient = function (e) {\n      return this;\n    }, o.prototype.getRampGradients = function () {\n      return null;\n    }, Object.defineProperty(o.prototype, \"useRampGradients\", {\n      get: function () {\n        return !1;\n      },\n      set: function (e) {},\n      enumerable: !0,\n      configurable: !0\n    }), o.prototype.addLifeTimeGradient = function (e, t, i) {\n      return this;\n    }, o.prototype.removeLifeTimeGradient = function (e) {\n      return this;\n    }, o.prototype._reset = function () {\n      this._releaseBuffers();\n    }, o.prototype._createUpdateVAO = function (e) {\n      var t = {};\n      t.position = e.createVertexBuffer(\"position\", 0, 3), t.age = e.createVertexBuffer(\"age\", 3, 1), t.life = e.createVertexBuffer(\"life\", 4, 1), t.seed = e.createVertexBuffer(\"seed\", 5, 4), t.size = e.createVertexBuffer(\"size\", 9, 3);\n      var i = 12;\n      this._colorGradientsTexture || (t.color = e.createVertexBuffer(\"color\", i, 4), i += 4), t.direction = e.createVertexBuffer(\"direction\", i, 3), i += 3, this._isBillboardBased || (t.initialDirection = e.createVertexBuffer(\"initialDirection\", i, 3), i += 3), this._angularSpeedGradientsTexture ? (t.angle = e.createVertexBuffer(\"angle\", i, 1), i += 1) : (t.angle = e.createVertexBuffer(\"angle\", i, 2), i += 2), this._isAnimationSheetEnabled && (t.cellIndex = e.createVertexBuffer(\"cellIndex\", i, 1), i += 1, this.spriteRandomStartCell && (t.cellStartOffset = e.createVertexBuffer(\"cellStartOffset\", i, 1), i += 1)), this.noiseTexture && (t.noiseCoordinates1 = e.createVertexBuffer(\"noiseCoordinates1\", i, 3), i += 3, t.noiseCoordinates2 = e.createVertexBuffer(\"noiseCoordinates2\", i, 3), i += 3);\n\n      var r = this._engine.recordVertexArrayObject(t, null, this._updateEffect);\n\n      return this._engine.bindArrayBuffer(null), r;\n    }, o.prototype._createRenderVAO = function (e, t) {\n      var i = {};\n      i.position = e.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, !0), i.age = e.createVertexBuffer(\"age\", 3, 1, this._attributesStrideSize, !0), i.life = e.createVertexBuffer(\"life\", 4, 1, this._attributesStrideSize, !0), i.size = e.createVertexBuffer(\"size\", 9, 3, this._attributesStrideSize, !0);\n      var r = 12;\n      this._colorGradientsTexture || (i.color = e.createVertexBuffer(\"color\", r, 4, this._attributesStrideSize, !0), r += 4), this.billboardMode === ui.ParticleSystem.BILLBOARDMODE_STRETCHED && (i.direction = e.createVertexBuffer(\"direction\", r, 3, this._attributesStrideSize, !0)), r += 3, this._isBillboardBased || (i.initialDirection = e.createVertexBuffer(\"initialDirection\", r, 3, this._attributesStrideSize, !0), r += 3), i.angle = e.createVertexBuffer(\"angle\", r, 1, this._attributesStrideSize, !0), this._angularSpeedGradientsTexture ? r++ : r += 2, this._isAnimationSheetEnabled && (i.cellIndex = e.createVertexBuffer(\"cellIndex\", r, 1, this._attributesStrideSize, !0), r += 1, this.spriteRandomStartCell && (i.cellStartOffset = e.createVertexBuffer(\"cellStartOffset\", r, 1, this._attributesStrideSize, !0), r += 1)), this.noiseTexture && (i.noiseCoordinates1 = e.createVertexBuffer(\"noiseCoordinates1\", r, 3, this._attributesStrideSize, !0), r += 3, i.noiseCoordinates2 = e.createVertexBuffer(\"noiseCoordinates2\", r, 3, this._attributesStrideSize, !0), r += 3), i.offset = t.createVertexBuffer(\"offset\", 0, 2), i.uv = t.createVertexBuffer(\"uv\", 2, 2);\n\n      var n = this._engine.recordVertexArrayObject(i, null, this._renderEffect);\n\n      return this._engine.bindArrayBuffer(null), n;\n    }, o.prototype._initialize = function (e) {\n      if (void 0 === e && (e = !1), !this._buffer0 || e) {\n        var t = this._scene.getEngine(),\n            i = new Array();\n\n        this.isBillboardBased || (this._attributesStrideSize += 3), this._colorGradientsTexture && (this._attributesStrideSize -= 4), this._angularSpeedGradientsTexture && (this._attributesStrideSize -= 1), this._isAnimationSheetEnabled && (this._attributesStrideSize += 1, this.spriteRandomStartCell && (this._attributesStrideSize += 1)), this.noiseTexture && (this._attributesStrideSize += 6);\n\n        for (var r = 0; r < this._capacity; r++) i.push(0), i.push(0), i.push(0), i.push(0), i.push(0), i.push(Math.random()), i.push(Math.random()), i.push(Math.random()), i.push(Math.random()), i.push(0), i.push(0), i.push(0), this._colorGradientsTexture || (i.push(0), i.push(0), i.push(0), i.push(0)), i.push(0), i.push(0), i.push(0), this.isBillboardBased || (i.push(0), i.push(0), i.push(0)), i.push(0), this._angularSpeedGradientsTexture || i.push(0), this._isAnimationSheetEnabled && (i.push(0), this.spriteRandomStartCell && i.push(0)), this.noiseTexture && (i.push(Math.random()), i.push(Math.random()), i.push(Math.random()), i.push(Math.random()), i.push(Math.random()), i.push(Math.random()));\n\n        var n = new Float32Array([.5, .5, 1, 1, -.5, .5, 0, 1, -.5, -.5, 0, 0, .5, -.5, 1, 0]);\n        this._buffer0 = new ui.Buffer(t, i, !1, this._attributesStrideSize), this._buffer1 = new ui.Buffer(t, i, !1, this._attributesStrideSize), this._spriteBuffer = new ui.Buffer(t, n, !1, 4), this._updateVAO = [], this._updateVAO.push(this._createUpdateVAO(this._buffer0)), this._updateVAO.push(this._createUpdateVAO(this._buffer1)), this._renderVAO = [], this._renderVAO.push(this._createRenderVAO(this._buffer1, this._spriteBuffer)), this._renderVAO.push(this._createRenderVAO(this._buffer0, this._spriteBuffer)), this._sourceBuffer = this._buffer0, this._targetBuffer = this._buffer1;\n      }\n    }, o.prototype._recreateUpdateEffect = function () {\n      var e = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\n      this._isBillboardBased && (e += \"\\n#define BILLBOARD\"), this._colorGradientsTexture && (e += \"\\n#define COLORGRADIENTS\"), this._sizeGradientsTexture && (e += \"\\n#define SIZEGRADIENTS\"), this._angularSpeedGradientsTexture && (e += \"\\n#define ANGULARSPEEDGRADIENTS\"), this._velocityGradientsTexture && (e += \"\\n#define VELOCITYGRADIENTS\"), this._limitVelocityGradientsTexture && (e += \"\\n#define LIMITVELOCITYGRADIENTS\"), this._dragGradientsTexture && (e += \"\\n#define DRAGGRADIENTS\"), this.isAnimationSheetEnabled && (e += \"\\n#define ANIMATESHEET\", this.spriteRandomStartCell && (e += \"\\n#define ANIMATESHEETRANDOMSTART\")), this.noiseTexture && (e += \"\\n#define NOISE\"), this._updateEffect && this._updateEffectOptions.defines === e || (this._updateEffectOptions.transformFeedbackVaryings = [\"outPosition\", \"outAge\", \"outLife\", \"outSeed\", \"outSize\"], this._colorGradientsTexture || this._updateEffectOptions.transformFeedbackVaryings.push(\"outColor\"), this._updateEffectOptions.transformFeedbackVaryings.push(\"outDirection\"), this._isBillboardBased || this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialDirection\"), this._updateEffectOptions.transformFeedbackVaryings.push(\"outAngle\"), this.isAnimationSheetEnabled && (this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellIndex\"), this.spriteRandomStartCell && this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellStartOffset\")), this.noiseTexture && (this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates1\"), this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates2\")), this._updateEffectOptions.defines = e, this._updateEffect = new ui.Effect(\"gpuUpdateParticles\", this._updateEffectOptions, this._scene.getEngine()));\n    }, o.prototype._recreateRenderEffect = function () {\n      var e = \"\";\n      if (this._scene.clipPlane && (e = \"\\n#define CLIPPLANE\"), this._scene.clipPlane2 && (e = \"\\n#define CLIPPLANE2\"), this._scene.clipPlane3 && (e = \"\\n#define CLIPPLANE3\"), this._scene.clipPlane4 && (e = \"\\n#define CLIPPLANE4\"), this.blendMode === ui.ParticleSystem.BLENDMODE_MULTIPLY && (e = \"\\n#define BLENDMULTIPLYMODE\"), this._isBillboardBased) switch (e += \"\\n#define BILLBOARD\", this.billboardMode) {\n        case ui.ParticleSystem.BILLBOARDMODE_Y:\n          e += \"\\n#define BILLBOARDY\";\n          break;\n\n        case ui.ParticleSystem.BILLBOARDMODE_STRETCHED:\n          e += \"\\n#define BILLBOARDSTRETCHED\";\n          break;\n\n        case ui.ParticleSystem.BILLBOARDMODE_ALL:\n      }\n\n      if (this._colorGradientsTexture && (e += \"\\n#define COLORGRADIENTS\"), this.isAnimationSheetEnabled && (e += \"\\n#define ANIMATESHEET\"), this._imageProcessingConfiguration && (this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines), e += \"\\n\" + this._imageProcessingConfigurationDefines.toString()), !this._renderEffect || this._renderEffect.defines !== e) {\n        var t = [\"view\", \"projection\", \"colorDead\", \"invView\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"sheetInfos\", \"translationPivot\", \"eyePosition\"],\n            i = [\"textureSampler\", \"colorGradientSampler\"];\n        ui.ImageProcessingConfiguration && (ui.ImageProcessingConfiguration.PrepareUniforms(t, this._imageProcessingConfigurationDefines), ui.ImageProcessingConfiguration.PrepareSamplers(i, this._imageProcessingConfigurationDefines)), this._renderEffect = new ui.Effect(\"gpuRenderParticles\", [\"position\", \"age\", \"life\", \"size\", \"color\", \"offset\", \"uv\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\"], t, i, this._scene.getEngine(), e);\n      }\n    }, o.prototype.animate = function (e) {\n      void 0 === e && (e = !1), this._timeDelta = this.updateSpeed * (e ? this.preWarmStepOffset : this._scene.getAnimationRatio()), this._actualFrame += this._timeDelta, this._stopped || this.targetStopDuration && this._actualFrame >= this.targetStopDuration && this.stop();\n    }, o.prototype._createFactorGradientTexture = function (e, t) {\n      var i = this[t];\n\n      if (e && e.length && !i) {\n        for (var r = new Float32Array(this._rawTextureWidth), n = 0; n < this._rawTextureWidth; n++) {\n          var o = n / this._rawTextureWidth;\n          ui.Tools.GetCurrentGradient(o, e, function (e, t, i) {\n            r[n] = ui.Scalar.Lerp(e.factor1, t.factor1, i);\n          });\n        }\n\n        this[t] = ui.RawTexture.CreateRTexture(r, this._rawTextureWidth, 1, this._scene, !1, !1, ui.Texture.NEAREST_SAMPLINGMODE);\n      }\n    }, o.prototype._createSizeGradientTexture = function () {\n      this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\n    }, o.prototype._createAngularSpeedGradientTexture = function () {\n      this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n    }, o.prototype._createVelocityGradientTexture = function () {\n      this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\n    }, o.prototype._createLimitVelocityGradientTexture = function () {\n      this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n    }, o.prototype._createDragGradientTexture = function () {\n      this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\n    }, o.prototype._createColorGradientTexture = function () {\n      if (this._colorGradients && this._colorGradients.length && !this._colorGradientsTexture) {\n        for (var r = new Uint8Array(4 * this._rawTextureWidth), n = ui.Tmp.Color4[0], o = 0; o < this._rawTextureWidth; o++) {\n          var e = o / this._rawTextureWidth;\n          ui.Tools.GetCurrentGradient(e, this._colorGradients, function (e, t, i) {\n            ui.Color4.LerpToRef(e.color1, t.color1, i, n), r[4 * o] = 255 * n.r, r[4 * o + 1] = 255 * n.g, r[4 * o + 2] = 255 * n.b, r[4 * o + 3] = 255 * n.a;\n          });\n        }\n\n        this._colorGradientsTexture = ui.RawTexture.CreateRGBATexture(r, this._rawTextureWidth, 1, this._scene, !1, !1, ui.Texture.NEAREST_SAMPLINGMODE);\n      }\n    }, o.prototype.render = function (e) {\n      if (void 0 === e && (e = !1), !this._started) return 0;\n      if (this._createColorGradientTexture(), this._createSizeGradientTexture(), this._createAngularSpeedGradientTexture(), this._createVelocityGradientTexture(), this._createLimitVelocityGradientTexture(), this._createDragGradientTexture(), this._recreateUpdateEffect(), this._recreateRenderEffect(), !this.isReady()) return 0;\n\n      if (!e) {\n        if (!this._preWarmDone && this.preWarmCycles) {\n          for (var t = 0; t < this.preWarmCycles; t++) this.animate(!0), this.render(!0);\n\n          this._preWarmDone = !0;\n        }\n\n        if (this._currentRenderId === this._scene.getRenderId()) return 0;\n        this._currentRenderId = this._scene.getRenderId();\n      }\n\n      if (this._initialize(), this._accumulatedCount += this.emitRate * this._timeDelta, 1 < this._accumulatedCount) {\n        var i = 0 | this._accumulatedCount;\n        this._accumulatedCount -= i, this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + i);\n      }\n\n      if (!this._currentActiveCount) return 0;\n      var r;\n\n      if (this._engine.enableEffect(this._updateEffect), this._engine.setState(!1), this._updateEffect.setFloat(\"currentCount\", this._currentActiveCount), this._updateEffect.setFloat(\"timeDelta\", this._timeDelta), this._updateEffect.setFloat(\"stopFactor\", this._stopped ? 0 : 1), this._updateEffect.setTexture(\"randomSampler\", this._randomTexture), this._updateEffect.setTexture(\"randomSampler2\", this._randomTexture2), this._updateEffect.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime), this._updateEffect.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower), this._colorGradientsTexture || (this._updateEffect.setDirectColor4(\"color1\", this.color1), this._updateEffect.setDirectColor4(\"color2\", this.color2)), this._updateEffect.setFloat2(\"sizeRange\", this.minSize, this.maxSize), this._updateEffect.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY), this._updateEffect.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation), this._updateEffect.setVector3(\"gravity\", this.gravity), this._sizeGradientsTexture && this._updateEffect.setTexture(\"sizeGradientSampler\", this._sizeGradientsTexture), this._angularSpeedGradientsTexture && this._updateEffect.setTexture(\"angularSpeedGradientSampler\", this._angularSpeedGradientsTexture), this._velocityGradientsTexture && this._updateEffect.setTexture(\"velocityGradientSampler\", this._velocityGradientsTexture), this._limitVelocityGradientsTexture && (this._updateEffect.setTexture(\"limitVelocityGradientSampler\", this._limitVelocityGradientsTexture), this._updateEffect.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping)), this._dragGradientsTexture && this._updateEffect.setTexture(\"dragGradientSampler\", this._dragGradientsTexture), this.particleEmitterType && this.particleEmitterType.applyToShader(this._updateEffect), this._isAnimationSheetEnabled && this._updateEffect.setFloat3(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed), this.noiseTexture && (this._updateEffect.setTexture(\"noiseSampler\", this.noiseTexture), this._updateEffect.setVector3(\"noiseStrength\", this.noiseStrength)), this.emitter.position) {\n        r = this.emitter.getWorldMatrix();\n      } else {\n        var n = this.emitter;\n        r = ui.Matrix.Translation(n.x, n.y, n.z);\n      }\n\n      if (this._updateEffect.setMatrix(\"emitterWM\", r), this._engine.bindVertexArrayObject(this._updateVAO[this._targetIndex], null), this._engine.bindTransformFeedbackBuffer(this._targetBuffer.getBuffer()), this._engine.setRasterizerState(!1), this._engine.beginTransformFeedback(!0), this._engine.drawArraysType(ui.Material.PointListDrawMode, 0, this._currentActiveCount), this._engine.endTransformFeedback(), this._engine.setRasterizerState(!0), this._engine.bindTransformFeedbackBuffer(null), !e) {\n        this._engine.enableEffect(this._renderEffect);\n\n        var o = this._scene.getViewMatrix();\n\n        if (this._renderEffect.setMatrix(\"view\", o), this._renderEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix()), this._renderEffect.setTexture(\"textureSampler\", this.particleTexture), this._renderEffect.setVector2(\"translationPivot\", this.translationPivot), this._colorGradientsTexture ? this._renderEffect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture) : this._renderEffect.setDirectColor4(\"colorDead\", this.colorDead), this._isAnimationSheetEnabled && this.particleTexture) {\n          var s = this.particleTexture.getBaseSize();\n\n          this._renderEffect.setFloat3(\"sheetInfos\", this.spriteCellWidth / s.width, this.spriteCellHeight / s.height, s.width / this.spriteCellWidth);\n        }\n\n        if (this._isBillboardBased) {\n          var a = this._scene.activeCamera;\n\n          this._renderEffect.setVector3(\"eyePosition\", a.globalPosition);\n        }\n\n        if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4) {\n          var l = o.clone();\n          l.invert(), this._renderEffect.setMatrix(\"invView\", l), ui.MaterialHelper.BindClipPlane(this._renderEffect, this._scene);\n        }\n\n        switch (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._renderEffect), this.blendMode) {\n          case ui.ParticleSystem.BLENDMODE_ADD:\n            this._engine.setAlphaMode(ui.Engine.ALPHA_ADD);\n\n            break;\n\n          case ui.ParticleSystem.BLENDMODE_ONEONE:\n            this._engine.setAlphaMode(ui.Engine.ALPHA_ONEONE);\n\n            break;\n\n          case ui.ParticleSystem.BLENDMODE_STANDARD:\n            this._engine.setAlphaMode(ui.Engine.ALPHA_COMBINE);\n\n            break;\n\n          case ui.ParticleSystem.BLENDMODE_MULTIPLY:\n            this._engine.setAlphaMode(ui.Engine.ALPHA_MULTIPLY);\n\n        }\n\n        this.forceDepthWrite && this._engine.setDepthWrite(!0), this._engine.bindVertexArrayObject(this._renderVAO[this._targetIndex], null), this._engine.drawArraysType(ui.Material.TriangleFanDrawMode, 0, 4, this._currentActiveCount), this._engine.setAlphaMode(ui.Engine.ALPHA_DISABLE);\n      }\n\n      this._targetIndex++, 2 === this._targetIndex && (this._targetIndex = 0);\n      var c = this._sourceBuffer;\n      return this._sourceBuffer = this._targetBuffer, this._targetBuffer = c, this._currentActiveCount;\n    }, o.prototype.rebuild = function () {\n      this._initialize(!0);\n    }, o.prototype._releaseBuffers = function () {\n      this._buffer0 && (this._buffer0.dispose(), this._buffer0 = null), this._buffer1 && (this._buffer1.dispose(), this._buffer1 = null), this._spriteBuffer && (this._spriteBuffer.dispose(), this._spriteBuffer = null);\n    }, o.prototype._releaseVAOs = function () {\n      if (this._updateVAO) {\n        for (var e = 0; e < this._updateVAO.length; e++) this._engine.releaseVertexArrayObject(this._updateVAO[e]);\n\n        this._updateVAO = [];\n\n        for (e = 0; e < this._renderVAO.length; e++) this._engine.releaseVertexArrayObject(this._renderVAO[e]);\n\n        this._renderVAO = [];\n      }\n    }, o.prototype.dispose = function (e) {\n      void 0 === e && (e = !0);\n\n      var t = this._scene.particleSystems.indexOf(this);\n\n      -1 < t && this._scene.particleSystems.splice(t, 1), this._releaseBuffers(), this._releaseVAOs(), this._colorGradientsTexture && (this._colorGradientsTexture.dispose(), this._colorGradientsTexture = null), this._sizeGradientsTexture && (this._sizeGradientsTexture.dispose(), this._sizeGradientsTexture = null), this._angularSpeedGradientsTexture && (this._angularSpeedGradientsTexture.dispose(), this._angularSpeedGradientsTexture = null), this._velocityGradientsTexture && (this._velocityGradientsTexture.dispose(), this._velocityGradientsTexture = null), this._limitVelocityGradientsTexture && (this._limitVelocityGradientsTexture.dispose(), this._limitVelocityGradientsTexture = null), this._dragGradientsTexture && (this._dragGradientsTexture.dispose(), this._dragGradientsTexture = null), this._randomTexture && (this._randomTexture.dispose(), this._randomTexture = null), this._randomTexture2 && (this._randomTexture2.dispose(), this._randomTexture2 = null), e && this.particleTexture && (this.particleTexture.dispose(), this.particleTexture = null), e && this.noiseTexture && (this.noiseTexture.dispose(), this.noiseTexture = null), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear();\n    }, o.prototype.clone = function (e, t) {\n      var i = new o(e, {\n        capacity: this._capacity,\n        randomTextureSize: this._randomTextureSize\n      }, this._scene);\n      return ui.Tools.DeepCopy(this, i), void 0 === t && (t = this.emitter), i.emitter = t, this.particleTexture && (i.particleTexture = new ui.Texture(this.particleTexture.url, this._scene)), i;\n    }, o.prototype.serialize = function () {\n      var e = {};\n      return ui.ParticleSystem._Serialize(e, this), e.activeParticleCount = this.activeParticleCount, e;\n    }, o.Parse = function (e, t, i, r) {\n      void 0 === r && (r = !1);\n      var n = new o(e.name, {\n        capacity: e.capacity,\n        randomTextureSize: e.randomTextureSize\n      }, t);\n      return e.activeParticleCount && (n.activeParticleCount = e.activeParticleCount), ui.ParticleSystem._Parse(e, n, t, i), e.preventAutoStart && (n.preventAutoStart = e.preventAutoStart), r || n.preventAutoStart || n.start(), n;\n    }, o;\n  }(ui.BaseParticleSystem), ui.GPUParticleSystem = di, function (l) {\n    var e = function () {\n      function e(e, t, i, r, n, o, s, a) {\n        void 0 === a && (a = null), this.idx = 0, this.color = new l.Color4(1, 1, 1, 1), this.position = l.Vector3.Zero(), this.rotation = l.Vector3.Zero(), this.scaling = l.Vector3.One(), this.uvs = new l.Vector4(0, 0, 1, 1), this.velocity = l.Vector3.Zero(), this.pivot = l.Vector3.Zero(), this.translateFromPivot = !1, this.alive = !0, this.isVisible = !0, this._pos = 0, this._ind = 0, this.shapeId = 0, this.idxInShape = 0, this._stillInvisible = !1, this._rotationMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1], this.parentId = null, this._globalPosition = l.Vector3.Zero(), this.idx = e, this._pos = t, this._ind = i, this._model = r, this.shapeId = n, this.idxInShape = o, this._sps = s, a && (this._modelBoundingInfo = a, this._boundingInfo = new l.BoundingInfo(a.minimum, a.maximum));\n      }\n\n      return Object.defineProperty(e.prototype, \"scale\", {\n        get: function () {\n          return this.scaling;\n        },\n        set: function (e) {\n          this.scaling = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"quaternion\", {\n        get: function () {\n          return this.rotationQuaternion;\n        },\n        set: function (e) {\n          this.rotationQuaternion = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.intersectsMesh = function (e) {\n        return !(!this._boundingInfo || !e._boundingInfo) && (this._sps._bSphereOnly ? l.BoundingSphere.Intersects(this._boundingInfo.boundingSphere, e._boundingInfo.boundingSphere) : this._boundingInfo.intersects(e._boundingInfo, !1));\n      }, e;\n    }();\n\n    l.SolidParticle = e;\n\n    var t = function (e, t, i, r, n, o) {\n      this._indicesLength = 0, this.shapeID = e, this._shape = t, this._indicesLength = i, this._shapeUV = r, this._positionFunction = n, this._vertexFunction = o;\n    };\n\n    l.ModelShape = t;\n\n    var i = function () {\n      this.ind = 0, this.indicesLength = 0, this.sqDistance = 0;\n    };\n\n    l.DepthSortedParticle = i;\n  }($a || ($a = {})), fi = $a || ($a = {}), pi = function () {\n    function e(e, t, i) {\n      this.particles = new Array(), this.nbParticles = 0, this.billboard = !1, this.recomputeNormals = !0, this.counter = 0, this.vars = {}, this._bSphereOnly = !1, this._bSphereRadiusFactor = 1, this._positions = new Array(), this._indices = new Array(), this._normals = new Array(), this._colors = new Array(), this._uvs = new Array(), this._index = 0, this._updatable = !0, this._pickable = !1, this._isVisibilityBoxLocked = !1, this._alwaysVisible = !1, this._depthSort = !1, this._shapeCounter = 0, this._copy = new fi.SolidParticle(0, 0, 0, null, 0, 0, this), this._color = new fi.Color4(0, 0, 0, 0), this._computeParticleColor = !0, this._computeParticleTexture = !0, this._computeParticleRotation = !0, this._computeParticleVertex = !1, this._computeBoundingBox = !1, this._depthSortParticles = !0, this._cam_axisZ = fi.Vector3.Zero(), this._cam_axisY = fi.Vector3.Zero(), this._cam_axisX = fi.Vector3.Zero(), this._axisZ = fi.Axis.Z, this._camDir = fi.Vector3.Zero(), this._camInvertedPosition = fi.Vector3.Zero(), this._rotMatrix = new fi.Matrix(), this._invertMatrix = new fi.Matrix(), this._rotated = fi.Vector3.Zero(), this._quaternion = new fi.Quaternion(), this._vertex = fi.Vector3.Zero(), this._normal = fi.Vector3.Zero(), this._yaw = 0, this._pitch = 0, this._roll = 0, this._halfroll = 0, this._halfpitch = 0, this._halfyaw = 0, this._sinRoll = 0, this._cosRoll = 0, this._sinPitch = 0, this._cosPitch = 0, this._sinYaw = 0, this._cosYaw = 0, this._mustUnrotateFixedNormals = !1, this._minimum = fi.Vector3.Zero(), this._maximum = fi.Vector3.Zero(), this._minBbox = fi.Vector3.Zero(), this._maxBbox = fi.Vector3.Zero(), this._particlesIntersect = !1, this._depthSortFunction = function (e, t) {\n        return t.sqDistance - e.sqDistance;\n      }, this._needs32Bits = !1, this._pivotBackTranslation = fi.Vector3.Zero(), this._scaledPivot = fi.Vector3.Zero(), this._particleHasParent = !1, this.name = e, this._scene = t || fi.Engine.LastCreatedScene, this._camera = t.activeCamera, this._pickable = !!i && i.isPickable, this._depthSort = !!i && i.enableDepthSort, this._particlesIntersect = !!i && i.particleIntersection, this._bSphereOnly = !!i && i.boundingSphereOnly, this._bSphereRadiusFactor = i && i.bSphereRadiusFactor ? i.bSphereRadiusFactor : 1, i && void 0 !== i.updatable ? this._updatable = i.updatable : this._updatable = !0, this._pickable && (this.pickedParticles = []), this._depthSort && (this.depthSortedParticles = []);\n    }\n\n    return e.prototype.buildMesh = function () {\n      if (0 === this.nbParticles) {\n        var e = fi.MeshBuilder.CreateDisc(\"\", {\n          radius: 1,\n          tessellation: 3\n        }, this._scene);\n        this.addShape(e, 1), e.dispose();\n      }\n\n      this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices), this._positions32 = new Float32Array(this._positions), this._uvs32 = new Float32Array(this._uvs), this._colors32 = new Float32Array(this._colors), this.recomputeNormals && fi.VertexData.ComputeNormals(this._positions32, this._indices32, this._normals), this._normals32 = new Float32Array(this._normals), this._fixedNormal32 = new Float32Array(this._normals), this._mustUnrotateFixedNormals && this._unrotateFixedNormals();\n      var t = new fi.VertexData();\n      t.indices = this._depthSort ? this._indices : this._indices32, t.set(this._positions32, fi.VertexBuffer.PositionKind), t.set(this._normals32, fi.VertexBuffer.NormalKind), 0 < this._uvs32.length && t.set(this._uvs32, fi.VertexBuffer.UVKind), 0 < this._colors32.length && t.set(this._colors32, fi.VertexBuffer.ColorKind);\n      var i = new fi.Mesh(this.name, this._scene);\n      return t.applyToMesh(i, this._updatable), this.mesh = i, this.mesh.isPickable = this._pickable, this._depthSort || (this._indices = null), this._positions = null, this._normals = null, this._uvs = null, this._colors = null, this._updatable || (this.particles.length = 0), i;\n    }, e.prototype.digest = function (e, t) {\n      var i = t && t.facetNb || 1,\n          r = t && t.number || 0,\n          n = t && t.delta || 0,\n          o = e.getVerticesData(fi.VertexBuffer.PositionKind),\n          s = e.getIndices(),\n          a = e.getVerticesData(fi.VertexBuffer.UVKind),\n          l = e.getVerticesData(fi.VertexBuffer.ColorKind),\n          c = e.getVerticesData(fi.VertexBuffer.NormalKind),\n          h = 0,\n          u = s.length / 3;\n      r ? (r = u < r ? u : r, i = Math.round(u / r), n = 0) : i = u < i ? u : i;\n\n      for (var d = [], f = [], p = [], _ = [], m = fi.Vector3.Zero(), g = i; h < u;) {\n        u - (i = g + Math.floor((1 + n) * Math.random())) < h && (i = u - h), d.length = 0, f.length = 0, p.length = 0;\n\n        for (var v = _.length = 0, y = 3 * h; y < 3 * (h + i); y++) {\n          f.push(v);\n          var b = s[y];\n          d.push(o[3 * b], o[3 * b + 1], o[3 * b + 2]), a && p.push(a[2 * b], a[2 * b + 1]), l && _.push(l[4 * b], l[4 * b + 1], l[4 * b + 2], l[4 * b + 3]), v++;\n        }\n\n        var T,\n            E,\n            x = this.nbParticles,\n            P = this._posToShape(d),\n            A = this._uvsToShapeUV(p);\n\n        for (T = 0; T < P.length; T++) m.addInPlace(P[T]);\n\n        for (m.scaleInPlace(1 / P.length), T = 0; T < P.length; T++) P[T].subtractInPlace(m);\n\n        this._particlesIntersect && (E = new fi.BoundingInfo(m, m));\n        var S = new fi.ModelShape(this._shapeCounter, P, 3 * i, A, null, null),\n            M = this._positions.length,\n            R = this._indices.length;\n        this._meshBuilder(this._index, P, this._positions, f, this._indices, p, this._uvs, _, this._colors, c, this._normals, x, 0, null), this._addParticle(x, M, R, S, this._shapeCounter, 0, E), this.particles[this.nbParticles].position.addInPlace(m), this._index += P.length, x++, this.nbParticles++, this._shapeCounter++, h += i;\n      }\n\n      return this;\n    }, e.prototype._unrotateFixedNormals = function () {\n      for (var e = 0, t = 0, i = 0; i < this.particles.length; i++) {\n        this._particle = this.particles[i], this._shape = this._particle._model._shape, this._particle.rotationQuaternion ? this._quaternion.copyFrom(this._particle.rotationQuaternion) : (this._yaw = this._particle.rotation.y, this._pitch = this._particle.rotation.x, this._roll = this._particle.rotation.z, this._quaternionRotationYPR()), this._quaternionToRotationMatrix(), this._rotMatrix.invertToRef(this._invertMatrix);\n\n        for (var r = 0; r < this._shape.length; r++) t = e + 3 * r, fi.Vector3.TransformNormalFromFloatsToRef(this._normals32[t], this._normals32[t + 1], this._normals32[t + 2], this._invertMatrix, this._normal), this._fixedNormal32[t] = this._normal.x, this._fixedNormal32[t + 1] = this._normal.y, this._fixedNormal32[t + 2] = this._normal.z;\n\n        e = t + 3;\n      }\n    }, e.prototype._resetCopy = function () {\n      this._copy.position.x = 0, this._copy.position.y = 0, this._copy.position.z = 0, this._copy.rotation.x = 0, this._copy.rotation.y = 0, this._copy.rotation.z = 0, this._copy.rotationQuaternion = null, this._copy.scaling.x = 1, this._copy.scaling.y = 1, this._copy.scaling.z = 1, this._copy.uvs.x = 0, this._copy.uvs.y = 0, this._copy.uvs.z = 1, this._copy.uvs.w = 1, this._copy.color = null, this._copy.translateFromPivot = !1;\n    }, e.prototype._meshBuilder = function (e, t, i, r, n, o, s, a, l, c, h, u, d, f) {\n      var p,\n          _ = 0,\n          m = 0,\n          g = 0;\n\n      for (this._resetCopy(), f && f.positionFunction && (f.positionFunction(this._copy, u, d), this._mustUnrotateFixedNormals = !0), this._copy.rotationQuaternion ? this._quaternion.copyFrom(this._copy.rotationQuaternion) : (this._yaw = this._copy.rotation.y, this._pitch = this._copy.rotation.x, this._roll = this._copy.rotation.z, this._quaternionRotationYPR()), this._quaternionToRotationMatrix(), this._scaledPivot.x = this._copy.pivot.x * this._copy.scaling.x, this._scaledPivot.y = this._copy.pivot.y * this._copy.scaling.y, this._scaledPivot.z = this._copy.pivot.z * this._copy.scaling.z, this._copy.translateFromPivot ? this._pivotBackTranslation.copyFromFloats(0, 0, 0) : this._pivotBackTranslation.copyFrom(this._scaledPivot), p = 0; p < t.length; p++) this._vertex.x = t[p].x, this._vertex.y = t[p].y, this._vertex.z = t[p].z, f && f.vertexFunction && f.vertexFunction(this._copy, this._vertex, p), this._vertex.x *= this._copy.scaling.x, this._vertex.y *= this._copy.scaling.y, this._vertex.z *= this._copy.scaling.z, this._vertex.x -= this._scaledPivot.x, this._vertex.y -= this._scaledPivot.y, this._vertex.z -= this._scaledPivot.z, fi.Vector3.TransformCoordinatesToRef(this._vertex, this._rotMatrix, this._rotated), this._rotated.addInPlace(this._pivotBackTranslation), i.push(this._copy.position.x + this._rotated.x, this._copy.position.y + this._rotated.y, this._copy.position.z + this._rotated.z), o && (s.push((this._copy.uvs.z - this._copy.uvs.x) * o[_] + this._copy.uvs.x, (this._copy.uvs.w - this._copy.uvs.y) * o[_ + 1] + this._copy.uvs.y), _ += 2), this._copy.color ? this._color = this._copy.color : a && void 0 !== a[m] ? (this._color.r = a[m], this._color.g = a[m + 1], this._color.b = a[m + 2], this._color.a = a[m + 3]) : (this._color.r = 1, this._color.g = 1, this._color.b = 1, this._color.a = 1), l.push(this._color.r, this._color.g, this._color.b, this._color.a), m += 4, !this.recomputeNormals && c && (this._normal.x = c[g], this._normal.y = c[g + 1], this._normal.z = c[g + 2], fi.Vector3.TransformNormalToRef(this._normal, this._rotMatrix, this._normal), h.push(this._normal.x, this._normal.y, this._normal.z), g += 3);\n\n      for (p = 0; p < r.length; p++) {\n        var v = e + r[p];\n        n.push(v), 65535 < v && (this._needs32Bits = !0);\n      }\n\n      if (this._pickable) {\n        var y = r.length / 3;\n\n        for (p = 0; p < y; p++) this.pickedParticles.push({\n          idx: u,\n          faceId: p\n        });\n      }\n\n      return this._depthSort && this.depthSortedParticles.push(new fi.DepthSortedParticle()), this._copy;\n    }, e.prototype._posToShape = function (e) {\n      for (var t = [], i = 0; i < e.length; i += 3) t.push(new fi.Vector3(e[i], e[i + 1], e[i + 2]));\n\n      return t;\n    }, e.prototype._uvsToShapeUV = function (e) {\n      var t = [];\n      if (e) for (var i = 0; i < e.length; i++) t.push(e[i]);\n      return t;\n    }, e.prototype._addParticle = function (e, t, i, r, n, o, s) {\n      void 0 === s && (s = null);\n      var a = new fi.SolidParticle(e, t, i, r, n, o, this, s);\n      return this.particles.push(a), a;\n    }, e.prototype.addShape = function (e, t, i) {\n      var r,\n          n = e.getVerticesData(fi.VertexBuffer.PositionKind),\n          o = e.getIndices(),\n          s = e.getVerticesData(fi.VertexBuffer.UVKind),\n          a = e.getVerticesData(fi.VertexBuffer.ColorKind),\n          l = e.getVerticesData(fi.VertexBuffer.NormalKind);\n      this._particlesIntersect && (r = e.getBoundingInfo());\n\n      for (var c, h, u = this._posToShape(n), d = this._uvsToShapeUV(s), f = i ? i.positionFunction : null, p = i ? i.vertexFunction : null, _ = new fi.ModelShape(this._shapeCounter, u, o.length, d, f, p), m = this.nbParticles, g = 0; g < t; g++) {\n        var v = this._positions.length,\n            y = this._indices.length;\n        h = this._meshBuilder(this._index, u, this._positions, o, this._indices, s, this._uvs, a, this._colors, l, this._normals, m, g, i), this._updatable && ((c = this._addParticle(m, v, y, _, this._shapeCounter, g, r)).position.copyFrom(h.position), c.rotation.copyFrom(h.rotation), h.rotationQuaternion && c.rotationQuaternion && c.rotationQuaternion.copyFrom(h.rotationQuaternion), h.color && c.color && c.color.copyFrom(h.color), c.scaling.copyFrom(h.scaling), c.uvs.copyFrom(h.uvs)), this._index += u.length, m++;\n      }\n\n      return this.nbParticles += t, this._shapeCounter++, this._shapeCounter - 1;\n    }, e.prototype._rebuildParticle = function (e) {\n      this._resetCopy(), e._model._positionFunction && e._model._positionFunction(this._copy, e.idx, e.idxInShape), this._copy.rotationQuaternion ? this._quaternion.copyFrom(this._copy.rotationQuaternion) : (this._yaw = this._copy.rotation.y, this._pitch = this._copy.rotation.x, this._roll = this._copy.rotation.z, this._quaternionRotationYPR()), this._quaternionToRotationMatrix(), this._scaledPivot.x = this._particle.pivot.x * this._particle.scaling.x, this._scaledPivot.y = this._particle.pivot.y * this._particle.scaling.y, this._scaledPivot.z = this._particle.pivot.z * this._particle.scaling.z, this._copy.translateFromPivot ? this._pivotBackTranslation.copyFromFloats(0, 0, 0) : this._pivotBackTranslation.copyFrom(this._scaledPivot), this._shape = e._model._shape;\n\n      for (var t = 0; t < this._shape.length; t++) this._vertex.x = this._shape[t].x, this._vertex.y = this._shape[t].y, this._vertex.z = this._shape[t].z, e._model._vertexFunction && e._model._vertexFunction(this._copy, this._vertex, t), this._vertex.x *= this._copy.scaling.x, this._vertex.y *= this._copy.scaling.y, this._vertex.z *= this._copy.scaling.z, this._vertex.x -= this._scaledPivot.x, this._vertex.y -= this._scaledPivot.y, this._vertex.z -= this._scaledPivot.z, fi.Vector3.TransformCoordinatesToRef(this._vertex, this._rotMatrix, this._rotated), this._rotated.addInPlace(this._pivotBackTranslation), this._positions32[e._pos + 3 * t] = this._copy.position.x + this._rotated.x, this._positions32[e._pos + 3 * t + 1] = this._copy.position.y + this._rotated.y, this._positions32[e._pos + 3 * t + 2] = this._copy.position.z + this._rotated.z;\n\n      e.position.x = 0, e.position.y = 0, e.position.z = 0, e.rotation.x = 0, e.rotation.y = 0, e.rotation.z = 0, e.rotationQuaternion = null, e.scaling.x = 1, e.scaling.y = 1, e.scaling.z = 1, e.uvs.x = 0, e.uvs.y = 0, e.uvs.z = 1, e.uvs.w = 1, e.pivot.x = 0, e.pivot.y = 0, e.pivot.z = 0, e.translateFromPivot = !1, e.parentId = null;\n    }, e.prototype.rebuildMesh = function () {\n      for (var e = 0; e < this.particles.length; e++) this._rebuildParticle(this.particles[e]);\n\n      return this.mesh.updateVerticesData(fi.VertexBuffer.PositionKind, this._positions32, !1, !1), this;\n    }, e.prototype.setParticles = function (e, t, i) {\n      if (void 0 === e && (e = 0), void 0 === t && (t = this.nbParticles - 1), void 0 === i && (i = !0), !this._updatable) return this;\n\n      if (this.beforeUpdateParticles(e, t, i), this._cam_axisX.x = 1, this._cam_axisX.y = 0, this._cam_axisX.z = 0, this._cam_axisY.x = 0, this._cam_axisY.y = 1, this._cam_axisY.z = 0, this._cam_axisZ.x = 0, this._cam_axisZ.y = 0, this._cam_axisZ.z = 1, (this.billboard || this._depthSort) && (this.mesh.computeWorldMatrix(!0), this.mesh._worldMatrix.invertToRef(this._invertMatrix)), this.billboard) {\n        this._camera.getDirectionToRef(this._axisZ, this._camDir), fi.Vector3.TransformNormalToRef(this._camDir, this._invertMatrix, this._cam_axisZ), this._cam_axisZ.normalize();\n\n        var r = this._camera.getViewMatrix(!0);\n\n        fi.Vector3.TransformNormalFromFloatsToRef(r.m[1], r.m[5], r.m[9], this._invertMatrix, this._cam_axisY), fi.Vector3.CrossToRef(this._cam_axisY, this._cam_axisZ, this._cam_axisX), this._cam_axisY.normalize(), this._cam_axisX.normalize();\n      }\n\n      this._depthSort && fi.Vector3.TransformCoordinatesToRef(this._camera.globalPosition, this._invertMatrix, this._camInvertedPosition), fi.Matrix.IdentityToRef(this._rotMatrix);\n      var n = 0,\n          o = 0,\n          s = 0,\n          a = 0,\n          l = 0,\n          c = 0,\n          h = 0;\n      this.mesh.isFacetDataEnabled && (this._computeBoundingBox = !0), t = t >= this.nbParticles ? this.nbParticles - 1 : t, this._computeBoundingBox && (0 == e && t == this.nbParticles - 1 ? (fi.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this._minimum), fi.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this._maximum)) : this.mesh._boundingInfo && (this._minimum.copyFrom(this.mesh._boundingInfo.boundingBox.minimum), this._maximum.copyFrom(this.mesh._boundingInfo.boundingBox.maximum)));\n      var u = (o = this.particles[e]._pos) / 3 | 0;\n      a = 4 * u, c = 2 * u;\n\n      for (var d = e; d <= t; d++) {\n        if (this._particle = this.particles[d], this._shape = this._particle._model._shape, this._shapeUV = this._particle._model._shapeUV, this.updateParticle(this._particle), this._depthSort && this._depthSortParticles) {\n          var f = this.depthSortedParticles[d];\n          f.ind = this._particle._ind, f.indicesLength = this._particle._model._indicesLength, f.sqDistance = fi.Vector3.DistanceSquared(this._particle.position, this._camInvertedPosition);\n        }\n\n        if (!this._particle.alive || this._particle._stillInvisible && !this._particle.isVisible) o += 3 * (h = this._shape.length), a += 4 * h, c += 2 * h;else {\n          if (this._particle.isVisible) for (this._particle._stillInvisible = !1, this._particleHasParent = null !== this._particle.parentId, this._scaledPivot.x = this._particle.pivot.x * this._particle.scaling.x, this._scaledPivot.y = this._particle.pivot.y * this._particle.scaling.y, this._scaledPivot.z = this._particle.pivot.z * this._particle.scaling.z, this.billboard && (this._particle.rotation.x = 0, this._particle.rotation.y = 0), (this._computeParticleRotation || this.billboard) && (this._particle.rotationQuaternion ? this._quaternion.copyFrom(this._particle.rotationQuaternion) : (this._yaw = this._particle.rotation.y, this._pitch = this._particle.rotation.x, this._roll = this._particle.rotation.z, this._quaternionRotationYPR()), this._quaternionToRotationMatrix()), this._particleHasParent ? (this._parent = this.particles[this._particle.parentId], this._rotated.x = this._particle.position.x * this._parent._rotationMatrix[0] + this._particle.position.y * this._parent._rotationMatrix[3] + this._particle.position.z * this._parent._rotationMatrix[6], this._rotated.y = this._particle.position.x * this._parent._rotationMatrix[1] + this._particle.position.y * this._parent._rotationMatrix[4] + this._particle.position.z * this._parent._rotationMatrix[7], this._rotated.z = this._particle.position.x * this._parent._rotationMatrix[2] + this._particle.position.y * this._parent._rotationMatrix[5] + this._particle.position.z * this._parent._rotationMatrix[8], this._particle._globalPosition.x = this._parent._globalPosition.x + this._rotated.x, this._particle._globalPosition.y = this._parent._globalPosition.y + this._rotated.y, this._particle._globalPosition.z = this._parent._globalPosition.z + this._rotated.z, (this._computeParticleRotation || this.billboard) && (this._particle._rotationMatrix[0] = this._rotMatrix.m[0] * this._parent._rotationMatrix[0] + this._rotMatrix.m[1] * this._parent._rotationMatrix[3] + this._rotMatrix.m[2] * this._parent._rotationMatrix[6], this._particle._rotationMatrix[1] = this._rotMatrix.m[0] * this._parent._rotationMatrix[1] + this._rotMatrix.m[1] * this._parent._rotationMatrix[4] + this._rotMatrix.m[2] * this._parent._rotationMatrix[7], this._particle._rotationMatrix[2] = this._rotMatrix.m[0] * this._parent._rotationMatrix[2] + this._rotMatrix.m[1] * this._parent._rotationMatrix[5] + this._rotMatrix.m[2] * this._parent._rotationMatrix[8], this._particle._rotationMatrix[3] = this._rotMatrix.m[4] * this._parent._rotationMatrix[0] + this._rotMatrix.m[5] * this._parent._rotationMatrix[3] + this._rotMatrix.m[6] * this._parent._rotationMatrix[6], this._particle._rotationMatrix[4] = this._rotMatrix.m[4] * this._parent._rotationMatrix[1] + this._rotMatrix.m[5] * this._parent._rotationMatrix[4] + this._rotMatrix.m[6] * this._parent._rotationMatrix[7], this._particle._rotationMatrix[5] = this._rotMatrix.m[4] * this._parent._rotationMatrix[2] + this._rotMatrix.m[5] * this._parent._rotationMatrix[5] + this._rotMatrix.m[6] * this._parent._rotationMatrix[8], this._particle._rotationMatrix[6] = this._rotMatrix.m[8] * this._parent._rotationMatrix[0] + this._rotMatrix.m[9] * this._parent._rotationMatrix[3] + this._rotMatrix.m[10] * this._parent._rotationMatrix[6], this._particle._rotationMatrix[7] = this._rotMatrix.m[8] * this._parent._rotationMatrix[1] + this._rotMatrix.m[9] * this._parent._rotationMatrix[4] + this._rotMatrix.m[10] * this._parent._rotationMatrix[7], this._particle._rotationMatrix[8] = this._rotMatrix.m[8] * this._parent._rotationMatrix[2] + this._rotMatrix.m[9] * this._parent._rotationMatrix[5] + this._rotMatrix.m[10] * this._parent._rotationMatrix[8])) : (this._particle._globalPosition.x = this._particle.position.x, this._particle._globalPosition.y = this._particle.position.y, this._particle._globalPosition.z = this._particle.position.z, (this._computeParticleRotation || this.billboard) && (this._particle._rotationMatrix[0] = this._rotMatrix.m[0], this._particle._rotationMatrix[1] = this._rotMatrix.m[1], this._particle._rotationMatrix[2] = this._rotMatrix.m[2], this._particle._rotationMatrix[3] = this._rotMatrix.m[4], this._particle._rotationMatrix[4] = this._rotMatrix.m[5], this._particle._rotationMatrix[5] = this._rotMatrix.m[6], this._particle._rotationMatrix[6] = this._rotMatrix.m[8], this._particle._rotationMatrix[7] = this._rotMatrix.m[9], this._particle._rotationMatrix[8] = this._rotMatrix.m[10])), this._particle.translateFromPivot ? (this._pivotBackTranslation.x = 0, this._pivotBackTranslation.y = 0, this._pivotBackTranslation.z = 0) : (this._pivotBackTranslation.x = this._scaledPivot.x, this._pivotBackTranslation.y = this._scaledPivot.y, this._pivotBackTranslation.z = this._scaledPivot.z), h = 0; h < this._shape.length; h++) n = o + 3 * h, s = a + 4 * h, l = c + 2 * h, this._vertex.x = this._shape[h].x, this._vertex.y = this._shape[h].y, this._vertex.z = this._shape[h].z, this._computeParticleVertex && this.updateParticleVertex(this._particle, this._vertex, h), this._vertex.x *= this._particle.scaling.x, this._vertex.y *= this._particle.scaling.y, this._vertex.z *= this._particle.scaling.z, this._vertex.x -= this._scaledPivot.x, this._vertex.y -= this._scaledPivot.y, this._vertex.z -= this._scaledPivot.z, this._rotated.x = this._vertex.x * this._particle._rotationMatrix[0] + this._vertex.y * this._particle._rotationMatrix[3] + this._vertex.z * this._particle._rotationMatrix[6], this._rotated.y = this._vertex.x * this._particle._rotationMatrix[1] + this._vertex.y * this._particle._rotationMatrix[4] + this._vertex.z * this._particle._rotationMatrix[7], this._rotated.z = this._vertex.x * this._particle._rotationMatrix[2] + this._vertex.y * this._particle._rotationMatrix[5] + this._vertex.z * this._particle._rotationMatrix[8], this._rotated.x += this._pivotBackTranslation.x, this._rotated.y += this._pivotBackTranslation.y, this._rotated.z += this._pivotBackTranslation.z, this._positions32[n] = this._particle._globalPosition.x + this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z, this._positions32[n + 1] = this._particle._globalPosition.y + this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z, this._positions32[n + 2] = this._particle._globalPosition.z + this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z, this._computeBoundingBox && (this._positions32[n] < this._minimum.x && (this._minimum.x = this._positions32[n]), this._positions32[n] > this._maximum.x && (this._maximum.x = this._positions32[n]), this._positions32[n + 1] < this._minimum.y && (this._minimum.y = this._positions32[n + 1]), this._positions32[n + 1] > this._maximum.y && (this._maximum.y = this._positions32[n + 1]), this._positions32[n + 2] < this._minimum.z && (this._minimum.z = this._positions32[n + 2]), this._positions32[n + 2] > this._maximum.z && (this._maximum.z = this._positions32[n + 2])), this._computeParticleVertex || (this._normal.x = this._fixedNormal32[n], this._normal.y = this._fixedNormal32[n + 1], this._normal.z = this._fixedNormal32[n + 2], this._rotated.x = this._normal.x * this._particle._rotationMatrix[0] + this._normal.y * this._particle._rotationMatrix[3] + this._normal.z * this._particle._rotationMatrix[6], this._rotated.y = this._normal.x * this._particle._rotationMatrix[1] + this._normal.y * this._particle._rotationMatrix[4] + this._normal.z * this._particle._rotationMatrix[7], this._rotated.z = this._normal.x * this._particle._rotationMatrix[2] + this._normal.y * this._particle._rotationMatrix[5] + this._normal.z * this._particle._rotationMatrix[8], this._normals32[n] = this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z, this._normals32[n + 1] = this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z, this._normals32[n + 2] = this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z), this._computeParticleColor && this._particle.color && (this._colors32[s] = this._particle.color.r, this._colors32[s + 1] = this._particle.color.g, this._colors32[s + 2] = this._particle.color.b, this._colors32[s + 3] = this._particle.color.a), this._computeParticleTexture && (this._uvs32[l] = this._shapeUV[2 * h] * (this._particle.uvs.z - this._particle.uvs.x) + this._particle.uvs.x, this._uvs32[l + 1] = this._shapeUV[2 * h + 1] * (this._particle.uvs.w - this._particle.uvs.y) + this._particle.uvs.y);else for (this._particle._stillInvisible = !0, h = 0; h < this._shape.length; h++) n = o + 3 * h, s = a + 4 * h, l = c + 2 * h, this._positions32[n] = 0, this._positions32[n + 1] = 0, this._positions32[n + 2] = 0, this._normals32[n] = 0, this._normals32[n + 1] = 0, this._normals32[n + 2] = 0, this._computeParticleColor && this._particle.color && (this._colors32[s] = this._particle.color.r, this._colors32[s + 1] = this._particle.color.g, this._colors32[s + 2] = this._particle.color.b, this._colors32[s + 3] = this._particle.color.a), this._computeParticleTexture && (this._uvs32[l] = this._shapeUV[2 * h] * (this._particle.uvs.z - this._particle.uvs.x) + this._particle.uvs.x, this._uvs32[l + 1] = this._shapeUV[2 * h + 1] * (this._particle.uvs.w - this._particle.uvs.y) + this._particle.uvs.y);\n\n          if (this._particlesIntersect) {\n            var p = this._particle._boundingInfo,\n                _ = p.boundingBox,\n                m = p.boundingSphere;\n\n            if (!this._bSphereOnly) {\n              for (var g = 0; g < _.vectors.length; g++) this._vertex.x = this._particle._modelBoundingInfo.boundingBox.vectors[g].x * this._particle.scaling.x, this._vertex.y = this._particle._modelBoundingInfo.boundingBox.vectors[g].y * this._particle.scaling.y, this._vertex.z = this._particle._modelBoundingInfo.boundingBox.vectors[g].z * this._particle.scaling.z, this._rotated.x = this._vertex.x * this._particle._rotationMatrix[0] + this._vertex.y * this._particle._rotationMatrix[3] + this._vertex.z * this._particle._rotationMatrix[6], this._rotated.y = this._vertex.x * this._particle._rotationMatrix[1] + this._vertex.y * this._particle._rotationMatrix[4] + this._vertex.z * this._particle._rotationMatrix[7], this._rotated.z = this._vertex.x * this._particle._rotationMatrix[2] + this._vertex.y * this._particle._rotationMatrix[5] + this._vertex.z * this._particle._rotationMatrix[8], _.vectors[g].x = this._particle.position.x + this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z, _.vectors[g].y = this._particle.position.y + this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z, _.vectors[g].z = this._particle.position.z + this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z;\n\n              _._update(this.mesh._worldMatrix);\n            }\n\n            this._minBbox.x = this._particle._modelBoundingInfo.minimum.x * this._particle.scaling.x, this._minBbox.y = this._particle._modelBoundingInfo.minimum.y * this._particle.scaling.y, this._minBbox.z = this._particle._modelBoundingInfo.minimum.z * this._particle.scaling.z, this._maxBbox.x = this._particle._modelBoundingInfo.maximum.x * this._particle.scaling.x, this._maxBbox.y = this._particle._modelBoundingInfo.maximum.y * this._particle.scaling.y, this._maxBbox.z = this._particle._modelBoundingInfo.maximum.z * this._particle.scaling.z, m.center.x = this._particle._globalPosition.x + .5 * (this._minBbox.x + this._maxBbox.x), m.center.y = this._particle._globalPosition.y + .5 * (this._minBbox.y + this._maxBbox.y), m.center.z = this._particle._globalPosition.z + .5 * (this._minBbox.z + this._maxBbox.z), m.radius = .5 * this._bSphereRadiusFactor * Math.sqrt((this._maxBbox.x - this._minBbox.x) * (this._maxBbox.x - this._minBbox.x) + (this._maxBbox.y - this._minBbox.y) * (this._maxBbox.y - this._minBbox.y) + (this._maxBbox.z - this._minBbox.z) * (this._maxBbox.z - this._minBbox.z)), m._update(this.mesh._worldMatrix);\n          }\n\n          o = n + 3, a = s + 4, c = l + 2;\n        }\n      }\n\n      if (i) {\n        if (this._computeParticleColor && this.mesh.updateVerticesData(fi.VertexBuffer.ColorKind, this._colors32, !1, !1), this._computeParticleTexture && this.mesh.updateVerticesData(fi.VertexBuffer.UVKind, this._uvs32, !1, !1), this.mesh.updateVerticesData(fi.VertexBuffer.PositionKind, this._positions32, !1, !1), !this.mesh.areNormalsFrozen || this.mesh.isFacetDataEnabled) {\n          if (this._computeParticleVertex || this.mesh.isFacetDataEnabled) {\n            var v = this.mesh.isFacetDataEnabled ? this.mesh.getFacetDataParameters() : null;\n            fi.VertexData.ComputeNormals(this._positions32, this._indices32, this._normals32, v);\n\n            for (var y = 0; y < this._normals32.length; y++) this._fixedNormal32[y] = this._normals32[y];\n          }\n\n          this.mesh.areNormalsFrozen || this.mesh.updateVerticesData(fi.VertexBuffer.NormalKind, this._normals32, !1, !1);\n        }\n\n        if (this._depthSort && this._depthSortParticles) {\n          this.depthSortedParticles.sort(this._depthSortFunction);\n          var b = this.depthSortedParticles.length,\n              T = 0,\n              E = 0,\n              x = 0,\n              P = 0;\n\n          for (T = 0; T < b; T++) {\n            E = this.depthSortedParticles[T].indicesLength, x = this.depthSortedParticles[T].ind;\n\n            for (y = 0; y < E; y++) this._indices32[P] = this._indices[x + y], P++;\n          }\n\n          this.mesh.updateIndices(this._indices32);\n        }\n      }\n\n      return this._computeBoundingBox && (this.mesh._boundingInfo = new fi.BoundingInfo(this._minimum, this._maximum), this.mesh._boundingInfo.update(this.mesh._worldMatrix)), this.afterUpdateParticles(e, t, i), this;\n    }, e.prototype._quaternionRotationYPR = function () {\n      this._halfroll = .5 * this._roll, this._halfpitch = .5 * this._pitch, this._halfyaw = .5 * this._yaw, this._sinRoll = Math.sin(this._halfroll), this._cosRoll = Math.cos(this._halfroll), this._sinPitch = Math.sin(this._halfpitch), this._cosPitch = Math.cos(this._halfpitch), this._sinYaw = Math.sin(this._halfyaw), this._cosYaw = Math.cos(this._halfyaw), this._quaternion.x = this._cosYaw * this._sinPitch * this._cosRoll + this._sinYaw * this._cosPitch * this._sinRoll, this._quaternion.y = this._sinYaw * this._cosPitch * this._cosRoll - this._cosYaw * this._sinPitch * this._sinRoll, this._quaternion.z = this._cosYaw * this._cosPitch * this._sinRoll - this._sinYaw * this._sinPitch * this._cosRoll, this._quaternion.w = this._cosYaw * this._cosPitch * this._cosRoll + this._sinYaw * this._sinPitch * this._sinRoll;\n    }, e.prototype._quaternionToRotationMatrix = function () {\n      this._rotMatrix.m[0] = 1 - 2 * (this._quaternion.y * this._quaternion.y + this._quaternion.z * this._quaternion.z), this._rotMatrix.m[1] = 2 * (this._quaternion.x * this._quaternion.y + this._quaternion.z * this._quaternion.w), this._rotMatrix.m[2] = 2 * (this._quaternion.z * this._quaternion.x - this._quaternion.y * this._quaternion.w), this._rotMatrix.m[3] = 0, this._rotMatrix.m[4] = 2 * (this._quaternion.x * this._quaternion.y - this._quaternion.z * this._quaternion.w), this._rotMatrix.m[5] = 1 - 2 * (this._quaternion.z * this._quaternion.z + this._quaternion.x * this._quaternion.x), this._rotMatrix.m[6] = 2 * (this._quaternion.y * this._quaternion.z + this._quaternion.x * this._quaternion.w), this._rotMatrix.m[7] = 0, this._rotMatrix.m[8] = 2 * (this._quaternion.z * this._quaternion.x + this._quaternion.y * this._quaternion.w), this._rotMatrix.m[9] = 2 * (this._quaternion.y * this._quaternion.z - this._quaternion.x * this._quaternion.w), this._rotMatrix.m[10] = 1 - 2 * (this._quaternion.y * this._quaternion.y + this._quaternion.x * this._quaternion.x), this._rotMatrix.m[11] = 0, this._rotMatrix.m[12] = 0, this._rotMatrix.m[13] = 0, this._rotMatrix.m[14] = 0, this._rotMatrix.m[15] = 1;\n    }, e.prototype.dispose = function () {\n      this.mesh.dispose(), this.vars = null, this._positions = null, this._indices = null, this._normals = null, this._uvs = null, this._colors = null, this._indices32 = null, this._positions32 = null, this._normals32 = null, this._fixedNormal32 = null, this._uvs32 = null, this._colors32 = null, this.pickedParticles = null;\n    }, e.prototype.refreshVisibleSize = function () {\n      return this._isVisibilityBoxLocked || this.mesh.refreshBoundingInfo(), this;\n    }, e.prototype.setVisibilityBox = function (e) {\n      var t = e / 2;\n      this.mesh._boundingInfo = new fi.BoundingInfo(new fi.Vector3(-t, -t, -t), new fi.Vector3(t, t, t));\n    }, Object.defineProperty(e.prototype, \"isAlwaysVisible\", {\n      get: function () {\n        return this._alwaysVisible;\n      },\n      set: function (e) {\n        this._alwaysVisible = e, this.mesh.alwaysSelectAsActiveMesh = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isVisibilityBoxLocked\", {\n      get: function () {\n        return this._isVisibilityBoxLocked;\n      },\n      set: function (e) {\n        this._isVisibilityBoxLocked = e, this.mesh.getBoundingInfo().isLocked = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"computeParticleRotation\", {\n      get: function () {\n        return this._computeParticleRotation;\n      },\n      set: function (e) {\n        this._computeParticleRotation = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"computeParticleColor\", {\n      get: function () {\n        return this._computeParticleColor;\n      },\n      set: function (e) {\n        this._computeParticleColor = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"computeParticleTexture\", {\n      get: function () {\n        return this._computeParticleTexture;\n      },\n      set: function (e) {\n        this._computeParticleTexture = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"computeParticleVertex\", {\n      get: function () {\n        return this._computeParticleVertex;\n      },\n      set: function (e) {\n        this._computeParticleVertex = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"computeBoundingBox\", {\n      get: function () {\n        return this._computeBoundingBox;\n      },\n      set: function (e) {\n        this._computeBoundingBox = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"depthSortParticles\", {\n      get: function () {\n        return this._depthSortParticles;\n      },\n      set: function (e) {\n        this._depthSortParticles = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.initParticles = function () {}, e.prototype.recycleParticle = function (e) {\n      return e;\n    }, e.prototype.updateParticle = function (e) {\n      return e;\n    }, e.prototype.updateParticleVertex = function (e, t, i) {\n      return t;\n    }, e.prototype.beforeUpdateParticles = function (e, t, i) {}, e.prototype.afterUpdateParticles = function (e, t, i) {}, e;\n  }(), fi.SolidParticleSystem = pi, _i = $a || ($a = {}), mi = function () {\n    function x() {}\n\n    return x.updateSideOrientation = function (e) {\n      return e == _i.Mesh.DOUBLESIDE ? _i.Mesh.DOUBLESIDE : null == e ? _i.Mesh.FRONTSIDE : e;\n    }, x.CreateBox = function (e, t, i) {\n      void 0 === i && (i = null);\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreateBox(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateSphere = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreateSphere(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateDisc = function (e, t, i) {\n      void 0 === i && (i = null);\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreateDisc(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateIcoSphere = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreateIcoSphere(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateRibbon = function (e, t, i) {\n      void 0 === i && (i = null);\n      var h = t.pathArray,\n          r = t.closeArray,\n          n = t.closePath,\n          o = x.updateSideOrientation(t.sideOrientation),\n          u = t.instance,\n          s = t.updatable;\n\n      if (u) {\n        _i.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, _i.Tmp.Vector3[0]), _i.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, _i.Tmp.Vector3[1]);\n        var a = u.getVerticesData(_i.VertexBuffer.PositionKind);\n\n        if (function (e) {\n          for (var t = h[0].length, i = u, r = 0, n = i._originalBuilderSideOrientation === _i.Mesh.DOUBLESIDE ? 2 : 1, o = 1; o <= n; o++) for (var s = 0; s < h.length; s++) {\n            var a = h[s],\n                l = a.length;\n            t = t < l ? t : l;\n\n            for (var c = 0; c < t;) e[r] = a[c].x, e[r + 1] = a[c].y, e[r + 2] = a[c].z, a[c].x < _i.Tmp.Vector3[0].x && (_i.Tmp.Vector3[0].x = a[c].x), a[c].x > _i.Tmp.Vector3[1].x && (_i.Tmp.Vector3[1].x = a[c].x), a[c].y < _i.Tmp.Vector3[0].y && (_i.Tmp.Vector3[0].y = a[c].y), a[c].y > _i.Tmp.Vector3[1].y && (_i.Tmp.Vector3[1].y = a[c].y), a[c].z < _i.Tmp.Vector3[0].z && (_i.Tmp.Vector3[0].z = a[c].z), a[c].z > _i.Tmp.Vector3[1].z && (_i.Tmp.Vector3[1].z = a[c].z), c++, r += 3;\n\n            i._creationDataStorage && i._creationDataStorage.closePath && (e[r] = a[0].x, e[r + 1] = a[0].y, e[r + 2] = a[0].z, r += 3);\n          }\n        }(a), u._boundingInfo = new _i.BoundingInfo(_i.Tmp.Vector3[2], _i.Tmp.Vector3[3]), u._boundingInfo.update(u._worldMatrix), u.updateVerticesData(_i.VertexBuffer.PositionKind, a, !1, !1), t.colors) {\n          for (var l = u.getVerticesData(_i.VertexBuffer.ColorKind), c = 0; c < t.colors.length; c++) l[4 * c] = t.colors[c].r, l[4 * c + 1] = t.colors[c].g, l[4 * c + 2] = t.colors[c].b, l[4 * c + 3] = t.colors[c].a;\n\n          u.updateVerticesData(_i.VertexBuffer.ColorKind, l, !1, !1);\n        }\n\n        if (t.uvs) {\n          for (var d = u.getVerticesData(_i.VertexBuffer.UVKind), f = 0; f < t.uvs.length; f++) d[2 * f] = t.uvs[f].x, d[2 * f + 1] = t.uvs[f].y;\n\n          u.updateVerticesData(_i.VertexBuffer.UVKind, d, !1, !1);\n        }\n\n        if (!u.areNormalsFrozen || u.isFacetDataEnabled) {\n          var p = u.getIndices(),\n              _ = u.getVerticesData(_i.VertexBuffer.NormalKind),\n              m = u.isFacetDataEnabled ? u.getFacetDataParameters() : null;\n\n          if (_i.VertexData.ComputeNormals(a, p, _, m), u._creationDataStorage && u._creationDataStorage.closePath) for (var g = 0, v = 0, y = 0; y < h.length; y++) g = 3 * u._creationDataStorage.idx[y], v = y + 1 < h.length ? 3 * (u._creationDataStorage.idx[y + 1] - 1) : _.length - 3, _[g] = .5 * (_[g] + _[v]), _[g + 1] = .5 * (_[g + 1] + _[v + 1]), _[g + 2] = .5 * (_[g + 2] + _[v + 2]), _[v] = _[g], _[v + 1] = _[g + 1], _[v + 2] = _[g + 2];\n          u.areNormalsFrozen || u.updateVerticesData(_i.VertexBuffer.NormalKind, _, !1, !1);\n        }\n\n        return u;\n      }\n\n      var b = new _i.Mesh(e, i);\n      b._originalBuilderSideOrientation = o, b._creationDataStorage = new _i._CreationDataStorage();\n\n      var T = _i.VertexData.CreateRibbon(t);\n\n      return n && (b._creationDataStorage.idx = T._idx), b._creationDataStorage.closePath = n, b._creationDataStorage.closeArray = r, T.applyToMesh(b, s), b;\n    }, x.CreateCylinder = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreateCylinder(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateTorus = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreateTorus(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateTorusKnot = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreateTorusKnot(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateLineSystem = function (e, t, i) {\n      var r = t.instance,\n          n = t.lines,\n          o = t.colors;\n\n      if (r) {\n        var s,\n            a,\n            l = r.getVerticesData(_i.VertexBuffer.PositionKind);\n        o && (s = r.getVerticesData(_i.VertexBuffer.ColorKind));\n\n        for (var c = 0, h = 0, u = 0; u < n.length; u++) for (var d = n[u], f = 0; f < d.length; f++) l[c] = d[f].x, l[c + 1] = d[f].y, l[c + 2] = d[f].z, o && s && (a = o[u], s[h] = a[f].r, s[h + 1] = a[f].g, s[h + 2] = a[f].b, s[h + 3] = a[f].a, h += 4), c += 3;\n\n        return r.updateVerticesData(_i.VertexBuffer.PositionKind, l, !1, !1), o && s && r.updateVerticesData(_i.VertexBuffer.ColorKind, s, !1, !1), r;\n      }\n\n      var p = !!o,\n          _ = new _i.LinesMesh(e, i, null, void 0, void 0, p, t.useVertexAlpha);\n\n      return _i.VertexData.CreateLineSystem(t).applyToMesh(_, t.updatable), _;\n    }, x.CreateLines = function (e, t, i) {\n      void 0 === i && (i = null);\n      var r = t.colors ? [t.colors] : null;\n      return x.CreateLineSystem(e, {\n        lines: [t.points],\n        updatable: t.updatable,\n        instance: t.instance,\n        colors: r,\n        useVertexAlpha: t.useVertexAlpha\n      }, i);\n    }, x.CreateDashedLines = function (e, t, i) {\n      void 0 === i && (i = null);\n      var d = t.points,\n          f = t.instance,\n          r = t.gapSize || 1,\n          n = t.dashSize || 3;\n\n      if (f) {\n        return f.updateMeshPositions(function (e) {\n          var t,\n              i,\n              r = _i.Vector3.Zero(),\n              n = e.length / 6,\n              o = 0,\n              s = 0,\n              a = 0,\n              l = 0,\n              c = 0,\n              h = 0;\n\n          for (c = 0; c < d.length - 1; c++) d[c + 1].subtractToRef(d[c], r), o += r.length();\n\n          t = o / n;\n          var u = f._creationDataStorage.dashSize;\n\n          for (i = u * t / (u + f._creationDataStorage.gapSize), c = 0; c < d.length - 1; c++) for (d[c + 1].subtractToRef(d[c], r), s = Math.floor(r.length() / t), r.normalize(), h = 0; h < s && l < e.length;) a = t * h, e[l] = d[c].x + a * r.x, e[l + 1] = d[c].y + a * r.y, e[l + 2] = d[c].z + a * r.z, e[l + 3] = d[c].x + (a + i) * r.x, e[l + 4] = d[c].y + (a + i) * r.y, e[l + 5] = d[c].z + (a + i) * r.z, l += 6, h++;\n\n          for (; l < e.length;) e[l] = d[c].x, e[l + 1] = d[c].y, e[l + 2] = d[c].z, l += 3;\n        }, !1), f;\n      }\n\n      var o = new _i.LinesMesh(e, i);\n      return _i.VertexData.CreateDashedLines(t).applyToMesh(o, t.updatable), o._creationDataStorage = new _i._CreationDataStorage(), o._creationDataStorage.dashSize = n, o._creationDataStorage.gapSize = r, o;\n    }, x.ExtrudeShape = function (e, t, i) {\n      void 0 === i && (i = null);\n      var r = t.path,\n          n = t.shape,\n          o = t.scale || 1,\n          s = t.rotation || 0,\n          a = 0 === t.cap ? 0 : t.cap || _i.Mesh.NO_CAP,\n          l = t.updatable,\n          c = x.updateSideOrientation(t.sideOrientation),\n          h = t.instance || null,\n          u = t.invertUV || !1;\n      return x._ExtrudeShapeGeneric(e, n, r, o, s, null, null, !1, !1, a, !1, i, !!l, c, h, u, t.frontUVs || null, t.backUVs || null);\n    }, x.ExtrudeShapeCustom = function (e, t, i) {\n      var r = t.path,\n          n = t.shape,\n          o = t.scaleFunction || function () {\n        return 1;\n      },\n          s = t.rotationFunction || function () {\n        return 0;\n      },\n          a = t.ribbonCloseArray || !1,\n          l = t.ribbonClosePath || !1,\n          c = 0 === t.cap ? 0 : t.cap || _i.Mesh.NO_CAP,\n          h = t.updatable,\n          u = x.updateSideOrientation(t.sideOrientation),\n          d = t.instance,\n          f = t.invertUV || !1;\n\n      return x._ExtrudeShapeGeneric(e, n, r, null, null, o, s, a, l, c, !0, i, !!h, u, d || null, f, t.frontUVs || null, t.backUVs || null);\n    }, x.CreateLathe = function (e, t, i) {\n      var r,\n          n = t.arc ? t.arc <= 0 || 1 < t.arc ? 1 : t.arc : 1,\n          o = void 0 === t.closed || t.closed,\n          s = t.shape,\n          a = t.radius || 1,\n          l = t.tessellation || 64,\n          c = t.clip || 0,\n          h = t.updatable,\n          u = x.updateSideOrientation(t.sideOrientation),\n          d = t.cap || _i.Mesh.NO_CAP,\n          f = 2 * Math.PI,\n          p = new Array(),\n          _ = t.invertUV || !1,\n          m = 0,\n          g = 0,\n          v = f / l * n,\n          y = new Array();\n\n      for (m = 0; m <= l - c; m++) {\n        y = [];\n\n        for (d != _i.Mesh.CAP_START && d != _i.Mesh.CAP_ALL || (y.push(new _i.Vector3(0, s[0].y, 0)), y.push(new _i.Vector3(Math.cos(m * v) * s[0].x * a, s[0].y, Math.sin(m * v) * s[0].x * a))), g = 0; g < s.length; g++) r = new _i.Vector3(Math.cos(m * v) * s[g].x * a, s[g].y, Math.sin(m * v) * s[g].x * a), y.push(r);\n\n        d != _i.Mesh.CAP_END && d != _i.Mesh.CAP_ALL || (y.push(new _i.Vector3(Math.cos(m * v) * s[s.length - 1].x * a, s[s.length - 1].y, Math.sin(m * v) * s[s.length - 1].x * a)), y.push(new _i.Vector3(0, s[s.length - 1].y, 0))), p.push(y);\n      }\n\n      return x.CreateRibbon(e, {\n        pathArray: p,\n        closeArray: o,\n        sideOrientation: u,\n        updatable: h,\n        invertUV: _,\n        frontUVs: t.frontUVs,\n        backUVs: t.backUVs\n      }, i);\n    }, x.CreatePlane = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n\n      if (t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreatePlane(t).applyToMesh(r, t.updatable), t.sourcePlane) {\n        r.translate(t.sourcePlane.normal, t.sourcePlane.d);\n\n        var n = Math.acos(_i.Vector3.Dot(t.sourcePlane.normal, _i.Axis.Z)),\n            o = _i.Vector3.Cross(_i.Axis.Z, t.sourcePlane.normal);\n\n        o.lengthSquared() > _i.Epsilon && r.rotate(o, n);\n      }\n\n      return r;\n    }, x.CreateGround = function (e, t, i) {\n      var r = new _i.GroundMesh(e, i);\n      return r._setReady(!1), r._subdivisionsX = t.subdivisionsX || t.subdivisions || 1, r._subdivisionsY = t.subdivisionsY || t.subdivisions || 1, r._width = t.width || 1, r._height = t.height || 1, r._maxX = r._width / 2, r._maxZ = r._height / 2, r._minX = -r._maxX, r._minZ = -r._maxZ, _i.VertexData.CreateGround(t).applyToMesh(r, t.updatable), r._setReady(!0), r;\n    }, x.CreateTiledGround = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n      return _i.VertexData.CreateTiledGround(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateGroundFromHeightMap = function (e, t, i, s) {\n      var a = i.width || 10,\n          l = i.height || 10,\n          c = i.subdivisions || 1,\n          h = i.minHeight || 0,\n          u = i.maxHeight || 1,\n          d = i.colorFilter || new _i.Color3(.3, .59, .11),\n          f = i.alphaFilter || 0,\n          p = i.updatable,\n          _ = i.onReady,\n          m = new _i.GroundMesh(e, s);\n      m._subdivisionsX = c, m._subdivisionsY = c, m._width = a, m._height = l, m._maxX = m._width / 2, m._maxZ = m._height / 2, m._minX = -m._maxX, m._minZ = -m._maxZ, m._setReady(!1);\n      return _i.Tools.LoadImage(t, function (e) {\n        var t = document.createElement(\"canvas\"),\n            i = t.getContext(\"2d\");\n        if (!i) throw new Error(\"Unable to get 2d context for CreateGroundFromHeightMap\");\n\n        if (!s.isDisposed) {\n          var r = e.width,\n              n = e.height;\n          t.width = r, t.height = n, i.drawImage(e, 0, 0);\n          var o = i.getImageData(0, 0, r, n).data;\n          _i.VertexData.CreateGroundFromHeightMap({\n            width: a,\n            height: l,\n            subdivisions: c,\n            minHeight: h,\n            maxHeight: u,\n            colorFilter: d,\n            buffer: o,\n            bufferWidth: r,\n            bufferHeight: n,\n            alphaFilter: f\n          }).applyToMesh(m, p), _ && _(m), m._setReady(!0);\n        }\n      }, function () {}, s.database), m;\n    }, x.CreatePolygon = function (e, t, i) {\n      t.sideOrientation = x.updateSideOrientation(t.sideOrientation);\n\n      for (var r = t.shape, n = t.holes || [], o = t.depth || 0, s = [], a = [], l = 0; l < r.length; l++) s[l] = new _i.Vector2(r[l].x, r[l].z);\n\n      s[0].equalsWithEpsilon(s[s.length - 1], 1e-8) && s.pop();\n\n      for (var c = new _i.PolygonMeshBuilder(e, s, i), h = 0; h < n.length; h++) {\n        a = [];\n\n        for (var u = 0; u < n[h].length; u++) a.push(new _i.Vector2(n[h][u].x, n[h][u].z));\n\n        c.addHole(a);\n      }\n\n      var d = c.build(t.updatable, o);\n      return d._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreatePolygon(d, t.sideOrientation, t.faceUV, t.faceColors, t.frontUVs, t.backUVs).applyToMesh(d, t.updatable), d;\n    }, x.ExtrudePolygon = function (e, t, i) {\n      return x.CreatePolygon(e, t, i);\n    }, x.CreateTube = function (e, t, i) {\n      var r = t.path,\n          n = t.instance,\n          o = 1;\n      void 0 !== t.radius ? o = t.radius : n && (o = n._creationDataStorage.radius);\n      var s = t.tessellation || 64,\n          a = t.radiusFunction || null,\n          l = t.cap || _i.Mesh.NO_CAP,\n          c = t.invertUV || !1,\n          h = t.updatable,\n          u = x.updateSideOrientation(t.sideOrientation);\n      t.arc = t.arc && (t.arc <= 0 || 1 < t.arc) ? 1 : t.arc || 1;\n\n      var d,\n          f,\n          p = function (n, e, t, i, r, o, s, a) {\n        for (var l, c, h, u, d = e.getTangents(), f = e.getNormals(), p = e.getDistances(), _ = 2 * Math.PI / r * a, m = o || function () {\n          return i;\n        }, g = _i.Tmp.Matrix[0], v = s === _i.Mesh.NO_CAP || s === _i.Mesh.CAP_END ? 0 : 2, y = 0; y < n.length; y++) {\n          c = m(y, p[y]), l = Array(), h = f[y];\n\n          for (var b = 0; b < r; b++) _i.Matrix.RotationAxisToRef(d[y], _ * b, g), u = l[b] ? l[b] : _i.Vector3.Zero(), _i.Vector3.TransformCoordinatesToRef(h, g, u), u.scaleInPlace(c).addInPlace(n[y]), l[b] = u;\n\n          t[v] = l, v++;\n        }\n\n        var T = function (e, t) {\n          for (var i = Array(), r = 0; r < e; r++) i.push(n[t]);\n\n          return i;\n        };\n\n        switch (s) {\n          case _i.Mesh.NO_CAP:\n            break;\n\n          case _i.Mesh.CAP_START:\n            t[0] = T(r, 0), t[1] = t[2].slice(0);\n            break;\n\n          case _i.Mesh.CAP_END:\n            t[v] = t[v - 1].slice(0), t[v + 1] = T(r, n.length - 1);\n            break;\n\n          case _i.Mesh.CAP_ALL:\n            t[0] = T(r, 0), t[1] = t[2].slice(0), t[v] = t[v - 1].slice(0), t[v + 1] = T(r, n.length - 1);\n        }\n\n        return t;\n      };\n\n      if (n) {\n        var _ = n._creationDataStorage,\n            m = t.arc || _.arc;\n        return f = p(r, d = _.path3D.update(r), _.pathArray, o, _.tessellation, a, _.cap, m), n = x.CreateRibbon(\"\", {\n          pathArray: f,\n          instance: n\n        }), _.path3D = d, _.pathArray = f, _.arc = m, _.radius = o, n;\n      }\n\n      f = p(r, d = new _i.Path3D(r), new Array(), o, s, a, l = l < 0 || 3 < l ? 0 : l, t.arc);\n      var g = x.CreateRibbon(e, {\n        pathArray: f,\n        closePath: !0,\n        closeArray: !1,\n        updatable: h,\n        sideOrientation: u,\n        invertUV: c,\n        frontUVs: t.frontUVs,\n        backUVs: t.backUVs\n      }, i);\n      return g._creationDataStorage.pathArray = f, g._creationDataStorage.path3D = d, g._creationDataStorage.tessellation = s, g._creationDataStorage.cap = l, g._creationDataStorage.arc = t.arc, g._creationDataStorage.radius = o, g;\n    }, x.CreatePolyhedron = function (e, t, i) {\n      var r = new _i.Mesh(e, i);\n      return t.sideOrientation = x.updateSideOrientation(t.sideOrientation), r._originalBuilderSideOrientation = t.sideOrientation, _i.VertexData.CreatePolyhedron(t).applyToMesh(r, t.updatable), r;\n    }, x.CreateDecal = function (e, t, i) {\n      var r = t.getIndices(),\n          n = t.getVerticesData(_i.VertexBuffer.PositionKind),\n          o = t.getVerticesData(_i.VertexBuffer.NormalKind),\n          s = i.position || _i.Vector3.Zero(),\n          a = i.normal || _i.Vector3.Up(),\n          f = i.size || _i.Vector3.One(),\n          l = i.angle || 0;\n\n      if (!a) {\n        var c = new _i.Vector3(0, 0, 1),\n            h = t.getScene().activeCamera,\n            u = _i.Vector3.TransformCoordinates(c, h.getWorldMatrix());\n\n        a = h.globalPosition.subtract(u);\n      }\n\n      var d = -Math.atan2(a.z, a.x) - Math.PI / 2,\n          p = Math.sqrt(a.x * a.x + a.z * a.z),\n          _ = Math.atan2(a.y, p),\n          m = _i.Matrix.RotationYawPitchRoll(d, _, l).multiply(_i.Matrix.Translation(s.x, s.y, s.z)),\n          g = _i.Matrix.Invert(m),\n          v = t.getWorldMatrix().multiply(g),\n          y = new _i.VertexData();\n\n      y.indices = [], y.positions = [], y.normals = [], y.uvs = [];\n\n      for (var b = 0, T = function (e) {\n        var t = new _i.PositionNormalVertex();\n        if (!r || !n || !o) return t;\n        var i = r[e];\n        return t.position = new _i.Vector3(n[3 * i], n[3 * i + 1], n[3 * i + 2]), t.position = _i.Vector3.TransformCoordinates(t.position, v), t.normal = new _i.Vector3(o[3 * i], o[3 * i + 1], o[3 * i + 2]), t.normal = _i.Vector3.TransformNormal(t.normal, v), t;\n      }, E = function (e, r) {\n        if (0 === e.length) return e;\n\n        for (var n = .5 * Math.abs(_i.Vector3.Dot(f, r)), t = function (e, t) {\n          var i = _i.Vector3.GetClipFactor(e.position, t.position, r, n);\n\n          return new _i.PositionNormalVertex(_i.Vector3.Lerp(e.position, t.position, i), _i.Vector3.Lerp(e.normal, t.normal, i));\n        }, i = new Array(), o = 0; o < e.length; o += 3) {\n          var s,\n              a,\n              l,\n              c = null,\n              h = null,\n              u = null,\n              d = null;\n\n          switch (((s = 0 < _i.Vector3.Dot(e[o].position, r) - n) ? 1 : 0) + ((a = 0 < _i.Vector3.Dot(e[o + 1].position, r) - n) ? 1 : 0) + ((l = 0 < _i.Vector3.Dot(e[o + 2].position, r) - n) ? 1 : 0)) {\n            case 0:\n              i.push(e[o]), i.push(e[o + 1]), i.push(e[o + 2]);\n              break;\n\n            case 1:\n              if (s && (c = e[o + 1], h = e[o + 2], u = t(e[o], c), d = t(e[o], h)), a) {\n                c = e[o], h = e[o + 2], u = t(e[o + 1], c), d = t(e[o + 1], h), i.push(u), i.push(h.clone()), i.push(c.clone()), i.push(h.clone()), i.push(u.clone()), i.push(d);\n                break;\n              }\n\n              l && (c = e[o], h = e[o + 1], u = t(e[o + 2], c), d = t(e[o + 2], h)), c && h && u && d && (i.push(c.clone()), i.push(h.clone()), i.push(u), i.push(d), i.push(u.clone()), i.push(h.clone()));\n              break;\n\n            case 2:\n              s || (h = t(c = e[o].clone(), e[o + 1]), u = t(c, e[o + 2]), i.push(c), i.push(h), i.push(u)), a || (h = t(c = e[o + 1].clone(), e[o + 2]), u = t(c, e[o]), i.push(c), i.push(h), i.push(u)), l || (h = t(c = e[o + 2].clone(), e[o]), u = t(c, e[o + 1]), i.push(c), i.push(h), i.push(u));\n          }\n        }\n\n        return i;\n      }, x = 0; x < r.length; x += 3) {\n        var P = new Array();\n        if (P.push(T(x)), P.push(T(x + 1)), P.push(T(x + 2)), 0 !== (P = E(P = E(P = E(P = E(P = E(P = E(P, new _i.Vector3(1, 0, 0)), new _i.Vector3(-1, 0, 0)), new _i.Vector3(0, 1, 0)), new _i.Vector3(0, -1, 0)), new _i.Vector3(0, 0, 1)), new _i.Vector3(0, 0, -1))).length) for (var A = 0; A < P.length; A++) {\n          var S = P[A];\n          y.indices.push(b), S.position.toArray(y.positions, 3 * b), S.normal.toArray(y.normals, 3 * b), y.uvs.push(.5 + S.position.x / f.x), y.uvs.push(.5 + S.position.y / f.y), b++;\n        }\n      }\n\n      var M = new _i.Mesh(e, t.getScene());\n      return y.applyToMesh(M), M.position = s.clone(), M.rotation = new _i.Vector3(_, d, l), M;\n    }, x._ExtrudeShapeGeneric = function (e, t, i, r, n, o, s, a, l, c, h, u, d, f, p, _, m, g) {\n      var v,\n          y,\n          b = function (e, t, i, r, n, o, s, a, l, c) {\n        for (var h = i.getTangents(), u = i.getNormals(), d = i.getBinormals(), f = i.getDistances(), p = 0, _ = c && a ? a : function () {\n          return null !== o ? o : 0;\n        }, m = c && s ? s : function () {\n          return null !== n ? n : 1;\n        }, g = l === _i.Mesh.NO_CAP || l === _i.Mesh.CAP_END ? 0 : 2, v = _i.Tmp.Matrix[0], y = 0; y < t.length; y++) {\n          for (var b = new Array(), T = _(y, f[y]), E = m(y, f[y]), x = 0; x < e.length; x++) {\n            _i.Matrix.RotationAxisToRef(h[y], p, v);\n\n            var P = h[y].scale(e[x].z).add(u[y].scale(e[x].x)).add(d[y].scale(e[x].y)),\n                A = b[x] ? b[x] : _i.Vector3.Zero();\n            _i.Vector3.TransformCoordinatesToRef(P, v, A), A.scaleInPlace(E).addInPlace(t[y]), b[x] = A;\n          }\n\n          r[g] = b, p += T, g++;\n        }\n\n        var S = function (e) {\n          var t,\n              i = Array(),\n              r = _i.Vector3.Zero();\n\n          for (t = 0; t < e.length; t++) r.addInPlace(e[t]);\n\n          for (r.scaleInPlace(1 / e.length), t = 0; t < e.length; t++) i.push(r);\n\n          return i;\n        };\n\n        switch (l) {\n          case _i.Mesh.NO_CAP:\n            break;\n\n          case _i.Mesh.CAP_START:\n            r[0] = S(r[2]), r[1] = r[2];\n            break;\n\n          case _i.Mesh.CAP_END:\n            r[g] = r[g - 1], r[g + 1] = S(r[g - 1]);\n            break;\n\n          case _i.Mesh.CAP_ALL:\n            r[0] = S(r[2]), r[1] = r[2], r[g] = r[g - 1], r[g + 1] = S(r[g - 1]);\n        }\n\n        return r;\n      };\n\n      if (p) {\n        var T = p._creationDataStorage;\n        return v = T.path3D.update(i), y = b(t, i, T.path3D, T.pathArray, r, n, o, s, T.cap, h), p = _i.Mesh.CreateRibbon(\"\", y, !1, !1, 0, u || void 0, !1, 0, p);\n      }\n\n      y = b(t, i, v = new _i.Path3D(i), new Array(), r, n, o, s, c = c < 0 || 3 < c ? 0 : c, h);\n      var E = x.CreateRibbon(e, {\n        pathArray: y,\n        closeArray: a,\n        closePath: l,\n        updatable: d,\n        sideOrientation: f,\n        invertUV: _,\n        frontUVs: m || void 0,\n        backUVs: g || void 0\n      }, u);\n      return E._creationDataStorage.pathArray = y, E._creationDataStorage.path3D = v, E._creationDataStorage.cap = c, E;\n    }, x;\n  }(), _i.MeshBuilder = mi, gi = $a || ($a = {}), vi = function () {\n    function r() {}\n\n    return Object.defineProperty(r, \"DecoderAvailable\", {\n      get: function () {\n        if (\"undefined\" != typeof DracoDecoderModule) return !0;\n        var e = r.Configuration.decoder;\n\n        if (e) {\n          if (e.wasmUrl && e.wasmBinaryUrl && \"object\" == typeof WebAssembly) return !0;\n          if (e.fallbackUrl) return !0;\n        }\n\n        return !1;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype.dispose = function () {}, r.prototype.decodeMeshAsync = function (e, y) {\n      var b = e instanceof ArrayBuffer ? new Uint8Array(e) : e;\n      return r._GetDecoderModule().then(function (e) {\n        var t = e.module,\n            i = new gi.VertexData(),\n            r = new t.DecoderBuffer();\n        r.Init(b, b.byteLength);\n        var n,\n            o,\n            s = new t.Decoder();\n\n        try {\n          var a = s.GetEncodedGeometryType(r);\n\n          switch (a) {\n            case t.TRIANGULAR_MESH:\n              n = new t.Mesh(), o = s.DecodeBufferToMesh(r, n);\n              break;\n\n            case t.POINT_CLOUD:\n              n = new t.PointCloud(), o = s.DecodeBufferToPointCloud(r, n);\n              break;\n\n            default:\n              throw new Error(\"Invalid geometry type \" + a);\n          }\n\n          if (!o.ok() || !n.ptr) throw new Error(o.error_msg());\n          var l = n.num_points();\n\n          if (a === t.TRIANGULAR_MESH) {\n            var c = n.num_faces(),\n                h = new t.DracoInt32Array();\n\n            try {\n              for (var u = new Uint32Array(3 * c), d = 0; d < c; d++) {\n                s.GetFaceFromMesh(n, d, h);\n                var f = 3 * d;\n                u[f + 0] = h.GetValue(0), u[f + 1] = h.GetValue(1), u[f + 2] = h.GetValue(2);\n              }\n\n              i.indices = u;\n            } finally {\n              t.destroy(h);\n            }\n          }\n\n          for (var p in y) {\n            var _ = y[p],\n                m = s.GetAttributeByUniqueId(n, _),\n                g = new t.DracoFloat32Array();\n\n            try {\n              s.GetAttributeFloatForAllPoints(n, m, g);\n              var v = new Float32Array(l * m.num_components());\n\n              for (d = 0; d < v.length; d++) v[d] = g.GetValue(d);\n\n              i.set(v, p);\n            } finally {\n              t.destroy(g);\n            }\n          }\n        } finally {\n          n && t.destroy(n), t.destroy(s), t.destroy(r);\n        }\n\n        return i;\n      });\n    }, r._GetDecoderModule = function () {\n      if (!r._DecoderModulePromise) {\n        var e = null,\n            i = {};\n        if (\"undefined\" != typeof DracoDecoderModule) e = Promise.resolve();else {\n          var t = r.Configuration.decoder;\n          t && (t.wasmUrl && t.wasmBinaryUrl && \"object\" == typeof WebAssembly ? e = Promise.all([r._LoadScriptAsync(t.wasmUrl), r._LoadFileAsync(t.wasmBinaryUrl).then(function (e) {\n            i.wasmBinary = e;\n          })]) : t.fallbackUrl && (e = r._LoadScriptAsync(t.fallbackUrl)));\n        }\n        if (!e) throw new Error(\"Draco decoder module is not available\");\n        r._DecoderModulePromise = e.then(function () {\n          return new Promise(function (t) {\n            i.onModuleLoaded = function (e) {\n              t({\n                module: e\n              });\n            }, DracoDecoderModule(i);\n          });\n        });\n      }\n\n      return r._DecoderModulePromise;\n    }, r._LoadScriptAsync = function (i) {\n      return new Promise(function (e, t) {\n        gi.Tools.LoadScript(i, function () {\n          e();\n        }, function (e) {\n          t(new Error(e));\n        });\n      });\n    }, r._LoadFileAsync = function (e) {\n      return new Promise(function (t, i) {\n        gi.Tools.LoadFile(e, function (e) {\n          t(e);\n        }, void 0, void 0, !0, function (e, t) {\n          i(t);\n        });\n      });\n    }, r.Configuration = {\n      decoder: {\n        wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n        wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n        fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n      }\n    }, r;\n  }(), gi.DracoCompression = vi, function (r) {\n    r.Engine.AudioEngineFactory = function (e) {\n      return new t(e);\n    };\n\n    var t = function () {\n      function e(e) {\n        void 0 === e && (e = null);\n        var t = this;\n        this._audioContext = null, this._audioContextInitialized = !1, this._muteButton = null, this.canUseWebAudio = !1, this.WarnedWebAudioUnsupported = !1, this.isMP3supported = !1, this.isOGGsupported = !1, this.unlocked = !0, this.useCustomUnlockedButton = !1, this.onAudioUnlockedObservable = new r.Observable(), this.onAudioLockedObservable = new r.Observable(), this._tryToRun = !1, this._onResize = function () {\n          t._moveButtonToTopLeft();\n        }, void 0 === window.AudioContext && void 0 === window.webkitAudioContext || (window.AudioContext = window.AudioContext || window.webkitAudioContext, this.canUseWebAudio = !0);\n        var i = document.createElement(\"audio\");\n        this._hostElement = e;\n\n        try {\n          i && i.canPlayType && i.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, \"\") && (this.isMP3supported = !0);\n        } catch (e) {}\n\n        try {\n          i && i.canPlayType && i.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\") && (this.isOGGsupported = !0);\n        } catch (e) {}\n      }\n\n      return Object.defineProperty(e.prototype, \"audioContext\", {\n        get: function () {\n          return this._audioContextInitialized ? this.unlocked || this._muteButton || this._displayMuteButton() : this._initializeAudioContext(), this._audioContext;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.lock = function () {\n        this._triggerSuspendedState();\n      }, e.prototype.unlock = function () {\n        this._triggerRunningState();\n      }, e.prototype._resumeAudioContext = function () {\n        var e;\n        return this._audioContext.resume && (e = this._audioContext.resume()), e || Promise.resolve();\n      }, e.prototype._initializeAudioContext = function () {\n        try {\n          this.canUseWebAudio && (this._audioContext = new AudioContext(), this.masterGain = this._audioContext.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this._audioContext.destination), this._audioContextInitialized = !0, \"running\" === this._audioContext.state && this._triggerRunningState());\n        } catch (e) {\n          this.canUseWebAudio = !1, r.Tools.Error(\"Web Audio: \" + e.message);\n        }\n      }, e.prototype._triggerRunningState = function () {\n        var e = this;\n        this._tryToRun || (this._tryToRun = !0, this._resumeAudioContext().then(function () {\n          e._tryToRun = !1, e._muteButton && e._hideMuteButton();\n        }).catch(function () {\n          e._tryToRun = !1, e.unlocked = !1;\n        }), this.unlocked = !0, this.onAudioUnlockedObservable.notifyObservers(this));\n      }, e.prototype._triggerSuspendedState = function () {\n        this.unlocked = !1, this.onAudioLockedObservable.notifyObservers(this), this._displayMuteButton();\n      }, e.prototype._displayMuteButton = function () {\n        var e = this;\n\n        if (!this.useCustomUnlockedButton) {\n          this._muteButton = document.createElement(\"BUTTON\"), this._muteButton.className = \"babylonUnmuteIcon\", this._muteButton.id = \"babylonUnmuteIconBtn\", this._muteButton.title = \"Unmute\";\n          var t = document.createElement(\"style\");\n          t.appendChild(document.createTextNode(\".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E);  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }\")), document.getElementsByTagName(\"head\")[0].appendChild(t), document.body.appendChild(this._muteButton), this._moveButtonToTopLeft(), this._muteButton.addEventListener(\"touchend\", function () {\n            e._triggerRunningState();\n          }, !0), this._muteButton.addEventListener(\"click\", function () {\n            e._triggerRunningState();\n          }, !0), window.addEventListener(\"resize\", this._onResize);\n        }\n      }, e.prototype._moveButtonToTopLeft = function () {\n        this._hostElement && this._muteButton && (this._muteButton.style.top = this._hostElement.offsetTop + 20 + \"px\", this._muteButton.style.left = this._hostElement.offsetLeft + 20 + \"px\");\n      }, e.prototype._hideMuteButton = function () {\n        this._muteButton && (document.body.removeChild(this._muteButton), this._muteButton = null);\n      }, e.prototype.dispose = function () {\n        this.canUseWebAudio && this._audioContextInitialized && (this._connectedAnalyser && this._audioContext && (this._connectedAnalyser.stopDebugCanvas(), this._connectedAnalyser.dispose(), this.masterGain.disconnect(), this.masterGain.connect(this._audioContext.destination), this._connectedAnalyser = null), this.masterGain.gain.value = 1), this.WarnedWebAudioUnsupported = !1, this._hideMuteButton(), window.removeEventListener(\"resize\", this._onResize), this.onAudioUnlockedObservable.clear(), this.onAudioLockedObservable.clear();\n      }, e.prototype.getGlobalVolume = function () {\n        return this.canUseWebAudio && this._audioContextInitialized ? this.masterGain.gain.value : -1;\n      }, e.prototype.setGlobalVolume = function (e) {\n        this.canUseWebAudio && this._audioContextInitialized && (this.masterGain.gain.value = e);\n      }, e.prototype.connectToAnalyser = function (e) {\n        this._connectedAnalyser && this._connectedAnalyser.stopDebugCanvas(), this.canUseWebAudio && this._audioContextInitialized && this._audioContext && (this._connectedAnalyser = e, this.masterGain.disconnect(), this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination));\n      }, e;\n    }();\n\n    r.AudioEngine = t;\n  }($a || ($a = {})), yi = $a || ($a = {}), bi = function () {\n    function d(e, t, i, r, n) {\n      void 0 === r && (r = null);\n      var o = this;\n      this.autoplay = !1, this.loop = !1, this.useCustomAttenuation = !1, this.isPlaying = !1, this.isPaused = !1, this.spatialSound = !1, this.refDistance = 1, this.rolloffFactor = 1, this.maxDistance = 100, this.distanceModel = \"linear\", this.onEndedObservable = new yi.Observable(), this._panningModel = \"equalpower\", this._playbackRate = 1, this._streaming = !1, this._startTime = 0, this._startOffset = 0, this._position = yi.Vector3.Zero(), this._positionInEmitterSpace = !1, this._localDirection = new yi.Vector3(1, 0, 0), this._volume = 1, this._isReadyToPlay = !1, this._isDirectional = !1, this._coneInnerAngle = 360, this._coneOuterAngle = 360, this._coneOuterGain = 0, this._isOutputConnected = !1, this._urlType = \"Unknown\", this.name = e;\n\n      var s = (this._scene = i)._getComponent(yi.SceneComponentConstants.NAME_AUDIO);\n\n      if (s || (s = new yi.AudioSceneComponent(i), i._addComponent(s)), this._readyToPlayCallback = r, this._customAttenuationFunction = function (e, t, i, r, n) {\n        return t < i ? e * (1 - t / i) : 0;\n      }, n && (this.autoplay = n.autoplay || !1, this.loop = n.loop || !1, void 0 !== n.volume && (this._volume = n.volume), this.spatialSound = n.spatialSound || !1, this.maxDistance = n.maxDistance || 100, this.useCustomAttenuation = n.useCustomAttenuation || !1, this.rolloffFactor = n.rolloffFactor || 1, this.refDistance = n.refDistance || 1, this.distanceModel = n.distanceModel || \"linear\", this._playbackRate = n.playbackRate || 1, this._streaming = n.streaming || !1), yi.Engine.audioEngine.canUseWebAudio && yi.Engine.audioEngine.audioContext) {\n        this._soundGain = yi.Engine.audioEngine.audioContext.createGain(), this._soundGain.gain.value = this._volume, this._inputAudioNode = this._soundGain, this._outputAudioNode = this._soundGain, this.spatialSound && this._createSpatialParameters(), this._scene.mainSoundTrack.AddSound(this);\n        var a = !0;\n        if (t) try {\n          \"string\" == typeof t ? this._urlType = \"String\" : t instanceof ArrayBuffer ? this._urlType = \"ArrayBuffer\" : t instanceof MediaStream ? this._urlType = \"MediaStream\" : Array.isArray(t) && (this._urlType = \"Array\");\n          var l = [],\n              c = !1;\n\n          switch (this._urlType) {\n            case \"MediaStream\":\n              this._streaming = !0, this._isReadyToPlay = !0, this._streamingSource = yi.Engine.audioEngine.audioContext.createMediaElementSource(t), this.autoplay && this.play(), this._readyToPlayCallback && this._readyToPlayCallback();\n              break;\n\n            case \"ArrayBuffer\":\n              0 < t.byteLength && (c = !0, this._soundLoaded(t));\n              break;\n\n            case \"String\":\n              l.push(t);\n\n            case \"Array\":\n              0 === l.length && (l = t);\n\n              for (var h = 0; h < l.length; h++) {\n                var u = l[h];\n\n                if (-1 !== u.indexOf(\".mp3\", u.length - 4) && yi.Engine.audioEngine.isMP3supported && (c = !0), -1 !== u.indexOf(\".ogg\", u.length - 4) && yi.Engine.audioEngine.isOGGsupported && (c = !0), -1 !== u.indexOf(\".wav\", u.length - 4) && (c = !0), -1 !== u.indexOf(\"blob:\") && (c = !0), c) {\n                  this._streaming ? (this._htmlAudioElement = new Audio(u), this._htmlAudioElement.controls = !1, this._htmlAudioElement.loop = this.loop, yi.Tools.SetCorsBehavior(u, this._htmlAudioElement), this._htmlAudioElement.preload = \"auto\", this._htmlAudioElement.addEventListener(\"canplaythrough\", function () {\n                    o._isReadyToPlay = !0, o.autoplay && o.play(), o._readyToPlayCallback && o._readyToPlayCallback();\n                  }), document.body.appendChild(this._htmlAudioElement), this._htmlAudioElement.load()) : this._scene._loadFile(u, function (e) {\n                    o._soundLoaded(e);\n                  }, void 0, !0, !0, function (e) {\n                    e && yi.Tools.Error(\"XHR \" + e.status + \" error on: \" + u + \".\"), yi.Tools.Error(\"Sound creation aborted.\"), o._scene.mainSoundTrack.RemoveSound(o);\n                  });\n                  break;\n                }\n              }\n\n              break;\n\n            default:\n              a = !1;\n          }\n\n          a ? c || (this._isReadyToPlay = !0, this._readyToPlayCallback && window.setTimeout(function () {\n            o._readyToPlayCallback && o._readyToPlayCallback();\n          }, 1e3)) : yi.Tools.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n        } catch (e) {\n          yi.Tools.Error(\"Unexpected error. Sound creation aborted.\"), this._scene.mainSoundTrack.RemoveSound(this);\n        }\n      } else this._scene.mainSoundTrack.AddSound(this), yi.Engine.audioEngine.WarnedWebAudioUnsupported || (yi.Tools.Error(\"Web Audio is not supported by your browser.\"), yi.Engine.audioEngine.WarnedWebAudioUnsupported = !0), this._readyToPlayCallback && window.setTimeout(function () {\n        o._readyToPlayCallback && o._readyToPlayCallback();\n      }, 1e3);\n    }\n\n    return d.prototype.dispose = function () {\n      yi.Engine.audioEngine.canUseWebAudio && (this.isPlaying && this.stop(), this._isReadyToPlay = !1, -1 === this.soundTrackId ? this._scene.mainSoundTrack.RemoveSound(this) : this._scene.soundTracks && this._scene.soundTracks[this.soundTrackId].RemoveSound(this), this._soundGain && (this._soundGain.disconnect(), this._soundGain = null), this._soundPanner && (this._soundPanner.disconnect(), this._soundPanner = null), this._soundSource && (this._soundSource.disconnect(), this._soundSource = null), this._audioBuffer = null, this._htmlAudioElement && (this._htmlAudioElement.pause(), this._htmlAudioElement.src = \"\", document.body.removeChild(this._htmlAudioElement)), this._streamingSource && this._streamingSource.disconnect(), this._connectedMesh && this._registerFunc && (this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._connectedMesh = null));\n    }, d.prototype.isReady = function () {\n      return this._isReadyToPlay;\n    }, d.prototype._soundLoaded = function (e) {\n      var t = this;\n      yi.Engine.audioEngine.audioContext && yi.Engine.audioEngine.audioContext.decodeAudioData(e, function (e) {\n        t._audioBuffer = e, t._isReadyToPlay = !0, t.autoplay && t.play(), t._readyToPlayCallback && t._readyToPlayCallback();\n      }, function (e) {\n        yi.Tools.Error(\"Error while decoding audio data for: \" + t.name + \" / Error: \" + e);\n      });\n    }, d.prototype.setAudioBuffer = function (e) {\n      yi.Engine.audioEngine.canUseWebAudio && (this._audioBuffer = e, this._isReadyToPlay = !0);\n    }, d.prototype.updateOptions = function (e) {\n      e && (this.loop = e.loop || this.loop, this.maxDistance = e.maxDistance || this.maxDistance, this.useCustomAttenuation = e.useCustomAttenuation || this.useCustomAttenuation, this.rolloffFactor = e.rolloffFactor || this.rolloffFactor, this.refDistance = e.refDistance || this.refDistance, this.distanceModel = e.distanceModel || this.distanceModel, this._playbackRate = e.playbackRate || this._playbackRate, this._updateSpatialParameters(), this.isPlaying && (this._streaming && this._htmlAudioElement ? this._htmlAudioElement.playbackRate = this._playbackRate : this._soundSource && (this._soundSource.playbackRate.value = this._playbackRate)));\n    }, d.prototype._createSpatialParameters = function () {\n      yi.Engine.audioEngine.canUseWebAudio && yi.Engine.audioEngine.audioContext && (this._scene.headphone && (this._panningModel = \"HRTF\"), this._soundPanner = yi.Engine.audioEngine.audioContext.createPanner(), this._updateSpatialParameters(), this._soundPanner.connect(this._outputAudioNode), this._inputAudioNode = this._soundPanner);\n    }, d.prototype._updateSpatialParameters = function () {\n      this.spatialSound && this._soundPanner && (this.useCustomAttenuation ? (this._soundPanner.distanceModel = \"linear\", this._soundPanner.maxDistance = Number.MAX_VALUE, this._soundPanner.refDistance = 1, this._soundPanner.rolloffFactor = 1) : (this._soundPanner.distanceModel = this.distanceModel, this._soundPanner.maxDistance = this.maxDistance, this._soundPanner.refDistance = this.refDistance, this._soundPanner.rolloffFactor = this.rolloffFactor), this._soundPanner.panningModel = this._panningModel);\n    }, d.prototype.switchPanningModelToHRTF = function () {\n      this._panningModel = \"HRTF\", this._switchPanningModel();\n    }, d.prototype.switchPanningModelToEqualPower = function () {\n      this._panningModel = \"equalpower\", this._switchPanningModel();\n    }, d.prototype._switchPanningModel = function () {\n      yi.Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && (this._soundPanner.panningModel = this._panningModel);\n    }, d.prototype.connectToSoundTrackAudioNode = function (e) {\n      yi.Engine.audioEngine.canUseWebAudio && (this._isOutputConnected && this._outputAudioNode.disconnect(), this._outputAudioNode.connect(e), this._isOutputConnected = !0);\n    }, d.prototype.setDirectionalCone = function (e, t, i) {\n      t < e ? yi.Tools.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\") : (this._coneInnerAngle = e, this._coneOuterAngle = t, this._coneOuterGain = i, this._isDirectional = !0, this.isPlaying && this.loop && (this.stop(), this.play()));\n    }, Object.defineProperty(d.prototype, \"directionalConeInnerAngle\", {\n      get: function () {\n        return this._coneInnerAngle;\n      },\n      set: function (e) {\n        if (e != this._coneInnerAngle) {\n          if (this._coneOuterAngle < e) return void yi.Tools.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          this._coneInnerAngle = e, yi.Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && (this._soundPanner.coneInnerAngle = this._coneInnerAngle);\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"directionalConeOuterAngle\", {\n      get: function () {\n        return this._coneOuterAngle;\n      },\n      set: function (e) {\n        if (e != this._coneOuterAngle) {\n          if (e < this._coneInnerAngle) return void yi.Tools.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          this._coneOuterAngle = e, yi.Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && (this._soundPanner.coneOuterAngle = this._coneOuterAngle);\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), d.prototype.setPosition = function (e) {\n      this._position = e, yi.Engine.audioEngine.canUseWebAudio && this.spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z) && this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\n    }, d.prototype.setLocalDirectionToMesh = function (e) {\n      this._localDirection = e, yi.Engine.audioEngine.canUseWebAudio && this._connectedMesh && this.isPlaying && this._updateDirection();\n    }, d.prototype._updateDirection = function () {\n      if (this._connectedMesh && this._soundPanner) {\n        var e = this._connectedMesh.getWorldMatrix(),\n            t = yi.Vector3.TransformNormal(this._localDirection, e);\n\n        t.normalize(), this._soundPanner.setOrientation(t.x, t.y, t.z);\n      }\n    }, d.prototype.updateDistanceFromListener = function () {\n      if (yi.Engine.audioEngine.canUseWebAudio && this._connectedMesh && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\n        var e = this._connectedMesh.getDistanceToCamera(this._scene.activeCamera);\n\n        this._soundGain.gain.value = this._customAttenuationFunction(this._volume, e, this.maxDistance, this.refDistance, this.rolloffFactor);\n      }\n    }, d.prototype.setAttenuationFunction = function (e) {\n      this._customAttenuationFunction = e;\n    }, d.prototype.play = function (e, t) {\n      var i = this;\n      if (this._isReadyToPlay && this._scene.audioEnabled && yi.Engine.audioEngine.audioContext) try {\n        this._startOffset < 0 && (e = -this._startOffset, this._startOffset = 0);\n        var r = e ? yi.Engine.audioEngine.audioContext.currentTime + e : yi.Engine.audioEngine.audioContext.currentTime;\n\n        if (this._soundSource && this._streamingSource || this.spatialSound && this._soundPanner && (isNaN(this._position.x) || isNaN(this._position.y) || isNaN(this._position.z) || this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z), this._isDirectional && (this._soundPanner.coneInnerAngle = this._coneInnerAngle, this._soundPanner.coneOuterAngle = this._coneOuterAngle, this._soundPanner.coneOuterGain = this._coneOuterGain, this._connectedMesh ? this._updateDirection() : this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z))), this._streaming) {\n          if (this._streamingSource || (this._streamingSource = yi.Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement), this._htmlAudioElement.onended = function () {\n            i._onended();\n          }, this._htmlAudioElement.playbackRate = this._playbackRate), this._streamingSource.disconnect(), this._streamingSource.connect(this._inputAudioNode), this._htmlAudioElement) {\n            var n = function () {\n              if (yi.Engine.audioEngine.unlocked) {\n                var e = i._htmlAudioElement.play();\n\n                void 0 !== e && e.catch(function (e) {\n                  yi.Engine.audioEngine.lock(), yi.Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                    n();\n                  });\n                });\n              } else yi.Engine.audioEngine.onAudioUnlockedObservable.addOnce(function () {\n                n();\n              });\n            };\n\n            n();\n          }\n        } else this._soundSource = yi.Engine.audioEngine.audioContext.createBufferSource(), this._soundSource.buffer = this._audioBuffer, this._soundSource.connect(this._inputAudioNode), this._soundSource.loop = this.loop, this._soundSource.playbackRate.value = this._playbackRate, this._soundSource.onended = function () {\n          i._onended();\n        }, this._soundSource.buffer && this._soundSource.start(r, this.isPaused ? this._startOffset % this._soundSource.buffer.duration : t || 0);\n\n        this._startTime = r, this.isPlaying = !0, this.isPaused = !1;\n      } catch (e) {\n        yi.Tools.Error(\"Error while trying to play audio: \" + this.name + \", \" + e.message);\n      }\n    }, d.prototype._onended = function () {\n      this.isPlaying = !1, this.onended && this.onended(), this.onEndedObservable.notifyObservers(this);\n    }, d.prototype.stop = function (e) {\n      if (this.isPlaying) {\n        if (this._streaming) this._htmlAudioElement ? (this._htmlAudioElement.pause(), 0 < this._htmlAudioElement.currentTime && (this._htmlAudioElement.currentTime = 0)) : this._streamingSource.disconnect();else if (yi.Engine.audioEngine.audioContext && this._soundSource) {\n          var t = e ? yi.Engine.audioEngine.audioContext.currentTime + e : yi.Engine.audioEngine.audioContext.currentTime;\n          this._soundSource.stop(t), this._soundSource.onended = function () {}, this.isPaused || (this._startOffset = 0);\n        }\n        this.isPlaying = !1;\n      }\n    }, d.prototype.pause = function () {\n      this.isPlaying && (this.isPaused = !0, this._streaming ? this._htmlAudioElement ? this._htmlAudioElement.pause() : this._streamingSource.disconnect() : yi.Engine.audioEngine.audioContext && (this.stop(0), this._startOffset += yi.Engine.audioEngine.audioContext.currentTime - this._startTime));\n    }, d.prototype.setVolume = function (e, t) {\n      yi.Engine.audioEngine.canUseWebAudio && this._soundGain && (t && yi.Engine.audioEngine.audioContext ? (this._soundGain.gain.cancelScheduledValues(yi.Engine.audioEngine.audioContext.currentTime), this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, yi.Engine.audioEngine.audioContext.currentTime), this._soundGain.gain.linearRampToValueAtTime(e, yi.Engine.audioEngine.audioContext.currentTime + t)) : this._soundGain.gain.value = e), this._volume = e;\n    }, d.prototype.setPlaybackRate = function (e) {\n      this._playbackRate = e, this.isPlaying && (this._streaming && this._htmlAudioElement ? this._htmlAudioElement.playbackRate = this._playbackRate : this._soundSource && (this._soundSource.playbackRate.value = this._playbackRate));\n    }, d.prototype.getVolume = function () {\n      return this._volume;\n    }, d.prototype.attachToMesh = function (e) {\n      var t = this;\n      this._connectedMesh && this._registerFunc && (this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._registerFunc = null), this._connectedMesh = e, this.spatialSound || (this.spatialSound = !0, this._createSpatialParameters(), this.isPlaying && this.loop && (this.stop(), this.play())), this._onRegisterAfterWorldMatrixUpdate(this._connectedMesh), this._registerFunc = function (e) {\n        return t._onRegisterAfterWorldMatrixUpdate(e);\n      }, e.registerAfterWorldMatrixUpdate(this._registerFunc);\n    }, d.prototype.detachFromMesh = function () {\n      this._connectedMesh && this._registerFunc && (this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc), this._registerFunc = null, this._connectedMesh = null);\n    }, d.prototype._onRegisterAfterWorldMatrixUpdate = function (e) {\n      if (e.getBoundingInfo) {\n        var t = e;\n        if (this._positionInEmitterSpace) t.worldMatrixFromCache.invertToRef(yi.Tmp.Matrix[0]), this.setPosition(yi.Tmp.Matrix[0].getTranslation());else {\n          var i = t.getBoundingInfo();\n          this.setPosition(i.boundingSphere.centerWorld);\n        }\n        yi.Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying && this._updateDirection();\n      }\n    }, d.prototype.clone = function () {\n      var e = this;\n      if (this._streaming) return null;\n\n      var t = function () {\n        e._isReadyToPlay ? (r._audioBuffer = e.getAudioBuffer(), r._isReadyToPlay = !0, r.autoplay && r.play()) : window.setTimeout(t, 300);\n      },\n          i = {\n        autoplay: this.autoplay,\n        loop: this.loop,\n        volume: this._volume,\n        spatialSound: this.spatialSound,\n        maxDistance: this.maxDistance,\n        useCustomAttenuation: this.useCustomAttenuation,\n        rolloffFactor: this.rolloffFactor,\n        refDistance: this.refDistance,\n        distanceModel: this.distanceModel\n      },\n          r = new d(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, i);\n\n      return this.useCustomAttenuation && r.setAttenuationFunction(this._customAttenuationFunction), r.setPosition(this._position), r.setPlaybackRate(this._playbackRate), t(), r;\n    }, d.prototype.getAudioBuffer = function () {\n      return this._audioBuffer;\n    }, d.prototype.serialize = function () {\n      var e = {\n        name: this.name,\n        url: this.name,\n        autoplay: this.autoplay,\n        loop: this.loop,\n        volume: this._volume,\n        spatialSound: this.spatialSound,\n        maxDistance: this.maxDistance,\n        rolloffFactor: this.rolloffFactor,\n        refDistance: this.refDistance,\n        distanceModel: this.distanceModel,\n        playbackRate: this._playbackRate,\n        panningModel: this._panningModel,\n        soundTrackId: this.soundTrackId\n      };\n      return this.spatialSound && (this._connectedMesh && (e.connectedMeshId = this._connectedMesh.id), e.position = this._position.asArray(), e.refDistance = this.refDistance, e.distanceModel = this.distanceModel, e.isDirectional = this._isDirectional, e.localDirectionToMesh = this._localDirection.asArray(), e.coneInnerAngle = this._coneInnerAngle, e.coneOuterAngle = this._coneOuterAngle, e.coneOuterGain = this._coneOuterGain), e;\n    }, d.Parse = function (e, t, i, r) {\n      var n,\n          o = e.name;\n      n = e.url ? i + e.url : i + o;\n      var s,\n          a = {\n        autoplay: e.autoplay,\n        loop: e.loop,\n        volume: e.volume,\n        spatialSound: e.spatialSound,\n        maxDistance: e.maxDistance,\n        rolloffFactor: e.rolloffFactor,\n        refDistance: e.refDistance,\n        distanceModel: e.distanceModel,\n        playbackRate: e.playbackRate\n      };\n\n      if (r) {\n        var l = function () {\n          r._isReadyToPlay ? (s._audioBuffer = r.getAudioBuffer(), s._isReadyToPlay = !0, s.autoplay && s.play()) : window.setTimeout(l, 300);\n        };\n\n        s = new d(o, new ArrayBuffer(0), t, null, a), l();\n      } else s = new d(o, n, t, function () {\n        t._removePendingData(s);\n      }, a), t._addPendingData(s);\n\n      if (e.position) {\n        var c = yi.Vector3.FromArray(e.position);\n        s.setPosition(c);\n      }\n\n      if (e.isDirectional && (s.setDirectionalCone(e.coneInnerAngle || 360, e.coneOuterAngle || 360, e.coneOuterGain || 0), e.localDirectionToMesh)) {\n        var h = yi.Vector3.FromArray(e.localDirectionToMesh);\n        s.setLocalDirectionToMesh(h);\n      }\n\n      if (e.connectedMeshId) {\n        var u = t.getMeshByID(e.connectedMeshId);\n        u && s.attachToMesh(u);\n      }\n\n      return s;\n    }, d;\n  }(), yi.Sound = bi, Ti = $a || ($a = {}), Ei = function () {\n    function e(e, t) {\n      void 0 === t && (t = {}), this.id = -1, this._isMainTrack = !1, this._isInitialized = !1, this._scene = e, this.soundCollection = new Array(), this._options = t, !this._isMainTrack && this._scene.soundTracks && (this._scene.soundTracks.push(this), this.id = this._scene.soundTracks.length - 1);\n    }\n\n    return e.prototype._initializeSoundTrackAudioGraph = function () {\n      Ti.Engine.audioEngine.canUseWebAudio && Ti.Engine.audioEngine.audioContext && (this._outputAudioNode = Ti.Engine.audioEngine.audioContext.createGain(), this._outputAudioNode.connect(Ti.Engine.audioEngine.masterGain), this._options && (this._options.volume && (this._outputAudioNode.gain.value = this._options.volume), this._options.mainTrack && (this._isMainTrack = this._options.mainTrack)), this._isInitialized = !0);\n    }, e.prototype.dispose = function () {\n      if (Ti.Engine.audioEngine && Ti.Engine.audioEngine.canUseWebAudio) {\n        for (this._connectedAnalyser && this._connectedAnalyser.stopDebugCanvas(); this.soundCollection.length;) this.soundCollection[0].dispose();\n\n        this._outputAudioNode && this._outputAudioNode.disconnect(), this._outputAudioNode = null;\n      }\n    }, e.prototype.AddSound = function (e) {\n      this._isInitialized || this._initializeSoundTrackAudioGraph(), Ti.Engine.audioEngine.canUseWebAudio && this._outputAudioNode && e.connectToSoundTrackAudioNode(this._outputAudioNode), e.soundTrackId && (-1 === e.soundTrackId ? this._scene.mainSoundTrack.RemoveSound(e) : this._scene.soundTracks && this._scene.soundTracks[e.soundTrackId].RemoveSound(e)), this.soundCollection.push(e), e.soundTrackId = this.id;\n    }, e.prototype.RemoveSound = function (e) {\n      var t = this.soundCollection.indexOf(e);\n      -1 !== t && this.soundCollection.splice(t, 1);\n    }, e.prototype.setVolume = function (e) {\n      Ti.Engine.audioEngine.canUseWebAudio && this._outputAudioNode && (this._outputAudioNode.gain.value = e);\n    }, e.prototype.switchPanningModelToHRTF = function () {\n      if (Ti.Engine.audioEngine.canUseWebAudio) for (var e = 0; e < this.soundCollection.length; e++) this.soundCollection[e].switchPanningModelToHRTF();\n    }, e.prototype.switchPanningModelToEqualPower = function () {\n      if (Ti.Engine.audioEngine.canUseWebAudio) for (var e = 0; e < this.soundCollection.length; e++) this.soundCollection[e].switchPanningModelToEqualPower();\n    }, e.prototype.connectToAnalyser = function (e) {\n      this._connectedAnalyser && this._connectedAnalyser.stopDebugCanvas(), this._connectedAnalyser = e, Ti.Engine.audioEngine.canUseWebAudio && this._outputAudioNode && (this._outputAudioNode.disconnect(), this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, Ti.Engine.audioEngine.masterGain));\n    }, e;\n  }(), Ti.SoundTrack = Ei, xi = $a || ($a = {}), Pi = function () {\n    function e(e) {\n      this.SMOOTHING = .75, this.FFT_SIZE = 512, this.BARGRAPHAMPLITUDE = 256, this.DEBUGCANVASPOS = {\n        x: 20,\n        y: 20\n      }, this.DEBUGCANVASSIZE = {\n        width: 320,\n        height: 200\n      }, this._scene = e, this._audioEngine = xi.Engine.audioEngine, this._audioEngine.canUseWebAudio && this._audioEngine.audioContext && (this._webAudioAnalyser = this._audioEngine.audioContext.createAnalyser(), this._webAudioAnalyser.minDecibels = -140, this._webAudioAnalyser.maxDecibels = 0, this._byteFreqs = new Uint8Array(this._webAudioAnalyser.frequencyBinCount), this._byteTime = new Uint8Array(this._webAudioAnalyser.frequencyBinCount), this._floatFreqs = new Float32Array(this._webAudioAnalyser.frequencyBinCount));\n    }\n\n    return e.prototype.getFrequencyBinCount = function () {\n      return this._audioEngine.canUseWebAudio ? this._webAudioAnalyser.frequencyBinCount : 0;\n    }, e.prototype.getByteFrequencyData = function () {\n      return this._audioEngine.canUseWebAudio && (this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING, this._webAudioAnalyser.fftSize = this.FFT_SIZE, this._webAudioAnalyser.getByteFrequencyData(this._byteFreqs)), this._byteFreqs;\n    }, e.prototype.getByteTimeDomainData = function () {\n      return this._audioEngine.canUseWebAudio && (this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING, this._webAudioAnalyser.fftSize = this.FFT_SIZE, this._webAudioAnalyser.getByteTimeDomainData(this._byteTime)), this._byteTime;\n    }, e.prototype.getFloatFrequencyData = function () {\n      return this._audioEngine.canUseWebAudio && (this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING, this._webAudioAnalyser.fftSize = this.FFT_SIZE, this._webAudioAnalyser.getFloatFrequencyData(this._floatFreqs)), this._floatFreqs;\n    }, e.prototype.drawDebugCanvas = function () {\n      var e = this;\n\n      if (this._audioEngine.canUseWebAudio && (this._debugCanvas || (this._debugCanvas = document.createElement(\"canvas\"), this._debugCanvas.width = this.DEBUGCANVASSIZE.width, this._debugCanvas.height = this.DEBUGCANVASSIZE.height, this._debugCanvas.style.position = \"absolute\", this._debugCanvas.style.top = this.DEBUGCANVASPOS.y + \"px\", this._debugCanvas.style.left = this.DEBUGCANVASPOS.x + \"px\", this._debugCanvasContext = this._debugCanvas.getContext(\"2d\"), document.body.appendChild(this._debugCanvas), this._registerFunc = function () {\n        e.drawDebugCanvas();\n      }, this._scene.registerBeforeRender(this._registerFunc)), this._registerFunc && this._debugCanvasContext)) {\n        var t = this.getByteFrequencyData();\n        this._debugCanvasContext.fillStyle = \"rgb(0, 0, 0)\", this._debugCanvasContext.fillRect(0, 0, this.DEBUGCANVASSIZE.width, this.DEBUGCANVASSIZE.height);\n\n        for (var i = 0; i < this.getFrequencyBinCount(); i++) {\n          var r = t[i] / this.BARGRAPHAMPLITUDE,\n              n = this.DEBUGCANVASSIZE.height * r,\n              o = this.DEBUGCANVASSIZE.height - n - 1,\n              s = this.DEBUGCANVASSIZE.width / this.getFrequencyBinCount(),\n              a = i / this.getFrequencyBinCount() * 360;\n          this._debugCanvasContext.fillStyle = \"hsl(\" + a + \", 100%, 50%)\", this._debugCanvasContext.fillRect(i * s, o, s, n);\n        }\n      }\n    }, e.prototype.stopDebugCanvas = function () {\n      this._debugCanvas && (this._registerFunc && (this._scene.unregisterBeforeRender(this._registerFunc), this._registerFunc = null), document.body.removeChild(this._debugCanvas), this._debugCanvas = null, this._debugCanvasContext = null);\n    }, e.prototype.connectAudioNodes = function (e, t) {\n      this._audioEngine.canUseWebAudio && (e.connect(this._webAudioAnalyser), this._webAudioAnalyser.connect(t));\n    }, e.prototype.dispose = function () {\n      this._audioEngine.canUseWebAudio && this._webAudioAnalyser.disconnect();\n    }, e;\n  }(), xi.Analyser = Pi, Ai = $a || ($a = {}), Si = function () {\n    function e(e, t, i) {\n      var r = this;\n      if (this.loop = !1, this._coneInnerAngle = 360, this._coneOuterAngle = 360, this._volume = 1, this.isPlaying = !1, this.isPaused = !1, this._sounds = [], this._weights = [], t.length !== i.length) throw new Error(\"Sounds length does not equal weights length\");\n      this.loop = e;\n\n      for (var n = 0, o = 0, s = this._weights = i; o < s.length; o++) {\n        n += s[o];\n      }\n\n      for (var a = 0 < n ? 1 / n : 0, l = 0; l < this._weights.length; l++) this._weights[l] *= a;\n\n      this._sounds = t;\n\n      for (var c = 0, h = this._sounds; c < h.length; c++) {\n        h[c].onEndedObservable.add(function () {\n          r._onended();\n        });\n      }\n    }\n\n    return Object.defineProperty(e.prototype, \"directionalConeInnerAngle\", {\n      get: function () {\n        return this._coneInnerAngle;\n      },\n      set: function (e) {\n        if (e !== this._coneInnerAngle) {\n          if (this._coneOuterAngle < e) return void Ai.Tools.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          this._coneInnerAngle = e;\n\n          for (var t = 0, i = this._sounds; t < i.length; t++) {\n            i[t].directionalConeInnerAngle = e;\n          }\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"directionalConeOuterAngle\", {\n      get: function () {\n        return this._coneOuterAngle;\n      },\n      set: function (e) {\n        if (e !== this._coneOuterAngle) {\n          if (e < this._coneInnerAngle) return void Ai.Tools.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n          this._coneOuterAngle = e;\n\n          for (var t = 0, i = this._sounds; t < i.length; t++) {\n            i[t].directionalConeOuterAngle = e;\n          }\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"volume\", {\n      get: function () {\n        return this._volume;\n      },\n      set: function (e) {\n        if (e !== this._volume) for (var t = 0, i = this._sounds; t < i.length; t++) {\n          i[t].setVolume(e);\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._onended = function () {\n      void 0 !== this._currentIndex && (this._sounds[this._currentIndex].autoplay = !1), this.loop && this.isPlaying ? this.play() : this.isPlaying = !1;\n    }, e.prototype.pause = function () {\n      this.isPaused = !0, void 0 !== this._currentIndex && this._sounds[this._currentIndex].pause();\n    }, e.prototype.stop = function () {\n      this.isPlaying = !1, void 0 !== this._currentIndex && this._sounds[this._currentIndex].stop();\n    }, e.prototype.play = function (e) {\n      if (!this.isPaused) {\n        this.stop();\n\n        for (var t = Math.random(), i = 0, r = 0; r < this._weights.length; r++) if (t <= (i += this._weights[r])) {\n          this._currentIndex = r;\n          break;\n        }\n      }\n\n      var n = this._sounds[this._currentIndex];\n      n.isReady() ? n.play(0, this.isPaused ? void 0 : e) : n.autoplay = !0, this.isPlaying = !0, this.isPaused = !1;\n    }, e;\n  }(), Ai.WeightedSound = Si, function (c) {\n    c.AbstractScene.AddParser(c.SceneComponentConstants.NAME_AUDIO, function (e, t, i, r) {\n      var n,\n          o = [];\n      if (i.sounds = i.sounds || [], void 0 !== e.sounds && null !== e.sounds) for (var s = 0, a = e.sounds.length; s < a; s++) {\n        var l = e.sounds[s];\n        c.Engine.audioEngine.canUseWebAudio ? (l.url || (l.url = l.name), o[l.url] ? i.sounds.push(c.Sound.Parse(l, t, r, o[l.url])) : (n = c.Sound.Parse(l, t, r), o[l.url] = n, i.sounds.push(n))) : i.sounds.push(new c.Sound(l.name, null, t));\n      }\n      o = [];\n    }), Object.defineProperty(c.Scene.prototype, \"mainSoundTrack\", {\n      get: function () {\n        var e = this._getComponent(c.SceneComponentConstants.NAME_AUDIO);\n\n        return e || (e = new i(this), this._addComponent(e)), this._mainSoundTrack || (this._mainSoundTrack = new c.SoundTrack(this, {\n          mainTrack: !0\n        })), this._mainSoundTrack;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), c.Scene.prototype.getSoundByName = function (e) {\n      var t;\n\n      for (t = 0; t < this.mainSoundTrack.soundCollection.length; t++) if (this.mainSoundTrack.soundCollection[t].name === e) return this.mainSoundTrack.soundCollection[t];\n\n      if (this.soundTracks) for (var i = 0; i < this.soundTracks.length; i++) for (t = 0; t < this.soundTracks[i].soundCollection.length; t++) if (this.soundTracks[i].soundCollection[t].name === e) return this.soundTracks[i].soundCollection[t];\n      return null;\n    }, Object.defineProperty(c.Scene.prototype, \"audioEnabled\", {\n      get: function () {\n        var e = this._getComponent(c.SceneComponentConstants.NAME_AUDIO);\n\n        return e || (e = new i(this), this._addComponent(e)), e.audioEnabled;\n      },\n      set: function (e) {\n        var t = this._getComponent(c.SceneComponentConstants.NAME_AUDIO);\n\n        t || (t = new i(this), this._addComponent(t)), e ? t.enableAudio() : t.disableAudio();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.Scene.prototype, \"headphone\", {\n      get: function () {\n        var e = this._getComponent(c.SceneComponentConstants.NAME_AUDIO);\n\n        return e || (e = new i(this), this._addComponent(e)), e.headphone;\n      },\n      set: function (e) {\n        var t = this._getComponent(c.SceneComponentConstants.NAME_AUDIO);\n\n        t || (t = new i(this), this._addComponent(t)), e ? t.switchAudioModeForHeadphones() : t.switchAudioModeForNormalSpeakers();\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n\n    var i = function () {\n      function e(e) {\n        this.name = c.SceneComponentConstants.NAME_AUDIO, this._audioEnabled = !0, this._headphone = !1, (this.scene = e).soundTracks = new Array(), e.sounds = new Array();\n      }\n\n      return Object.defineProperty(e.prototype, \"audioEnabled\", {\n        get: function () {\n          return this._audioEnabled;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"headphone\", {\n        get: function () {\n          return this._headphone;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.register = function () {\n        this.scene._afterRenderStage.registerStep(c.SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\n      }, e.prototype.rebuild = function () {}, e.prototype.serialize = function (e) {\n        if (e.sounds = [], this.scene.soundTracks) for (var t = 0; t < this.scene.soundTracks.length; t++) for (var i = this.scene.soundTracks[t], r = 0; r < i.soundCollection.length; r++) e.sounds.push(i.soundCollection[r].serialize());\n      }, e.prototype.addFromContainer = function (e) {\n        var t = this;\n        e.sounds && e.sounds.forEach(function (e) {\n          e.play(), e.autoplay = !0, t.scene.mainSoundTrack.AddSound(e);\n        });\n      }, e.prototype.removeFromContainer = function (e) {\n        var t = this;\n        e.sounds && e.sounds.forEach(function (e) {\n          e.stop(), e.autoplay = !1, t.scene.mainSoundTrack.RemoveSound(e);\n        });\n      }, e.prototype.dispose = function () {\n        var e = this.scene;\n        if (e._mainSoundTrack && e.mainSoundTrack.dispose(), e.soundTracks) for (var t = 0; t < e.soundTracks.length; t++) e.soundTracks[t].dispose();\n      }, e.prototype.disableAudio = function () {\n        var e,\n            t = this.scene;\n\n        for (this._audioEnabled = !1, e = 0; e < t.mainSoundTrack.soundCollection.length; e++) t.mainSoundTrack.soundCollection[e].pause();\n\n        if (t.soundTracks) for (e = 0; e < t.soundTracks.length; e++) for (var i = 0; i < t.soundTracks[e].soundCollection.length; i++) t.soundTracks[e].soundCollection[i].pause();\n      }, e.prototype.enableAudio = function () {\n        var e,\n            t = this.scene;\n\n        for (this._audioEnabled = !0, e = 0; e < t.mainSoundTrack.soundCollection.length; e++) t.mainSoundTrack.soundCollection[e].isPaused && t.mainSoundTrack.soundCollection[e].play();\n\n        if (t.soundTracks) for (e = 0; e < t.soundTracks.length; e++) for (var i = 0; i < t.soundTracks[e].soundCollection.length; i++) t.soundTracks[e].soundCollection[i].isPaused && t.soundTracks[e].soundCollection[i].play();\n      }, e.prototype.switchAudioModeForHeadphones = function () {\n        var e = this.scene;\n        if (this._headphone = !0, e.mainSoundTrack.switchPanningModelToHRTF(), e.soundTracks) for (var t = 0; t < e.soundTracks.length; t++) e.soundTracks[t].switchPanningModelToHRTF();\n      }, e.prototype.switchAudioModeForNormalSpeakers = function () {\n        var e = this.scene;\n        if (this._headphone = !1, e.mainSoundTrack.switchPanningModelToEqualPower(), e.soundTracks) for (var t = 0; t < e.soundTracks.length; t++) e.soundTracks[t].switchPanningModelToEqualPower();\n      }, e.prototype._afterRender = function () {\n        var e = this.scene;\n\n        if (this._audioEnabled && e._mainSoundTrack && e.soundTracks && (0 !== e._mainSoundTrack.soundCollection.length || 1 !== e.soundTracks.length)) {\n          var t,\n              i = c.Engine.audioEngine;\n\n          if ((t = 0 < e.activeCameras.length ? e.activeCameras[0] : e.activeCamera) && i.audioContext) {\n            i.audioContext.listener.setPosition(t.position.x, t.position.y, t.position.z), t.rigCameras && 0 < t.rigCameras.length && (t = t.rigCameras[0]);\n            var r,\n                n = c.Matrix.Invert(t.getViewMatrix()),\n                o = c.Vector3.TransformNormal(new c.Vector3(0, 0, -1), n);\n\n            for (o.normalize(), isNaN(o.x) || isNaN(o.y) || isNaN(o.z) || i.audioContext.listener.setOrientation(o.x, o.y, o.z, 0, 1, 0), r = 0; r < e.mainSoundTrack.soundCollection.length; r++) {\n              var s = e.mainSoundTrack.soundCollection[r];\n              s.useCustomAttenuation && s.updateDistanceFromListener();\n            }\n\n            if (e.soundTracks) for (r = 0; r < e.soundTracks.length; r++) for (var a = 0; a < e.soundTracks[r].soundCollection.length; a++) (s = e.soundTracks[r].soundCollection[a]).useCustomAttenuation && s.updateDistanceFromListener();\n          }\n        }\n      }, e;\n    }();\n\n    c.AudioSceneComponent = i;\n  }($a || ($a = {})), function (e) {\n    var t = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r._sound = t, r;\n      }\n\n      return T(e, n), e.prototype._prepare = function () {}, e.prototype.execute = function () {\n        void 0 !== this._sound && this._sound.play();\n      }, e.prototype.serialize = function (e) {\n        return n.prototype._serialize.call(this, {\n          name: \"PlaySoundAction\",\n          properties: [{\n            name: \"sound\",\n            value: this._sound.name\n          }]\n        }, e);\n      }, e;\n    }(e.Action);\n\n    e.PlaySoundAction = t;\n\n    var i = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, i) || this;\n        return r._sound = t, r;\n      }\n\n      return T(e, n), e.prototype._prepare = function () {}, e.prototype.execute = function () {\n        void 0 !== this._sound && this._sound.stop();\n      }, e.prototype.serialize = function (e) {\n        return n.prototype._serialize.call(this, {\n          name: \"StopSoundAction\",\n          properties: [{\n            name: \"sound\",\n            value: this._sound.name\n          }]\n        }, e);\n      }, e;\n    }(e.Action);\n\n    e.StopSoundAction = i;\n  }($a || ($a = {})), Mi = $a || ($a = {}), Ri = function (y) {\n    function s(e, t, i, r, n, o, s, a, l, c, h, u, d) {\n      void 0 === i && (i = null), void 0 === r && (r = !1), void 0 === n && (n = null), void 0 === o && (o = null), void 0 === s && (s = null), void 0 === a && (a = Mi.Engine.TEXTUREFORMAT_RGBA), void 0 === l && (l = !1), void 0 === c && (c = null), void 0 === h && (h = !1), void 0 === u && (u = .8), void 0 === d && (d = 0);\n      var f = y.call(this, t) || this;\n      if (f.boundingBoxPosition = Mi.Vector3.Zero(), f._rotationY = 0, f._prefiltered = !1, f.name = e, f.url = e, f._noMipmap = r, f.hasAlpha = !1, f._format = a, f.isCube = !0, f._textureMatrix = Mi.Matrix.Identity(), f._createPolynomials = h, f.coordinatesMode = Mi.Texture.CUBIC_MODE, !e && !n) return f;\n\n      var p = e.lastIndexOf(\".\"),\n          _ = c || (-1 < p ? e.substring(p).toLowerCase() : \"\"),\n          m = \".dds\" === _,\n          g = \".env\" === _;\n\n      if (g ? (f.gammaSpace = !1, f._prefiltered = !1) : (f._prefiltered = l) && (f.gammaSpace = !1), f._texture = f._getFromCache(e, r), !n && (g || m || i || (i = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"]), n = [], i)) for (var v = 0; v < i.length; v++) n.push(e + i[v]);\n      return f._files = n, f._texture ? o && (f._texture.isReady ? Mi.Tools.SetImmediate(function () {\n        return o();\n      }) : f._texture.onLoadedObservable.add(o)) : t.useDelayedTextureLoading ? f.delayLoadState = Mi.Engine.DELAYLOADSTATE_NOTLOADED : f._texture = l ? t.getEngine().createPrefilteredCubeTexture(e, t, u, d, o, s, a, c, f._createPolynomials) : t.getEngine().createCubeTexture(e, t, n, r, o, s, f._format, c, !1, u, d), f;\n    }\n\n    return T(s, y), Object.defineProperty(s.prototype, \"boundingBoxSize\", {\n      get: function () {\n        return this._boundingBoxSize;\n      },\n      set: function (e) {\n        if (!this._boundingBoxSize || !this._boundingBoxSize.equals(e)) {\n          this._boundingBoxSize = e;\n          var t = this.getScene();\n          t && t.markAllMaterialsAsDirty(Mi.Material.TextureDirtyFlag);\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"rotationY\", {\n      get: function () {\n        return this._rotationY;\n      },\n      set: function (e) {\n        this._rotationY = e, this.setReflectionTextureMatrix(Mi.Matrix.RotationY(this._rotationY));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), s.CreateFromImages = function (e, t, i) {\n      var r = \"\";\n      return e.forEach(function (e) {\n        return r += e;\n      }), new s(r, t, null, i, e);\n    }, s.CreateFromPrefilteredData = function (e, t, i, r) {\n      return void 0 === i && (i = null), void 0 === r && (r = !0), new s(e, t, null, !1, null, null, null, void 0, !0, i, r);\n    }, s.prototype.delayLoad = function () {\n      if (this.delayLoadState === Mi.Engine.DELAYLOADSTATE_NOTLOADED) {\n        var e = this.getScene();\n        e && (this.delayLoadState = Mi.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap), this._texture || (this._prefiltered ? this._texture = e.getEngine().createPrefilteredCubeTexture(this.url, e, this.lodGenerationScale, this.lodGenerationOffset, void 0, void 0, this._format, void 0, this._createPolynomials) : this._texture = e.getEngine().createCubeTexture(this.url, e, this._files, this._noMipmap, void 0, void 0, this._format)));\n      }\n    }, s.prototype.getReflectionTextureMatrix = function () {\n      return this._textureMatrix;\n    }, s.prototype.setReflectionTextureMatrix = function (e) {\n      this._textureMatrix = e;\n    }, s.Parse = function (t, i, r) {\n      var e = Mi.SerializationHelper.Parse(function () {\n        var e = !1;\n        return t.prefiltered && (e = t.prefiltered), new s(r + t.name, i, t.extensions, !1, null, null, null, void 0, e);\n      }, t, i);\n      if (t.boundingBoxPosition && (e.boundingBoxPosition = Mi.Vector3.FromArray(t.boundingBoxPosition)), t.boundingBoxSize && (e.boundingBoxSize = Mi.Vector3.FromArray(t.boundingBoxSize)), t.animations) for (var n = 0; n < t.animations.length; n++) {\n        var o = t.animations[n];\n        e.animations.push(Mi.Animation.Parse(o));\n      }\n      return e;\n    }, s.prototype.clone = function () {\n      var t = this;\n      return Mi.SerializationHelper.Clone(function () {\n        var e = t.getScene();\n        return e ? new s(t.url, e, t._extensions, t._noMipmap, t._files) : t;\n      }, this);\n    }, b([Mi.serialize(\"rotationY\")], s.prototype, \"rotationY\", null), s;\n  }(Mi.BaseTexture), Mi.CubeTexture = Ri, Ci = $a || ($a = {}), Oi = function (h) {\n    function n(e, t, i, r, n, o, s, a, l) {\n      void 0 === r && (r = Ci.Engine.TEXTUREFORMAT_RGBA), void 0 === n && (n = Ci.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === a && (a = Ci.Texture.TRILINEAR_SAMPLINGMODE), void 0 === l && (l = null);\n      var c = h.call(this, \"\", e) || this;\n      return c._texture = e.getEngine().createRawCubeTexture(t, i, r, n, o, s, a, l), c;\n    }\n\n    return T(n, h), n.prototype.update = function (e, t, i, r, n, o) {\n      void 0 === n && (n = null), void 0 === o && (o = 0), this._texture.getEngine().updateRawCubeTexture(this._texture, e, t, i, r, n);\n    }, n.prototype.updateRGBDAsync = function (e, t, i, r) {\n      return void 0 === t && (t = null), void 0 === i && (i = .8), void 0 === r && (r = 0), n._UpdateRGBDAsync(this._texture, e, t, i, r);\n    }, n.prototype.clone = function () {\n      var r = this;\n      return Ci.SerializationHelper.Clone(function () {\n        var e = r.getScene(),\n            t = r._texture,\n            i = new n(e, t._bufferViewArray, t.width, t.format, t.type, t.generateMipMaps, t.invertY, t.samplingMode, t._compression);\n        return t.dataSource === Ci.InternalTexture.DATASOURCE_CUBERAW_RGBD && i.updateRGBDAsync(t._bufferViewArrayArray, t._sphericalPolynomial, t._lodGenerationScale, t._lodGenerationOffset), i;\n      }, this);\n    }, n._UpdateRGBDAsync = function (e, t, i, r, n) {\n      return e._dataSource = Ci.InternalTexture.DATASOURCE_CUBERAW_RGBD, e._bufferViewArrayArray = t, e._lodGenerationScale = r, e._lodGenerationOffset = n, e._sphericalPolynomial = i, Ci.EnvironmentTextureTools.UploadLevelsAsync(e, t).then(function () {\n        e.isReady = !0;\n      });\n    }, n;\n  }(Ci.CubeTexture), Ci.RawCubeTexture = Oi, Di = $a || ($a = {}), Ii = function (f) {\n    function i(e, t, i, r, n, o, s, a, l, c, h, u) {\n      void 0 === n && (n = !0), void 0 === o && (o = Di.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === s && (s = !1), void 0 === a && (a = Di.Texture.TRILINEAR_SAMPLINGMODE), void 0 === l && (l = !0), void 0 === c && (c = !1), void 0 === h && (h = !1), void 0 === u && (u = Di.Engine.TEXTUREFORMAT_RGBA);\n      var d = f.call(this, null, i, !r) || this;\n      return d.isCube = s, d.renderParticles = !0, d.renderSprites = !1, d.coordinatesMode = Di.Texture.PROJECTION_MODE, d.ignoreCameraViewport = !1, d.onBeforeBindObservable = new Di.Observable(), d.onAfterUnbindObservable = new Di.Observable(), d.onBeforeRenderObservable = new Di.Observable(), d.onAfterRenderObservable = new Di.Observable(), d.onClearObservable = new Di.Observable(), d._currentRefreshId = -1, d._refreshRate = 1, d._samples = 1, d.boundingBoxPosition = Di.Vector3.Zero(), (i = d.getScene()) ? (d.renderList = new Array(), d._engine = i.getEngine(), d.name = e, d.isRenderTarget = !0, d._initialSizeParameter = t, d._processSizeParameter(t), d._resizeObserver = d.getScene().getEngine().onResizeObservable.add(function () {}), d._generateMipMaps = !!r, d._doNotChangeAspectRatio = n, d._renderingManager = new Di.RenderingManager(i), d._renderingManager._useSceneAutoClearSetup = !0, h || (d._renderTargetOptions = {\n        generateMipMaps: r,\n        type: o,\n        format: u,\n        samplingMode: a,\n        generateDepthBuffer: l,\n        generateStencilBuffer: c\n      }, a === Di.Texture.NEAREST_SAMPLINGMODE && (d.wrapU = Di.Texture.CLAMP_ADDRESSMODE, d.wrapV = Di.Texture.CLAMP_ADDRESSMODE), s ? (d._texture = i.getEngine().createRenderTargetCubeTexture(d.getRenderSize(), d._renderTargetOptions), d.coordinatesMode = Di.Texture.INVCUBIC_MODE, d._textureMatrix = Di.Matrix.Identity()) : d._texture = i.getEngine().createRenderTargetTexture(d._size, d._renderTargetOptions)), d) : d;\n    }\n\n    return T(i, f), Object.defineProperty(i.prototype, \"renderList\", {\n      get: function () {\n        return this._renderList;\n      },\n      set: function (e) {\n        this._renderList = e, this._renderList && this._hookArray(this._renderList);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype._hookArray = function (n) {\n      var o = this,\n          s = n.push;\n\n      n.push = function () {\n        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];\n\n        var i = 0 === n.length,\n            r = s.apply(n, e);\n        return i && o.getScene().meshes.forEach(function (e) {\n          e._markSubMeshesAsLightDirty();\n        }), r;\n      };\n\n      var r = n.splice;\n\n      n.splice = function (e, t) {\n        var i = r.apply(n, [e, t]);\n        return 0 === n.length && o.getScene().meshes.forEach(function (e) {\n          e._markSubMeshesAsLightDirty();\n        }), i;\n      };\n    }, Object.defineProperty(i.prototype, \"onAfterUnbind\", {\n      set: function (e) {\n        this._onAfterUnbindObserver && this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"onBeforeRender\", {\n      set: function (e) {\n        this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"onAfterRender\", {\n      set: function (e) {\n        this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"onClear\", {\n      set: function (e) {\n        this._onClearObserver && this.onClearObservable.remove(this._onClearObserver), this._onClearObserver = this.onClearObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"renderTargetOptions\", {\n      get: function () {\n        return this._renderTargetOptions;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype._onRatioRescale = function () {\n      this._sizeRatio && this.resize(this._initialSizeParameter);\n    }, Object.defineProperty(i.prototype, \"boundingBoxSize\", {\n      get: function () {\n        return this._boundingBoxSize;\n      },\n      set: function (e) {\n        if (!this._boundingBoxSize || !this._boundingBoxSize.equals(e)) {\n          this._boundingBoxSize = e;\n          var t = this.getScene();\n          t && t.markAllMaterialsAsDirty(Di.Material.TextureDirtyFlag);\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.createDepthStencilTexture = function (e, t, i) {\n      if (void 0 === e && (e = 0), void 0 === t && (t = !0), void 0 === i && (i = !1), this.getScene()) {\n        var r = this.getScene().getEngine();\n        this.depthStencilTexture = r.createDepthStencilTexture(this._size, {\n          bilinearFiltering: t,\n          comparisonFunction: e,\n          generateStencil: i,\n          isCube: this.isCube\n        }), r.setFrameBufferDepthStencilTexture(this);\n      }\n    }, i.prototype._processSizeParameter = function (e) {\n      e.ratio ? (this._sizeRatio = e.ratio, this._size = {\n        width: this._bestReflectionRenderTargetDimension(this._engine.getRenderWidth(), this._sizeRatio),\n        height: this._bestReflectionRenderTargetDimension(this._engine.getRenderHeight(), this._sizeRatio)\n      }) : this._size = e;\n    }, Object.defineProperty(i.prototype, \"samples\", {\n      get: function () {\n        return this._samples;\n      },\n      set: function (e) {\n        if (this._samples !== e) {\n          var t = this.getScene();\n          t && (this._samples = t.getEngine().updateRenderTargetTextureSampleCount(this._texture, e));\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.resetRefreshCounter = function () {\n      this._currentRefreshId = -1;\n    }, Object.defineProperty(i.prototype, \"refreshRate\", {\n      get: function () {\n        return this._refreshRate;\n      },\n      set: function (e) {\n        this._refreshRate = e, this.resetRefreshCounter();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.addPostProcess = function (e) {\n      if (!this._postProcessManager) {\n        var t = this.getScene();\n        if (!t) return;\n        this._postProcessManager = new Di.PostProcessManager(t), this._postProcesses = new Array();\n      }\n\n      this._postProcesses.push(e), this._postProcesses[0].autoClear = !1;\n    }, i.prototype.clearPostProcesses = function (e) {\n      if (void 0 === e && (e = !1), this._postProcesses) {\n        if (e) for (var t = 0, i = this._postProcesses; t < i.length; t++) {\n          i[t].dispose();\n        }\n        this._postProcesses = [];\n      }\n    }, i.prototype.removePostProcess = function (e) {\n      if (this._postProcesses) {\n        var t = this._postProcesses.indexOf(e);\n\n        -1 !== t && (this._postProcesses.splice(t, 1), 0 < this._postProcesses.length && (this._postProcesses[0].autoClear = !1));\n      }\n    }, i.prototype._shouldRender = function () {\n      return -1 === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1);\n    }, i.prototype.getRenderSize = function () {\n      return this.getRenderWidth();\n    }, i.prototype.getRenderWidth = function () {\n      return this._size.width ? this._size.width : this._size;\n    }, i.prototype.getRenderHeight = function () {\n      return this._size.width ? this._size.height : this._size;\n    }, Object.defineProperty(i.prototype, \"canRescale\", {\n      get: function () {\n        return !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.scale = function (e) {\n      var t = this.getRenderSize() * e;\n      this.resize(t);\n    }, i.prototype.getReflectionTextureMatrix = function () {\n      return this.isCube ? this._textureMatrix : f.prototype.getReflectionTextureMatrix.call(this);\n    }, i.prototype.resize = function (e) {\n      this.releaseInternalTexture();\n      var t = this.getScene();\n      t && (this._processSizeParameter(e), this.isCube ? this._texture = t.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions) : this._texture = t.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions));\n    }, i.prototype.render = function (e, t) {\n      if (void 0 === e && (e = !1), void 0 === t && (t = !1), a = this.getScene()) {\n        var i,\n            r = a.getEngine();\n\n        if (void 0 !== this.useCameraPostProcesses && (e = this.useCameraPostProcesses), this._waitingRenderList) {\n          this.renderList = [];\n\n          for (var n = 0; n < this._waitingRenderList.length; n++) {\n            var o = this._waitingRenderList[n],\n                s = a.getMeshByID(o);\n            s && this.renderList.push(s);\n          }\n\n          delete this._waitingRenderList;\n        }\n\n        if (this.renderListPredicate) {\n          var a;\n          if (this.renderList ? this.renderList.splice(0) : this.renderList = [], !(a = this.getScene())) return;\n          var l = a.meshes;\n\n          for (n = 0; n < l.length; n++) {\n            var c = l[n];\n            this.renderListPredicate(c) && this.renderList.push(c);\n          }\n        }\n\n        this.onBeforeBindObservable.notifyObservers(this), this.activeCamera ? (i = this.activeCamera, r.setViewport(this.activeCamera.viewport, this.getRenderWidth(), this.getRenderHeight()), this.activeCamera !== a.activeCamera && a.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(!0))) : (i = a.activeCamera) && r.setViewport(i.viewport, this.getRenderWidth(), this.getRenderHeight()), this._renderingManager.reset();\n\n        for (var h = this.renderList ? this.renderList : a.getActiveMeshes().data, u = this.renderList ? this.renderList.length : a.getActiveMeshes().length, d = a.getRenderId(), f = 0; f < u; f++) {\n          if (c = h[f]) {\n            if (!c.isReady(0 === this.refreshRate)) {\n              this.resetRefreshCounter();\n              continue;\n            }\n\n            c._preActivateForIntermediateRendering(d);\n\n            var p = void 0;\n\n            if (p = !(this.renderList || !i) && 0 == (c.layerMask & i.layerMask), c.isEnabled() && c.isVisible && c.subMeshes && !p) {\n              c._activate(d);\n\n              for (var _ = 0; _ < c.subMeshes.length; _++) {\n                var m = c.subMeshes[_];\n                a._activeIndices.addCount(m.indexCount, !1), this._renderingManager.dispatch(m, c);\n              }\n            }\n          }\n        }\n\n        for (var g = 0; g < a.particleSystems.length; g++) {\n          var v = a.particleSystems[g],\n              y = v.emitter;\n          v.isStarted() && y && y.position && y.isEnabled() && 0 <= h.indexOf(y) && this._renderingManager.dispatchParticles(v);\n        }\n\n        if (this.isCube) for (var b = 0; b < 6; b++) this.renderToTarget(b, h, u, e, t), a.incrementRenderId(), a.resetCachedMaterial();else this.renderToTarget(0, h, u, e, t);\n        this.onAfterUnbindObservable.notifyObservers(this), a.activeCamera && (this.activeCamera && this.activeCamera !== a.activeCamera && a.setTransformMatrix(a.activeCamera.getViewMatrix(), a.activeCamera.getProjectionMatrix(!0)), r.setViewport(a.activeCamera.viewport)), a.resetCachedMaterial();\n      }\n    }, i.prototype._bestReflectionRenderTargetDimension = function (e, t) {\n      var i = e * t,\n          r = Di.Tools.NearestPOT(i + 16384 / (128 + i));\n      return Math.min(Di.Tools.FloorPOT(e), r);\n    }, i.prototype.unbindFrameBuffer = function (e, t) {\n      var i = this;\n      this._texture && e.unBindFramebuffer(this._texture, this.isCube, function () {\n        i.onAfterRenderObservable.notifyObservers(t);\n      });\n    }, i.prototype.renderToTarget = function (e, t, i, r, n) {\n      var o = this.getScene();\n\n      if (o) {\n        var s = o.getEngine();\n        this._texture && (this._postProcessManager ? this._postProcessManager._prepareFrame(this._texture, this._postProcesses) : r && o.postProcessManager._prepareFrame(this._texture) || this._texture && s.bindFramebuffer(this._texture, this.isCube ? e : void 0, void 0, void 0, this.ignoreCameraViewport, this.depthStencilTexture ? this.depthStencilTexture : void 0), this.onBeforeRenderObservable.notifyObservers(e), this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(s) : s.clear(this.clearColor || o.clearColor, !0, !0, !0), this._doNotChangeAspectRatio || o.updateTransformMatrix(!0), this._renderingManager.render(this.customRenderFunction, t, this.renderParticles, this.renderSprites), this._postProcessManager ? this._postProcessManager._finalizeFrame(!1, this._texture, e, this._postProcesses, this.ignoreCameraViewport) : r && o.postProcessManager._finalizeFrame(!1, this._texture, e), this._doNotChangeAspectRatio || o.updateTransformMatrix(!0), n && Di.Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), s), this.isCube && 5 !== e ? this.onAfterRenderObservable.notifyObservers(e) : (this.isCube && 5 === e && s.generateMipMapsForCubemap(this._texture), this.unbindFrameBuffer(s, e)));\n      }\n    }, i.prototype.setRenderingOrder = function (e, t, i, r) {\n      void 0 === t && (t = null), void 0 === i && (i = null), void 0 === r && (r = null), this._renderingManager.setRenderingOrder(e, t, i, r);\n    }, i.prototype.setRenderingAutoClearDepthStencil = function (e, t) {\n      this._renderingManager.setRenderingAutoClearDepthStencil(e, t), this._renderingManager._useSceneAutoClearSetup = !1;\n    }, i.prototype.clone = function () {\n      var e = this.getSize(),\n          t = new i(this.name, e, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer);\n      return t.hasAlpha = this.hasAlpha, t.level = this.level, t.coordinatesMode = this.coordinatesMode, this.renderList && (t.renderList = this.renderList.slice(0)), t;\n    }, i.prototype.serialize = function () {\n      if (!this.name) return null;\n      var e = f.prototype.serialize.call(this);\n      if (e.renderTargetSize = this.getRenderSize(), e.renderList = [], this.renderList) for (var t = 0; t < this.renderList.length; t++) e.renderList.push(this.renderList[t].id);\n      return e;\n    }, i.prototype.disposeFramebufferObjects = function () {\n      var e = this.getInternalTexture(),\n          t = this.getScene();\n      e && t && t.getEngine()._releaseFramebufferObjects(e);\n    }, i.prototype.dispose = function () {\n      this._postProcessManager && (this._postProcessManager.dispose(), this._postProcessManager = null), this.clearPostProcesses(!0), this._resizeObserver && (this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver), this._resizeObserver = null), this.renderList = null;\n      var e = this.getScene();\n\n      if (e) {\n        var t = e.customRenderTargets.indexOf(this);\n        0 <= t && e.customRenderTargets.splice(t, 1);\n\n        for (var i = 0, r = e.cameras; i < r.length; i++) {\n          var n = r[i];\n          0 <= (t = n.customRenderTargets.indexOf(this)) && n.customRenderTargets.splice(t, 1);\n        }\n\n        f.prototype.dispose.call(this);\n      }\n    }, i.prototype._rebuild = function () {\n      this.refreshRate === i.REFRESHRATE_RENDER_ONCE && (this.refreshRate = i.REFRESHRATE_RENDER_ONCE), this._postProcessManager && this._postProcessManager._rebuild();\n    }, i.prototype.freeRenderingGroups = function () {\n      this._renderingManager && this._renderingManager.freeRenderingGroups();\n    }, i.REFRESHRATE_RENDER_ONCE = 0, i.REFRESHRATE_RENDER_ONEVERYFRAME = 1, i.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2, i;\n  }(Di.Texture), Di.RenderTargetTexture = Ii, wi = $a || ($a = {}), Li = function (p) {\n    function e(e, t, i, r, n) {\n      var o = this,\n          s = !(!n || !n.generateMipMaps) && n.generateMipMaps,\n          a = !(!n || !n.generateDepthTexture) && n.generateDepthTexture,\n          l = !n || void 0 === n.doNotChangeAspectRatio || n.doNotChangeAspectRatio;\n\n      if ((o = p.call(this, e, t, r, s, l) || this)._engine = r.getEngine(), o.isSupported) {\n        for (var c = [], h = [], u = 0; u < i; u++) n && n.types && void 0 !== n.types[u] ? c.push(n.types[u]) : c.push(n && n.defaultType ? n.defaultType : wi.Engine.TEXTURETYPE_UNSIGNED_INT), n && n.samplingModes && void 0 !== n.samplingModes[u] ? h.push(n.samplingModes[u]) : h.push(wi.Texture.BILINEAR_SAMPLINGMODE);\n\n        var d = !n || void 0 === n.generateDepthBuffer || n.generateDepthBuffer,\n            f = !(!n || void 0 === n.generateStencilBuffer) && n.generateStencilBuffer;\n        return o._size = t, o._multiRenderTargetOptions = {\n          samplingModes: h,\n          generateMipMaps: s,\n          generateDepthBuffer: d,\n          generateStencilBuffer: f,\n          generateDepthTexture: a,\n          types: c,\n          textureCount: i\n        }, o._createInternalTextures(), o._createTextures(), o;\n      }\n\n      o.dispose();\n    }\n\n    return T(e, p), Object.defineProperty(e.prototype, \"isSupported\", {\n      get: function () {\n        return 1 < this._engine.webGLVersion || this._engine.getCaps().drawBuffersExtension;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"textures\", {\n      get: function () {\n        return this._textures;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"depthTexture\", {\n      get: function () {\n        return this._textures[this._textures.length - 1];\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"wrapU\", {\n      set: function (e) {\n        if (this._textures) for (var t = 0; t < this._textures.length; t++) this._textures[t].wrapU = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"wrapV\", {\n      set: function (e) {\n        if (this._textures) for (var t = 0; t < this._textures.length; t++) this._textures[t].wrapV = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._rebuild = function () {\n      this.releaseInternalTextures(), this._createInternalTextures();\n\n      for (var e = 0; e < this._internalTextures.length; e++) {\n        this._textures[e]._texture = this._internalTextures[e];\n      }\n\n      this._texture = this._internalTextures[0];\n    }, e.prototype._createInternalTextures = function () {\n      this._internalTextures = this._engine.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);\n    }, e.prototype._createTextures = function () {\n      this._textures = [];\n\n      for (var e = 0; e < this._internalTextures.length; e++) {\n        var t = new wi.Texture(null, this.getScene());\n        t._texture = this._internalTextures[e], this._textures.push(t);\n      }\n\n      this._texture = this._internalTextures[0];\n    }, Object.defineProperty(e.prototype, \"samples\", {\n      get: function () {\n        return this._samples;\n      },\n      set: function (e) {\n        this._samples !== e && (this._samples = this._engine.updateMultipleRenderTargetTextureSampleCount(this._internalTextures, e));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.resize = function (e) {\n      this.releaseInternalTextures(), this._internalTextures = this._engine.createMultipleRenderTarget(e, this._multiRenderTargetOptions), this._createInternalTextures();\n    }, e.prototype.unbindFrameBuffer = function (e, t) {\n      var i = this;\n      e.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, function () {\n        i.onAfterRenderObservable.notifyObservers(t);\n      });\n    }, e.prototype.dispose = function () {\n      this.releaseInternalTextures(), p.prototype.dispose.call(this);\n    }, e.prototype.releaseInternalTextures = function () {\n      if (this._internalTextures) for (var e = this._internalTextures.length - 1; 0 <= e; e--) void 0 !== this._internalTextures[e] && (this._internalTextures[e].dispose(), this._internalTextures.splice(e, 1));\n    }, e;\n  }(wi.RenderTargetTexture), wi.MultiRenderTarget = Li, Fi = $a || ($a = {}), Bi = function (l) {\n    function r(e, t, i, r, n, o, s) {\n      void 0 === n && (n = Fi.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === o && (o = Fi.Texture.BILINEAR_SAMPLINGMODE), void 0 === s && (s = !0);\n      var a = l.call(this, e, t, i, r, !0, n, !1, o, s) || this;\n      return a.scene = i, a.mirrorPlane = new Fi.Plane(0, 1, 0, 1), a._transformMatrix = Fi.Matrix.Zero(), a._mirrorMatrix = Fi.Matrix.Zero(), a._adaptiveBlurKernel = 0, a._blurKernelX = 0, a._blurKernelY = 0, a._blurRatio = 1, a.ignoreCameraViewport = !0, a._updateGammaSpace(), a._imageProcessingConfigChangeObserver = i.imageProcessingConfiguration.onUpdateParameters.add(function () {\n        a._updateGammaSpace;\n      }), a.onBeforeRenderObservable.add(function () {\n        Fi.Matrix.ReflectionToRef(a.mirrorPlane, a._mirrorMatrix), a._savedViewMatrix = i.getViewMatrix(), a._mirrorMatrix.multiplyToRef(a._savedViewMatrix, a._transformMatrix), i.setTransformMatrix(a._transformMatrix, i.getProjectionMatrix()), i.clipPlane = a.mirrorPlane, i.getEngine().cullBackFaces = !1, i._mirroredCameraPosition = Fi.Vector3.TransformCoordinates(i.activeCamera.globalPosition, a._mirrorMatrix);\n      }), a.onAfterRenderObservable.add(function () {\n        i.setTransformMatrix(a._savedViewMatrix, i.getProjectionMatrix()), i.getEngine().cullBackFaces = !0, i._mirroredCameraPosition = null, delete i.clipPlane;\n      }), a;\n    }\n\n    return T(r, l), Object.defineProperty(r.prototype, \"blurRatio\", {\n      get: function () {\n        return this._blurRatio;\n      },\n      set: function (e) {\n        this._blurRatio !== e && (this._blurRatio = e, this._preparePostProcesses());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"adaptiveBlurKernel\", {\n      set: function (e) {\n        this._adaptiveBlurKernel = e, this._autoComputeBlurKernel();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"blurKernel\", {\n      set: function (e) {\n        this.blurKernelX = e, this.blurKernelY = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"blurKernelX\", {\n      get: function () {\n        return this._blurKernelX;\n      },\n      set: function (e) {\n        this._blurKernelX !== e && (this._blurKernelX = e, this._preparePostProcesses());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"blurKernelY\", {\n      get: function () {\n        return this._blurKernelY;\n      },\n      set: function (e) {\n        this._blurKernelY !== e && (this._blurKernelY = e, this._preparePostProcesses());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype._autoComputeBlurKernel = function () {\n      var e = this.getScene().getEngine(),\n          t = this.getRenderWidth() / e.getRenderWidth(),\n          i = this.getRenderHeight() / e.getRenderHeight();\n      this.blurKernelX = this._adaptiveBlurKernel * t, this.blurKernelY = this._adaptiveBlurKernel * i;\n    }, r.prototype._onRatioRescale = function () {\n      this._sizeRatio && (this.resize(this._initialSizeParameter), this._adaptiveBlurKernel || this._preparePostProcesses()), this._adaptiveBlurKernel && this._autoComputeBlurKernel();\n    }, r.prototype._updateGammaSpace = function () {\n      this.gammaSpace = !this.scene.imageProcessingConfiguration.isEnabled || !this.scene.imageProcessingConfiguration.applyByPostProcess;\n    }, r.prototype._preparePostProcesses = function () {\n      if (this.clearPostProcesses(!0), this._blurKernelX && this._blurKernelY) {\n        var e = this.getScene().getEngine(),\n            t = e.getCaps().textureFloatRender ? Fi.Engine.TEXTURETYPE_FLOAT : Fi.Engine.TEXTURETYPE_HALF_FLOAT;\n        this._blurX = new Fi.BlurPostProcess(\"horizontal blur\", new Fi.Vector2(1, 0), this._blurKernelX, this._blurRatio, null, Fi.Texture.BILINEAR_SAMPLINGMODE, e, !1, t), this._blurX.autoClear = !1, 1 === this._blurRatio && this.samples < 2 && this._texture ? this._blurX.inputTexture = this._texture : this._blurX.alwaysForcePOT = !0, this._blurY = new Fi.BlurPostProcess(\"vertical blur\", new Fi.Vector2(0, 1), this._blurKernelY, this._blurRatio, null, Fi.Texture.BILINEAR_SAMPLINGMODE, e, !1, t), this._blurY.autoClear = !1, this._blurY.alwaysForcePOT = 1 !== this._blurRatio, this.addPostProcess(this._blurX), this.addPostProcess(this._blurY);\n      } else this._blurY && (this.removePostProcess(this._blurY), this._blurY.dispose(), this._blurY = null), this._blurX && (this.removePostProcess(this._blurX), this._blurX.dispose(), this._blurX = null);\n    }, r.prototype.clone = function () {\n      var e = this.getScene();\n      if (!e) return this;\n      var t = this.getSize(),\n          i = new r(this.name, t.width, e, this._renderTargetOptions.generateMipMaps, this._renderTargetOptions.type, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer);\n      return i.hasAlpha = this.hasAlpha, i.level = this.level, i.mirrorPlane = this.mirrorPlane.clone(), this.renderList && (i.renderList = this.renderList.slice(0)), i;\n    }, r.prototype.serialize = function () {\n      if (!this.name) return null;\n      var e = l.prototype.serialize.call(this);\n      return e.mirrorPlane = this.mirrorPlane.asArray(), e;\n    }, r.prototype.dispose = function () {\n      l.prototype.dispose.call(this), this.scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver);\n    }, r;\n  }(Fi.RenderTargetTexture), Fi.MirrorTexture = Bi, Ni = $a || ($a = {}), Vi = function (o) {\n    function r(e, t, i, r) {\n      var n = o.call(this, e, t, i, r, !0) || this;\n      return n.refractionPlane = new Ni.Plane(0, 1, 0, 1), n.depth = 2, n.onBeforeRenderObservable.add(function () {\n        i.clipPlane = n.refractionPlane;\n      }), n.onAfterRenderObservable.add(function () {\n        delete i.clipPlane;\n      }), n;\n    }\n\n    return T(r, o), r.prototype.clone = function () {\n      var e = this.getScene();\n      if (!e) return this;\n      var t = this.getSize(),\n          i = new r(this.name, t.width, e, this._generateMipMaps);\n      return i.hasAlpha = this.hasAlpha, i.level = this.level, i.refractionPlane = this.refractionPlane.clone(), this.renderList && (i.renderList = this.renderList.slice(0)), i.depth = this.depth, i;\n    }, r.prototype.serialize = function () {\n      if (!this.name) return null;\n      var e = o.prototype.serialize.call(this);\n      return e.mirrorPlane = this.refractionPlane.asArray(), e.depth = this.depth, e;\n    }, r;\n  }(Ni.RenderTargetTexture), Ni.RefractionTexture = Vi, Ui = $a || ($a = {}), zi = function (l) {\n    function r(e, t, i, r, n, o) {\n      void 0 === i && (i = null), void 0 === n && (n = Ui.Texture.TRILINEAR_SAMPLINGMODE), void 0 === o && (o = Ui.Engine.TEXTUREFORMAT_RGBA);\n      var s = l.call(this, null, i, !r, void 0, n, void 0, void 0, void 0, void 0, o) || this;\n      s.name = e, s._engine = s.getScene().getEngine(), s.wrapU = Ui.Texture.CLAMP_ADDRESSMODE, s.wrapV = Ui.Texture.CLAMP_ADDRESSMODE, s._generateMipMaps = r, t.getContext ? (s._canvas = t, s._texture = s._engine.createDynamicTexture(t.width, t.height, r, n)) : (s._canvas = document.createElement(\"canvas\"), t.width || 0 === t.width ? s._texture = s._engine.createDynamicTexture(t.width, t.height, r, n) : s._texture = s._engine.createDynamicTexture(t, t, r, n));\n      var a = s.getSize();\n      return s._canvas.width = a.width, s._canvas.height = a.height, s._context = s._canvas.getContext(\"2d\"), s;\n    }\n\n    return T(r, l), Object.defineProperty(r.prototype, \"canRescale\", {\n      get: function () {\n        return !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype._recreate = function (e) {\n      this._canvas.width = e.width, this._canvas.height = e.height, this.releaseInternalTexture(), this._texture = this._engine.createDynamicTexture(e.width, e.height, this._generateMipMaps, this._samplingMode);\n    }, r.prototype.scale = function (e) {\n      var t = this.getSize();\n      t.width *= e, t.height *= e, this._recreate(t);\n    }, r.prototype.scaleTo = function (e, t) {\n      var i = this.getSize();\n      i.width = e, i.height = t, this._recreate(i);\n    }, r.prototype.getContext = function () {\n      return this._context;\n    }, r.prototype.clear = function () {\n      var e = this.getSize();\n\n      this._context.fillRect(0, 0, e.width, e.height);\n    }, r.prototype.update = function (e, t) {\n      void 0 === t && (t = !1), this._engine.updateDynamicTexture(this._texture, this._canvas, void 0 === e || e, t, this._format || void 0);\n    }, r.prototype.drawText = function (e, t, i, r, n, o, s, a) {\n      void 0 === a && (a = !0);\n      var l = this.getSize();\n\n      if (o && (this._context.fillStyle = o, this._context.fillRect(0, 0, l.width, l.height)), this._context.font = r, null == t) {\n        var c = this._context.measureText(e);\n\n        t = (l.width - c.width) / 2;\n      }\n\n      if (null == i) {\n        var h = parseInt(r.replace(/\\D/g, \"\"));\n        i = l.height / 2 + h / 3.65;\n      }\n\n      this._context.fillStyle = n, this._context.fillText(e, t, i), a && this.update(s);\n    }, r.prototype.clone = function () {\n      var e = this.getScene();\n      if (!e) return this;\n      var t = this.getSize(),\n          i = new r(this.name, t, e, this._generateMipMaps);\n      return i.hasAlpha = this.hasAlpha, i.level = this.level, i.wrapU = this.wrapU, i.wrapV = this.wrapV, i;\n    }, r.prototype.serialize = function () {\n      var e = this.getScene();\n      e && !e.isReady() && Ui.Tools.Warn(\"The scene must be ready before serializing the dynamic texture\");\n      var t = l.prototype.serialize.call(this);\n      return t.base64String = this._canvas.toDataURL(), t.invertY = this._invertY, t.samplingMode = this.samplingMode, t;\n    }, r.prototype._rebuild = function () {\n      this.update();\n    }, r;\n  }(Ui.Texture), Ui.DynamicTexture = zi, Gi = $a || ($a = {}), ki = function (l) {\n    function o(e, t, i, r, n, o, s) {\n      void 0 === r && (r = !1), void 0 === n && (n = !1), void 0 === o && (o = Gi.Texture.TRILINEAR_SAMPLINGMODE), void 0 === s && (s = {\n        autoPlay: !0,\n        loop: !0,\n        autoUpdateTexture: !0\n      });\n      var a = l.call(this, null, i, !r, n) || this;\n      return a._onUserActionRequestedObservable = null, a._stillImageCaptured = !1, a._poster = !1, a._createInternalTexture = function () {\n        if (null != a._texture) {\n          if (!a._poster) return;\n          a._texture.dispose(), a._poster = !1;\n        }\n\n        if (!a._engine.needPOTTextures || Gi.Tools.IsExponentOfTwo(a.video.videoWidth) && Gi.Tools.IsExponentOfTwo(a.video.videoHeight) ? (a.wrapU = Gi.Texture.WRAP_ADDRESSMODE, a.wrapV = Gi.Texture.WRAP_ADDRESSMODE) : (a.wrapU = Gi.Texture.CLAMP_ADDRESSMODE, a.wrapV = Gi.Texture.CLAMP_ADDRESSMODE, a._generateMipMaps = !1), a._texture = a._engine.createDynamicTexture(a.video.videoWidth, a.video.videoHeight, a._generateMipMaps, a._samplingMode), a.video.autoplay) a._texture.isReady = !0, a._updateInternalTexture(), a.onLoadObservable.hasObservers() && a.onLoadObservable.notifyObservers(a);else {\n          var e = a.video.onplaying,\n              t = !1;\n\n          a.video.onplaying = function () {\n            a.video.onplaying = e, a._texture.isReady = !0, a._updateInternalTexture(), t || a.video.pause(), a.onLoadObservable.hasObservers() && a.onLoadObservable.notifyObservers(a);\n          };\n\n          var i = a.video.play();\n          i ? i.then(function () {}).catch(function () {\n            t = !0, a._onUserActionRequestedObservable && a._onUserActionRequestedObservable.hasObservers() && a._onUserActionRequestedObservable.notifyObservers(a);\n          }) : (a.video.onplaying = e, a._texture.isReady = !0, a._updateInternalTexture(), a.onLoadObservable.hasObservers() && a.onLoadObservable.notifyObservers(a));\n        }\n      }, a.reset = function () {\n        null != a._texture && (a._poster || (a._texture.dispose(), a._texture = null));\n      }, a._updateInternalTexture = function (e) {\n        null != a._texture && a._texture.isReady && (a.video.readyState < a.video.HAVE_CURRENT_DATA || a._engine.updateVideoTexture(a._texture, a.video, a._invertY));\n      }, a._engine = a.getScene().getEngine(), a._generateMipMaps = r, a._samplingMode = o, a.autoUpdateTexture = s.autoUpdateTexture, a.name = e || a._getName(t), a.video = a._getVideo(t), s.poster && (a.video.poster = s.poster), void 0 !== s.autoPlay && (a.video.autoplay = s.autoPlay), void 0 !== s.loop && (a.video.loop = s.loop), a.video.setAttribute(\"playsinline\", \"\"), a.video.addEventListener(\"canplay\", a._createInternalTexture), a.video.addEventListener(\"paused\", a._updateInternalTexture), a.video.addEventListener(\"seeked\", a._updateInternalTexture), a.video.addEventListener(\"emptied\", a.reset), a.video.readyState >= a.video.HAVE_CURRENT_DATA && a._createInternalTexture(), s.poster && (a._texture = a._engine.createTexture(s.poster, !1, !0, i), a._poster = !0), a;\n    }\n\n    return T(o, l), Object.defineProperty(o.prototype, \"onUserActionRequestedObservable\", {\n      get: function () {\n        return this._onUserActionRequestedObservable || (this._onUserActionRequestedObservable = new Gi.Observable()), this._onUserActionRequestedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), o.prototype._getName = function (e) {\n      return e instanceof HTMLVideoElement ? e.currentSrc : \"object\" == typeof e ? e.toString() : e;\n    }, o.prototype._getVideo = function (e) {\n      if (e instanceof HTMLVideoElement) return Gi.Tools.SetCorsBehavior(e.currentSrc, e), e;\n      var i = document.createElement(\"video\");\n      return \"string\" == typeof e ? (Gi.Tools.SetCorsBehavior(e, i), i.src = e) : (Gi.Tools.SetCorsBehavior(e[0], i), e.forEach(function (e) {\n        var t = document.createElement(\"source\");\n        t.src = e, i.appendChild(t);\n      })), i;\n    }, o.prototype._rebuild = function () {\n      this.update();\n    }, o.prototype.update = function () {\n      this.autoUpdateTexture && this.updateTexture(!0);\n    }, o.prototype.updateTexture = function (e) {\n      e && (this.video.paused && this._stillImageCaptured || (this._stillImageCaptured = !0, this._updateInternalTexture()));\n    }, o.prototype.updateURL = function (e) {\n      this.video.src = e;\n    }, o.prototype.dispose = function () {\n      l.prototype.dispose.call(this), this._onUserActionRequestedObservable && (this._onUserActionRequestedObservable.clear(), this._onUserActionRequestedObservable = null), this.video.removeEventListener(\"canplay\", this._createInternalTexture), this.video.removeEventListener(\"paused\", this._updateInternalTexture), this.video.removeEventListener(\"seeked\", this._updateInternalTexture), this.video.removeEventListener(\"emptied\", this.reset), this.video.pause();\n    }, o.CreateFromWebCam = function (i, r, e) {\n      var t,\n          n = document.createElement(\"video\");\n      n.setAttribute(\"autoplay\", \"\"), n.setAttribute(\"muted\", \"\"), n.setAttribute(\"playsinline\", \"\"), e && e.deviceId && (t = {\n        exact: e.deviceId\n      }), window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, navigator.mediaDevices ? navigator.mediaDevices.getUserMedia({\n        video: e\n      }).then(function (e) {\n        void 0 !== n.mozSrcObject ? n.mozSrcObject = e : n.srcObject = e;\n\n        var t = function () {\n          r && r(new o(\"video\", n, i, !0, !0)), n.removeEventListener(\"playing\", t);\n        };\n\n        n.addEventListener(\"playing\", t), n.play();\n      }).catch(function (e) {\n        Gi.Tools.Error(e.name);\n      }) : (navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia, navigator.getUserMedia && navigator.getUserMedia({\n        video: {\n          deviceId: t,\n          width: {\n            min: e && e.minWidth || 256,\n            max: e && e.maxWidth || 640\n          },\n          height: {\n            min: e && e.minHeight || 256,\n            max: e && e.maxHeight || 480\n          }\n        }\n      }, function (e) {\n        void 0 !== n.mozSrcObject ? n.mozSrcObject = e : n.src = window.URL && window.URL.createObjectURL(e) || e, n.play(), r && r(new o(\"video\", n, i, !0, !0));\n      }, function (e) {\n        Gi.Tools.Error(e.name);\n      }));\n    }, o;\n  }(Gi.Texture), Gi.VideoTexture = ki, Wi = $a || ($a = {}), Hi = function (h) {\n    function l(e, t, i, r, n, o, s, a, l) {\n      void 0 === o && (o = !0), void 0 === s && (s = !1), void 0 === a && (a = Wi.Texture.TRILINEAR_SAMPLINGMODE), void 0 === l && (l = Wi.Engine.TEXTURETYPE_UNSIGNED_INT);\n      var c = h.call(this, null, n, !o, s) || this;\n      return c.format = r, c._engine = n.getEngine(), c._texture = n.getEngine().createRawTexture(e, t, i, r, o, s, a, null, l), c.wrapU = Wi.Texture.CLAMP_ADDRESSMODE, c.wrapV = Wi.Texture.CLAMP_ADDRESSMODE, c;\n    }\n\n    return T(l, h), l.prototype.update = function (e) {\n      this._engine.updateRawTexture(this._texture, e, this._texture.format, this._texture.invertY, void 0, this._texture.type);\n    }, l.CreateLuminanceTexture = function (e, t, i, r, n, o, s) {\n      return void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = Wi.Texture.TRILINEAR_SAMPLINGMODE), new l(e, t, i, Wi.Engine.TEXTUREFORMAT_LUMINANCE, r, n, o, s);\n    }, l.CreateLuminanceAlphaTexture = function (e, t, i, r, n, o, s) {\n      return void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = Wi.Texture.TRILINEAR_SAMPLINGMODE), new l(e, t, i, Wi.Engine.TEXTUREFORMAT_LUMINANCE_ALPHA, r, n, o, s);\n    }, l.CreateAlphaTexture = function (e, t, i, r, n, o, s) {\n      return void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = Wi.Texture.TRILINEAR_SAMPLINGMODE), new l(e, t, i, Wi.Engine.TEXTUREFORMAT_ALPHA, r, n, o, s);\n    }, l.CreateRGBTexture = function (e, t, i, r, n, o, s, a) {\n      return void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = Wi.Texture.TRILINEAR_SAMPLINGMODE), void 0 === a && (a = Wi.Engine.TEXTURETYPE_UNSIGNED_INT), new l(e, t, i, Wi.Engine.TEXTUREFORMAT_RGB, r, n, o, s, a);\n    }, l.CreateRGBATexture = function (e, t, i, r, n, o, s, a) {\n      return void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = Wi.Texture.TRILINEAR_SAMPLINGMODE), void 0 === a && (a = Wi.Engine.TEXTURETYPE_UNSIGNED_INT), new l(e, t, i, Wi.Engine.TEXTUREFORMAT_RGBA, r, n, o, s, a);\n    }, l.CreateRTexture = function (e, t, i, r, n, o, s, a) {\n      return void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = Wi.Texture.TRILINEAR_SAMPLINGMODE), void 0 === a && (a = Wi.Engine.TEXTURETYPE_FLOAT), new l(e, t, i, Wi.Engine.TEXTUREFORMAT_R, r, n, o, s, a);\n    }, l;\n  }(Wi.Texture), Wi.RawTexture = Hi, Xi = $a || ($a = {}), ji = function (u) {\n    function e(e, t, i, r, n, o, s, a, l, c) {\n      void 0 === s && (s = !0), void 0 === a && (a = !1), void 0 === l && (l = Xi.Texture.TRILINEAR_SAMPLINGMODE), void 0 === c && (c = Xi.Engine.TEXTURETYPE_UNSIGNED_INT);\n      var h = u.call(this, null, o, !s, a) || this;\n      return h.format = n, h._engine = o.getEngine(), h._texture = o.getEngine().createRawTexture3D(e, t, i, r, n, s, a, l, void 0, c), h.is3D = !0, h;\n    }\n\n    return T(e, u), e.prototype.update = function (e) {\n      this._texture && this._engine.updateRawTexture3D(this._texture, e, this._texture.format, this._texture.invertY, void 0, this._texture.type);\n    }, e;\n  }(Xi.Texture), Xi.RawTexture3D = ji, Yi = $a || ($a = {}), Ki = function () {\n    function e(e) {\n      this._vertexBuffers = {}, this._scene = e;\n    }\n\n    return e.prototype._prepareBuffers = function () {\n      if (!this._vertexBuffers[Yi.VertexBuffer.PositionKind]) {\n        var e = [];\n        e.push(1, 1), e.push(-1, 1), e.push(-1, -1), e.push(1, -1), this._vertexBuffers[Yi.VertexBuffer.PositionKind] = new Yi.VertexBuffer(this._scene.getEngine(), e, Yi.VertexBuffer.PositionKind, !1, !1, 2), this._buildIndexBuffer();\n      }\n    }, e.prototype._buildIndexBuffer = function () {\n      var e = [];\n      e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = this._scene.getEngine().createIndexBuffer(e);\n    }, e.prototype._rebuild = function () {\n      var e = this._vertexBuffers[Yi.VertexBuffer.PositionKind];\n      e && (e._rebuild(), this._buildIndexBuffer());\n    }, e.prototype._prepareFrame = function (e, t) {\n      void 0 === e && (e = null), void 0 === t && (t = null);\n      var i = this._scene.activeCamera;\n      return !!i && !(!(t = t || i._postProcesses.filter(function (e) {\n        return null != e;\n      })) || 0 === t.length || !this._scene.postProcessesEnabled) && (t[0].activate(i, e, null != t), !0);\n    }, e.prototype.directRender = function (e, t, i, r, n) {\n      void 0 === t && (t = null), void 0 === i && (i = !1), void 0 === r && (r = 0), void 0 === n && (n = 0);\n\n      for (var o = this._scene.getEngine(), s = 0; s < e.length; s++) {\n        s < e.length - 1 ? e[s + 1].activate(this._scene.activeCamera, t) : t ? o.bindFramebuffer(t, r, void 0, void 0, i, void 0, n) : o.restoreDefaultFramebuffer();\n        var a = e[s],\n            l = a.apply();\n        l && (a.onBeforeRenderObservable.notifyObservers(l), this._prepareBuffers(), o.bindBuffers(this._vertexBuffers, this._indexBuffer, l), o.drawElementsType(Yi.Material.TriangleFillMode, 0, 6), a.onAfterRenderObservable.notifyObservers(l));\n      }\n\n      o.setDepthBuffer(!0), o.setDepthWrite(!0);\n    }, e.prototype._finalizeFrame = function (e, t, i, r, n) {\n      void 0 === n && (n = !1);\n      var o = this._scene.activeCamera;\n\n      if (o && 0 !== (r = r || o._postProcesses.filter(function (e) {\n        return null != e;\n      })).length && this._scene.postProcessesEnabled) {\n        for (var s = this._scene.getEngine(), a = 0, l = r.length; a < l; a++) {\n          var c = r[a];\n          if (a < l - 1 ? c._outputTexture = r[a + 1].activate(o, t) : t ? (s.bindFramebuffer(t, i, void 0, void 0, n), c._outputTexture = t) : (s.restoreDefaultFramebuffer(), c._outputTexture = null), e) break;\n          var h = c.apply();\n          h && (c.onBeforeRenderObservable.notifyObservers(h), this._prepareBuffers(), s.bindBuffers(this._vertexBuffers, this._indexBuffer, h), s.drawElementsType(Yi.Material.TriangleFillMode, 0, 6), c.onAfterRenderObservable.notifyObservers(h));\n        }\n\n        s.setDepthBuffer(!0), s.setDepthWrite(!0), s.setAlphaMode(Yi.Engine.ALPHA_DISABLE);\n      }\n    }, e.prototype.dispose = function () {\n      var e = this._vertexBuffers[Yi.VertexBuffer.PositionKind];\n      e && (e.dispose(), this._vertexBuffers[Yi.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null);\n    }, e;\n  }(), Yi.PostProcessManager = Ki, Qi = $a || ($a = {}), Zi = function () {\n    function e(e, t, i, r, n, o, s, a, l, c, h, u, d, f) {\n      void 0 === s && (s = Qi.Texture.NEAREST_SAMPLINGMODE), void 0 === c && (c = null), void 0 === h && (h = Qi.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === u && (u = \"postprocess\"), void 0 === f && (f = !1), this.name = e, this.width = -1, this.height = -1, this._outputTexture = null, this.autoClear = !0, this.alphaMode = Qi.Engine.ALPHA_DISABLE, this.animations = new Array(), this.enablePixelPerfectMode = !1, this.forceFullscreenViewport = !0, this.scaleMode = Qi.Engine.SCALEMODE_FLOOR, this.alwaysForcePOT = !1, this._samples = 1, this.adaptScaleToCurrentViewport = !1, this._reusable = !1, this._textures = new Qi.SmartArray(2), this._currentRenderTextureInd = 0, this._scaleRatio = new Qi.Vector2(1, 1), this._texelSize = Qi.Vector2.Zero(), this.onActivateObservable = new Qi.Observable(), this.onSizeChangedObservable = new Qi.Observable(), this.onApplyObservable = new Qi.Observable(), this.onBeforeRenderObservable = new Qi.Observable(), this.onAfterRenderObservable = new Qi.Observable(), null != o ? (this._camera = o, this._scene = o.getScene(), o.attachPostProcess(this), this._engine = this._scene.getEngine(), this._scene.postProcesses.push(this)) : a && (this._engine = a, this._engine.postProcesses.push(this)), this._options = n, this.renderTargetSamplingMode = s || Qi.Texture.NEAREST_SAMPLINGMODE, this._reusable = l || !1, this._textureType = h, this._samplers = r || [], this._samplers.push(\"textureSampler\"), this._fragmentUrl = t, this._vertexUrl = u, this._parameters = i || [], this._parameters.push(\"scale\"), this._indexParameters = d, f || this.updateEffect(c);\n    }\n\n    return Object.defineProperty(e.prototype, \"samples\", {\n      get: function () {\n        return this._samples;\n      },\n      set: function (e) {\n        var t = this;\n        this._samples = e, this._textures.forEach(function (e) {\n          e.samples !== t._samples && t._engine.updateRenderTargetTextureSampleCount(e, t._samples);\n        });\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onActivate\", {\n      set: function (e) {\n        this._onActivateObserver && this.onActivateObservable.remove(this._onActivateObserver), e && (this._onActivateObserver = this.onActivateObservable.add(e));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onSizeChanged\", {\n      set: function (e) {\n        this._onSizeChangedObserver && this.onSizeChangedObservable.remove(this._onSizeChangedObserver), this._onSizeChangedObserver = this.onSizeChangedObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onApply\", {\n      set: function (e) {\n        this._onApplyObserver && this.onApplyObservable.remove(this._onApplyObserver), this._onApplyObserver = this.onApplyObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onBeforeRender\", {\n      set: function (e) {\n        this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onAfterRender\", {\n      set: function (e) {\n        this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"inputTexture\", {\n      get: function () {\n        return this._textures.data[this._currentRenderTextureInd];\n      },\n      set: function (e) {\n        this._forcedOutputTexture = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getCamera = function () {\n      return this._camera;\n    }, Object.defineProperty(e.prototype, \"texelSize\", {\n      get: function () {\n        return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.texelSize : (this._forcedOutputTexture && this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height), this._texelSize);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getEngine = function () {\n      return this._engine;\n    }, e.prototype.getEffect = function () {\n      return this._effect;\n    }, e.prototype.shareOutputWith = function (e) {\n      return this._disposeTextures(), this._shareOutputWithPostProcess = e, this;\n    }, e.prototype.useOwnOutput = function () {\n      0 == this._textures.length && (this._textures = new Qi.SmartArray(2)), this._shareOutputWithPostProcess = null;\n    }, e.prototype.updateEffect = function (e, t, i, r, n, o) {\n      void 0 === e && (e = null), void 0 === t && (t = null), void 0 === i && (i = null), this._effect = this._engine.createEffect({\n        vertex: this._vertexUrl,\n        fragment: this._fragmentUrl\n      }, [\"position\"], t || this._parameters, i || this._samplers, null !== e ? e : \"\", void 0, n, o, r || this._indexParameters);\n    }, e.prototype.isReusable = function () {\n      return this._reusable;\n    }, e.prototype.markTextureDirty = function () {\n      this.width = -1;\n    }, e.prototype.activate = function (e, t, i) {\n      var r = this;\n      void 0 === t && (t = null);\n\n      var n = (e = e || this._camera).getScene(),\n          o = n.getEngine(),\n          s = o.getCaps().maxTextureSize,\n          a = (t ? t.width : this._engine.getRenderWidth(!0)) * this._options | 0,\n          l = (t ? t.height : this._engine.getRenderHeight(!0)) * this._options | 0,\n          c = e.parent;\n\n      !c || c.leftCamera != e && c.rightCamera != e || (a /= 2);\n      var h,\n          u = this._options.width || a,\n          d = this._options.height || l;\n\n      if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n        if (this.adaptScaleToCurrentViewport) {\n          var f = o.currentViewport;\n          f && (u *= f.width, d *= f.height);\n        }\n\n        if ((this.renderTargetSamplingMode === Qi.Texture.TRILINEAR_SAMPLINGMODE || this.alwaysForcePOT) && (this._options.width || (u = o.needPOTTextures ? Qi.Tools.GetExponentOfTwo(u, s, this.scaleMode) : u), this._options.height || (d = o.needPOTTextures ? Qi.Tools.GetExponentOfTwo(d, s, this.scaleMode) : d)), this.width !== u || this.height !== d) {\n          if (0 < this._textures.length) {\n            for (var p = 0; p < this._textures.length; p++) this._engine._releaseTexture(this._textures.data[p]);\n\n            this._textures.reset();\n          }\n\n          this.width = u, this.height = d;\n          var _ = {\n            width: this.width,\n            height: this.height\n          },\n              m = {\n            generateMipMaps: !1,\n            generateDepthBuffer: i || 0 === e._postProcesses.indexOf(this),\n            generateStencilBuffer: (i || 0 === e._postProcesses.indexOf(this)) && this._engine.isStencilEnable,\n            samplingMode: this.renderTargetSamplingMode,\n            type: this._textureType\n          };\n          this._textures.push(this._engine.createRenderTargetTexture(_, m)), this._reusable && this._textures.push(this._engine.createRenderTargetTexture(_, m)), this._texelSize.copyFromFloats(1 / this.width, 1 / this.height), this.onSizeChangedObservable.notifyObservers(this);\n        }\n\n        this._textures.forEach(function (e) {\n          e.samples !== r.samples && r._engine.updateRenderTargetTextureSampleCount(e, r.samples);\n        });\n      }\n\n      return this._shareOutputWithPostProcess ? h = this._shareOutputWithPostProcess.inputTexture : this._forcedOutputTexture ? (h = this._forcedOutputTexture, this.width = this._forcedOutputTexture.width, this.height = this._forcedOutputTexture.height) : h = this.inputTexture, this.enablePixelPerfectMode ? (this._scaleRatio.copyFromFloats(a / u, l / d), this._engine.bindFramebuffer(h, 0, a, l, this.forceFullscreenViewport)) : (this._scaleRatio.copyFromFloats(1, 1), this._engine.bindFramebuffer(h, 0, void 0, void 0, this.forceFullscreenViewport)), this.onActivateObservable.notifyObservers(e), this.autoClear && this.alphaMode === Qi.Engine.ALPHA_DISABLE && this._engine.clear(this.clearColor ? this.clearColor : n.clearColor, n._allowPostProcessClearColor, !0, !0), this._reusable && (this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2), h;\n    }, Object.defineProperty(e.prototype, \"isSupported\", {\n      get: function () {\n        return this._effect.isSupported;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"aspectRatio\", {\n      get: function () {\n        return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.aspectRatio : this._forcedOutputTexture ? this._forcedOutputTexture.width / this._forcedOutputTexture.height : this.width / this.height;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.isReady = function () {\n      return this._effect && this._effect.isReady();\n    }, e.prototype.apply = function () {\n      return this._effect && this._effect.isReady() ? (this._engine.enableEffect(this._effect), this._engine.setState(!1), this._engine.setDepthBuffer(!1), this._engine.setDepthWrite(!1), this._engine.setAlphaMode(this.alphaMode), this.alphaConstants && this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a), e = this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.inputTexture : this._forcedOutputTexture ? this._forcedOutputTexture : this.inputTexture, this._effect._bindTexture(\"textureSampler\", e), this._effect.setVector2(\"scale\", this._scaleRatio), this.onApplyObservable.notifyObservers(this._effect), this._effect) : null;\n      var e;\n    }, e.prototype._disposeTextures = function () {\n      if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n        if (0 < this._textures.length) for (var e = 0; e < this._textures.length; e++) this._engine._releaseTexture(this._textures.data[e]);\n\n        this._textures.dispose();\n      }\n    }, e.prototype.dispose = function (e) {\n      if (e = e || this._camera, this._disposeTextures(), this._scene) {\n        var t = this._scene.postProcesses.indexOf(this);\n\n        -1 !== t && this._scene.postProcesses.splice(t, 1);\n      } else {\n        var i = this._engine.postProcesses.indexOf(this);\n\n        -1 !== i && this._engine.postProcesses.splice(i, 1);\n      }\n\n      if (e) {\n        if (e.detachPostProcess(this), 0 === e._postProcesses.indexOf(this) && 0 < e._postProcesses.length) {\n          var r = this._camera._getFirstPostProcess();\n\n          r && r.markTextureDirty();\n        }\n\n        this.onActivateObservable.clear(), this.onAfterRenderObservable.clear(), this.onApplyObservable.clear(), this.onBeforeRenderObservable.clear(), this.onSizeChangedObservable.clear();\n      }\n    }, e;\n  }(), Qi.PostProcess = Zi, qi = $a || ($a = {}), Ji = function (l) {\n    function e(e, t, i, r, n, o, s, a) {\n      return void 0 === i && (i = null), void 0 === s && (s = qi.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === a && (a = !1), l.call(this, e, \"pass\", null, null, t, i, r, n, o, void 0, s, void 0, null, a) || this;\n    }\n\n    return T(e, l), e;\n  }(qi.PostProcess), qi.PassPostProcess = Ji;\n\n  var $i, er, tr, ir, rr, nr, or, sr, ar, lr, cr, hr, ur, dr, fr, pr, _r, mr, gr, vr, yr, br, Tr, Er, xr, Pr, Ar, Sr, Mr, Rr, Cr, Or, Dr, Ir, wr, Lr, Fr, Br, Nr, Vr, Ur, zr, Gr, kr, Wr, Hr, Xr, jr, Yr, Kr, Qr, Zr, qr, Jr, $r, en, tn, rn, nn, on, sn, an, ln, cn, hn, un, dn, fn, pn, _n, mn, gn, vn, yn, bn, Tn, En, xn, Pn, An, Sn, Mn, Rn, Cn, On, Dn, In, wn, Ln, Fn, Bn, Nn, Vn, Un, zn, Gn, kn, Wn, Hn, Xn, jn, Yn, Kn, Qn, Zn, qn, Jn, $n, eo, to, io, ro, no, oo, so, ao, lo, co, ho, uo, fo, po, _o, mo, go, vo, yo, bo, To, Eo, xo, Po, Ao, So, Mo, Ro, Co, Oo, Do, Io, wo, Lo, Fo, Bo, No, Vo, Uo, zo, Go, ko, Wo, Ho, Xo, jo, Yo, Ko, Qo, Zo, qo, Jo, $o, es, ts, is, rs, ns, os, ss, as, ls, cs, hs, us, ds, fs, ps, _s, ms, gs, vs, ys, bs, Ts, Es, xs, Ps, As, Ss, Ms, Rs, Cs, Os, Ds, Is, ws, Ls, Fs, Bs, Ns, Vs, Us, zs, Gs, ks, Ws, Hs, Xs, js, Ys, Ks, Qs, Zs, qs, Js, $s, ea, ta, ia, ra, na, oa, sa, aa;\n\n  ae = this && this.__assign || function () {\n    return (ae = Object.assign || function (e) {\n      for (var t, i = 1, r = arguments.length; i < r; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n      return e;\n    }).apply(this, arguments);\n  };\n\n  $i = $a || ($a = {}), er = function () {\n    function s(e, t, i) {\n      this._bias = 5e-5, this._normalBias = 0, this._blurBoxOffset = 1, this._blurScale = 2, this._blurKernel = 1, this._useKernelBlur = !1, this._filter = s.FILTER_NONE, this._filteringQuality = s.QUALITY_HIGH, this._contactHardeningLightSizeUVRatio = .1, this._darkness = 0, this._transparencyShadow = !1, this.frustumEdgeFalloff = 0, this.forceBackFacesOnly = !1, this._lightDirection = $i.Vector3.Zero(), this._viewMatrix = $i.Matrix.Zero(), this._projectionMatrix = $i.Matrix.Zero(), this._transformMatrix = $i.Matrix.Zero(), this._cachedPosition = new $i.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cachedDirection = new $i.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._currentFaceIndex = 0, this._currentFaceIndexCache = 0, this._defaultTextureMatrix = $i.Matrix.Identity(), this._mapSize = e, this._light = t, this._scene = t.getScene();\n\n      var r = (t._shadowGenerator = this)._scene._getComponent($i.SceneComponentConstants.NAME_SHADOWGENERATOR);\n\n      r || (r = new $i.ShadowGeneratorSceneComponent(this._scene), this._scene._addComponent(r));\n\n      var n = this._scene.getEngine().getCaps();\n\n      i ? n.textureFloatRender && n.textureFloatLinearFiltering ? this._textureType = $i.Engine.TEXTURETYPE_FLOAT : n.textureHalfFloatRender && n.textureHalfFloatLinearFiltering ? this._textureType = $i.Engine.TEXTURETYPE_HALF_FLOAT : this._textureType = $i.Engine.TEXTURETYPE_UNSIGNED_INT : n.textureHalfFloatRender && n.textureHalfFloatLinearFiltering ? this._textureType = $i.Engine.TEXTURETYPE_HALF_FLOAT : n.textureFloatRender && n.textureFloatLinearFiltering ? this._textureType = $i.Engine.TEXTURETYPE_FLOAT : this._textureType = $i.Engine.TEXTURETYPE_UNSIGNED_INT, this._initializeGenerator(), this._applyFilterValues();\n    }\n\n    return Object.defineProperty(s.prototype, \"bias\", {\n      get: function () {\n        return this._bias;\n      },\n      set: function (e) {\n        this._bias = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"normalBias\", {\n      get: function () {\n        return this._normalBias;\n      },\n      set: function (e) {\n        this._normalBias = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"blurBoxOffset\", {\n      get: function () {\n        return this._blurBoxOffset;\n      },\n      set: function (e) {\n        this._blurBoxOffset !== e && (this._blurBoxOffset = e, this._disposeBlurPostProcesses());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"blurScale\", {\n      get: function () {\n        return this._blurScale;\n      },\n      set: function (e) {\n        this._blurScale !== e && (this._blurScale = e, this._disposeBlurPostProcesses());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"blurKernel\", {\n      get: function () {\n        return this._blurKernel;\n      },\n      set: function (e) {\n        this._blurKernel !== e && (this._blurKernel = e, this._disposeBlurPostProcesses());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useKernelBlur\", {\n      get: function () {\n        return this._useKernelBlur;\n      },\n      set: function (e) {\n        this._useKernelBlur !== e && (this._useKernelBlur = e, this._disposeBlurPostProcesses());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"depthScale\", {\n      get: function () {\n        return void 0 !== this._depthScale ? this._depthScale : this._light.getDepthScale();\n      },\n      set: function (e) {\n        this._depthScale = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"filter\", {\n      get: function () {\n        return this._filter;\n      },\n      set: function (e) {\n        if (this._light.needCube()) {\n          if (e === s.FILTER_BLUREXPONENTIALSHADOWMAP) return void (this.useExponentialShadowMap = !0);\n          if (e === s.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) return void (this.useCloseExponentialShadowMap = !0);\n          if (e === s.FILTER_PCF || e === s.FILTER_PCSS) return void (this.usePoissonSampling = !0);\n        }\n\n        e !== s.FILTER_PCF && e !== s.FILTER_PCSS || 1 !== this._scene.getEngine().webGLVersion ? this._filter !== e && (this._filter = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty()) : this.usePoissonSampling = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"usePoissonSampling\", {\n      get: function () {\n        return this.filter === s.FILTER_POISSONSAMPLING;\n      },\n      set: function (e) {\n        (e || this.filter === s.FILTER_POISSONSAMPLING) && (this.filter = e ? s.FILTER_POISSONSAMPLING : s.FILTER_NONE);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useVarianceShadowMap\", {\n      get: function () {\n        return $i.Tools.Warn(\"VSM are now replaced by ESM. Please use useExponentialShadowMap instead.\"), this.useExponentialShadowMap;\n      },\n      set: function (e) {\n        $i.Tools.Warn(\"VSM are now replaced by ESM. Please use useExponentialShadowMap instead.\"), this.useExponentialShadowMap = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useBlurVarianceShadowMap\", {\n      get: function () {\n        return $i.Tools.Warn(\"VSM are now replaced by ESM. Please use useBlurExponentialShadowMap instead.\"), this.useBlurExponentialShadowMap;\n      },\n      set: function (e) {\n        $i.Tools.Warn(\"VSM are now replaced by ESM. Please use useBlurExponentialShadowMap instead.\"), this.useBlurExponentialShadowMap = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useExponentialShadowMap\", {\n      get: function () {\n        return this.filter === s.FILTER_EXPONENTIALSHADOWMAP;\n      },\n      set: function (e) {\n        (e || this.filter === s.FILTER_EXPONENTIALSHADOWMAP) && (this.filter = e ? s.FILTER_EXPONENTIALSHADOWMAP : s.FILTER_NONE);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useBlurExponentialShadowMap\", {\n      get: function () {\n        return this.filter === s.FILTER_BLUREXPONENTIALSHADOWMAP;\n      },\n      set: function (e) {\n        (e || this.filter === s.FILTER_BLUREXPONENTIALSHADOWMAP) && (this.filter = e ? s.FILTER_BLUREXPONENTIALSHADOWMAP : s.FILTER_NONE);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useCloseExponentialShadowMap\", {\n      get: function () {\n        return this.filter === s.FILTER_CLOSEEXPONENTIALSHADOWMAP;\n      },\n      set: function (e) {\n        (e || this.filter === s.FILTER_CLOSEEXPONENTIALSHADOWMAP) && (this.filter = e ? s.FILTER_CLOSEEXPONENTIALSHADOWMAP : s.FILTER_NONE);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useBlurCloseExponentialShadowMap\", {\n      get: function () {\n        return this.filter === s.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;\n      },\n      set: function (e) {\n        (e || this.filter === s.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) && (this.filter = e ? s.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP : s.FILTER_NONE);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"usePercentageCloserFiltering\", {\n      get: function () {\n        return this.filter === s.FILTER_PCF;\n      },\n      set: function (e) {\n        (e || this.filter === s.FILTER_PCF) && (this.filter = e ? s.FILTER_PCF : s.FILTER_NONE);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"filteringQuality\", {\n      get: function () {\n        return this._filteringQuality;\n      },\n      set: function (e) {\n        this._filteringQuality = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"useContactHardeningShadow\", {\n      get: function () {\n        return this.filter === s.FILTER_PCSS;\n      },\n      set: function (e) {\n        (e || this.filter === s.FILTER_PCSS) && (this.filter = e ? s.FILTER_PCSS : s.FILTER_NONE);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"contactHardeningLightSizeUVRatio\", {\n      get: function () {\n        return this._contactHardeningLightSizeUVRatio;\n      },\n      set: function (e) {\n        this._contactHardeningLightSizeUVRatio = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), s.prototype.getDarkness = function () {\n      return this._darkness;\n    }, s.prototype.setDarkness = function (e) {\n      return this._darkness = 1 <= e ? 1 : e <= 0 ? 0 : e, this;\n    }, s.prototype.setTransparencyShadow = function (e) {\n      return this._transparencyShadow = e, this;\n    }, s.prototype.getShadowMap = function () {\n      return this._shadowMap;\n    }, s.prototype.getShadowMapForRendering = function () {\n      return this._shadowMap2 ? this._shadowMap2 : this._shadowMap;\n    }, s.prototype.addShadowCaster = function (e, t) {\n      var i;\n      return void 0 === t && (t = !0), this._shadowMap && (this._shadowMap.renderList || (this._shadowMap.renderList = []), this._shadowMap.renderList.push(e), t && (i = this._shadowMap.renderList).push.apply(i, e.getChildMeshes())), this;\n    }, s.prototype.removeShadowCaster = function (e, t) {\n      if (void 0 === t && (t = !0), !this._shadowMap || !this._shadowMap.renderList) return this;\n\n      var i = this._shadowMap.renderList.indexOf(e);\n\n      if (-1 !== i && this._shadowMap.renderList.splice(i, 1), t) for (var r = 0, n = e.getChildren(); r < n.length; r++) {\n        var o = n[r];\n        this.removeShadowCaster(o);\n      }\n      return this;\n    }, s.prototype.getLight = function () {\n      return this._light;\n    }, s.prototype._initializeGenerator = function () {\n      this._light._markMeshesAsLightDirty(), this._initializeShadowMap();\n    }, s.prototype._initializeShadowMap = function () {\n      var t = this,\n          i = this._scene.getEngine();\n\n      1 < i.webGLVersion ? (this._shadowMap = new $i.RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube(), void 0, !1, !1), this._shadowMap.createDepthStencilTexture($i.Engine.LESS, !0)) : this._shadowMap = new $i.RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube()), this._shadowMap.wrapU = $i.Texture.CLAMP_ADDRESSMODE, this._shadowMap.wrapV = $i.Texture.CLAMP_ADDRESSMODE, this._shadowMap.anisotropicFilteringLevel = 1, this._shadowMap.updateSamplingMode($i.Texture.BILINEAR_SAMPLINGMODE), this._shadowMap.renderParticles = !1, this._shadowMap.ignoreCameraViewport = !0, this._shadowMap.onBeforeRenderObservable.add(function (e) {\n        t._currentFaceIndex = e, t._filter === s.FILTER_PCF && i.setColorWrite(!1);\n      }), this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this), this._shadowMap.onAfterUnbindObservable.add(function () {\n        if (t._filter === s.FILTER_PCF && i.setColorWrite(!0), t.useBlurExponentialShadowMap || t.useBlurCloseExponentialShadowMap) {\n          var e = t.getShadowMapForRendering();\n          e && t._scene.postProcessManager.directRender(t._blurPostProcesses, e.getInternalTexture(), !0);\n        }\n      });\n      var r = new $i.Color4(0, 0, 0, 0),\n          n = new $i.Color4(1, 1, 1, 1);\n\n      this._shadowMap.onClearObservable.add(function (e) {\n        t._filter === s.FILTER_PCF ? e.clear(n, !1, !0, !1) : t.useExponentialShadowMap || t.useBlurExponentialShadowMap ? e.clear(r, !0, !0, !1) : e.clear(n, !0, !0, !1);\n      });\n    }, s.prototype._initializeBlurRTTAndPostProcesses = function () {\n      var t = this,\n          e = this._scene.getEngine(),\n          i = this._mapSize / this.blurScale;\n\n      this.useKernelBlur && 1 === this.blurScale || (this._shadowMap2 = new $i.RenderTargetTexture(this._light.name + \"_shadowMap2\", i, this._scene, !1, !0, this._textureType), this._shadowMap2.wrapU = $i.Texture.CLAMP_ADDRESSMODE, this._shadowMap2.wrapV = $i.Texture.CLAMP_ADDRESSMODE, this._shadowMap2.updateSamplingMode($i.Texture.BILINEAR_SAMPLINGMODE)), this.useKernelBlur ? (this._kernelBlurXPostprocess = new $i.BlurPostProcess(this._light.name + \"KernelBlurX\", new $i.Vector2(1, 0), this.blurKernel, 1, null, $i.Texture.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.width = i, this._kernelBlurXPostprocess.height = i, this._kernelBlurXPostprocess.onApplyObservable.add(function (e) {\n        e.setTexture(\"textureSampler\", t._shadowMap);\n      }), this._kernelBlurYPostprocess = new $i.BlurPostProcess(this._light.name + \"KernelBlurY\", new $i.Vector2(0, 1), this.blurKernel, 1, null, $i.Texture.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.autoClear = !1, this._kernelBlurYPostprocess.autoClear = !1, this._textureType === $i.Engine.TEXTURETYPE_UNSIGNED_INT && (this._kernelBlurXPostprocess.packedFloat = !0, this._kernelBlurYPostprocess.packedFloat = !0), this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess]) : (this._boxBlurPostprocess = new $i.PostProcess(this._light.name + \"DepthBoxBlur\", \"depthBoxBlur\", [\"screenSize\", \"boxOffset\"], [], 1, null, $i.Texture.BILINEAR_SAMPLINGMODE, e, !1, \"#define OFFSET \" + this._blurBoxOffset, this._textureType), this._boxBlurPostprocess.onApplyObservable.add(function (e) {\n        e.setFloat2(\"screenSize\", i, i), e.setTexture(\"textureSampler\", t._shadowMap);\n      }), this._boxBlurPostprocess.autoClear = !1, this._blurPostProcesses = [this._boxBlurPostprocess]);\n    }, s.prototype._renderForShadowMap = function (e, t, i, r) {\n      var n,\n          o = this._scene.getEngine();\n\n      if (r.length) {\n        for (o.setColorWrite(!1), n = 0; n < r.length; n++) this._renderSubMeshForShadowMap(r.data[n]);\n\n        o.setColorWrite(!0);\n      }\n\n      for (n = 0; n < e.length; n++) this._renderSubMeshForShadowMap(e.data[n]);\n\n      for (n = 0; n < t.length; n++) this._renderSubMeshForShadowMap(t.data[n]);\n\n      if (this._transparencyShadow) for (n = 0; n < i.length; n++) this._renderSubMeshForShadowMap(i.data[n]);\n    }, s.prototype._renderSubMeshForShadowMap = function (e) {\n      var i = this,\n          t = e.getRenderingMesh(),\n          r = this._scene,\n          n = r.getEngine(),\n          o = e.getMaterial();\n\n      if (o) {\n        n.setState(o.backFaceCulling);\n\n        var s = t._getInstancesRenderList(e._id);\n\n        if (!s.mustReturn) {\n          var a = n.getCaps().instancedArrays && null !== s.visibleInstances[e._id] && void 0 !== s.visibleInstances[e._id];\n\n          if (this.isReady(e, a)) {\n            if (n.enableEffect(this._effect), t._bind(e, this._effect, $i.Material.TriangleFillMode), this._effect.setFloat3(\"biasAndScale\", this.bias, this.normalBias, this.depthScale), this._effect.setMatrix(\"viewProjection\", this.getTransformMatrix()), this.getLight().getTypeID() === $i.Light.LIGHTTYPEID_DIRECTIONALLIGHT ? this._effect.setVector3(\"lightData\", this._cachedDirection) : this._effect.setVector3(\"lightData\", this._cachedPosition), r.activeCamera && this._effect.setFloat2(\"depthValues\", this.getLight().getDepthMinZ(r.activeCamera), this.getLight().getDepthMinZ(r.activeCamera) + this.getLight().getDepthMaxZ(r.activeCamera)), o && o.needAlphaTesting()) {\n              var l = o.getAlphaTestTexture();\n              l && (this._effect.setTexture(\"diffuseSampler\", l), this._effect.setMatrix(\"diffuseMatrix\", l.getTextureMatrix() || this._defaultTextureMatrix));\n            }\n\n            t.useBones && t.computeBonesUsingShaders && this._effect.setMatrices(\"mBones\", t.skeleton.getTransformMatrices(t)), $i.MaterialHelper.BindMorphTargetParameters(t, this._effect), this.forceBackFacesOnly && n.setState(!0, 0, !1, !0), t._processRendering(e, this._effect, $i.Material.TriangleFillMode, s, a, function (e, t) {\n              return i._effect.setMatrix(\"world\", t);\n            }), this.forceBackFacesOnly && n.setState(!0, 0, !1, !1);\n          } else this._shadowMap && this._shadowMap.resetRefreshCounter();\n        }\n      }\n    }, s.prototype._applyFilterValues = function () {\n      this._shadowMap && (this.filter === s.FILTER_NONE || this.filter === s.FILTER_PCSS ? this._shadowMap.updateSamplingMode($i.Texture.NEAREST_SAMPLINGMODE) : this._shadowMap.updateSamplingMode($i.Texture.BILINEAR_SAMPLINGMODE));\n    }, s.prototype.forceCompilation = function (e, t) {\n      var i = this,\n          r = ae({\n        useInstances: !1\n      }, t),\n          n = this.getShadowMap();\n\n      if (n) {\n        var o = n.renderList;\n\n        if (o) {\n          for (var s = new Array(), a = 0, l = o; a < l.length; a++) {\n            var c = l[a];\n            s.push.apply(s, c.subMeshes);\n          }\n\n          if (0 !== s.length) {\n            var h = 0,\n                u = function () {\n              if (i._scene && i._scene.getEngine()) {\n                for (; i.isReady(s[h], r.useInstances);) if (++h >= s.length) return void (e && e(i));\n\n                setTimeout(u, 16);\n              }\n            };\n\n            u();\n          } else e && e(this);\n        } else e && e(this);\n      } else e && e(this);\n    }, s.prototype.forceCompilationAsync = function (t) {\n      var i = this;\n      return new Promise(function (e) {\n        i.forceCompilation(function () {\n          e();\n        }, t);\n      });\n    }, s.prototype.isReady = function (e, t) {\n      var i = [];\n      this._textureType !== $i.Engine.TEXTURETYPE_UNSIGNED_INT && i.push(\"#define FLOAT\"), this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? i.push(\"#define ESM\") : (this.usePercentageCloserFiltering || this.useContactHardeningShadow) && i.push(\"#define DEPTHTEXTURE\");\n      var r = [$i.VertexBuffer.PositionKind],\n          n = e.getMesh(),\n          o = e.getMaterial();\n\n      if (this.normalBias && n.isVerticesDataPresent($i.VertexBuffer.NormalKind) && (r.push($i.VertexBuffer.NormalKind), i.push(\"#define NORMAL\"), n.nonUniformScaling && i.push(\"#define NONUNIFORMSCALING\"), this.getLight().getTypeID() === $i.Light.LIGHTTYPEID_DIRECTIONALLIGHT && i.push(\"#define DIRECTIONINLIGHTDATA\")), o && o.needAlphaTesting()) {\n        var s = o.getAlphaTestTexture();\n        s && (i.push(\"#define ALPHATEST\"), n.isVerticesDataPresent($i.VertexBuffer.UVKind) && (r.push($i.VertexBuffer.UVKind), i.push(\"#define UV1\")), n.isVerticesDataPresent($i.VertexBuffer.UV2Kind) && 1 === s.coordinatesIndex && (r.push($i.VertexBuffer.UV2Kind), i.push(\"#define UV2\")));\n      }\n\n      n.useBones && n.computeBonesUsingShaders ? (r.push($i.VertexBuffer.MatricesIndicesKind), r.push($i.VertexBuffer.MatricesWeightsKind), 4 < n.numBoneInfluencers && (r.push($i.VertexBuffer.MatricesIndicesExtraKind), r.push($i.VertexBuffer.MatricesWeightsExtraKind)), i.push(\"#define NUM_BONE_INFLUENCERS \" + n.numBoneInfluencers), i.push(\"#define BonesPerMesh \" + (n.skeleton.bones.length + 1))) : i.push(\"#define NUM_BONE_INFLUENCERS 0\");\n      var a = n.morphTargetManager,\n          l = 0;\n      a && 0 < a.numInfluencers && (i.push(\"#define MORPHTARGETS\"), l = a.numInfluencers, i.push(\"#define NUM_MORPH_INFLUENCERS \" + l), $i.MaterialHelper.PrepareAttributesForMorphTargets(r, n, {\n        NUM_MORPH_INFLUENCERS: l\n      })), t && (i.push(\"#define INSTANCES\"), r.push(\"world0\"), r.push(\"world1\"), r.push(\"world2\"), r.push(\"world3\"));\n      var c = i.join(\"\\n\");\n      return this._cachedDefines !== c && (this._cachedDefines = c, this._effect = this._scene.getEngine().createEffect(\"shadowMap\", r, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"lightData\", \"depthValues\", \"biasAndScale\", \"morphTargetInfluences\"], [\"diffuseSampler\"], c, void 0, void 0, void 0, {\n        maxSimultaneousMorphTargets: l\n      })), !!this._effect.isReady() && ((this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (this._blurPostProcesses && this._blurPostProcesses.length || this._initializeBlurRTTAndPostProcesses()), !(this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) && !(this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) && !(this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()));\n    }, s.prototype.prepareDefines = function (e, t) {\n      var i = this._scene,\n          r = this._light;\n      i.shadowsEnabled && r.shadowEnabled && (e[\"SHADOW\" + t] = !0, this.useContactHardeningShadow && (e[\"SHADOWPCSS\" + t] = !0, this._filteringQuality === s.QUALITY_LOW ? e[\"SHADOWLOWQUALITY\" + t] = !0 : this._filteringQuality === s.QUALITY_MEDIUM && (e[\"SHADOWMEDIUMQUALITY\" + t] = !0)), this.usePercentageCloserFiltering ? (e[\"SHADOWPCF\" + t] = !0, this._filteringQuality === s.QUALITY_LOW ? e[\"SHADOWLOWQUALITY\" + t] = !0 : this._filteringQuality === s.QUALITY_MEDIUM && (e[\"SHADOWMEDIUMQUALITY\" + t] = !0)) : this.usePoissonSampling ? e[\"SHADOWPOISSON\" + t] = !0 : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? e[\"SHADOWESM\" + t] = !0 : (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (e[\"SHADOWCLOSEESM\" + t] = !0), r.needCube() && (e[\"SHADOWCUBE\" + t] = !0));\n    }, s.prototype.bindShadowLight = function (e, t) {\n      var i = this._light,\n          r = this._scene;\n\n      if (r.shadowsEnabled && i.shadowEnabled) {\n        var n = r.activeCamera;\n\n        if (n) {\n          var o = this.getShadowMap();\n          o && (i.needCube() || t.setMatrix(\"lightMatrix\" + e, this.getTransformMatrix()), this._filter === s.FILTER_PCF ? (t.setDepthStencilTexture(\"shadowSampler\" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), o.getSize().width, 1 / o.getSize().width, this.frustumEdgeFalloff, e)) : this._filter === s.FILTER_PCSS ? (t.setDepthStencilTexture(\"shadowSampler\" + e, this.getShadowMapForRendering()), t.setTexture(\"depthSampler\" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / o.getSize().width, this._contactHardeningLightSizeUVRatio * o.getSize().width, this.frustumEdgeFalloff, e)) : (t.setTexture(\"shadowSampler\" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), this.blurScale / o.getSize().width, this.depthScale, this.frustumEdgeFalloff, e)), i._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(n), this.getLight().getDepthMinZ(n) + this.getLight().getDepthMaxZ(n), e));\n        }\n      }\n    }, s.prototype.getTransformMatrix = function () {\n      var e = this._scene;\n      if (this._currentRenderID === e.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) return this._transformMatrix;\n      this._currentRenderID = e.getRenderId(), this._currentFaceIndexCache = this._currentFaceIndex;\n      var t = this._light.position;\n\n      if (this._light.computeTransformedInformation() && (t = this._light.transformedPosition), $i.Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection), 1 === Math.abs($i.Vector3.Dot(this._lightDirection, $i.Vector3.Up())) && (this._lightDirection.z = 1e-13), this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !t.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {\n        this._cachedPosition.copyFrom(t), this._cachedDirection.copyFrom(this._lightDirection), $i.Matrix.LookAtLHToRef(t, t.add(this._lightDirection), $i.Vector3.Up(), this._viewMatrix);\n        var i = this.getShadowMap();\n\n        if (i) {\n          var r = i.renderList;\n          r && this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, r);\n        }\n\n        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n      }\n\n      return this._transformMatrix;\n    }, s.prototype.recreateShadowMap = function () {\n      var e = this._shadowMap;\n\n      if (e) {\n        var t = e.renderList;\n        this._disposeRTTandPostProcesses(), this._initializeGenerator(), this.filter = this.filter, this._applyFilterValues(), this._shadowMap.renderList = t;\n      }\n    }, s.prototype._disposeBlurPostProcesses = function () {\n      this._shadowMap2 && (this._shadowMap2.dispose(), this._shadowMap2 = null), this._boxBlurPostprocess && (this._boxBlurPostprocess.dispose(), this._boxBlurPostprocess = null), this._kernelBlurXPostprocess && (this._kernelBlurXPostprocess.dispose(), this._kernelBlurXPostprocess = null), this._kernelBlurYPostprocess && (this._kernelBlurYPostprocess.dispose(), this._kernelBlurYPostprocess = null), this._blurPostProcesses = [];\n    }, s.prototype._disposeRTTandPostProcesses = function () {\n      this._shadowMap && (this._shadowMap.dispose(), this._shadowMap = null), this._disposeBlurPostProcesses();\n    }, s.prototype.dispose = function () {\n      this._disposeRTTandPostProcesses(), this._light && (this._light._shadowGenerator = null, this._light._markMeshesAsLightDirty());\n    }, s.prototype.serialize = function () {\n      var e = {},\n          t = this.getShadowMap();\n      if (!t) return e;\n      if (e.lightId = this._light.id, e.mapSize = t.getRenderSize(), e.useExponentialShadowMap = this.useExponentialShadowMap, e.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap, e.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap, e.usePoissonSampling = this.usePoissonSampling, e.forceBackFacesOnly = this.forceBackFacesOnly, e.depthScale = this.depthScale, e.darkness = this.getDarkness(), e.blurBoxOffset = this.blurBoxOffset, e.blurKernel = this.blurKernel, e.blurScale = this.blurScale, e.useKernelBlur = this.useKernelBlur, e.transparencyShadow = this._transparencyShadow, e.frustumEdgeFalloff = this.frustumEdgeFalloff, e.bias = this.bias, e.normalBias = this.normalBias, e.usePercentageCloserFiltering = this.usePercentageCloserFiltering, e.useContactHardeningShadow = this.useContactHardeningShadow, e.filteringQuality = this.filteringQuality, e.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio, e.renderList = [], t.renderList) for (var i = 0; i < t.renderList.length; i++) {\n        var r = t.renderList[i];\n        e.renderList.push(r.id);\n      }\n      return e;\n    }, s.Parse = function (e, t) {\n      for (var i = t.getLightByID(e.lightId), r = new s(e.mapSize, i), n = r.getShadowMap(), o = 0; o < e.renderList.length; o++) {\n        t.getMeshesByID(e.renderList[o]).forEach(function (e) {\n          n && (n.renderList || (n.renderList = []), n.renderList.push(e));\n        });\n      }\n\n      return e.usePoissonSampling ? r.usePoissonSampling = !0 : e.useExponentialShadowMap ? r.useExponentialShadowMap = !0 : e.useBlurExponentialShadowMap ? r.useBlurExponentialShadowMap = !0 : e.useCloseExponentialShadowMap ? r.useCloseExponentialShadowMap = !0 : e.useBlurCloseExponentialShadowMap ? r.useBlurCloseExponentialShadowMap = !0 : e.usePercentageCloserFiltering ? r.usePercentageCloserFiltering = !0 : e.useContactHardeningShadow && (r.useContactHardeningShadow = !0), e.filteringQuality && (r.filteringQuality = e.filteringQuality), e.contactHardeningLightSizeUVRatio ? r.contactHardeningLightSizeUVRatio = e.contactHardeningLightSizeUVRatio : e.useVarianceShadowMap ? r.useExponentialShadowMap = !0 : e.useBlurVarianceShadowMap && (r.useBlurExponentialShadowMap = !0), e.depthScale && (r.depthScale = e.depthScale), e.blurScale && (r.blurScale = e.blurScale), e.blurBoxOffset && (r.blurBoxOffset = e.blurBoxOffset), e.useKernelBlur && (r.useKernelBlur = e.useKernelBlur), e.blurKernel && (r.blurKernel = e.blurKernel), void 0 !== e.bias && (r.bias = e.bias), void 0 !== e.normalBias && (r.normalBias = e.normalBias), void 0 !== e.frustumEdgeFalloff && (r.frustumEdgeFalloff = e.frustumEdgeFalloff), e.darkness && r.setDarkness(e.darkness), e.transparencyShadow && r.setTransparencyShadow(!0), r.forceBackFacesOnly = e.forceBackFacesOnly, r;\n    }, s.FILTER_NONE = 0, s.FILTER_EXPONENTIALSHADOWMAP = 1, s.FILTER_POISSONSAMPLING = 2, s.FILTER_BLUREXPONENTIALSHADOWMAP = 3, s.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4, s.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5, s.FILTER_PCF = 6, s.FILTER_PCSS = 7, s.QUALITY_HIGH = 0, s.QUALITY_MEDIUM = 1, s.QUALITY_LOW = 2, s;\n  }(), $i.ShadowGenerator = er, function (a) {\n    a.AbstractScene.AddParser(a.SceneComponentConstants.NAME_SHADOWGENERATOR, function (e, t, i, r) {\n      if (void 0 !== e.shadowGenerators && null !== e.shadowGenerators) for (var n = 0, o = e.shadowGenerators.length; n < o; n++) {\n        var s = e.shadowGenerators[n];\n        a.ShadowGenerator.Parse(s, t);\n      }\n    });\n\n    var e = function () {\n      function e(e) {\n        this.name = a.SceneComponentConstants.NAME_SHADOWGENERATOR, this.scene = e;\n      }\n\n      return e.prototype.register = function () {\n        this.scene._gatherRenderTargetsStage.registerStep(a.SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n      }, e.prototype.rebuild = function () {}, e.prototype.serialize = function (e) {\n        e.shadowGenerators = [];\n\n        for (var t = 0, i = this.scene.lights; t < i.length; t++) {\n          var r = i[t].getShadowGenerator();\n          r && e.shadowGenerators.push(r.serialize());\n        }\n      }, e.prototype.addFromContainer = function (e) {}, e.prototype.removeFromContainer = function (e) {}, e.prototype.dispose = function () {}, e.prototype._gatherRenderTargets = function (e) {\n        var t = this.scene;\n        if (this.scene.shadowsEnabled) for (var i = 0; i < t.lights.length; i++) {\n          var r = t.lights[i],\n              n = r.getShadowGenerator();\n\n          if (r.isEnabled() && r.shadowEnabled && n) {\n            var o = n.getShadowMap();\n            -1 !== t.textures.indexOf(o) && e.push(o);\n          }\n        }\n      }, e;\n    }();\n\n    a.ShadowGeneratorSceneComponent = e;\n  }($a || ($a = {})), tr = $a || ($a = {}), ir = function () {\n    function e(e, t, i) {\n      void 0 === t && (t = \"\"), void 0 === i && (i = \"black\");\n      var r = this;\n      this._renderingCanvas = e, this._loadingText = t, this._loadingDivBackgroundColor = i, this._resizeLoadingUI = function () {\n        var e = r._renderingCanvas.getBoundingClientRect(),\n            t = window.getComputedStyle(r._renderingCanvas).position;\n\n        r._loadingDiv && (r._loadingDiv.style.position = \"fixed\" === t ? \"fixed\" : \"absolute\", r._loadingDiv.style.left = e.left + \"px\", r._loadingDiv.style.top = e.top + \"px\", r._loadingDiv.style.width = e.width + \"px\", r._loadingDiv.style.height = e.height + \"px\");\n      };\n    }\n\n    return e.prototype.displayLoadingUI = function () {\n      if (!this._loadingDiv) {\n        this._loadingDiv = document.createElement(\"div\"), this._loadingDiv.id = \"babylonjsLoadingDiv\", this._loadingDiv.style.opacity = \"0\", this._loadingDiv.style.transition = \"opacity 1.5s ease\", this._loadingDiv.style.pointerEvents = \"none\", this._loadingTextDiv = document.createElement(\"div\"), this._loadingTextDiv.style.position = \"absolute\", this._loadingTextDiv.style.left = \"0\", this._loadingTextDiv.style.top = \"50%\", this._loadingTextDiv.style.marginTop = \"80px\", this._loadingTextDiv.style.width = \"100%\", this._loadingTextDiv.style.height = \"20px\", this._loadingTextDiv.style.fontFamily = \"Arial\", this._loadingTextDiv.style.fontSize = \"14px\", this._loadingTextDiv.style.color = \"white\", this._loadingTextDiv.style.textAlign = \"center\", this._loadingTextDiv.innerHTML = \"Loading\", this._loadingDiv.appendChild(this._loadingTextDiv), this._loadingTextDiv.innerHTML = this._loadingText;\n        var e = document.createElement(\"style\");\n        e.type = \"text/css\";\n        e.innerHTML = \"@-webkit-keyframes spin1 {                    0% { -webkit-transform: rotate(0deg);}\\n                    100% { -webkit-transform: rotate(360deg);}\\n                }                @keyframes spin1 {                    0% { transform: rotate(0deg);}\\n                    100% { transform: rotate(360deg);}\\n                }\", document.getElementsByTagName(\"head\")[0].appendChild(e);\n        var t = new Image();\n        t.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAYq0lEQVR4Xu2dCZRcVZnHScAJUZSwjSOIbAJmEAZwQCCMoAInYRGIg8AwegQx7AFzUBBmzAFlE4EAwxz2GRk2w7AnAURZBiEOZgyEQDAQAjmEJqTpNd3V1V3Vmd+/6utKV7/1vnpVXd2p/zn3vOV+27vfu/fd/W3QQAPrBZqbm7fJZrN79vf3T+/r67uf4wO9vb37WXQDIwWtra0Tenp6voQTv5XP56/BkfcR3iLk1g6B7hEeI+zP5V+ZiAbqBZ2dnZ8lV+6Gg87CobfhpOc4byf0FjwYE9DneBkWcXrM2tmzNzTxDdQKJPyETCazI46YgiMuI9zJuXJltuChFIHsP/PSfIfTjU19A2mira1tcxy3ey6XO5vEnkV4kes11XBmENDVj97XOT2O03FmWgMuoNLzGRJva8IUnPkzjjcT/kLoKCZzfQB7XiX8M2G8md7AUJgzJ+Z6e88gZ1xGuj3HsY17PcVkrG9gp7CUF/F8PUvxqdZDrFq1ahNVfKjwTCYxZuDE2wjKlc2WViMePM+HPNsFPOdf22OPblD5OZQHvphnV65cjTMzxaQY3eA5V9OO/hmnm1lSjE7woFsQbiXki4++foHnXkW4mLC1JUl947333tsMY3emqfB9jtPJlXN5U0+bOXPmWCPxgOccSy4+AfqPio+9/oFnbyatbqVE28GSZfjQ1NT0KQzaHMcdyPfyaNoE12HcvdxT29K3Fkv8A2vWrPmcifAFZNtD91yRY+SBZ+9UsMtEgD+jTpeenp6JXI6xpKkuUDqRcA6Kr0Wpens+InQTnIpV6Fdi+BQT64ulS5eOIzefD62na7CeoGcnLCM8ykt5OWlzcPv772/BS/w3nP+K+xU11+DvQe5dcrQlTfWAwbNMb8XA8AyGX80xtLlA6TAJuteMbVhhia1v5VMcr+LWMeoZ4xiYw7q6urbhHbgG+paCkIRQehHu4pO3O5fVydEomF5Ulx548JfVD2wqfKE2I3R3ob/f2GoC1DWhdz7HG3i5j2pvb9+Z24m6HvVZQtYsZFWcowlzePEP4jJdR/OQhxTVpAs9NMXxmZxuZKo8IG4s+v8R2tUFphSBTBWzH+OAFwn/gS3TuN55xYoVqfc6dXd3fwHZ1xFaTX0iyGbwjJqXXAammxP00EXx6UMGEx7ram7+vKnzBZ/87Xiwp40tEdDTgYwlHG/CmadSjO7L+XiialOZAej7POFG2VK0Khngl6Pn8/LL0YEtlFh4n8oDAqvaAYH8tzH2iNDm1IIFn8Ax50G7xtgCAU07CfAG4RHOz+vLZL7e0dGxlYlKHaj8BHo25xgrsfV5wrYH4KmouxV+ZZDnCUdwmXxMGgFvFUVWD+jQuOot6rI0tb4gcfaG9v+MrcAn+wj38gL8C7cObmlp2ZRjOkWYD6ypuAf6zjFHLSJ0c/6YQ813DM/yZXgehreiVgP8cvSfsOeExYsXuzs6n8v9j8mqBRZQmdjXVPuira1NHSpn8UDf4Xu0vd2uCtDzacJOlDDf5ng94X8JTWarB8R1EK7ju7udiYgEz/v3pLFKm4oHUHhh3iZdfshpaEYpA4pvKLLXBujLYKRq71XLhUHg27z12rW9B6L/QhLrWWxRH7nzeDK8awi/5HRTEx0K6MZQ694LHk0DqrgfADkreIYz1q5c+UlTEQzesIuMryrggYQWjNL3RGO7p2tuFMeqjaOidgzyCz1yJMTJ6L6d66WEVCcHIO/dQkI75Chs2g97Hoc3jRz9Lge1ED5l4r0gckqRPB0gTw34t1B+h3IqxZkmrn2SULUa7ezZszdE5xfR9130Xsm5ilrnHrmkQOcKvrkncxqrIiY6wlewbw7BOUfDo/b84zzvj9C7J7eCS0NrUiRKCPjUE7ScMBdlF/B2HqBi0ERXBcuXL99YnQz9fX2ah3Up4UnsWGEmDRuUhoTn+Z5PfvbZZ2N/fuCZRJgnfhNVBu73EZoIKt7l0L2UBsYeDZg016nb5EUCWuXQewinUtTuyq2aTStF14a8SD+VDQVj6hDYxjuXf4Hjl83sSMCmTp8j4FtoMuRQ5dAZcii3kk/0s2bBhxIcBxjxUlib1hWInEDO/6qKV+y4geO5HAMntEE/pq+nZyo0ywsG1SmwL4Orf+0yqGCfmvR73LAn9lAeBjQTEhkA+1h49a08iRflcq4H5iuXFU9cz4lqihC/LXS/NZa6Bc+pz5gql5ub6VXD2tZWTSPeyS7XgeLhXrMnEhj6MSHSwaIhFGZH8oA/JzzFeexvJbRN2HW03moT6cEChx6w4QY2rurn85JWrxsiCy0FwjcIqos8w7GZNPulkawDEbFHlaBtjzODEDrVztuKXMmADPWA3RaljyJeNdKq98ilAez8iJdyGqfO31V4NoV/EvyaCqR54V2EshE5Lqcb+TrkstkTLD4WKB4PNNZQ8P05HAelMXNSPWChC8JsYvwthJo0jSoF6fIqjjqe08Aat+LIkd+AVjn09zxbZFqK3tjXAUbXUaWDjTUSyN4J45YZX2Igo4cEOVfFson2ALIxSjR0jog5YNgpfNHM90BxIjDyWIB8Z2NfB01HISJ20wPaw4w1FlavXq1v8aPGXhFw9JNRFTDItifU/RwwpfmKxYsDK180kU4x0lhAXvOSJUs+bezlIDL2N4xi4GpjK4MGCuzUA+SPxzn3m4iKgKyV2DCV08DeMWg0B+zHHOt2DpjS3Mz1BfFOM25C5ZH4LxldJBB0g7GVARkaXgv8VsKqZtIMPpN9RUnJgRzU5Wfp22vifcG3+2vQvmdsdQXsX2pm+oKX+GYjjQXkPWqsXshpRhcJ0RpbGShSHiSuheP37ZYHsGusVHOrU1lMxkO9od4eE+8LlSzQqfetpnPAooBN/2Um+gISp89MkF8K4G3RrMJYoOhbYGxlQEGhSOGogfoLwipExGtUZVVBYIVAluaAaUpuWA+YujlPF22Ra/iBLYEOsV6tV4w0FiitfmLsXiBMU0NiAVrfsp77Zd8MHPgbDoHtva6uLs1jiv1piAKy5tCG+4KJ9wVO/p6RDzvy+b5rzSwP9Okh/WKPERiCWzfk4K8bUSTiOljAyCdx5DZG4gE8W5Dov+NYUfsV/j50fUC4dmXIQDh0qQ6PVgJsOcLM8oA410Ggvo6Ojr81di+g2TKuQOiyJOKWxlpCJpM5zUjKAL3awTsamQfEbYhjtDGKa5tPsyn/wAuiURftlBO56h6aunEwCMxxvV1d+2Fr7Jce2vAu5LUtLeoGi/19gtbToCaR97BoD6BvUs+WkXqgbw6OuhC6wH5l4rRGaCFOvYnjYbyxnpcsCvDVhYOxo6+zszNwSNHVTtJEmSiwzlMAQmNPwIPW42Dds2hfEK/5WJo0Fth+5VNxFHSlkoTzFRh/N3wnq0OGWxXtdoO8enFwaI4jsyidYgNZTxhrMEjEJ4w+En65ESWRXZ7Q4K/COqDAPlhka87WedB8KawmngTIHREOJs5pMiRp+p/GGgxL1FiA9hxjK6G1tVVdhJGAV15+cPXq1f7dahVC20Wg4miCp0uTe3Xh4Hwu93rY1B7SR/t7xQbP5R1FGgpy8IlKe+MJhZ9Aa7u5jPm+pGLX2BMDOZ+hDXgQiXIJ5xoXHZg96anEEFcvOTi0SMUXS4w0FijSTzTWYEA3hkTSEtDI2qw6RoytDLA6jctCvzKqJ8oPFOO7kAhnYe9cZGiWiZ/N9ezguWaSL4h3TUfvKJIfoN0I4sjigYSdZyxlcDVMgEczEY41ER6oZFBOh2Yqegf2zYoziFC3DuZZrjSTPLDtMlxaNPmPP/54W2OPxksrVozP5fLPGr8vEOpbxJCr3jQSJyDvGRNRhv7iHh8vE5LMpKznHBz4zSTOaXwe+mXGGh9tbWvVQf+iyfCAON/ZlTj4v43ECfB94Le4CuMrWVpTtw7O9fZOM5M8oD7xVSOLBdLuNWN1g7bgJUF8+4qpBjf7Te9M6hD4tBDc0289Wh2MHbuaSR7gsHOMLBaQ9W/G6o5MJrNDPu9dcYdQ33Yc95I6OFV5hnp2cGCliDingX5KU+9MShd0dmqta/k8J4zwnV2JsuuNxAnI83VwNpO52kiSoC4djA255cuXBzYPycGzjTQWkPdNY00OfRcQVLafRnd39ySLLsG1i20AyPZ3cDb7AyNJgnp1cOhUHUhcFiL045v9jTUa8Gjlm29fsQQhb3DzJLUEhC+oiK7EISPOwapoEh+7JQJti5YfGXs0YNC62ouC1h9lsrlToClsjc/RM7uSe0kd3EmlzTO/Kqk8Q106mM/Yw2aOB9jnOg6sWTHxJ9FraSJMy6nGz7RbZUDYmN7e3BnQ5Gisez7u3J9c0JwA6Pb0aCFvNObgwKk6NoU59uJwaJ8y1viAT4vCtEFXYO8SFQGtCZpllyXQtNqL+4lmZ/BN/5qJKQFZozEHe9JtAGSaw4wsFnie4JmUQcjleh8yZq0Fnmq3y0D02IzPMgnonYqYIfA4pC+TcXrgIahLB+PEb5s5HrjaR0b7kbHGB0pK7TDO1/T39x1lUZGAPlUH0xTbz+KSoC4dDDx2DQCHzTCaWOB5zjbW+KCSpW0IS0BIJmy6zWCk7WDuxZ4r5oO6dHB7e/sBZo4H2OfUsYOv9jHW+ECJdkAtA/c6MpmMd+XaEKj7km9M4F5TEfBzSKovDLKG1cHobw+b6EDa3WOksYBPAhevBUJMxl8GJTRhFyMLBKSJFn5ls9nvmogS0DfaHOzb3h8AcUuNNBLQNiWa0gRv4MwMMyBwCqxAfCIH82JdYSJKQN+ocjA5NHD2I/e1aj/23iPyhbG6A+bAgXsZoUEII/UAkkQORu71JqIE7o22HBw4VaelpWU74mPPDc/39d1trO5Qb4vJ8QXxbwat06WofcTInMCzeToAtN4VXUn/l1AXDkan9tDSfmL6C81BZooHxDkN9CMveLFZFFAWWZtDwVta3G0sJcAbe3bmYEiniShBXabcL+wflQDD5mD0yKlvk0b/Tk33AG5F7idG+/ibRe54oEl1nLG6A+ZYe1jyAIuG/u2LB3MazxwAfL5vJFGJinxQUwcju6c/n3+FNPm5JhJyy2k/sQTp5nm+2HBJCGi1X1WpwzuBoQXAN+IcjDz8mdePKi/WhH1uxd7GcCjIVBcWpUYDfZ0VbclEJSr2akMBhVrdX6j+Jx3DpSh7vKB8CIiqKwcrcXGqdr05k3RKbU9ryTQVkUB3aHMrEshw7kGCXiv8xxG0h6Uzent6Fpn6MhA17A6GT/3yTxNO1coJbgWur3JFf1fXNuTes5AZe18xXobFHJKv04JZc3O7CtIcgGL9KW03u3QCfL4D4b292dhrpoYgsYOhEz4kaOuHqXKqiagYiN9QnUlyKgX84JUYsQFP9GKzMFRSe8XJb9upE9Dn62CK/KQT75wdTLz+NXgPNdrDuYzeUd0ByN4Wp07n+EdCRZuTY1/ymZQDwIjQye9pA32xdw6IiUgHc639mN8kzCLRjkxzQRzitUpkZ8LZBP1CILUd55EVvdgsCrzJl5i8mgCja+Zgjst4Pq3DUnMmtSWqyNIuQruRU3+CbO08n+pvBAZAjf1IU5kcGJc0YRMBfVV3MPd2RN4+YbvYukI/3sSpe+LUmbw0ryG/6ts1oSLeYrMw6C0xeaFAGc+Wq3hbfeRk582b55lrzf3UHJwWkD0Wp+6BQ3+BfXEXw6UCdHX4TVB0BoJi9Y1Cp59XbUWN8HW7lRjLli3zbINE+1hNiCRI1cGakIhT99ani/A6z1z1nDoUqNQfbO40kyqDfrCBwMg3E5rsCy+8sFlHR8dEnFzRTq/I8hQ9NFFOtGhXVOxgFeUqfknUK7Ctpjl1ANKJ/vmUkvrdwRZmWjpA4J9MTyja2toKY8TQa/ufxP/Whdd5c5cQJHIwfBsTvkKiaqd6/fRyOHKqavdL0H+V2sxmWvrQCAeKItfmQlNyDG/8SVwnetMHyxmA7lm0K2I7GFrlVBW/V6FPP9GqeU4V0Kt2+O2yhctUN6AJBEWD9ngMnessJxh5AfCoQe+8q+xQOYLuWbQrQh2MXP1XYh8S9DKC2sI1z6kCatW3/RCZ6Vj9fNPMqx2wQVNJQlcNEl/mGG5pv48bi7HxMVSOoHsW7QqPg5GlvnJtk6/B9+HMqYUfaXE6rampqWy4dVhgi8FfLprnBXEex+i/wCSkNiSNDSpUxxt7Ccj2nQQYAwUHc9yE3HEotuifDklnfFYMdGNC/lWCxotDf4PvB/jHZTs71c+f2n+ryqCPPcb5/pKdGrTvbH2MUjH4ByOLBDpON9YSFi5cuI1FOwFbbyTox5T6y+iwFL8CqvWvwVtolWgSv/N4sXbl5ZP3r8hRLT50d56KgYJDCYXVhYOhtqqReKDdZuGJtSQSOk8f67x581SspvH3lpoBe9Vefbg/lzveaXmnAf6tEDMNGRp3LnV3ch29o10lQIf+bOKZc+XnmMGARF2EK4vUwQiSw33n7ZlqDWwcaK9Ob29vd26vwj+OT8m3kKFxdd9tlILSJ1Wo8Y8RZT/YiKOY4le5P3SGZJAc7telg7FroL16Jc/n/a1cBBCxsSblwT8LOfofcCh4AQ4x1uoCXZtgVKnYDXLMUECnPSQD29VBcrhfVw7GHrVXb6WylGg0SvUZcrr+YPYuwWVfaE9ltmpA2Q6EQq2UY+yigzf2oqCH4v4MIysD94fdwdig9uqDnB4T5/d+gwHPGNVFcOopyJiPLOfmGTwa0Ek8qS8RKDKORLFWH95utwbDd94SRqqN/Cv4PDXbTFfXfUZWBvRUPJCRBJiIqfnnccy0Dz74wHkWoypY2D4ZGU8gK+kKjQKQ8RcTW1uQI2fmc7nH7LIMFEW+sw6xdyN4CgvNByNIDjp+ZyRVhzlV7dVLaZc7t1cRoW0w9of/No6ptbuRdZupqC3QPZY33HchMkbJiRPssgyaHkN82XaJXPtOJuN+JRuixQI6Cu1VXiZtJehcFGpeNPyXI6cqPWTIvsxU1R7o912akevre4OHfTHot3fEfRbD3y8+Qu0djO5Ce5UXNGl7dTt4z0RGqnOuhgLZgmcPk2FHrrd3jgwkAVQ58e1ioxjcHeMLPWQcq+5gZKm9+hJHjXo5z4xQBQsxxyDjEfir+nNq5GfQo/nYh6f9e4NUgGEFx3DEzvw1nPrOhSJ+kh6GUBUHw6//Kmls96dJ2qv6FxNF9z8g405kVLVXDfkaiFAd4JIkttYUGFpyDOf91Ch/YVEe8DA/gORpuywDfLNMjBOQt4qEupbTPTX4YeJig+/qrnoxkfMeIdH2UHGBfP0H6kFepElc1rY5lBQYXZbzuO7BWYH7b3V3d/+TX1FEG/JSExEJdOi7qsnrx3DuNM8Zdg2NqnN/BjK0EXlVhxORr56wP6Lv/DT+X1FzYLynaOWe2s1TjCQW4An9t6Jk4hBVdH6YpB9YNXoS+SRk/JaQZHd5J2CnesLuyGaze3KZ2hTemoNcpO+uB3pAQuzvC7SeJSfc0258Wo97aX9PT+TmMEMB73jsO0wJzXnVx4llL7pe5kWaFtSqGHHgu6rpPr5jsdx+hyI59G+hA4C25GDO1V69mbf/77h0+lZpzZX44B+Ye1X1cWKz92pKrYlcjtzc6gfN+ufhApd/ErcwTvuTRNI0m4c4Tg77u6gfbCHdTuQcrRFaRKiFU7Xl1O/RqX9RObevRxR43gmEBYUn9wEJIMeF/jk0yVKTta2tE0jg43kx1OatWifEYKDrHYKGDnfkMrU1xHUPaoh7k8i+030EvoV3c6i4aTCoc/9+9NVkFgh6BmZFaig08he3oxYkwBEkQGCzg7gfG6kzaDvuSyLfgIyqt1cF6SAspoS4iJf3c9xaf3JrGEgUzZcOGgvO4agzjTQUkI9V5z4851MuLhBvUUp1gR7tjXEHL+shXFZnduNIBomi6T73FVLLByQePu4N3CxMbVxyzfeQUTYZrdpA3yvoPVf/1jdTGggC6aXx0ieLSecFcWoj72vkhU4IcswU7gVORksb6FHnufbouJ4Xbv+gf1g0EADav9uSeO9YenpA3IfURFVZ0gqEms1rRg0qCzM4TuYy1T061jt0dXXpX0xJ96FMDXIqQXtJ3tSfze6OaY0KU1ogfTUgUJMK0lBIL06dS/F/LJeRe0k2kAAk7BgSWN2GVW/aCOjRuPCbBHVGBG6J3ECKIN3VlfjroguqA+RrMsFvCNqisf5mRox2qPlB4s8vuiMdIE/fVjVvLlRnhKlqYLig7QIpOiva40PAqR2E22neJFrN10AVgWMOIDgPuMOjmRFa+HVaR0fHliaugXoEOe80nBWrZg2dZkZoYffuaW5u1kCVkadmbT70AGdqJodWOhxHqP2eFg1UDvsLatnSFq41M+KKnp6eXbhsdB2OdGiCeX8+/2ecqgnmk/VXNYtqYLSAnNposzpjgw3+H/belpVa8J7TAAAAAElFTkSuQmCC\", t.style.position = \"absolute\", t.style.left = \"50%\", t.style.top = \"50%\", t.style.marginLeft = \"-60px\", t.style.marginTop = \"-60px\", t.style.animation = \"spin1 2s infinite ease-in-out\", t.style.webkitAnimation = \"spin1 2s infinite ease-in-out\", t.style.transformOrigin = \"50% 50%\", t.style.webkitTransformOrigin = \"50% 50%\", this._loadingDiv.appendChild(t), this._resizeLoadingUI(), window.addEventListener(\"resize\", this._resizeLoadingUI), this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor, document.body.appendChild(this._loadingDiv), this._loadingDiv.style.opacity = \"1\";\n      }\n    }, e.prototype.hideLoadingUI = function () {\n      var e = this;\n\n      if (this._loadingDiv) {\n        this._loadingDiv.style.opacity = \"0\", this._loadingDiv.addEventListener(\"transitionend\", function () {\n          e._loadingDiv && (document.body.removeChild(e._loadingDiv), window.removeEventListener(\"resize\", e._resizeLoadingUI), e._loadingDiv = null);\n        });\n      }\n    }, Object.defineProperty(e.prototype, \"loadingUIText\", {\n      get: function () {\n        return this._loadingText;\n      },\n      set: function (e) {\n        this._loadingText = e, this._loadingTextDiv && (this._loadingTextDiv.innerHTML = this._loadingText);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"loadingUIBackgroundColor\", {\n      get: function () {\n        return this._loadingDivBackgroundColor;\n      },\n      set: function (e) {\n        this._loadingDivBackgroundColor = e, this._loadingDiv && (this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e;\n  }(), tr.DefaultLoadingScreen = ir, function (P) {\n    var A = function () {\n      function t(e, t, i) {\n        this.lengthComputable = e, this.loaded = t, this.total = i;\n      }\n\n      return t.FromProgressEvent = function (e) {\n        return new t(e.lengthComputable, e.loaded, e.total);\n      }, t;\n    }();\n\n    P.SceneLoaderProgressEvent = A;\n\n    var e = function () {\n      function x() {}\n\n      return Object.defineProperty(x, \"ForceFullSceneLoadingForIncremental\", {\n        get: function () {\n          return x._ForceFullSceneLoadingForIncremental;\n        },\n        set: function (e) {\n          x._ForceFullSceneLoadingForIncremental = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(x, \"ShowLoadingScreen\", {\n        get: function () {\n          return x._ShowLoadingScreen;\n        },\n        set: function (e) {\n          x._ShowLoadingScreen = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(x, \"loggingLevel\", {\n        get: function () {\n          return x._loggingLevel;\n        },\n        set: function (e) {\n          x._loggingLevel = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(x, \"CleanBoneMatrixWeights\", {\n        get: function () {\n          return x._CleanBoneMatrixWeights;\n        },\n        set: function (e) {\n          x._CleanBoneMatrixWeights = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), x._getDefaultPlugin = function () {\n        return x._registeredPlugins[\".babylon\"];\n      }, x._getPluginForExtension = function (e) {\n        var t = x._registeredPlugins[e];\n        return t || (P.Tools.Warn(\"Unable to find a plugin to load \" + e + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: http://doc.babylonjs.com/how_to/load_from_any_file_type\"), x._getDefaultPlugin());\n      }, x._getPluginForDirectLoad = function (e) {\n        for (var t in x._registeredPlugins) {\n          var i = x._registeredPlugins[t].plugin;\n          if (i.canDirectLoad && i.canDirectLoad(e)) return x._registeredPlugins[t];\n        }\n\n        return x._getDefaultPlugin();\n      }, x._getPluginForFilename = function (e) {\n        var t = e.indexOf(\"?\");\n        -1 !== t && (e = e.substring(0, t));\n        var i = e.lastIndexOf(\".\"),\n            r = e.substring(i, e.length).toLowerCase();\n        return x._getPluginForExtension(r);\n      }, x._getDirectLoad = function (e) {\n        return \"data:\" === e.substr(0, 5) ? e.substr(5) : null;\n      }, x._loadData = function (e, i, r, t, n, o, s) {\n        var a,\n            l = x._getDirectLoad(e.name),\n            c = s ? x._getPluginForExtension(s) : l ? x._getPluginForDirectLoad(e.name) : x._getPluginForFilename(e.name);\n\n        a = c.plugin.createPlugin ? c.plugin.createPlugin() : c.plugin;\n        var h,\n            u = c.isBinary;\n        x.OnPluginActivatedObservable.notifyObservers(a);\n\n        var d = function (e, t) {\n          i.isDisposed ? n(\"Scene has been disposed\") : (i.database = h, r(a, e, t));\n        },\n            f = null,\n            p = !1,\n            _ = a.onDisposeObservable;\n\n        _ && _.add(function () {\n          p = !0, f && (f.abort(), f = null), o();\n        });\n\n        var m = function () {\n          p || (f = P.Tools.LoadFile(e.url, d, t ? function (e) {\n            t(A.FromProgressEvent(e));\n          } : void 0, h, u, function (e, t) {\n            n(\"Failed to load scene.\" + (t ? \" \" + t.message : \"\"), t);\n          }));\n        };\n\n        if (l) return d(l), a;\n\n        if (-1 === e.rootUrl.indexOf(\"file:\")) {\n          var g = i.getEngine(),\n              v = g.enableOfflineSupport;\n\n          if (v) {\n            for (var y = !1, b = 0, T = i.disableOfflineSupportExceptionRules; b < T.length; b++) {\n              if (T[b].test(e.url)) {\n                y = !0;\n                break;\n              }\n            }\n\n            v = !y;\n          }\n\n          v ? h = new P.Database(e.url, m, g.disableManifestCheck) : m();\n        } else {\n          var E = P.FilesInput.FilesToLoad[e.name.toLowerCase()];\n          E ? f = P.Tools.ReadFile(E, d, t, u) : n(\"Unable to find file named \" + e.name);\n        }\n\n        return a;\n      }, x._getFileInfo = function (e, t) {\n        var i, r;\n\n        if (t) {\n          if (\"/\" === t.substr(0, 1)) return P.Tools.Error(\"Wrong sceneFilename parameter\"), null;\n          i = e + t, r = t;\n        } else i = e, r = P.Tools.GetFilename(e), e = P.Tools.GetFolderPath(e);\n\n        return {\n          url: i,\n          rootUrl: e,\n          name: r\n        };\n      }, x.GetPluginForExtension = function (e) {\n        return x._getPluginForExtension(e).plugin;\n      }, x.IsPluginForExtensionAvailable = function (e) {\n        return !!x._registeredPlugins[e];\n      }, x.RegisterPlugin = function (t) {\n        if (\"string\" == typeof t.extensions) {\n          var e = t.extensions;\n          x._registeredPlugins[e.toLowerCase()] = {\n            plugin: t,\n            isBinary: !1\n          };\n        } else {\n          var i = t.extensions;\n          Object.keys(i).forEach(function (e) {\n            x._registeredPlugins[e.toLowerCase()] = {\n              plugin: t,\n              isBinary: i[e].isBinary\n            };\n          });\n        }\n      }, x.ImportMesh = function (a, e, t, l, n, i, r, o) {\n        if (void 0 === t && (t = \"\"), void 0 === l && (l = P.Engine.LastCreatedScene), void 0 === n && (n = null), void 0 === i && (i = null), void 0 === r && (r = null), void 0 === o && (o = null), !l) return P.Tools.Error(\"No scene available to import mesh to\"), null;\n\n        var c = x._getFileInfo(e, t);\n\n        if (!c) return null;\n        var s = {};\n\n        l._addPendingData(s);\n\n        var h = function () {\n          l._removePendingData(s);\n        },\n            u = function (e, t) {\n          var i = \"Unable to import meshes from \" + c.url + \": \" + e;\n          r ? r(l, i, t) : P.Tools.Error(i), h();\n        },\n            d = i ? function (e) {\n          try {\n            i(e);\n          } catch (e) {\n            u(\"Error in onProgress callback\", e);\n          }\n        } : void 0,\n            f = function (e, t, i, r) {\n          if (l.importedMeshesFiles.push(c.url), n) try {\n            n(e, t, i, r);\n          } catch (e) {\n            u(\"Error in onSuccess callback\", e);\n          }\n\n          l._removePendingData(s);\n        };\n\n        return x._loadData(c, l, function (t, e, i) {\n          if (t.rewriteRootURL && (c.rootUrl = t.rewriteRootURL(c.rootUrl, i)), t.importMesh) {\n            var r = t,\n                n = new Array(),\n                o = new Array(),\n                s = new Array();\n            if (!r.importMesh(a, l, e, c.rootUrl, n, o, s, u)) return;\n            l.loadingPluginName = t.name, f(n, o, s, []);\n          } else {\n            t.importMeshAsync(a, l, e, c.rootUrl, d, c.name).then(function (e) {\n              l.loadingPluginName = t.name, f(e.meshes, e.particleSystems, e.skeletons, e.animationGroups);\n            }).catch(function (e) {\n              u(e.message, e);\n            });\n          }\n        }, d, u, h, o);\n      }, x.ImportMeshAsync = function (e, t, i, o, s, a) {\n        return void 0 === i && (i = \"\"), void 0 === o && (o = P.Engine.LastCreatedScene), void 0 === s && (s = null), void 0 === a && (a = null), new Promise(function (n, r) {\n          x.ImportMesh(e, t, i, o, function (e, t, i, r) {\n            n({\n              meshes: e,\n              particleSystems: t,\n              skeletons: i,\n              animationGroups: r\n            });\n          }, s, function (e, t, i) {\n            r(i || new Error(t));\n          }, a);\n        });\n      }, x.Load = function (e, t, i, r, n, o, s) {\n        return void 0 === r && (r = null), void 0 === n && (n = null), void 0 === o && (o = null), void 0 === s && (s = null), x.Append(e, t, new P.Scene(i), r, n, o, s);\n      }, x.LoadAsync = function (e, i, n, o, s) {\n        return void 0 === o && (o = null), void 0 === s && (s = null), new Promise(function (t, r) {\n          x.Load(e, i, n, function (e) {\n            t(e);\n          }, o, function (e, t, i) {\n            r(i || new Error(t));\n          }, s);\n        });\n      }, x.Append = function (e, t, r, i, n, o, s) {\n        if (void 0 === t && (t = \"\"), void 0 === r && (r = P.Engine.LastCreatedScene), void 0 === i && (i = null), void 0 === n && (n = null), void 0 === o && (o = null), void 0 === s && (s = null), !r) return P.Tools.Error(\"No scene available to append to\"), null;\n\n        var a = x._getFileInfo(e, t);\n\n        if (!a) return null;\n        x.ShowLoadingScreen && r.getEngine().displayLoadingUI();\n        var l = {};\n\n        r._addPendingData(l);\n\n        var c = function () {\n          r._removePendingData(l), r.getEngine().hideLoadingUI();\n        },\n            h = function (e, t) {\n          var i = \"Unable to load from \" + a.url + (e ? \": \" + e : \"\");\n          o ? o(r, i, t) : P.Tools.Error(i), c();\n        },\n            u = n ? function (e) {\n          try {\n            n(e);\n          } catch (e) {\n            h(\"Error in onProgress callback\", e);\n          }\n        } : void 0,\n            d = function () {\n          if (i) try {\n            i(r);\n          } catch (e) {\n            h(\"Error in onSuccess callback\", e);\n          }\n\n          r._removePendingData(l);\n        };\n\n        return x._loadData(a, r, function (e, t, i) {\n          if (e.load) {\n            if (!e.load(r, t, a.rootUrl, h)) return;\n            r.loadingPluginName = e.name, d();\n          } else {\n            e.loadAsync(r, t, a.rootUrl, u, a.name).then(function () {\n              r.loadingPluginName = e.name, d();\n            }).catch(function (e) {\n              h(e.message, e);\n            });\n          }\n\n          x.ShowLoadingScreen && r.executeWhenReady(function () {\n            r.getEngine().hideLoadingUI();\n          });\n        }, u, h, c, s);\n      }, x.AppendAsync = function (e, i, n, o, s) {\n        return void 0 === i && (i = \"\"), void 0 === n && (n = P.Engine.LastCreatedScene), void 0 === o && (o = null), void 0 === s && (s = null), new Promise(function (t, r) {\n          x.Append(e, i, n, function (e) {\n            t(e);\n          }, o, function (e, t, i) {\n            r(i || new Error(t));\n          }, s);\n        });\n      }, x.LoadAssetContainer = function (e, t, n, i, r, o, s) {\n        if (void 0 === t && (t = \"\"), void 0 === n && (n = P.Engine.LastCreatedScene), void 0 === i && (i = null), void 0 === r && (r = null), void 0 === o && (o = null), void 0 === s && (s = null), !n) return P.Tools.Error(\"No scene available to load asset container to\"), null;\n\n        var a = x._getFileInfo(e, t);\n\n        if (!a) return null;\n        var l = {};\n\n        n._addPendingData(l);\n\n        var c = function () {\n          n._removePendingData(l);\n        },\n            h = function (e, t) {\n          var i = \"Unable to load assets from \" + a.url + (e ? \": \" + e : \"\");\n          o ? o(n, i, t) : P.Tools.Error(i), c();\n        },\n            u = r ? function (e) {\n          try {\n            r(e);\n          } catch (e) {\n            h(\"Error in onProgress callback\", e);\n          }\n        } : void 0,\n            d = function (e) {\n          if (i) try {\n            i(e);\n          } catch (e) {\n            h(\"Error in onSuccess callback\", e);\n          }\n\n          n._removePendingData(l);\n        };\n\n        return x._loadData(a, n, function (t, e, i) {\n          if (t.loadAssetContainer) {\n            var r = t.loadAssetContainer(n, e, a.rootUrl, h);\n            if (!r) return;\n            n.loadingPluginName = t.name, d(r);\n          } else if (t.loadAssetContainerAsync) {\n            t.loadAssetContainerAsync(n, e, a.rootUrl, u, a.name).then(function (e) {\n              n.loadingPluginName = t.name, d(e);\n            }).catch(function (e) {\n              h(e.message, e);\n            });\n          } else h(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n\n          x.ShowLoadingScreen && n.executeWhenReady(function () {\n            n.getEngine().hideLoadingUI();\n          });\n        }, u, h, c, s);\n      }, x.LoadAssetContainerAsync = function (e, i, n, o, s) {\n        return void 0 === i && (i = \"\"), void 0 === n && (n = P.Engine.LastCreatedScene), void 0 === o && (o = null), void 0 === s && (s = null), new Promise(function (t, r) {\n          x.LoadAssetContainer(e, i, n, function (e) {\n            t(e);\n          }, o, function (e, t, i) {\n            r(i || new Error(t));\n          }, s);\n        });\n      }, x._ForceFullSceneLoadingForIncremental = !1, x._ShowLoadingScreen = !0, x._CleanBoneMatrixWeights = !1, x.NO_LOGGING = 0, x.MINIMAL_LOGGING = 1, x.SUMMARY_LOGGING = 2, x.DETAILED_LOGGING = 3, x._loggingLevel = x.NO_LOGGING, x.OnPluginActivatedObservable = new P.Observable(), x._registeredPlugins = {}, x;\n    }();\n\n    P.SceneLoader = e;\n  }($a || ($a = {})), rr = $a || ($a = {}), nr = function (e, t, i, r) {\n    for (var n = 0, o = t.materials.length; n < o; n++) {\n      var s = t.materials[n];\n      if (s.id === e) return rr.Material.Parse(s, i, r);\n    }\n\n    return null;\n  }, or = function (e, t, i) {\n    for (var r in t) if (e.name === t[r]) return i.push(e.id), !0;\n\n    return !(!e.parentId || -1 === i.indexOf(e.parentId)) && (i.push(e.id), !0);\n  }, sr = function (e, t) {\n    return e + \" of \" + (t ? t.file + \" from \" + t.name + \" version: \" + t.version + \", exporter version: \" + t.exporter_version : \"unknown\");\n  }, ar = function (e, t, i, r, n) {\n    void 0 === n && (n = !1);\n    var o = new rr.AssetContainer(e),\n        s = \"importScene has failed JSON parse\";\n\n    try {\n      var a = JSON.parse(t);\n      s = \"\";\n      var l,\n          c,\n          h = rr.SceneLoader.loggingLevel === rr.SceneLoader.DETAILED_LOGGING;\n      if (void 0 !== a.lights && null !== a.lights) for (l = 0, c = a.lights.length; l < c; l++) {\n        var u = a.lights[l],\n            d = rr.Light.Parse(u, e);\n        d && (o.lights.push(d), s += 0 === l ? \"\\n\\tLights:\" : \"\", s += \"\\n\\t\\t\" + d.toString(h));\n      }\n      if (void 0 !== a.animations && null !== a.animations) for (l = 0, c = a.animations.length; l < c; l++) {\n        var f = a.animations[l],\n            p = rr.Animation.Parse(f);\n        e.animations.push(p), o.animations.push(p), s += 0 === l ? \"\\n\\tAnimations:\" : \"\", s += \"\\n\\t\\t\" + p.toString(h);\n      }\n      if (void 0 !== a.materials && null !== a.materials) for (l = 0, c = a.materials.length; l < c; l++) {\n        var _ = a.materials[l],\n            m = rr.Material.Parse(_, e, i);\n        o.materials.push(m), s += 0 === l ? \"\\n\\tMaterials:\" : \"\", s += \"\\n\\t\\t\" + m.toString(h);\n      }\n      if (void 0 !== a.multiMaterials && null !== a.multiMaterials) for (l = 0, c = a.multiMaterials.length; l < c; l++) {\n        var g = a.multiMaterials[l],\n            v = rr.Material.ParseMultiMaterial(g, e);\n        o.multiMaterials.push(v), s += 0 === l ? \"\\n\\tMultiMaterials:\" : \"\", s += \"\\n\\t\\t\" + v.toString(h);\n      }\n      if (void 0 !== a.morphTargetManagers && null !== a.morphTargetManagers) for (var y = 0, b = a.morphTargetManagers; y < b.length; y++) {\n        var T = b[y];\n        o.morphTargetManagers.push(rr.MorphTargetManager.Parse(T, e));\n      }\n      if (void 0 !== a.skeletons && null !== a.skeletons) for (l = 0, c = a.skeletons.length; l < c; l++) {\n        var E = a.skeletons[l],\n            x = rr.Skeleton.Parse(E, e);\n        o.skeletons.push(x), s += 0 === l ? \"\\n\\tSkeletons:\" : \"\", s += \"\\n\\t\\t\" + x.toString(h);\n      }\n      var P = a.geometries;\n\n      if (null != P) {\n        var A = new Array(),\n            S = P.boxes;\n        if (null != S) for (l = 0, c = S.length; l < c; l++) {\n          var M = S[l];\n          A.push(rr.BoxGeometry.Parse(M, e));\n        }\n        var R = P.spheres;\n        if (null != R) for (l = 0, c = R.length; l < c; l++) {\n          var C = R[l];\n          A.push(rr.SphereGeometry.Parse(C, e));\n        }\n        var O = P.cylinders;\n        if (null != O) for (l = 0, c = O.length; l < c; l++) {\n          var D = O[l];\n          A.push(rr.CylinderGeometry.Parse(D, e));\n        }\n        var I = P.toruses;\n        if (null != I) for (l = 0, c = I.length; l < c; l++) {\n          var w = I[l];\n          A.push(rr.TorusGeometry.Parse(w, e));\n        }\n        var L = P.grounds;\n        if (null != L) for (l = 0, c = L.length; l < c; l++) {\n          var F = L[l];\n          A.push(rr.GroundGeometry.Parse(F, e));\n        }\n        var B = P.planes;\n        if (null != B) for (l = 0, c = B.length; l < c; l++) {\n          var N = B[l];\n          A.push(rr.PlaneGeometry.Parse(N, e));\n        }\n        var V = P.torusKnots;\n        if (null != V) for (l = 0, c = V.length; l < c; l++) {\n          var U = V[l];\n          A.push(rr.TorusKnotGeometry.Parse(U, e));\n        }\n        var z = P.vertexData;\n        if (null != z) for (l = 0, c = z.length; l < c; l++) {\n          var G = z[l];\n          A.push(rr.Geometry.Parse(G, e, i));\n        }\n        A.forEach(function (e) {\n          e && o.geometries.push(e);\n        });\n      }\n\n      if (void 0 !== a.transformNodes && null !== a.transformNodes) for (l = 0, c = a.transformNodes.length; l < c; l++) {\n        var k = a.transformNodes[l],\n            W = rr.TransformNode.Parse(k, e, i);\n        o.transformNodes.push(W);\n      }\n      if (void 0 !== a.meshes && null !== a.meshes) for (l = 0, c = a.meshes.length; l < c; l++) {\n        var H = a.meshes[l],\n            X = rr.Mesh.Parse(H, e, i);\n        o.meshes.push(X), s += 0 === l ? \"\\n\\tMeshes:\" : \"\", s += \"\\n\\t\\t\" + X.toString(h);\n      }\n      if (void 0 !== a.cameras && null !== a.cameras) for (l = 0, c = a.cameras.length; l < c; l++) {\n        var j = a.cameras[l],\n            Y = rr.Camera.Parse(j, e);\n        o.cameras.push(Y), s += 0 === l ? \"\\n\\tCameras:\" : \"\", s += \"\\n\\t\\t\" + Y.toString(h);\n      }\n      if (void 0 !== a.animationGroups && null !== a.animationGroups) for (l = 0, c = a.animationGroups.length; l < c; l++) {\n        var K = a.animationGroups[l],\n            Q = rr.AnimationGroup.Parse(K, e);\n        o.animationGroups.push(Q), s += 0 === l ? \"\\n\\tAnimationGroups:\" : \"\", s += \"\\n\\t\\t\" + Q.toString(h);\n      }\n\n      for (l = 0, c = e.cameras.length; l < c; l++) {\n        (Y = e.cameras[l])._waitingParentId && (Y.parent = e.getLastEntryByID(Y._waitingParentId), Y._waitingParentId = null);\n      }\n\n      for (l = 0, c = e.lights.length; l < c; l++) {\n        var Z = e.lights[l];\n        Z && Z._waitingParentId && (Z.parent = e.getLastEntryByID(Z._waitingParentId), Z._waitingParentId = null);\n      }\n\n      for (l = 0, c = e.transformNodes.length; l < c; l++) {\n        var q = e.transformNodes[l];\n        q._waitingParentId && (q.parent = e.getLastEntryByID(q._waitingParentId), q._waitingParentId = null);\n      }\n\n      for (l = 0, c = e.meshes.length; l < c; l++) {\n        (X = e.meshes[l])._waitingParentId && (X.parent = e.getLastEntryByID(X._waitingParentId), X._waitingParentId = null);\n      }\n\n      for (l = 0, c = e.meshes.length; l < c; l++) {\n        var J = e.meshes[l];\n        J._waitingFreezeWorldMatrix ? (J.freezeWorldMatrix(), J._waitingFreezeWorldMatrix = null) : J.computeWorldMatrix(!0);\n      }\n\n      for (l = 0, c = e.lights.length; l < c; l++) {\n        var $ = e.lights[l];\n\n        if (0 < $._excludedMeshesIds.length) {\n          for (var ee = 0; ee < $._excludedMeshesIds.length; ee++) {\n            var te = e.getMeshByID($._excludedMeshesIds[ee]);\n            te && $.excludedMeshes.push(te);\n          }\n\n          $._excludedMeshesIds = [];\n        }\n\n        if (0 < $._includedOnlyMeshesIds.length) {\n          for (var ie = 0; ie < $._includedOnlyMeshesIds.length; ie++) {\n            var re = e.getMeshByID($._includedOnlyMeshesIds[ie]);\n            re && $.includedOnlyMeshes.push(re);\n          }\n\n          $._includedOnlyMeshesIds = [];\n        }\n      }\n\n      for (rr.AbstractScene.Parse(a, e, o, i), l = 0, c = e.meshes.length; l < c; l++) {\n        (X = e.meshes[l])._waitingActions && (rr.ActionManager.Parse(X._waitingActions, X, e), X._waitingActions = null);\n      }\n\n      void 0 !== a.actions && null !== a.actions && rr.ActionManager.Parse(a.actions, null, e), n || o.removeAllFromScene();\n    } catch (e) {\n      var ne = sr(\"loadAssets\", a ? a.producer : \"Unknown\") + s;\n      if (!r) throw rr.Tools.Log(ne), e;\n      r(ne, e);\n    } finally {\n      null !== s && rr.SceneLoader.loggingLevel !== rr.SceneLoader.NO_LOGGING && rr.Tools.Log(sr(\"loadAssets\", a ? a.producer : \"Unknown\") + (rr.SceneLoader.loggingLevel !== rr.SceneLoader.MINIMAL_LOGGING ? s : \"\"));\n    }\n\n    return o;\n  }, rr.SceneLoader.RegisterPlugin({\n    name: \"babylon.js\",\n    extensions: \".babylon\",\n    canDirectLoad: function (e) {\n      return -1 !== e.indexOf(\"babylon\");\n    },\n    importMesh: function (e, i, t, r, n, o, s, a) {\n      var l = \"importMesh has failed JSON parse\";\n\n      try {\n        var c = JSON.parse(t);\n        l = \"\";\n        var h = rr.SceneLoader.loggingLevel === rr.SceneLoader.DETAILED_LOGGING;\n        e ? Array.isArray(e) || (e = [e]) : e = null;\n        var u = new Array();\n\n        if (void 0 !== c.meshes && null !== c.meshes) {\n          var d,\n              f,\n              p,\n              _ = [],\n              m = [];\n\n          for (d = 0, f = c.meshes.length; d < f; d++) {\n            var g = c.meshes[d];\n\n            if (null === e || or(g, e, u)) {\n              if (null !== e && delete e[e.indexOf(g.name)], void 0 !== g.geometryId && null !== g.geometryId && void 0 !== c.geometries && null !== c.geometries) {\n                var v = !1;\n                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach(function (t) {\n                  !0 !== v && c.geometries[t] && Array.isArray(c.geometries[t]) && c.geometries[t].forEach(function (e) {\n                    if (e.id === g.geometryId) {\n                      switch (t) {\n                        case \"boxes\":\n                          rr.BoxGeometry.Parse(e, i);\n                          break;\n\n                        case \"spheres\":\n                          rr.SphereGeometry.Parse(e, i);\n                          break;\n\n                        case \"cylinders\":\n                          rr.CylinderGeometry.Parse(e, i);\n                          break;\n\n                        case \"toruses\":\n                          rr.TorusGeometry.Parse(e, i);\n                          break;\n\n                        case \"grounds\":\n                          rr.GroundGeometry.Parse(e, i);\n                          break;\n\n                        case \"planes\":\n                          rr.PlaneGeometry.Parse(e, i);\n                          break;\n\n                        case \"torusKnots\":\n                          rr.TorusKnotGeometry.Parse(e, i);\n                          break;\n\n                        case \"vertexData\":\n                          rr.Geometry.Parse(e, i, r);\n                      }\n\n                      v = !0;\n                    }\n                  });\n                }), !1 === v && rr.Tools.Warn(\"Geometry not found for mesh \" + g.id);\n              }\n\n              if (g.materialId) {\n                var y = -1 !== m.indexOf(g.materialId);\n                if (!1 === y && void 0 !== c.multiMaterials && null !== c.multiMaterials) for (var b = 0, T = c.multiMaterials.length; b < T; b++) {\n                  var E = c.multiMaterials[b];\n\n                  if (E.id === g.materialId) {\n                    for (var x = 0, P = E.materials.length; x < P; x++) {\n                      var A,\n                          S = E.materials[x];\n                      m.push(S), (A = nr(S, c, i, r)) && (l += \"\\n\\tMaterial \" + A.toString(h));\n                    }\n\n                    m.push(E.id);\n                    var M = rr.Material.ParseMultiMaterial(E, i);\n                    M && (y = !0, l += \"\\n\\tMulti-Material \" + M.toString(h));\n                    break;\n                  }\n                }\n                !1 === y && (m.push(g.materialId), (A = nr(g.materialId, c, i, r)) ? l += \"\\n\\tMaterial \" + A.toString(h) : rr.Tools.Warn(\"Material not found for mesh \" + g.id));\n              }\n\n              if (-1 < g.skeletonId && void 0 !== c.skeletons && null !== c.skeletons && !1 == -1 < _.indexOf(g.skeletonId)) for (var R = 0, C = c.skeletons.length; R < C; R++) {\n                var O = c.skeletons[R];\n\n                if (O.id === g.skeletonId) {\n                  var D = rr.Skeleton.Parse(O, i);\n                  s.push(D), _.push(O.id), l += \"\\n\\tSkeleton \" + D.toString(h);\n                }\n              }\n              if (void 0 !== c.morphTargetManagers && null !== c.morphTargetManagers) for (var I = 0, w = c.morphTargetManagers; I < w.length; I++) {\n                var L = w[I];\n                rr.MorphTargetManager.Parse(L, i);\n              }\n              var F = rr.Mesh.Parse(g, i, r);\n              n.push(F), l += \"\\n\\tMesh \" + F.toString(h);\n            }\n          }\n\n          for (d = 0, f = i.meshes.length; d < f; d++) (p = i.meshes[d])._waitingParentId && (p.parent = i.getLastEntryByID(p._waitingParentId), p._waitingParentId = null);\n\n          for (d = 0, f = i.meshes.length; d < f; d++) (p = i.meshes[d])._waitingFreezeWorldMatrix ? (p.freezeWorldMatrix(), p._waitingFreezeWorldMatrix = null) : p.computeWorldMatrix(!0);\n        }\n\n        if (void 0 !== c.particleSystems && null !== c.particleSystems) {\n          var B = rr.AbstractScene.GetIndividualParser(rr.SceneComponentConstants.NAME_PARTICLESYSTEM);\n          if (B) for (d = 0, f = c.particleSystems.length; d < f; d++) {\n            var N = c.particleSystems[d];\n            -1 !== u.indexOf(N.emitterId) && o.push(B(N, i, r));\n          }\n        }\n\n        return !0;\n      } catch (e) {\n        var V = sr(\"importMesh\", c ? c.producer : \"Unknown\") + l;\n        if (!a) throw rr.Tools.Log(V), e;\n        a(V, e);\n      } finally {\n        null !== l && rr.SceneLoader.loggingLevel !== rr.SceneLoader.NO_LOGGING && rr.Tools.Log(sr(\"importMesh\", c ? c.producer : \"Unknown\") + (rr.SceneLoader.loggingLevel !== rr.SceneLoader.MINIMAL_LOGGING ? l : \"\"));\n      }\n\n      return !1;\n    },\n    load: function (e, t, i, r) {\n      var n = \"importScene has failed JSON parse\";\n\n      try {\n        var o = JSON.parse(t);\n        if (n = \"\", void 0 !== o.useDelayedTextureLoading && null !== o.useDelayedTextureLoading && (e.useDelayedTextureLoading = o.useDelayedTextureLoading && !rr.SceneLoader.ForceFullSceneLoadingForIncremental), void 0 !== o.autoClear && null !== o.autoClear && (e.autoClear = o.autoClear), void 0 !== o.clearColor && null !== o.clearColor && (e.clearColor = rr.Color4.FromArray(o.clearColor)), void 0 !== o.ambientColor && null !== o.ambientColor && (e.ambientColor = rr.Color3.FromArray(o.ambientColor)), void 0 !== o.gravity && null !== o.gravity && (e.gravity = rr.Vector3.FromArray(o.gravity)), o.fogMode && 0 !== o.fogMode) switch (e.fogMode = o.fogMode, e.fogColor = rr.Color3.FromArray(o.fogColor), e.fogStart = o.fogStart, e.fogEnd = o.fogEnd, e.fogDensity = o.fogDensity, n += \"\\tFog mode for scene:  \", e.fogMode) {\n          case 1:\n            n += \"exp\\n\";\n            break;\n\n          case 2:\n            n += \"exp2\\n\";\n            break;\n\n          case 3:\n            n += \"linear\\n\";\n        }\n\n        if (o.physicsEnabled) {\n          var s;\n          \"cannon\" === o.physicsEngine ? s = new rr.CannonJSPlugin() : \"oimo\" === o.physicsEngine && (s = new rr.OimoJSPlugin()), n = \"\\tPhysics engine \" + (o.physicsEngine ? o.physicsEngine : \"oimo\") + \" enabled\\n\";\n          var a = o.physicsGravity ? rr.Vector3.FromArray(o.physicsGravity) : null;\n          e.enablePhysics(a, s);\n        }\n\n        if (void 0 !== o.metadata && null !== o.metadata && (e.metadata = o.metadata), void 0 !== o.collisionsEnabled && null !== o.collisionsEnabled && (e.collisionsEnabled = o.collisionsEnabled), e.workerCollisions = !!o.workerCollisions, !ar(e, t, i, r, !0)) return !1;\n\n        if (o.autoAnimate && e.beginAnimation(e, o.autoAnimateFrom, o.autoAnimateTo, o.autoAnimateLoop, o.autoAnimateSpeed || 1), void 0 !== o.activeCameraID && null !== o.activeCameraID && e.setActiveCameraByID(o.activeCameraID), void 0 !== o.environmentTexture && null !== o.environmentTexture) {\n          if (o.environmentTextureType && \"BABYLON.HDRCubeTexture\" === o.environmentTextureType) {\n            var l = o.environmentTextureSize ? o.environmentTextureSize : 128,\n                c = new rr.HDRCubeTexture(i + o.environmentTexture, e, l);\n            o.environmentTextureRotationY && (c.rotationY = o.environmentTextureRotationY), e.environmentTexture = c;\n          } else {\n            var h = rr.CubeTexture.CreateFromPrefilteredData(i + o.environmentTexture, e);\n            o.environmentTextureRotationY && (h.rotationY = o.environmentTextureRotationY), e.environmentTexture = h;\n          }\n\n          if (!0 === o.createDefaultSkybox) {\n            var u = void 0 !== e.activeCamera && null !== e.activeCamera ? (e.activeCamera.maxZ - e.activeCamera.minZ) / 2 : 1e3,\n                d = o.skyboxBlurLevel || 0;\n            e.createDefaultSkybox(void 0, !0, u, d);\n          }\n        }\n\n        return !0;\n      } catch (e) {\n        var f = sr(\"importScene\", o ? o.producer : \"Unknown\") + n;\n        if (!r) throw rr.Tools.Log(f), e;\n        r(f, e);\n      } finally {\n        null !== n && rr.SceneLoader.loggingLevel !== rr.SceneLoader.NO_LOGGING && rr.Tools.Log(sr(\"importScene\", o ? o.producer : \"Unknown\") + (rr.SceneLoader.loggingLevel !== rr.SceneLoader.MINIMAL_LOGGING ? n : \"\"));\n      }\n\n      return !1;\n    },\n    loadAssetContainer: function (e, t, i, r) {\n      return ar(e, t, i, r);\n    }\n  }), lr = $a || ($a = {}), cr = function () {\n    function n(e, t, i, r, n, o, s, a, l) {\n      this.onProcessFileCallback = function () {\n        return !0;\n      }, this._engine = e, this._currentScene = t, this._sceneLoadedCallback = i, this._progressCallback = r, this._additionalRenderLoopLogicCallback = n, this._textureLoadingCallback = o, this._startingProcessingFilesCallback = s, this._onReloadCallback = a, this._errorCallback = l;\n    }\n\n    return n.prototype.monitorElementForDragNDrop = function (e) {\n      var t = this;\n      e && (this._elementToMonitor = e, this._dragEnterHandler = function (e) {\n        t.drag(e);\n      }, this._dragOverHandler = function (e) {\n        t.drag(e);\n      }, this._dropHandler = function (e) {\n        t.drop(e);\n      }, this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, !1), this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, !1), this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, !1));\n    }, n.prototype.dispose = function () {\n      this._elementToMonitor && (this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler), this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler), this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler));\n    }, n.prototype.renderFunction = function () {\n      if (this._additionalRenderLoopLogicCallback && this._additionalRenderLoopLogicCallback(), this._currentScene) {\n        if (this._textureLoadingCallback) {\n          var e = this._currentScene.getWaitingItemsCount();\n\n          0 < e && this._textureLoadingCallback(e);\n        }\n\n        this._currentScene.render();\n      }\n    }, n.prototype.drag = function (e) {\n      e.stopPropagation(), e.preventDefault();\n    }, n.prototype.drop = function (e) {\n      e.stopPropagation(), e.preventDefault(), this.loadFiles(e);\n    }, n.prototype._traverseFolder = function (e, n, o, s) {\n      var a = this,\n          t = e.createReader(),\n          l = e.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n      t.readEntries(function (e) {\n        o.count += e.length;\n\n        for (var t = 0, i = e; t < i.length; t++) {\n          var r = i[t];\n          r.isFile ? r.file(function (e) {\n            e.correctName = l + e.name, n.push(e), 0 == --o.count && s();\n          }) : r.isDirectory && a._traverseFolder(r, n, o, s);\n        }\n\n        --o.count && s();\n      });\n    }, n.prototype._processFiles = function (e) {\n      for (var t = 0; t < e.length; t++) {\n        var i = e[t].correctName.toLowerCase(),\n            r = i.split(\".\").pop();\n        this.onProcessFileCallback(e[t], i, r) && (\"babylon\" !== r && \"stl\" !== r && \"obj\" !== r && \"gltf\" !== r && \"glb\" !== r || -1 !== i.indexOf(\".binary.babylon\") || -1 !== i.indexOf(\".incremental.babylon\") || (this._sceneFileToLoad = e[t]), n.FilesToLoad[i] = e[t]);\n      }\n    }, n.prototype.loadFiles = function (e) {\n      var t = this;\n\n      if (e && e.dataTransfer && e.dataTransfer.files && (this._filesToLoad = e.dataTransfer.files), e && e.target && e.target.files && (this._filesToLoad = e.target.files), this._filesToLoad && 0 !== this._filesToLoad.length && (this._startingProcessingFilesCallback && this._startingProcessingFilesCallback(this._filesToLoad), this._filesToLoad && 0 < this._filesToLoad.length)) {\n        for (var i = new Array(), r = [], n = e.dataTransfer ? e.dataTransfer.items : null, o = 0; o < this._filesToLoad.length; o++) {\n          var s = this._filesToLoad[o],\n              a = s.name.toLowerCase(),\n              l = void 0;\n\n          if (s.correctName = a, n) {\n            var c = n[o];\n            c.getAsEntry ? l = c.getAsEntry() : c.webkitGetAsEntry && (l = c.webkitGetAsEntry());\n          }\n\n          l && l.isDirectory ? r.push(l) : i.push(s);\n        }\n\n        if (0 === r.length) this._processFiles(i), this._processReload();else for (var h = {\n          count: r.length\n        }, u = 0, d = r; u < d.length; u++) {\n          var f = d[u];\n\n          this._traverseFolder(f, i, h, function () {\n            t._processFiles(i), 0 === h.count && t._processReload();\n          });\n        }\n      }\n    }, n.prototype._processReload = function () {\n      this._onReloadCallback ? this._onReloadCallback(this._sceneFileToLoad) : this.reload();\n    }, n.prototype.reload = function () {\n      var t = this;\n      this._sceneFileToLoad ? (this._currentScene && (0 < lr.Tools.errorsCount && lr.Tools.ClearLogCache(), this._engine.stopRenderLoop()), lr.SceneLoader.LoadAsync(\"file:\", this._sceneFileToLoad.name, this._engine, function (e) {\n        t._progressCallback && t._progressCallback(e);\n      }).then(function (e) {\n        t._currentScene && t._currentScene.dispose(), t._currentScene = e, t._sceneLoadedCallback && t._sceneLoadedCallback(t._sceneFileToLoad, t._currentScene), t._currentScene.executeWhenReady(function () {\n          t._engine.runRenderLoop(function () {\n            t.renderFunction();\n          });\n        });\n      }).catch(function (e) {\n        t._errorCallback && t._errorCallback(t._sceneFileToLoad, t._currentScene, e.message);\n      })) : lr.Tools.Error(\"Please provide a valid .babylon file.\");\n    }, n.FilesToLoad = {}, n;\n  }(), lr.FilesInput = cr, hr = $a || ($a = {}), ur = function () {\n    function n() {}\n\n    return n.EnableFor = function (t) {\n      t._tags = t._tags || {}, t.hasTags = function () {\n        return n.HasTags(t);\n      }, t.addTags = function (e) {\n        return n.AddTagsTo(t, e);\n      }, t.removeTags = function (e) {\n        return n.RemoveTagsFrom(t, e);\n      }, t.matchesTagsQuery = function (e) {\n        return n.MatchesQuery(t, e);\n      };\n    }, n.DisableFor = function (e) {\n      delete e._tags, delete e.hasTags, delete e.addTags, delete e.removeTags, delete e.matchesTagsQuery;\n    }, n.HasTags = function (e) {\n      return !!e._tags && !hr.Tools.IsEmpty(e._tags);\n    }, n.GetTags = function (e, t) {\n      if (void 0 === t && (t = !0), !e._tags) return null;\n\n      if (t) {\n        var i = [];\n\n        for (var r in e._tags) e._tags.hasOwnProperty(r) && !0 === e._tags[r] && i.push(r);\n\n        return i.join(\" \");\n      }\n\n      return e._tags;\n    }, n.AddTagsTo = function (r, e) {\n      e && \"string\" == typeof e && e.split(\" \").forEach(function (e, t, i) {\n        n._AddTagTo(r, e);\n      });\n    }, n._AddTagTo = function (e, t) {\n      \"\" !== (t = t.trim()) && \"true\" !== t && \"false\" !== t && (t.match(/[\\s]/) || t.match(/^([!]|([|]|[&]){2})/) || (n.EnableFor(e), e._tags[t] = !0));\n    }, n.RemoveTagsFrom = function (e, t) {\n      if (n.HasTags(e)) {\n        var i = t.split(\" \");\n\n        for (var r in i) n._RemoveTagFrom(e, i[r]);\n      }\n    }, n._RemoveTagFrom = function (e, t) {\n      delete e._tags[t];\n    }, n.MatchesQuery = function (t, e) {\n      return void 0 === e || (\"\" === e ? n.HasTags(t) : hr.AndOrNotEvaluator.Eval(e, function (e) {\n        return n.HasTags(t) && t._tags[e];\n      }));\n    }, n;\n  }(), hr.Tags = ur, dr = $a || ($a = {}), fr = function () {\n    function c() {}\n\n    return c.Eval = function (e, t) {\n      return \"true\" === (e = e.match(/\\([^\\(\\)]*\\)/g) ? e.replace(/\\([^\\(\\)]*\\)/g, function (e) {\n        return e = e.slice(1, e.length - 1), c._HandleParenthesisContent(e, t);\n      }) : c._HandleParenthesisContent(e, t)) || \"false\" !== e && c.Eval(e, t);\n    }, c._HandleParenthesisContent = function (e, t) {\n      var i;\n\n      t = t || function (e) {\n        return \"true\" === e;\n      };\n\n      var r = e.split(\"||\");\n\n      for (var n in r) if (r.hasOwnProperty(n)) {\n        var o = c._SimplifyNegation(r[n].trim()),\n            s = o.split(\"&&\");\n\n        if (1 < s.length) for (var a = 0; a < s.length; ++a) {\n          var l = c._SimplifyNegation(s[a].trim());\n\n          if (!(i = \"true\" !== l && \"false\" !== l ? \"!\" === l[0] ? !t(l.substring(1)) : t(l) : \"true\" === l)) {\n            o = \"false\";\n            break;\n          }\n        }\n\n        if (i || \"true\" === o) {\n          i = !0;\n          break;\n        }\n\n        i = \"true\" !== o && \"false\" !== o ? \"!\" === o[0] ? !t(o.substring(1)) : t(o) : \"true\" === o;\n      }\n\n      return i ? \"true\" : \"false\";\n    }, c._SimplifyNegation = function (e) {\n      return \"!true\" === (e = (e = e.replace(/^[\\s!]+/, function (e) {\n        return (e = e.replace(/[\\s]/g, function () {\n          return \"\";\n        })).length % 2 ? \"!\" : \"\";\n      })).trim()) ? e = \"false\" : \"!false\" === e && (e = \"true\"), e;\n    }, c;\n  }(), dr.AndOrNotEvaluator = fr, pr = $a || ($a = {}), _r = function () {\n    function c(e, t, i) {\n      void 0 === i && (i = !1);\n      var r = this;\n      this.idbFactory = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB, this.callbackManifestChecked = t, this.currentSceneUrl = c._ReturnFullUrlLocation(e), this.db = null, this._enableSceneOffline = !1, this._enableTexturesOffline = !1, this.manifestVersionFound = 0, this.mustUpdateRessources = !1, this.hasReachedQuota = !1, c.IDBStorageEnabled ? i ? (this._enableSceneOffline = !0, this._enableTexturesOffline = !0, this.manifestVersionFound = 1, pr.Tools.SetImmediate(function () {\n        r.callbackManifestChecked(!0);\n      })) : this._checkManifestFile() : this.callbackManifestChecked(!0);\n    }\n\n    return Object.defineProperty(c.prototype, \"enableSceneOffline\", {\n      get: function () {\n        return this._enableSceneOffline;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"enableTexturesOffline\", {\n      get: function () {\n        return this._enableTexturesOffline;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), c.prototype._checkManifestFile = function () {\n      var i = this,\n          r = function () {\n        i._enableSceneOffline = !1, i._enableTexturesOffline = !1, i.callbackManifestChecked(!1);\n      },\n          n = !1,\n          e = this.currentSceneUrl + \".manifest\",\n          o = new XMLHttpRequest();\n\n      navigator.onLine && (n = !0, e = e + (null == e.match(/\\?/) ? \"?\" : \"&\") + Date.now()), o.open(\"GET\", e, !0), o.addEventListener(\"load\", function () {\n        if (200 === o.status || pr.Tools.ValidateXHRData(o, 1)) try {\n          var e = JSON.parse(o.response);\n          i._enableSceneOffline = e.enableSceneOffline, i._enableTexturesOffline = e.enableTexturesOffline, e.version && !isNaN(parseInt(e.version)) && (i.manifestVersionFound = e.version), i.callbackManifestChecked && i.callbackManifestChecked(!0);\n        } catch (e) {\n          r();\n        } else r();\n      }, !1), o.addEventListener(\"error\", function (e) {\n        if (n) {\n          n = !1;\n          var t = i.currentSceneUrl + \".manifest\";\n          o.open(\"GET\", t, !0), o.send();\n        } else r();\n      }, !1);\n\n      try {\n        o.send();\n      } catch (e) {\n        pr.Tools.Error(\"Error on XHR send request.\"), this.callbackManifestChecked(!1);\n      }\n    }, c.prototype.openAsync = function (t, e) {\n      var i = this,\n          r = function () {\n        i.isSupported = !1, e && e();\n      };\n\n      if (this.idbFactory && (this._enableSceneOffline || this._enableTexturesOffline)) {\n        if (this.db) t && t();else {\n          this.hasReachedQuota = !1, this.isSupported = !0;\n          var n = this.idbFactory.open(\"babylonjs\", 1);\n          n.onerror = function (e) {\n            r();\n          }, n.onblocked = function (e) {\n            pr.Tools.Error(\"IDB request blocked. Please reload the page.\"), r();\n          }, n.onsuccess = function (e) {\n            i.db = n.result, t();\n          }, n.onupgradeneeded = function (e) {\n            if (i.db = e.target.result, i.db) try {\n              i.db.createObjectStore(\"scenes\", {\n                keyPath: \"sceneUrl\"\n              }), i.db.createObjectStore(\"versions\", {\n                keyPath: \"sceneUrl\"\n              }), i.db.createObjectStore(\"textures\", {\n                keyPath: \"textureUrl\"\n              });\n            } catch (e) {\n              pr.Tools.Error(\"Error while creating object stores. Exception: \" + e.message), r();\n            }\n          };\n        }\n      } else this.isSupported = !1, e && e();\n    }, c.prototype.loadImageFromDB = function (e, t) {\n      var i = this,\n          r = c._ReturnFullUrlLocation(e),\n          n = function () {\n        i.hasReachedQuota || null === i.db ? t.src = e : i._saveImageIntoDBAsync(r, t);\n      };\n\n      this.mustUpdateRessources ? n() : this._loadImageFromDBAsync(r, t, n);\n    }, c.prototype._loadImageFromDBAsync = function (r, n, o) {\n      if (this.isSupported && null !== this.db) {\n        var s,\n            e = this.db.transaction([\"textures\"]);\n        e.onabort = function (e) {\n          n.src = r;\n        }, e.oncomplete = function (e) {\n          var t;\n\n          if (s) {\n            var i = window.URL || window.webkitURL;\n            t = i.createObjectURL(s.data), n.onerror = function () {\n              pr.Tools.Error(\"Error loading image from blob URL: \" + t + \" switching back to web url: \" + r), n.src = r;\n            }, n.src = t;\n          } else o();\n        };\n        var t = e.objectStore(\"textures\").get(r);\n        t.onsuccess = function (e) {\n          s = e.target.result;\n        }, t.onerror = function (e) {\n          pr.Tools.Error(\"Error loading texture \" + r + \" from DB.\"), n.src = r;\n        };\n      } else pr.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\"), n.src = r;\n    }, c.prototype._saveImageIntoDBAsync = function (r, n) {\n      var o = this;\n\n      if (this.isSupported) {\n        var s = function () {\n          var t;\n\n          if (a) {\n            var i = window.URL || window.webkitURL;\n\n            try {\n              t = i.createObjectURL(a);\n            } catch (e) {\n              t = i.createObjectURL(a);\n            }\n          }\n\n          t && (n.src = t);\n        };\n\n        if (c.IsUASupportingBlobStorage) {\n          var a,\n              l = new XMLHttpRequest();\n          l.open(\"GET\", r, !0), l.responseType = \"blob\", l.addEventListener(\"load\", function () {\n            if (200 === l.status && o.db) {\n              a = l.response;\n              var e = o.db.transaction([\"textures\"], \"readwrite\");\n              e.onabort = function (e) {\n                try {\n                  var t = (e.srcElement || e.target).error;\n                  t && \"QuotaExceededError\" === t.name && (o.hasReachedQuota = !0);\n                } catch (e) {}\n\n                s();\n              }, e.oncomplete = function (e) {\n                s();\n              };\n              var t = {\n                textureUrl: r,\n                data: a\n              };\n\n              try {\n                var i = e.objectStore(\"textures\").put(t);\n                i.onsuccess = function (e) {}, i.onerror = function (e) {\n                  s();\n                };\n              } catch (e) {\n                25 === e.code && (c.IsUASupportingBlobStorage = !1), n.src = r;\n              }\n            } else n.src = r;\n          }, !1), l.addEventListener(\"error\", function (e) {\n            pr.Tools.Error(\"Error in XHR request in BABYLON.Database.\"), n.src = r;\n          }, !1), l.send();\n        } else n.src = r;\n      } else pr.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\"), n.src = r;\n    }, c.prototype._checkVersionFromDB = function (e, t) {\n      var i = this;\n\n      this._loadVersionFromDBAsync(e, t, function () {\n        i._saveVersionIntoDBAsync(e, t);\n      });\n    }, c.prototype._loadVersionFromDBAsync = function (t, i, r) {\n      var n,\n          o = this;\n      if (this.isSupported && this.db) try {\n        var e = this.db.transaction([\"versions\"]);\n        e.oncomplete = function (e) {\n          n ? o.manifestVersionFound !== n.data ? (o.mustUpdateRessources = !0, r()) : i(n.data) : (o.mustUpdateRessources = !0, r());\n        }, e.onabort = function (e) {\n          i(-1);\n        };\n        var s = e.objectStore(\"versions\").get(t);\n        s.onsuccess = function (e) {\n          n = e.target.result;\n        }, s.onerror = function (e) {\n          pr.Tools.Error(\"Error loading version for scene \" + t + \" from DB.\"), i(-1);\n        };\n      } catch (e) {\n        pr.Tools.Error(\"Error while accessing 'versions' object store (READ OP). Exception: \" + e.message), i(-1);\n      } else pr.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\"), i(-1);\n    }, c.prototype._saveVersionIntoDBAsync = function (e, i) {\n      var r = this;\n      if (this.isSupported && !this.hasReachedQuota && this.db) try {\n        var t = this.db.transaction([\"versions\"], \"readwrite\");\n        t.onabort = function (e) {\n          try {\n            var t = e.srcElement.error;\n            t && \"QuotaExceededError\" === t.name && (r.hasReachedQuota = !0);\n          } catch (e) {}\n\n          i(-1);\n        }, t.oncomplete = function (e) {\n          i(r.manifestVersionFound);\n        };\n        var n = {\n          sceneUrl: e,\n          data: this.manifestVersionFound\n        },\n            o = t.objectStore(\"versions\").put(n);\n        o.onsuccess = function (e) {}, o.onerror = function (e) {\n          pr.Tools.Error(\"Error in DB add version request in BABYLON.Database.\");\n        };\n      } catch (e) {\n        pr.Tools.Error(\"Error while accessing 'versions' object store (WRITE OP). Exception: \" + e.message), i(-1);\n      } else i(-1);\n    }, c.prototype.loadFileFromDB = function (e, t, i, r, n) {\n      var o = this,\n          s = c._ReturnFullUrlLocation(e),\n          a = function () {\n        o._saveFileIntoDBAsync(s, t, i, n, r);\n      };\n\n      this._checkVersionFromDB(s, function (e) {\n        -1 !== e ? o.mustUpdateRessources ? o._saveFileIntoDBAsync(s, t, i, n, r) : o._loadFileFromDBAsync(s, t, a, n) : r && r();\n      });\n    }, c.prototype._loadFileFromDBAsync = function (t, i, r, e) {\n      if (this.isSupported && this.db) {\n        var n, o;\n        n = -1 !== t.indexOf(\".babylon\") ? \"scenes\" : \"textures\";\n        var s = this.db.transaction([n]);\n        s.oncomplete = function (e) {\n          o ? i(o.data) : r();\n        }, s.onabort = function (e) {\n          r();\n        };\n        var a = s.objectStore(n).get(t);\n        a.onsuccess = function (e) {\n          o = e.target.result;\n        }, a.onerror = function (e) {\n          pr.Tools.Error(\"Error loading file \" + t + \" from DB.\"), r();\n        };\n      } else pr.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\"), i();\n    }, c.prototype._saveFileIntoDBAsync = function (r, n, e, o, s) {\n      var a = this;\n\n      if (this.isSupported) {\n        var l;\n        l = -1 !== r.indexOf(\".babylon\") ? \"scenes\" : \"textures\";\n        var c,\n            h = new XMLHttpRequest();\n        h.open(\"GET\", r + \"?\" + Date.now(), !0), o && (h.responseType = \"arraybuffer\"), e && (h.onprogress = e), h.addEventListener(\"load\", function () {\n          if (200 === h.status || h.status < 400 && pr.Tools.ValidateXHRData(h, o ? 6 : 1)) {\n            if (c = o ? h.response : h.responseText, !a.hasReachedQuota && a.db) {\n              var e,\n                  t = a.db.transaction([l], \"readwrite\");\n              t.onabort = function (e) {\n                try {\n                  var t = e.srcElement.error;\n                  t && \"QuotaExceededError\" === t.name && (a.hasReachedQuota = !0);\n                } catch (e) {}\n\n                n(c);\n              }, t.oncomplete = function (e) {\n                n(c);\n              }, e = \"scenes\" === l ? {\n                sceneUrl: r,\n                data: c,\n                version: a.manifestVersionFound\n              } : {\n                textureUrl: r,\n                data: c\n              };\n\n              try {\n                var i = t.objectStore(l).put(e);\n                i.onsuccess = function (e) {}, i.onerror = function (e) {\n                  pr.Tools.Error(\"Error in DB add file request in BABYLON.Database.\");\n                };\n              } catch (e) {\n                n(c);\n              }\n            } else n(c);\n          } else 400 <= h.status && s ? s(h) : n();\n        }, !1), h.addEventListener(\"error\", function (e) {\n          pr.Tools.Error(\"error on XHR request.\"), n();\n        }, !1), h.send();\n      } else pr.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\"), n();\n    }, c.IsUASupportingBlobStorage = !0, c.IDBStorageEnabled = !0, c._ParseURL = function (e) {\n      var t = (document.createElement(\"a\").href = e).substring(0, e.lastIndexOf(\"#\")),\n          i = e.substring(t.lastIndexOf(\"/\") + 1, e.length);\n      return e.substring(0, e.indexOf(i, 0));\n    }, c._ReturnFullUrlLocation = function (e) {\n      return -1 === e.indexOf(\"http:/\") && -1 === e.indexOf(\"https:/\") ? c._ParseURL(window.location.href) + e : e;\n    }, c;\n  }(), pr.Database = _r, mr = $a || ($a = {}), gr = function () {\n    function i() {\n      this._isEnabled = !0, this.leftColor = mr.Color3.White(), this.rightColor = mr.Color3.Black(), this.bias = 0, this.power = 1;\n    }\n\n    return Object.defineProperty(i.prototype, \"isEnabled\", {\n      get: function () {\n        return this._isEnabled;\n      },\n      set: function (e) {\n        this._isEnabled !== e && (this._isEnabled = e, mr.Engine.MarkAllMaterialsAsDirty(mr.Material.FresnelDirtyFlag | mr.Material.MiscDirtyFlag));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.clone = function () {\n      var e = new i();\n      return mr.Tools.DeepCopy(this, e), e;\n    }, i.prototype.serialize = function () {\n      var e = {};\n      return e.isEnabled = this.isEnabled, e.leftColor = this.leftColor.asArray(), e.rightColor = this.rightColor.asArray(), e.bias = this.bias, e.power = this.power, e;\n    }, i.Parse = function (e) {\n      var t = new i();\n      return t.isEnabled = e.isEnabled, t.leftColor = mr.Color3.FromArray(e.leftColor), t.rightColor = mr.Color3.FromArray(e.rightColor), t.bias = e.bias, t.power = e.power || 1, t;\n    }, i;\n  }(), mr.FresnelParameters = gr, vr = $a || ($a = {}), yr = function (n) {\n    function s(e, t) {\n      var i = n.call(this, e, t, !0) || this;\n      return t.multiMaterials.push(i), i.subMaterials = new Array(), i.storeEffectOnSubMeshes = !0, i;\n    }\n\n    return T(s, n), Object.defineProperty(s.prototype, \"subMaterials\", {\n      get: function () {\n        return this._subMaterials;\n      },\n      set: function (e) {\n        this._subMaterials = e, this._hookArray(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), s.prototype._hookArray = function (r) {\n      var n = this,\n          o = r.push;\n\n      r.push = function () {\n        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];\n\n        var i = o.apply(r, e);\n        return n._markAllSubMeshesAsTexturesDirty(), i;\n      };\n\n      var s = r.splice;\n\n      r.splice = function (e, t) {\n        var i = s.apply(r, [e, t]);\n        return n._markAllSubMeshesAsTexturesDirty(), i;\n      };\n    }, s.prototype.getSubMaterial = function (e) {\n      return e < 0 || e >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[e];\n    }, s.prototype.getActiveTextures = function () {\n      var e;\n      return (e = n.prototype.getActiveTextures.call(this)).concat.apply(e, this.subMaterials.map(function (e) {\n        return e ? e.getActiveTextures() : [];\n      }));\n    }, s.prototype.getClassName = function () {\n      return \"MultiMaterial\";\n    }, s.prototype.isReadyForSubMesh = function (e, t, i) {\n      for (var r = 0; r < this.subMaterials.length; r++) {\n        var n = this.subMaterials[r];\n\n        if (n) {\n          if (n.storeEffectOnSubMeshes) {\n            if (!n.isReadyForSubMesh(e, t, i)) return !1;\n            continue;\n          }\n\n          if (!n.isReady(e)) return !1;\n        }\n      }\n\n      return !0;\n    }, s.prototype.clone = function (e, t) {\n      for (var i = new s(e, this.getScene()), r = 0; r < this.subMaterials.length; r++) {\n        var n = null,\n            o = this.subMaterials[r];\n        n = t && o ? o.clone(e + \"-\" + o.name) : this.subMaterials[r], i.subMaterials.push(n);\n      }\n\n      return i;\n    }, s.prototype.serialize = function () {\n      var e = {};\n      e.name = this.name, e.id = this.id, vr.Tags && (e.tags = vr.Tags.GetTags(this)), e.materials = [];\n\n      for (var t = 0; t < this.subMaterials.length; t++) {\n        var i = this.subMaterials[t];\n        i ? e.materials.push(i.id) : e.materials.push(null);\n      }\n\n      return e;\n    }, s.prototype.dispose = function (e, t) {\n      var i = this.getScene();\n\n      if (i) {\n        var r = i.multiMaterials.indexOf(this);\n        0 <= r && i.multiMaterials.splice(r, 1), n.prototype.dispose.call(this, e, t);\n      }\n    }, s;\n  }(vr.Material), vr.MultiMaterial = yr, br = $a || ($a = {}), Tr = function () {\n    function e() {\n      this.touchAngularSensibility = 2e5, this.touchMoveSensibility = 250, this._offsetX = null, this._offsetY = null, this._pointerPressed = new Array();\n    }\n\n    return e.prototype.attachControl = function (e, n) {\n      var o = this,\n          s = null;\n      void 0 === this._pointerInput && (this._onLostFocus = function (e) {\n        o._offsetX = null, o._offsetY = null;\n      }, this._pointerInput = function (e, t) {\n        var i = e.event;\n        if (\"mouse\" !== i.pointerType) if (e.type === br.PointerEventTypes.POINTERDOWN) {\n          if (n || i.preventDefault(), o._pointerPressed.push(i.pointerId), 1 !== o._pointerPressed.length) return;\n          s = {\n            x: i.clientX,\n            y: i.clientY\n          };\n        } else if (e.type === br.PointerEventTypes.POINTERUP) {\n          if (n || i.preventDefault(), -1 === (r = o._pointerPressed.indexOf(i.pointerId))) return;\n          if (o._pointerPressed.splice(r, 1), 0 != r) return;\n          s = null, o._offsetX = null, o._offsetY = null;\n        } else if (e.type === br.PointerEventTypes.POINTERMOVE) {\n          if (n || i.preventDefault(), !s) return;\n          var r;\n          if (0 != (r = o._pointerPressed.indexOf(i.pointerId))) return;\n          o._offsetX = i.clientX - s.x, o._offsetY = -(i.clientY - s.y);\n        }\n      }), this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, br.PointerEventTypes.POINTERDOWN | br.PointerEventTypes.POINTERUP | br.PointerEventTypes.POINTERMOVE), this._onLostFocus && e.addEventListener(\"blur\", this._onLostFocus);\n    }, e.prototype.detachControl = function (e) {\n      this._pointerInput && e && (this._observer && (this.camera.getScene().onPointerObservable.remove(this._observer), this._observer = null), this._onLostFocus && (e.removeEventListener(\"blur\", this._onLostFocus), this._onLostFocus = null), this._pointerPressed = [], this._offsetX = null, this._offsetY = null);\n    }, e.prototype.checkInputs = function () {\n      if (this._offsetX && this._offsetY) {\n        var e = this.camera;\n        if (e.cameraRotation.y += this._offsetX / this.touchAngularSensibility, 1 < this._pointerPressed.length) e.cameraRotation.x += -this._offsetY / this.touchAngularSensibility;else {\n          var t = e._computeLocalCameraSpeed(),\n              i = new br.Vector3(0, 0, t * this._offsetY / this.touchMoveSensibility);\n\n          br.Matrix.RotationYawPitchRollToRef(e.rotation.y, e.rotation.x, 0, e._cameraRotationMatrix), e.cameraDirection.addInPlace(br.Vector3.TransformCoordinates(i, e._cameraRotationMatrix));\n        }\n      }\n    }, e.prototype.getClassName = function () {\n      return \"FreeCameraTouchInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"touch\";\n    }, b([br.serialize()], e.prototype, \"touchAngularSensibility\", void 0), b([br.serialize()], e.prototype, \"touchMoveSensibility\", void 0), e;\n  }(), br.FreeCameraTouchInput = Tr, br.CameraInputTypes.FreeCameraTouchInput = Tr, function (i) {\n    i.Node.AddNodeConstructor(\"TouchCamera\", function (e, t) {\n      return function () {\n        return new r(e, i.Vector3.Zero(), t);\n      };\n    });\n\n    var r = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, t, i) || this;\n        return r.inputs.addTouch(), r._setupInputs(), r;\n      }\n\n      return T(e, n), Object.defineProperty(e.prototype, \"touchAngularSensibility\", {\n        get: function () {\n          var e = this.inputs.attached.touch;\n          return e ? e.touchAngularSensibility : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.touch;\n          t && (t.touchAngularSensibility = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"touchMoveSensibility\", {\n        get: function () {\n          var e = this.inputs.attached.touch;\n          return e ? e.touchMoveSensibility : 0;\n        },\n        set: function (e) {\n          var t = this.inputs.attached.touch;\n          t && (t.touchMoveSensibility = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.getClassName = function () {\n        return \"TouchCamera\";\n      }, e.prototype._setupInputs = function () {\n        var e = this.inputs.attached.mouse;\n        e && (e.touchEnabled = !1);\n      }, e;\n    }(i.FreeCamera);\n\n    i.TouchCamera = r;\n  }($a || ($a = {})), Er = $a || ($a = {}), xr = function (h) {\n    function i(e, t, i, r, n, o, s) {\n      void 0 === n && (n = null), void 0 === o && (o = !0), void 0 === s && (s = !1);\n      var a = h.call(this, null, r, !o) || this;\n      a.isCube = s, a.isEnabled = !0, a.autoClear = !0, a.onGeneratedObservable = new Er.Observable(), a._textures = {}, a._currentRefreshId = -1, a._refreshRate = 1, a._vertexBuffers = {}, a._uniforms = new Array(), a._samplers = new Array(), a._floats = {}, a._ints = {}, a._floatsArrays = {}, a._colors3 = {}, a._colors4 = {}, a._vectors2 = {}, a._vectors3 = {}, a._matrices = {}, a._fallbackTextureUsed = !1, a._cachedDefines = \"\", a._contentUpdateId = -1;\n\n      var l = (r = a.getScene())._getComponent(Er.SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n\n      l || (l = new Er.ProceduralTextureSceneComponent(r), r._addComponent(l)), r.proceduralTextures.push(a), a._engine = r.getEngine(), a.name = e, a.isRenderTarget = !0, a._size = t, a._generateMipMaps = o, a.setFragment(i), a._fallbackTexture = n, s ? (a._texture = a._engine.createRenderTargetCubeTexture(t, {\n        generateMipMaps: o,\n        generateDepthBuffer: !1,\n        generateStencilBuffer: !1\n      }), a.setFloat(\"face\", 0)) : a._texture = a._engine.createRenderTargetTexture(t, {\n        generateMipMaps: o,\n        generateDepthBuffer: !1,\n        generateStencilBuffer: !1\n      });\n      var c = [];\n      return c.push(1, 1), c.push(-1, 1), c.push(-1, -1), c.push(1, -1), a._vertexBuffers[Er.VertexBuffer.PositionKind] = new Er.VertexBuffer(a._engine, c, Er.VertexBuffer.PositionKind, !1, !1, 2), a._createIndexBuffer(), a;\n    }\n\n    return T(i, h), i.prototype.getContent = function () {\n      return this._contentData && this._currentRefreshId == this._contentUpdateId || (this._contentData = this.readPixels(0, 0, this._contentData), this._contentUpdateId = this._currentRefreshId), this._contentData;\n    }, i.prototype._createIndexBuffer = function () {\n      var e = this._engine,\n          t = [];\n      t.push(0), t.push(1), t.push(2), t.push(0), t.push(2), t.push(3), this._indexBuffer = e.createIndexBuffer(t);\n    }, i.prototype._rebuild = function () {\n      var e = this._vertexBuffers[Er.VertexBuffer.PositionKind];\n      e && e._rebuild(), this._createIndexBuffer(), this.refreshRate === Er.RenderTargetTexture.REFRESHRATE_RENDER_ONCE && (this.refreshRate = Er.RenderTargetTexture.REFRESHRATE_RENDER_ONCE);\n    }, i.prototype.reset = function () {\n      void 0 !== this._effect && this._engine._releaseEffect(this._effect);\n    }, i.prototype._getDefines = function () {\n      return \"\";\n    }, i.prototype.isReady = function () {\n      var e,\n          t = this,\n          i = this._engine;\n      if (!this._fragment) return !1;\n      if (this._fallbackTextureUsed) return !0;\n\n      var r = this._getDefines();\n\n      return !(!this._effect || r !== this._cachedDefines || !this._effect.isReady()) || (e = void 0 !== this._fragment.fragmentElement ? {\n        vertex: \"procedural\",\n        fragmentElement: this._fragment.fragmentElement\n      } : {\n        vertex: \"procedural\",\n        fragment: this._fragment\n      }, this._cachedDefines = r, this._effect = i.createEffect(e, [Er.VertexBuffer.PositionKind], this._uniforms, this._samplers, r, void 0, void 0, function () {\n        t.releaseInternalTexture(), t._fallbackTexture && (t._texture = t._fallbackTexture._texture, t._texture && t._texture.incrementReferences()), t._fallbackTextureUsed = !0;\n      }), this._effect.isReady());\n    }, i.prototype.resetRefreshCounter = function () {\n      this._currentRefreshId = -1;\n    }, i.prototype.setFragment = function (e) {\n      this._fragment = e;\n    }, Object.defineProperty(i.prototype, \"refreshRate\", {\n      get: function () {\n        return this._refreshRate;\n      },\n      set: function (e) {\n        this._refreshRate = e, this.resetRefreshCounter();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype._shouldRender = function () {\n      return this.isEnabled && this.isReady() && this._texture ? !this._fallbackTextureUsed && (-1 === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1)) : (this._texture && (this._texture.isReady = !1), !1);\n    }, i.prototype.getRenderSize = function () {\n      return this._size;\n    }, i.prototype.resize = function (e, t) {\n      this._fallbackTextureUsed || (this.releaseInternalTexture(), this._texture = this._engine.createRenderTargetTexture(e, t), this._size = e, this._generateMipMaps = t);\n    }, i.prototype._checkUniform = function (e) {\n      -1 === this._uniforms.indexOf(e) && this._uniforms.push(e);\n    }, i.prototype.setTexture = function (e, t) {\n      return -1 === this._samplers.indexOf(e) && this._samplers.push(e), this._textures[e] = t, this;\n    }, i.prototype.setFloat = function (e, t) {\n      return this._checkUniform(e), this._floats[e] = t, this;\n    }, i.prototype.setInt = function (e, t) {\n      return this._checkUniform(e), this._ints[e] = t, this;\n    }, i.prototype.setFloats = function (e, t) {\n      return this._checkUniform(e), this._floatsArrays[e] = t, this;\n    }, i.prototype.setColor3 = function (e, t) {\n      return this._checkUniform(e), this._colors3[e] = t, this;\n    }, i.prototype.setColor4 = function (e, t) {\n      return this._checkUniform(e), this._colors4[e] = t, this;\n    }, i.prototype.setVector2 = function (e, t) {\n      return this._checkUniform(e), this._vectors2[e] = t, this;\n    }, i.prototype.setVector3 = function (e, t) {\n      return this._checkUniform(e), this._vectors3[e] = t, this;\n    }, i.prototype.setMatrix = function (e, t) {\n      return this._checkUniform(e), this._matrices[e] = t, this;\n    }, i.prototype.render = function (e) {\n      var t = this.getScene();\n\n      if (t) {\n        var i = this._engine;\n\n        for (var r in i.enableEffect(this._effect), i.setState(!1), this._textures) this._effect.setTexture(r, this._textures[r]);\n\n        for (r in this._ints) this._effect.setInt(r, this._ints[r]);\n\n        for (r in this._floats) this._effect.setFloat(r, this._floats[r]);\n\n        for (r in this._floatsArrays) this._effect.setArray(r, this._floatsArrays[r]);\n\n        for (r in this._colors3) this._effect.setColor3(r, this._colors3[r]);\n\n        for (r in this._colors4) {\n          var n = this._colors4[r];\n\n          this._effect.setFloat4(r, n.r, n.g, n.b, n.a);\n        }\n\n        for (r in this._vectors2) this._effect.setVector2(r, this._vectors2[r]);\n\n        for (r in this._vectors3) this._effect.setVector3(r, this._vectors3[r]);\n\n        for (r in this._matrices) this._effect.setMatrix(r, this._matrices[r]);\n\n        if (this._texture) {\n          if (this.isCube) for (var o = 0; o < 6; o++) i.bindFramebuffer(this._texture, o, void 0, void 0, !0), i.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect), this._effect.setFloat(\"face\", o), this.autoClear && i.clear(t.clearColor, !0, !1, !1), i.drawElementsType(Er.Material.TriangleFillMode, 0, 6), 5 === o && i.generateMipMapsForCubemap(this._texture);else i.bindFramebuffer(this._texture, 0, void 0, void 0, !0), i.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect), this.autoClear && i.clear(t.clearColor, !0, !1, !1), i.drawElementsType(Er.Material.TriangleFillMode, 0, 6);\n          i.unBindFramebuffer(this._texture, this.isCube), this.onGenerated && this.onGenerated(), this.onGeneratedObservable.notifyObservers(this);\n        }\n      }\n    }, i.prototype.clone = function () {\n      var e = this.getSize(),\n          t = new i(this.name, e.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);\n      return t.hasAlpha = this.hasAlpha, t.level = this.level, t.coordinatesMode = this.coordinatesMode, t;\n    }, i.prototype.dispose = function () {\n      var e = this.getScene();\n\n      if (e) {\n        var t = e.proceduralTextures.indexOf(this);\n        0 <= t && e.proceduralTextures.splice(t, 1);\n        var i = this._vertexBuffers[Er.VertexBuffer.PositionKind];\n        i && (i.dispose(), this._vertexBuffers[Er.VertexBuffer.PositionKind] = null), this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer) && (this._indexBuffer = null), h.prototype.dispose.call(this);\n      }\n    }, b([Er.serialize()], i.prototype, \"isEnabled\", void 0), b([Er.serialize()], i.prototype, \"autoClear\", void 0), b([Er.serialize()], i.prototype, \"_generateMipMaps\", void 0), b([Er.serialize()], i.prototype, \"_size\", void 0), b([Er.serialize()], i.prototype, \"refreshRate\", null), i;\n  }(Er.Texture), Er.ProceduralTexture = xr, Pr = $a || ($a = {}), Ar = function () {\n    function e(e) {\n      this.name = Pr.SceneComponentConstants.NAME_PROCEDURALTEXTURE, this.scene = e, this.scene.proceduralTextures = new Array(), e.layers = new Array();\n    }\n\n    return e.prototype.register = function () {\n      this.scene._beforeClearStage.registerStep(Pr.SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\n    }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {}, e.prototype._beforeClear = function () {\n      if (this.scene.proceduralTexturesEnabled) {\n        Pr.Tools.StartPerformanceCounter(\"Procedural textures\", 0 < this.scene.proceduralTextures.length);\n\n        for (var e = 0; e < this.scene.proceduralTextures.length; e++) {\n          var t = this.scene.proceduralTextures[e];\n          t._shouldRender() && t.render();\n        }\n\n        Pr.Tools.EndPerformanceCounter(\"Procedural textures\", 0 < this.scene.proceduralTextures.length);\n      }\n    }, e;\n  }(), Pr.ProceduralTextureSceneComponent = Ar, Sr = $a || ($a = {}), Mr = function (a) {\n    function e(e, t, i, r, n, o) {\n      var s = a.call(this, e, i, null, r, n, o) || this;\n      return s._animate = !0, s._time = 0, s._texturePath = t, s._loadJson(t), s.refreshRate = 1, s;\n    }\n\n    return T(e, a), e.prototype._loadJson = function (e) {\n      var t = this,\n          i = function () {\n        Sr.Tools.Log(\"No config file found in \" + e + \" trying to use ShadersStore or DOM element\");\n\n        try {\n          t.setFragment(t._texturePath);\n        } catch (e) {\n          Sr.Tools.Error(\"No json or ShaderStore or DOM element found for CustomProceduralTexture\");\n        }\n      },\n          r = e + \"/config.json\",\n          n = new XMLHttpRequest();\n\n      n.open(\"GET\", r, !0), n.addEventListener(\"load\", function () {\n        if (200 === n.status || Sr.Tools.ValidateXHRData(n, 1)) try {\n          t._config = JSON.parse(n.response), t.updateShaderUniforms(), t.updateTextures(), t.setFragment(t._texturePath + \"/custom\"), t._animate = t._config.animate, t.refreshRate = t._config.refreshrate;\n        } catch (e) {\n          i();\n        } else i();\n      }, !1), n.addEventListener(\"error\", function () {\n        i();\n      }, !1);\n\n      try {\n        n.send();\n      } catch (e) {\n        Sr.Tools.Error(\"CustomProceduralTexture: Error on XHR send request.\");\n      }\n    }, e.prototype.isReady = function () {\n      if (!a.prototype.isReady.call(this)) return !1;\n\n      for (var e in this._textures) {\n        if (!this._textures[e].isReady()) return !1;\n      }\n\n      return !0;\n    }, e.prototype.render = function (e) {\n      var t = this.getScene();\n      this._animate && t && (this._time += .03 * t.getAnimationRatio(), this.updateShaderUniforms()), a.prototype.render.call(this, e);\n    }, e.prototype.updateTextures = function () {\n      for (var e = 0; e < this._config.sampler2Ds.length; e++) this.setTexture(this._config.sampler2Ds[e].sample2Dname, new Sr.Texture(this._texturePath + \"/\" + this._config.sampler2Ds[e].textureRelativeUrl, this.getScene()));\n    }, e.prototype.updateShaderUniforms = function () {\n      if (this._config) for (var e = 0; e < this._config.uniforms.length; e++) {\n        var t = this._config.uniforms[e];\n\n        switch (t.type) {\n          case \"float\":\n            this.setFloat(t.name, t.value);\n            break;\n\n          case \"color3\":\n            this.setColor3(t.name, new Sr.Color3(t.r, t.g, t.b));\n            break;\n\n          case \"color4\":\n            this.setColor4(t.name, new Sr.Color4(t.r, t.g, t.b, t.a));\n            break;\n\n          case \"vector2\":\n            this.setVector2(t.name, new Sr.Vector2(t.x, t.y));\n            break;\n\n          case \"vector3\":\n            this.setVector3(t.name, new Sr.Vector3(t.x, t.y, t.z));\n        }\n      }\n      this.setFloat(\"time\", this._time);\n    }, Object.defineProperty(e.prototype, \"animate\", {\n      get: function () {\n        return this._animate;\n      },\n      set: function (e) {\n        this._animate = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e;\n  }(Sr.ProceduralTexture), Sr.CustomProceduralTexture = Mr, Rr = $a || ($a = {}), Cr = function () {\n    function e() {\n      this.gamepadAngularSensibility = 200, this.gamepadMoveSensibility = 40, this._cameraTransform = Rr.Matrix.Identity(), this._deltaTransform = Rr.Vector3.Zero(), this._vector3 = Rr.Vector3.Zero(), this._vector2 = Rr.Vector2.Zero();\n    }\n\n    return e.prototype.attachControl = function (e, t) {\n      var i = this,\n          r = this.camera.getScene().gamepadManager;\n      this._onGamepadConnectedObserver = r.onGamepadConnectedObservable.add(function (e) {\n        e.type !== Rr.Gamepad.POSE_ENABLED && (i.gamepad && e.type !== Rr.Gamepad.XBOX || (i.gamepad = e));\n      }), this._onGamepadDisconnectedObserver = r.onGamepadDisconnectedObservable.add(function (e) {\n        i.gamepad === e && (i.gamepad = null);\n      }), this.gamepad = r.getGamepadByType(Rr.Gamepad.XBOX);\n    }, e.prototype.detachControl = function (e) {\n      this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver), this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver), this.gamepad = null;\n    }, e.prototype.checkInputs = function () {\n      if (this.gamepad && this.gamepad.leftStick) {\n        var e = this.camera,\n            t = this.gamepad.leftStick,\n            i = t.x / this.gamepadMoveSensibility,\n            r = t.y / this.gamepadMoveSensibility;\n        t.x = .005 < Math.abs(i) ? 0 + i : 0, t.y = .005 < Math.abs(r) ? 0 + r : 0;\n        var n = this.gamepad.rightStick;\n\n        if (n) {\n          var o = n.x / this.gamepadAngularSensibility,\n              s = n.y / this.gamepadAngularSensibility;\n          n.x = .001 < Math.abs(o) ? 0 + o : 0, n.y = .001 < Math.abs(s) ? 0 + s : 0;\n        } else n = {\n          x: 0,\n          y: 0\n        };\n\n        e.rotationQuaternion ? e.rotationQuaternion.toRotationMatrix(this._cameraTransform) : Rr.Matrix.RotationYawPitchRollToRef(e.rotation.y, e.rotation.x, 0, this._cameraTransform);\n\n        var a = 50 * e._computeLocalCameraSpeed();\n\n        this._vector3.copyFromFloats(t.x * a, 0, -t.y * a), Rr.Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform), e.cameraDirection.addInPlace(this._deltaTransform), this._vector2.copyFromFloats(n.y, n.x), e.cameraRotation.addInPlace(this._vector2);\n      }\n    }, e.prototype.getClassName = function () {\n      return \"FreeCameraGamepadInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"gamepad\";\n    }, b([Rr.serialize()], e.prototype, \"gamepadAngularSensibility\", void 0), b([Rr.serialize()], e.prototype, \"gamepadMoveSensibility\", void 0), e;\n  }(), Rr.FreeCameraGamepadInput = Cr, Rr.CameraInputTypes.FreeCameraGamepadInput = Cr, Or = $a || ($a = {}), Dr = function () {\n    function e() {\n      this.gamepadRotationSensibility = 80, this.gamepadMoveSensibility = 40;\n    }\n\n    return e.prototype.attachControl = function (e, t) {\n      var i = this,\n          r = this.camera.getScene().gamepadManager;\n      this._onGamepadConnectedObserver = r.onGamepadConnectedObservable.add(function (e) {\n        e.type !== Or.Gamepad.POSE_ENABLED && (i.gamepad && e.type !== Or.Gamepad.XBOX || (i.gamepad = e));\n      }), this._onGamepadDisconnectedObserver = r.onGamepadDisconnectedObservable.add(function (e) {\n        i.gamepad === e && (i.gamepad = null);\n      }), this.gamepad = r.getGamepadByType(Or.Gamepad.XBOX);\n    }, e.prototype.detachControl = function (e) {\n      this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver), this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver), this.gamepad = null;\n    }, e.prototype.checkInputs = function () {\n      if (this.gamepad) {\n        var e = this.camera,\n            t = this.gamepad.rightStick;\n\n        if (t) {\n          if (0 != t.x) {\n            var i = t.x / this.gamepadRotationSensibility;\n            0 != i && .005 < Math.abs(i) && (e.inertialAlphaOffset += i);\n          }\n\n          if (0 != t.y) {\n            var r = t.y / this.gamepadRotationSensibility;\n            0 != r && .005 < Math.abs(r) && (e.inertialBetaOffset += r);\n          }\n        }\n\n        var n = this.gamepad.leftStick;\n\n        if (n && 0 != n.y) {\n          var o = n.y / this.gamepadMoveSensibility;\n          0 != o && .005 < Math.abs(o) && (this.camera.inertialRadiusOffset -= o);\n        }\n      }\n    }, e.prototype.getClassName = function () {\n      return \"ArcRotateCameraGamepadInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"gamepad\";\n    }, b([Or.serialize()], e.prototype, \"gamepadRotationSensibility\", void 0), b([Or.serialize()], e.prototype, \"gamepadMoveSensibility\", void 0), e;\n  }(), Or.ArcRotateCameraGamepadInput = Dr, Or.CameraInputTypes.ArcRotateCameraGamepadInput = Dr, Ir = $a || ($a = {}), wr = function () {\n    function e(e) {\n      var n = this;\n      this._scene = e, this._babylonGamepads = [], this._oneGamepadConnected = !1, this._isMonitoring = !1, this.onGamepadDisconnectedObservable = new Ir.Observable(), Ir.Tools.IsWindowObjectExist() ? (this._gamepadEventSupported = \"GamepadEvent\" in window, this._gamepadSupport = navigator.getGamepads || navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads) : this._gamepadEventSupported = !1, this.onGamepadConnectedObservable = new Ir.Observable(function (e) {\n        for (var t in n._babylonGamepads) {\n          var i = n._babylonGamepads[t];\n          i && i._isConnected && n.onGamepadConnectedObservable.notifyObserver(e, i);\n        }\n      }), this._onGamepadConnectedEvent = function (e) {\n        var t,\n            i = e.gamepad;\n        i.index in n._babylonGamepads && n._babylonGamepads[i.index].isConnected || (n._babylonGamepads[i.index] ? ((t = n._babylonGamepads[i.index]).browserGamepad = i, t._isConnected = !0) : t = n._addNewGamepad(i), n.onGamepadConnectedObservable.notifyObservers(t), n._startMonitoringGamepads());\n      }, this._onGamepadDisconnectedEvent = function (e) {\n        var t = e.gamepad;\n\n        for (var i in n._babylonGamepads) if (n._babylonGamepads[i].index === t.index) {\n          var r = n._babylonGamepads[i];\n          r._isConnected = !1, n.onGamepadDisconnectedObservable.notifyObservers(r);\n          break;\n        }\n      }, this._gamepadSupport && (this._updateGamepadObjects(), this._babylonGamepads.length && this._startMonitoringGamepads(), this._gamepadEventSupported ? (window.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, !1), window.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, !1)) : this._startMonitoringGamepads());\n    }\n\n    return Object.defineProperty(e.prototype, \"gamepads\", {\n      get: function () {\n        return this._babylonGamepads;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getGamepadByType = function (e) {\n      void 0 === e && (e = Ir.Gamepad.XBOX);\n\n      for (var t = 0, i = this._babylonGamepads; t < i.length; t++) {\n        var r = i[t];\n        if (r && r.type === e) return r;\n      }\n\n      return null;\n    }, e.prototype.dispose = function () {\n      this._gamepadEventSupported && (this._onGamepadConnectedEvent && window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent), this._onGamepadDisconnectedEvent && window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent), this._onGamepadConnectedEvent = null, this._onGamepadDisconnectedEvent = null), this._babylonGamepads.forEach(function (e) {\n        e.dispose();\n      }), this.onGamepadConnectedObservable.clear(), this.onGamepadDisconnectedObservable.clear(), this._oneGamepadConnected = !1, this._stopMonitoringGamepads(), this._babylonGamepads = [];\n    }, e.prototype._addNewGamepad = function (e) {\n      var t;\n      this._oneGamepadConnected || (this._oneGamepadConnected = !0);\n      var i = -1 !== e.id.search(\"Xbox One\");\n      return t = i || -1 !== e.id.search(\"Xbox 360\") || -1 !== e.id.search(\"xinput\") ? new Ir.Xbox360Pad(e.id, e.index, e, i) : e.pose ? Ir.PoseEnabledControllerHelper.InitiateController(e) : new Ir.GenericPad(e.id, e.index, e), this._babylonGamepads[t.index] = t;\n    }, e.prototype._startMonitoringGamepads = function () {\n      this._isMonitoring || (this._isMonitoring = !0, this._scene || this._checkGamepadsStatus());\n    }, e.prototype._stopMonitoringGamepads = function () {\n      this._isMonitoring = !1;\n    }, e.prototype._checkGamepadsStatus = function () {\n      var e = this;\n\n      for (var t in this._updateGamepadObjects(), this._babylonGamepads) {\n        var i = this._babylonGamepads[t];\n        i && i.isConnected && i.update();\n      }\n\n      this._isMonitoring && !this._scene && Ir.Tools.QueueNewFrame(function () {\n        e._checkGamepadsStatus();\n      });\n    }, e.prototype._updateGamepadObjects = function () {\n      for (var e = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [], t = 0; t < e.length; t++) {\n        var i = e[t];\n        if (i) if (this._babylonGamepads[i.index]) this._babylonGamepads[t].browserGamepad = i, this._babylonGamepads[t].isConnected || (this._babylonGamepads[t]._isConnected = !0, this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[t]));else {\n          var r = this._addNewGamepad(i);\n\n          this.onGamepadConnectedObservable.notifyObservers(r);\n        }\n      }\n    }, e;\n  }(), Ir.GamepadManager = wr, function (o) {\n    var e = function (e, t) {\n      this.x = e, this.y = t;\n    };\n\n    o.StickValues = e;\n\n    var s = function () {\n      function a(e, t, i, r, n, o, s) {\n        void 0 === r && (r = 0), void 0 === n && (n = 1), void 0 === o && (o = 2), void 0 === s && (s = 3), this.id = e, this.index = t, this.browserGamepad = i, this._leftStick = {\n          x: 0,\n          y: 0\n        }, this._rightStick = {\n          x: 0,\n          y: 0\n        }, this._isConnected = !0, this._invertLeftStickY = !1, this.type = a.GAMEPAD, this._leftStickAxisX = r, this._leftStickAxisY = n, this._rightStickAxisX = o, this._rightStickAxisY = s, 2 <= this.browserGamepad.axes.length && (this._leftStick = {\n          x: this.browserGamepad.axes[this._leftStickAxisX],\n          y: this.browserGamepad.axes[this._leftStickAxisY]\n        }), 4 <= this.browserGamepad.axes.length && (this._rightStick = {\n          x: this.browserGamepad.axes[this._rightStickAxisX],\n          y: this.browserGamepad.axes[this._rightStickAxisY]\n        });\n      }\n\n      return Object.defineProperty(a.prototype, \"isConnected\", {\n        get: function () {\n          return this._isConnected;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), a.prototype.onleftstickchanged = function (e) {\n        this._onleftstickchanged = e;\n      }, a.prototype.onrightstickchanged = function (e) {\n        this._onrightstickchanged = e;\n      }, Object.defineProperty(a.prototype, \"leftStick\", {\n        get: function () {\n          return this._leftStick;\n        },\n        set: function (e) {\n          !this._onleftstickchanged || this._leftStick.x === e.x && this._leftStick.y === e.y || this._onleftstickchanged(e), this._leftStick = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(a.prototype, \"rightStick\", {\n        get: function () {\n          return this._rightStick;\n        },\n        set: function (e) {\n          !this._onrightstickchanged || this._rightStick.x === e.x && this._rightStick.y === e.y || this._onrightstickchanged(e), this._rightStick = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), a.prototype.update = function () {\n        this._leftStick && (this.leftStick = {\n          x: this.browserGamepad.axes[this._leftStickAxisX],\n          y: this.browserGamepad.axes[this._leftStickAxisY]\n        }, this._invertLeftStickY && (this.leftStick.y *= -1)), this._rightStick && (this.rightStick = {\n          x: this.browserGamepad.axes[this._rightStickAxisX],\n          y: this.browserGamepad.axes[this._rightStickAxisY]\n        });\n      }, a.prototype.dispose = function () {}, a.GAMEPAD = 0, a.GENERIC = 1, a.XBOX = 2, a.POSE_ENABLED = 3, a;\n    }(),\n        t = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, t, i) || this;\n        return r.onButtonDownObservable = new o.Observable(), r.onButtonUpObservable = new o.Observable(), r.type = s.GENERIC, r._buttons = new Array(i.buttons.length), r;\n      }\n\n      return T(e, n), e.prototype.onbuttondown = function (e) {\n        this._onbuttondown = e;\n      }, e.prototype.onbuttonup = function (e) {\n        this._onbuttonup = e;\n      }, e.prototype._setButtonValue = function (e, t, i) {\n        return e !== t && (1 === e && (this._onbuttondown && this._onbuttondown(i), this.onButtonDownObservable.notifyObservers(i)), 0 === e && (this._onbuttonup && this._onbuttonup(i), this.onButtonUpObservable.notifyObservers(i))), e;\n      }, e.prototype.update = function () {\n        n.prototype.update.call(this);\n\n        for (var e = 0; e < this._buttons.length; e++) this._buttons[e] = this._setButtonValue(this.browserGamepad.buttons[e].value, this._buttons[e], e);\n      }, e.prototype.dispose = function () {\n        n.prototype.dispose.call(this), this.onButtonDownObservable.clear(), this.onButtonUpObservable.clear();\n      }, e;\n    }(o.Gamepad = s);\n\n    o.GenericPad = t;\n  }($a || ($a = {})), function (s) {\n    var t, e, i, r;\n    (e = t = s.Xbox360Button || (s.Xbox360Button = {}))[e.A = 0] = \"A\", e[e.B = 1] = \"B\", e[e.X = 2] = \"X\", e[e.Y = 3] = \"Y\", e[e.Start = 4] = \"Start\", e[e.Back = 5] = \"Back\", e[e.LB = 6] = \"LB\", e[e.RB = 7] = \"RB\", e[e.LeftStick = 8] = \"LeftStick\", e[e.RightStick = 9] = \"RightStick\", (r = i = s.Xbox360Dpad || (s.Xbox360Dpad = {}))[r.Up = 0] = \"Up\", r[r.Down = 1] = \"Down\", r[r.Left = 2] = \"Left\", r[r.Right = 3] = \"Right\";\n\n    var n = function (o) {\n      function e(e, t, i, r) {\n        void 0 === r && (r = !1);\n        var n = o.call(this, e, t, i, 0, 1, 2, 3) || this;\n        return n._leftTrigger = 0, n._rightTrigger = 0, n.onButtonDownObservable = new s.Observable(), n.onButtonUpObservable = new s.Observable(), n.onPadDownObservable = new s.Observable(), n.onPadUpObservable = new s.Observable(), n._buttonA = 0, n._buttonB = 0, n._buttonX = 0, n._buttonY = 0, n._buttonBack = 0, n._buttonStart = 0, n._buttonLB = 0, n._buttonRB = 0, n._buttonLeftStick = 0, n._buttonRightStick = 0, n._dPadUp = 0, n._dPadDown = 0, n._dPadLeft = 0, n._dPadRight = 0, n._isXboxOnePad = !1, n.type = s.Gamepad.XBOX, n._isXboxOnePad = r, n;\n      }\n\n      return T(e, o), e.prototype.onlefttriggerchanged = function (e) {\n        this._onlefttriggerchanged = e;\n      }, e.prototype.onrighttriggerchanged = function (e) {\n        this._onrighttriggerchanged = e;\n      }, Object.defineProperty(e.prototype, \"leftTrigger\", {\n        get: function () {\n          return this._leftTrigger;\n        },\n        set: function (e) {\n          this._onlefttriggerchanged && this._leftTrigger !== e && this._onlefttriggerchanged(e), this._leftTrigger = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"rightTrigger\", {\n        get: function () {\n          return this._rightTrigger;\n        },\n        set: function (e) {\n          this._onrighttriggerchanged && this._rightTrigger !== e && this._onrighttriggerchanged(e), this._rightTrigger = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.onbuttondown = function (e) {\n        this._onbuttondown = e;\n      }, e.prototype.onbuttonup = function (e) {\n        this._onbuttonup = e;\n      }, e.prototype.ondpaddown = function (e) {\n        this._ondpaddown = e;\n      }, e.prototype.ondpadup = function (e) {\n        this._ondpadup = e;\n      }, e.prototype._setButtonValue = function (e, t, i) {\n        return e !== t && (1 === e && (this._onbuttondown && this._onbuttondown(i), this.onButtonDownObservable.notifyObservers(i)), 0 === e && (this._onbuttonup && this._onbuttonup(i), this.onButtonUpObservable.notifyObservers(i))), e;\n      }, e.prototype._setDPadValue = function (e, t, i) {\n        return e !== t && (1 === e && (this._ondpaddown && this._ondpaddown(i), this.onPadDownObservable.notifyObservers(i)), 0 === e && (this._ondpadup && this._ondpadup(i), this.onPadUpObservable.notifyObservers(i))), e;\n      }, Object.defineProperty(e.prototype, \"buttonA\", {\n        get: function () {\n          return this._buttonA;\n        },\n        set: function (e) {\n          this._buttonA = this._setButtonValue(e, this._buttonA, t.A);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonB\", {\n        get: function () {\n          return this._buttonB;\n        },\n        set: function (e) {\n          this._buttonB = this._setButtonValue(e, this._buttonB, t.B);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonX\", {\n        get: function () {\n          return this._buttonX;\n        },\n        set: function (e) {\n          this._buttonX = this._setButtonValue(e, this._buttonX, t.X);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonY\", {\n        get: function () {\n          return this._buttonY;\n        },\n        set: function (e) {\n          this._buttonY = this._setButtonValue(e, this._buttonY, t.Y);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonStart\", {\n        get: function () {\n          return this._buttonStart;\n        },\n        set: function (e) {\n          this._buttonStart = this._setButtonValue(e, this._buttonStart, t.Start);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonBack\", {\n        get: function () {\n          return this._buttonBack;\n        },\n        set: function (e) {\n          this._buttonBack = this._setButtonValue(e, this._buttonBack, t.Back);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonLB\", {\n        get: function () {\n          return this._buttonLB;\n        },\n        set: function (e) {\n          this._buttonLB = this._setButtonValue(e, this._buttonLB, t.LB);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonRB\", {\n        get: function () {\n          return this._buttonRB;\n        },\n        set: function (e) {\n          this._buttonRB = this._setButtonValue(e, this._buttonRB, t.RB);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonLeftStick\", {\n        get: function () {\n          return this._buttonLeftStick;\n        },\n        set: function (e) {\n          this._buttonLeftStick = this._setButtonValue(e, this._buttonLeftStick, t.LeftStick);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"buttonRightStick\", {\n        get: function () {\n          return this._buttonRightStick;\n        },\n        set: function (e) {\n          this._buttonRightStick = this._setButtonValue(e, this._buttonRightStick, t.RightStick);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"dPadUp\", {\n        get: function () {\n          return this._dPadUp;\n        },\n        set: function (e) {\n          this._dPadUp = this._setDPadValue(e, this._dPadUp, i.Up);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"dPadDown\", {\n        get: function () {\n          return this._dPadDown;\n        },\n        set: function (e) {\n          this._dPadDown = this._setDPadValue(e, this._dPadDown, i.Down);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"dPadLeft\", {\n        get: function () {\n          return this._dPadLeft;\n        },\n        set: function (e) {\n          this._dPadLeft = this._setDPadValue(e, this._dPadLeft, i.Left);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"dPadRight\", {\n        get: function () {\n          return this._dPadRight;\n        },\n        set: function (e) {\n          this._dPadRight = this._setDPadValue(e, this._dPadRight, i.Right);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.update = function () {\n        o.prototype.update.call(this), this._isXboxOnePad ? (this.buttonA = this.browserGamepad.buttons[0].value, this.buttonB = this.browserGamepad.buttons[1].value, this.buttonX = this.browserGamepad.buttons[2].value, this.buttonY = this.browserGamepad.buttons[3].value, this.buttonLB = this.browserGamepad.buttons[4].value, this.buttonRB = this.browserGamepad.buttons[5].value, this.leftTrigger = this.browserGamepad.axes[2], this.rightTrigger = this.browserGamepad.axes[5], this.buttonBack = this.browserGamepad.buttons[9].value, this.buttonStart = this.browserGamepad.buttons[8].value, this.buttonLeftStick = this.browserGamepad.buttons[6].value, this.buttonRightStick = this.browserGamepad.buttons[7].value, this.dPadUp = this.browserGamepad.buttons[11].value, this.dPadDown = this.browserGamepad.buttons[12].value, this.dPadLeft = this.browserGamepad.buttons[13].value, this.dPadRight = this.browserGamepad.buttons[14].value) : (this.buttonA = this.browserGamepad.buttons[0].value, this.buttonB = this.browserGamepad.buttons[1].value, this.buttonX = this.browserGamepad.buttons[2].value, this.buttonY = this.browserGamepad.buttons[3].value, this.buttonLB = this.browserGamepad.buttons[4].value, this.buttonRB = this.browserGamepad.buttons[5].value, this.leftTrigger = this.browserGamepad.buttons[6].value, this.rightTrigger = this.browserGamepad.buttons[7].value, this.buttonBack = this.browserGamepad.buttons[8].value, this.buttonStart = this.browserGamepad.buttons[9].value, this.buttonLeftStick = this.browserGamepad.buttons[10].value, this.buttonRightStick = this.browserGamepad.buttons[11].value, this.dPadUp = this.browserGamepad.buttons[12].value, this.dPadDown = this.browserGamepad.buttons[13].value, this.dPadLeft = this.browserGamepad.buttons[14].value, this.dPadRight = this.browserGamepad.buttons[15].value);\n      }, e.prototype.dispose = function () {\n        o.prototype.dispose.call(this), this.onButtonDownObservable.clear(), this.onButtonUpObservable.clear(), this.onPadDownObservable.clear(), this.onPadUpObservable.clear();\n      }, e;\n    }(s.Gamepad);\n\n    s.Xbox360Pad = n;\n  }($a || ($a = {})), function (s) {\n    var r, e;\n    (e = r = s.PoseEnabledControllerType || (s.PoseEnabledControllerType = {}))[e.VIVE = 0] = \"VIVE\", e[e.OCULUS = 1] = \"OCULUS\", e[e.WINDOWS = 2] = \"WINDOWS\", e[e.GEAR_VR = 3] = \"GEAR_VR\", e[e.DAYDREAM = 4] = \"DAYDREAM\", e[e.GENERIC = 5] = \"GENERIC\";\n\n    var t = function () {\n      function e() {}\n\n      return e.InitiateController = function (e) {\n        return -1 !== e.id.indexOf(\"Oculus Touch\") ? new s.OculusTouchController(e) : 0 === e.id.indexOf(s.WindowsMotionController.GAMEPAD_ID_PREFIX) ? new s.WindowsMotionController(e) : -1 !== e.id.toLowerCase().indexOf(\"openvr\") ? new s.ViveController(e) : 0 === e.id.indexOf(s.GearVRController.GAMEPAD_ID_PREFIX) || -1 !== e.id.indexOf(\"Oculus Go\") ? new s.GearVRController(e) : 0 === e.id.indexOf(s.DaydreamController.GAMEPAD_ID_PREFIX) ? new s.DaydreamController(e) : new s.GenericController(e);\n      }, e;\n    }();\n\n    s.PoseEnabledControllerHelper = t;\n\n    var i = function (i) {\n      function e(e) {\n        var t = i.call(this, e.id, e.index, e) || this;\n        return t._deviceRoomPosition = s.Vector3.Zero(), t._deviceRoomRotationQuaternion = new s.Quaternion(), t.devicePosition = s.Vector3.Zero(), t.deviceRotationQuaternion = new s.Quaternion(), t.deviceScaleFactor = 1, t._trackPosition = !0, t._maxRotationDistFromHeadset = Math.PI / 5, t._draggedRoomRotation = 0, t._leftHandSystemQuaternion = new s.Quaternion(), t._deviceToWorld = s.Matrix.Identity(), t._pointingPoseNode = null, t._workingMatrix = s.Matrix.Identity(), t._meshAttachedObservable = new s.Observable(), t.type = s.Gamepad.POSE_ENABLED, t.controllerType = r.GENERIC, t.position = s.Vector3.Zero(), t.rotationQuaternion = new s.Quaternion(), t._calculatedPosition = s.Vector3.Zero(), t._calculatedRotation = new s.Quaternion(), s.Quaternion.RotationYawPitchRollToRef(Math.PI, 0, 0, t._leftHandSystemQuaternion), t;\n      }\n\n      return T(e, i), e.prototype._disableTrackPosition = function (e) {\n        this._trackPosition && (this._calculatedPosition.copyFrom(e), this._trackPosition = !1);\n      }, e.prototype.update = function () {\n        i.prototype.update.call(this), this._updatePoseAndMesh();\n      }, e.prototype._updatePoseAndMesh = function () {\n        var e = this.browserGamepad.pose;\n\n        if ((this.updateFromDevice(e), !this._trackPosition && s.Engine.LastCreatedScene && s.Engine.LastCreatedScene.activeCamera && s.Engine.LastCreatedScene.activeCamera.devicePosition) && ((t = s.Engine.LastCreatedScene.activeCamera)._computeDevicePosition(), this._deviceToWorld.setTranslation(t.devicePosition), t.deviceRotationQuaternion)) {\n          var t;\n\n          (t = t)._deviceRoomRotationQuaternion.toEulerAnglesToRef(s.Tmp.Vector3[0]);\n\n          var i = Math.atan2(Math.sin(s.Tmp.Vector3[0].y - this._draggedRoomRotation), Math.cos(s.Tmp.Vector3[0].y - this._draggedRoomRotation));\n\n          if (Math.abs(i) > this._maxRotationDistFromHeadset) {\n            var r = i - (i < 0 ? -this._maxRotationDistFromHeadset : this._maxRotationDistFromHeadset);\n            this._draggedRoomRotation += r;\n            var n = Math.sin(-r),\n                o = Math.cos(-r);\n            this._calculatedPosition.x = this._calculatedPosition.x * o - this._calculatedPosition.z * n, this._calculatedPosition.z = this._calculatedPosition.x * n + this._calculatedPosition.z * o;\n          }\n        }\n\n        s.Vector3.TransformCoordinatesToRef(this._calculatedPosition, this._deviceToWorld, this.devicePosition), this._deviceToWorld.getRotationMatrixToRef(this._workingMatrix), s.Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion), this.deviceRotationQuaternion.multiplyInPlace(this._calculatedRotation), this._mesh && (this._mesh.position.copyFrom(this.devicePosition), this._mesh.rotationQuaternion && this._mesh.rotationQuaternion.copyFrom(this.deviceRotationQuaternion));\n      }, e.prototype.updateFromDevice = function (e) {\n        if (e) {\n          (this.rawPose = e).position && (this._deviceRoomPosition.copyFromFloats(e.position[0], e.position[1], -e.position[2]), this._mesh && this._mesh.getScene().useRightHandedSystem && (this._deviceRoomPosition.z *= -1), this._trackPosition && this._deviceRoomPosition.scaleToRef(this.deviceScaleFactor, this._calculatedPosition), this._calculatedPosition.addInPlace(this.position));\n          var t = this.rawPose;\n          e.orientation && t.orientation && (this._deviceRoomRotationQuaternion.copyFromFloats(t.orientation[0], t.orientation[1], -t.orientation[2], -t.orientation[3]), this._mesh && (this._mesh.getScene().useRightHandedSystem ? (this._deviceRoomRotationQuaternion.z *= -1, this._deviceRoomRotationQuaternion.w *= -1) : this._deviceRoomRotationQuaternion.multiplyToRef(this._leftHandSystemQuaternion, this._deviceRoomRotationQuaternion)), this._deviceRoomRotationQuaternion.multiplyToRef(this.rotationQuaternion, this._calculatedRotation));\n        }\n      }, e.prototype.attachToMesh = function (e) {\n        if (this._mesh && (this._mesh.parent = null), this._mesh = e, this._poseControlledCamera && (this._mesh.parent = this._poseControlledCamera), this._mesh.rotationQuaternion || (this._mesh.rotationQuaternion = new s.Quaternion()), this._updatePoseAndMesh(), this._pointingPoseNode) {\n          for (var t = [], i = this._pointingPoseNode; i.parent;) t.push(i.parent), i = i.parent;\n\n          t.reverse().forEach(function (e) {\n            e.computeWorldMatrix(!0);\n          });\n        }\n\n        this._meshAttachedObservable.notifyObservers(e);\n      }, e.prototype.attachToPoseControlledCamera = function (e) {\n        this._poseControlledCamera = e, this._mesh && (this._mesh.parent = this._poseControlledCamera);\n      }, e.prototype.dispose = function () {\n        this._mesh && this._mesh.dispose(), this._mesh = null, i.prototype.dispose.call(this);\n      }, Object.defineProperty(e.prototype, \"mesh\", {\n        get: function () {\n          return this._mesh;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.getForwardRay = function (e) {\n        if (void 0 === e && (e = 100), !this.mesh) return new s.Ray(s.Vector3.Zero(), new s.Vector3(0, 0, 1), e);\n        var t = this._pointingPoseNode ? this._pointingPoseNode.getWorldMatrix() : this.mesh.getWorldMatrix(),\n            i = t.getTranslation(),\n            r = new s.Vector3(0, 0, -1),\n            n = s.Vector3.TransformNormal(r, t),\n            o = s.Vector3.Normalize(n);\n        return new s.Ray(i, o, e);\n      }, e.POINTING_POSE = \"POINTING_POSE\", e;\n    }(s.Gamepad);\n\n    s.PoseEnabledController = i;\n  }($a || ($a = {})), Lr = $a || ($a = {}), Fr = function (i) {\n    function e(e) {\n      var t = i.call(this, e) || this;\n      return t.onTriggerStateChangedObservable = new Lr.Observable(), t.onMainButtonStateChangedObservable = new Lr.Observable(), t.onSecondaryButtonStateChangedObservable = new Lr.Observable(), t.onPadStateChangedObservable = new Lr.Observable(), t.onPadValuesChangedObservable = new Lr.Observable(), t.pad = {\n        x: 0,\n        y: 0\n      }, t._changes = {\n        pressChanged: !1,\n        touchChanged: !1,\n        valueChanged: !1,\n        changed: !1\n      }, t._buttons = new Array(e.buttons.length), t.hand = e.hand, t;\n    }\n\n    return T(e, i), e.prototype.onButtonStateChange = function (e) {\n      this._onButtonStateChange = e;\n    }, Object.defineProperty(e.prototype, \"defaultModel\", {\n      get: function () {\n        return this._defaultModel;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.update = function () {\n      i.prototype.update.call(this);\n\n      for (var e = 0; e < this._buttons.length; e++) this._setButtonValue(this.browserGamepad.buttons[e], this._buttons[e], e);\n\n      this.leftStick.x === this.pad.x && this.leftStick.y === this.pad.y || (this.pad.x = this.leftStick.x, this.pad.y = this.leftStick.y, this.onPadValuesChangedObservable.notifyObservers(this.pad));\n    }, e.prototype._setButtonValue = function (e, t, i) {\n      e || (e = {\n        pressed: !1,\n        touched: !1,\n        value: 0\n      }), t ? (this._checkChanges(e, t), this._changes.changed && (this._onButtonStateChange && this._onButtonStateChange(this.index, i, e), this._handleButtonChange(i, e, this._changes)), this._buttons[i].pressed = e.pressed, this._buttons[i].touched = e.touched, this._buttons[i].value = e.value < 1e-8 ? 0 : e.value) : this._buttons[i] = {\n        pressed: e.pressed,\n        touched: e.touched,\n        value: e.value\n      };\n    }, e.prototype._checkChanges = function (e, t) {\n      return this._changes.pressChanged = e.pressed !== t.pressed, this._changes.touchChanged = e.touched !== t.touched, this._changes.valueChanged = e.value !== t.value, this._changes.changed = this._changes.pressChanged || this._changes.touchChanged || this._changes.valueChanged, this._changes;\n    }, e.prototype.dispose = function () {\n      i.prototype.dispose.call(this), this.onTriggerStateChangedObservable.clear(), this.onMainButtonStateChangedObservable.clear(), this.onSecondaryButtonStateChangedObservable.clear(), this.onPadStateChangedObservable.clear(), this.onPadValuesChangedObservable.clear();\n    }, e;\n  }(Lr.PoseEnabledController), Lr.WebVRController = Fr, Br = $a || ($a = {}), Nr = function (i) {\n    function n(e) {\n      var t = i.call(this, e) || this;\n      return t.onSecondaryTriggerStateChangedObservable = new Br.Observable(), t.onThumbRestChangedObservable = new Br.Observable(), t.controllerType = Br.PoseEnabledControllerType.OCULUS, t;\n    }\n\n    return T(n, i), n.prototype.initControllerMesh = function (e, t) {\n      var i,\n          r = this;\n      i = \"left\" === this.hand ? n.MODEL_LEFT_FILENAME : n.MODEL_RIGHT_FILENAME, Br.SceneLoader.ImportMesh(\"\", n.MODEL_BASE_URL, i, e, function (e) {\n        r._defaultModel = e[1], r.attachToMesh(r._defaultModel), t && t(r._defaultModel);\n      });\n    }, Object.defineProperty(n.prototype, \"onAButtonStateChangedObservable\", {\n      get: function () {\n        if (\"right\" === this.hand) return this.onMainButtonStateChangedObservable;\n        throw new Error(\"No A button on left hand\");\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"onBButtonStateChangedObservable\", {\n      get: function () {\n        if (\"right\" === this.hand) return this.onSecondaryButtonStateChangedObservable;\n        throw new Error(\"No B button on left hand\");\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"onXButtonStateChangedObservable\", {\n      get: function () {\n        if (\"left\" === this.hand) return this.onMainButtonStateChangedObservable;\n        throw new Error(\"No X button on right hand\");\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"onYButtonStateChangedObservable\", {\n      get: function () {\n        if (\"left\" === this.hand) return this.onSecondaryButtonStateChangedObservable;\n        throw new Error(\"No Y button on right hand\");\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.prototype._handleButtonChange = function (e, t, i) {\n      var r = t,\n          n = \"right\" === this.hand ? -1 : 1;\n\n      switch (e) {\n        case 0:\n          return void this.onPadStateChangedObservable.notifyObservers(r);\n\n        case 1:\n          return this._defaultModel && (this._defaultModel.getChildren()[3].rotation.x = .2 * -r.value, this._defaultModel.getChildren()[3].position.y = .005 * -r.value, this._defaultModel.getChildren()[3].position.z = .005 * -r.value), void this.onTriggerStateChangedObservable.notifyObservers(r);\n\n        case 2:\n          return this._defaultModel && (this._defaultModel.getChildren()[4].position.x = n * r.value * .0035), void this.onSecondaryTriggerStateChangedObservable.notifyObservers(r);\n\n        case 3:\n          return this._defaultModel && (r.pressed ? this._defaultModel.getChildren()[1].position.y = -.001 : this._defaultModel.getChildren()[1].position.y = 0), void this.onMainButtonStateChangedObservable.notifyObservers(r);\n\n        case 4:\n          return this._defaultModel && (r.pressed ? this._defaultModel.getChildren()[2].position.y = -.001 : this._defaultModel.getChildren()[2].position.y = 0), void this.onSecondaryButtonStateChangedObservable.notifyObservers(r);\n\n        case 5:\n          return void this.onThumbRestChangedObservable.notifyObservers(r);\n      }\n    }, n.MODEL_BASE_URL = \"https://controllers.babylonjs.com/oculus/\", n.MODEL_LEFT_FILENAME = \"left.babylon\", n.MODEL_RIGHT_FILENAME = \"right.babylon\", n;\n  }(Br.WebVRController), Br.OculusTouchController = Nr, Vr = $a || ($a = {}), Ur = function (i) {\n    function r(e) {\n      var t = i.call(this, e) || this;\n      return t.controllerType = Vr.PoseEnabledControllerType.VIVE, t._invertLeftStickY = !0, t;\n    }\n\n    return T(r, i), r.prototype.initControllerMesh = function (e, t) {\n      var i = this;\n      Vr.SceneLoader.ImportMesh(\"\", r.MODEL_BASE_URL, r.MODEL_FILENAME, e, function (e) {\n        i._defaultModel = e[1], i.attachToMesh(i._defaultModel), t && t(i._defaultModel);\n      });\n    }, Object.defineProperty(r.prototype, \"onLeftButtonStateChangedObservable\", {\n      get: function () {\n        return this.onMainButtonStateChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"onRightButtonStateChangedObservable\", {\n      get: function () {\n        return this.onMainButtonStateChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"onMenuButtonStateChangedObservable\", {\n      get: function () {\n        return this.onSecondaryButtonStateChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype._handleButtonChange = function (e, t, i) {\n      var r = t;\n\n      switch (e) {\n        case 0:\n          return void this.onPadStateChangedObservable.notifyObservers(r);\n\n        case 1:\n          return this._defaultModel && (this._defaultModel.getChildren()[6].rotation.x = .15 * -r.value), void this.onTriggerStateChangedObservable.notifyObservers(r);\n\n        case 2:\n          return void this.onMainButtonStateChangedObservable.notifyObservers(r);\n\n        case 3:\n          return this._defaultModel && (r.pressed ? this._defaultModel.getChildren()[2].position.y = -.001 : this._defaultModel.getChildren()[2].position.y = 0), void this.onSecondaryButtonStateChangedObservable.notifyObservers(r);\n      }\n    }, r.MODEL_BASE_URL = \"https://controllers.babylonjs.com/vive/\", r.MODEL_FILENAME = \"wand.babylon\", r;\n  }(Vr.WebVRController), Vr.ViveController = Ur, zr = $a || ($a = {}), Gr = function (t) {\n    function r(e) {\n      return t.call(this, e) || this;\n    }\n\n    return T(r, t), r.prototype.initControllerMesh = function (e, t) {\n      var i = this;\n      zr.SceneLoader.ImportMesh(\"\", r.MODEL_BASE_URL, r.MODEL_FILENAME, e, function (e) {\n        i._defaultModel = e[1], i.attachToMesh(i._defaultModel), t && t(i._defaultModel);\n      });\n    }, r.prototype._handleButtonChange = function (e, t, i) {\n      console.log(\"Button id: \" + e + \"state: \"), console.dir(t);\n    }, r.MODEL_BASE_URL = \"https://controllers.babylonjs.com/generic/\", r.MODEL_FILENAME = \"generic.babylon\", r;\n  }(zr.WebVRController), zr.GenericController = Gr, kr = $a || ($a = {}), Wr = function () {\n    this.buttonMeshes = {}, this.axisMeshes = {};\n  }, Hr = function (s) {\n    function l(e) {\n      var t = s.call(this, e) || this;\n      return t._mapping = {\n        buttons: [\"thumbstick\", \"trigger\", \"grip\", \"menu\", \"trackpad\"],\n        buttonMeshNames: {\n          trigger: \"SELECT\",\n          menu: \"MENU\",\n          grip: \"GRASP\",\n          thumbstick: \"THUMBSTICK_PRESS\",\n          trackpad: \"TOUCHPAD_PRESS\"\n        },\n        buttonObservableNames: {\n          trigger: \"onTriggerStateChangedObservable\",\n          menu: \"onSecondaryButtonStateChangedObservable\",\n          grip: \"onMainButtonStateChangedObservable\",\n          thumbstick: \"onPadStateChangedObservable\",\n          trackpad: \"onTrackpadChangedObservable\"\n        },\n        axisMeshNames: [\"THUMBSTICK_X\", \"THUMBSTICK_Y\", \"TOUCHPAD_TOUCH_X\", \"TOUCHPAD_TOUCH_Y\"],\n        pointingPoseMeshName: kr.PoseEnabledController.POINTING_POSE\n      }, t.onTrackpadChangedObservable = new kr.Observable(), t.onTrackpadValuesChangedObservable = new kr.Observable(), t.trackpad = {\n        x: 0,\n        y: 0\n      }, t.controllerType = kr.PoseEnabledControllerType.WINDOWS, t._loadedMeshInfo = null, t;\n    }\n\n    return T(l, s), Object.defineProperty(l.prototype, \"onTriggerButtonStateChangedObservable\", {\n      get: function () {\n        return this.onTriggerStateChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(l.prototype, \"onMenuButtonStateChangedObservable\", {\n      get: function () {\n        return this.onSecondaryButtonStateChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(l.prototype, \"onGripButtonStateChangedObservable\", {\n      get: function () {\n        return this.onMainButtonStateChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(l.prototype, \"onThumbstickButtonStateChangedObservable\", {\n      get: function () {\n        return this.onPadStateChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(l.prototype, \"onTouchpadButtonStateChangedObservable\", {\n      get: function () {\n        return this.onTrackpadChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(l.prototype, \"onTouchpadValuesChangedObservable\", {\n      get: function () {\n        return this.onTrackpadValuesChangedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), l.prototype._updateTrackpad = function () {\n      !this.browserGamepad.axes || this.browserGamepad.axes[2] == this.trackpad.x && this.browserGamepad.axes[3] == this.trackpad.y || (this.trackpad.x = this.browserGamepad.axes[2], this.trackpad.y = this.browserGamepad.axes[3], this.onTrackpadValuesChangedObservable.notifyObservers(this.trackpad));\n    }, l.prototype.update = function () {\n      if (s.prototype.update.call(this), this.browserGamepad.axes && (this._updateTrackpad(), this._loadedMeshInfo)) for (var e = 0; e < this._mapping.axisMeshNames.length; e++) this._lerpAxisTransform(e, this.browserGamepad.axes[e]);\n    }, l.prototype._handleButtonChange = function (e, t, i) {\n      var r = this._mapping.buttons[e];\n\n      if (r) {\n        this._updateTrackpad();\n\n        var n = this[this._mapping.buttonObservableNames[r]];\n        n && n.notifyObservers(t), this._lerpButtonTransform(r, t.value);\n      }\n    }, l.prototype._lerpButtonTransform = function (e, t) {\n      if (this._loadedMeshInfo) {\n        var i = this._loadedMeshInfo.buttonMeshes[e];\n        i.unpressed.rotationQuaternion && i.pressed.rotationQuaternion && i.value.rotationQuaternion && (kr.Quaternion.SlerpToRef(i.unpressed.rotationQuaternion, i.pressed.rotationQuaternion, t, i.value.rotationQuaternion), kr.Vector3.LerpToRef(i.unpressed.position, i.pressed.position, t, i.value.position));\n      }\n    }, l.prototype._lerpAxisTransform = function (e, t) {\n      if (this._loadedMeshInfo) {\n        var i = this._loadedMeshInfo.axisMeshes[e];\n\n        if (i && i.min.rotationQuaternion && i.max.rotationQuaternion && i.value.rotationQuaternion) {\n          var r = .5 * t + .5;\n          kr.Quaternion.SlerpToRef(i.min.rotationQuaternion, i.max.rotationQuaternion, r, i.value.rotationQuaternion), kr.Vector3.LerpToRef(i.min.position, i.max.position, r, i.value.position);\n        }\n      }\n    }, l.prototype.initControllerMesh = function (t, i, r) {\n      var n,\n          o,\n          s = this;\n\n      if (void 0 === r && (r = !1), kr.SceneLoader.IsPluginForExtensionAvailable(\".glb\")) {\n        var e = \"default\";\n\n        if (this.id && !r) {\n          var a = this.id.match(l.GAMEPAD_ID_PATTERN);\n          e = a && a[0] || e;\n        }\n\n        o = \"left\" === this.hand ? l.MODEL_LEFT_FILENAME : l.MODEL_RIGHT_FILENAME, n = l.MODEL_BASE_URL + e + \"/\";\n      } else kr.Tools.Warn(\"You need to reference GLTF loader to load Windows Motion Controllers model. Falling back to generic models\"), n = kr.GenericController.MODEL_BASE_URL, o = kr.GenericController.MODEL_FILENAME;\n\n      kr.SceneLoader.ImportMesh(\"\", n, o, t, function (e) {\n        s._loadedMeshInfo = s.processModel(t, e), s._loadedMeshInfo && (s._defaultModel = s._loadedMeshInfo.rootNode, s.attachToMesh(s._defaultModel), i && i(s._defaultModel));\n      }, null, function (e, t) {\n        kr.Tools.Log(t), kr.Tools.Warn(\"Failed to retrieve controller model from the remote server: \" + n + o), r || s.initControllerMesh(e, i, !0);\n      });\n    }, l.prototype.processModel = function (e, t) {\n      for (var i = null, r = new kr.Mesh(this.id + \" \" + this.hand, e), n = null, o = 0; o < t.length; o++) {\n        var s = t[o];\n\n        if (!s.parent) {\n          s.isPickable = !1, n = s;\n          break;\n        }\n      }\n\n      return n ? (n.setParent(r), i = this.createMeshInfo(r)) : kr.Tools.Warn(\"Could not find root node in model file.\"), i;\n    }, l.prototype.createMeshInfo = function (e) {\n      var t,\n          i = new Wr();\n\n      for (i.rootNode = e, i.buttonMeshes = {}, i.axisMeshes = {}, t = 0; t < this._mapping.buttons.length; t++) {\n        var r = this._mapping.buttonMeshNames[this._mapping.buttons[t]];\n\n        if (r) {\n          var n = c(e, r);\n\n          if (n) {\n            var o = {\n              index: t,\n              value: h(n, \"VALUE\"),\n              pressed: h(n, \"PRESSED\"),\n              unpressed: h(n, \"UNPRESSED\")\n            };\n            o.value && o.pressed && o.unpressed ? i.buttonMeshes[this._mapping.buttons[t]] = o : kr.Tools.Warn(\"Missing button submesh under mesh with name: \" + r + \"(VALUE: \" + !!o.value + \", PRESSED: \" + !!o.pressed + \", UNPRESSED:\" + !!o.unpressed + \")\");\n          } else kr.Tools.Warn(\"Missing button mesh with name: \" + r);\n        } else kr.Tools.Log(\"Skipping unknown button at index: \" + t + \" with mapped name: \" + this._mapping.buttons[t]);\n      }\n\n      for (t = 0; t < this._mapping.axisMeshNames.length; t++) {\n        var s = this._mapping.axisMeshNames[t];\n\n        if (s) {\n          var a = c(e, s);\n\n          if (a) {\n            var l = {\n              index: t,\n              value: h(a, \"VALUE\"),\n              min: h(a, \"MIN\"),\n              max: h(a, \"MAX\")\n            };\n            l.value && l.min && l.max ? i.axisMeshes[t] = l : kr.Tools.Warn(\"Missing axis submesh under mesh with name: \" + s + \"(VALUE: \" + !!l.value + \", MIN: \" + !!l.min + \", MAX:\" + !!l.max + \")\");\n          } else kr.Tools.Warn(\"Missing axis mesh with name: \" + s);\n        } else kr.Tools.Log(\"Skipping unknown axis at index: \" + t);\n      }\n\n      return i.pointingPoseNode = c(e, this._mapping.pointingPoseMeshName), i.pointingPoseNode ? this._pointingPoseNode = i.pointingPoseNode : kr.Tools.Warn(\"Missing pointing pose mesh with name: \" + this._mapping.pointingPoseMeshName), i;\n\n      function c(e, t) {\n        return e.getChildMeshes(!1, function (e) {\n          return e.name === t;\n        })[0];\n      }\n\n      function h(e, t) {\n        return e.getChildMeshes(!0, function (e) {\n          return e.name == t;\n        })[0];\n      }\n    }, l.prototype.getForwardRay = function (e) {\n      if (void 0 === e && (e = 100), !this._loadedMeshInfo || !this._loadedMeshInfo.pointingPoseNode) return s.prototype.getForwardRay.call(this, e);\n\n      var t = this._loadedMeshInfo.pointingPoseNode.getWorldMatrix(),\n          i = t.getTranslation(),\n          r = new kr.Vector3(0, 0, -1),\n          n = kr.Vector3.TransformNormal(r, t),\n          o = kr.Vector3.Normalize(n);\n\n      return new kr.Ray(i, o, e);\n    }, l.prototype.dispose = function () {\n      s.prototype.dispose.call(this), this.onTrackpadChangedObservable.clear();\n    }, l.MODEL_BASE_URL = \"https://controllers.babylonjs.com/microsoft/\", l.MODEL_LEFT_FILENAME = \"left.glb\", l.MODEL_RIGHT_FILENAME = \"right.glb\", l.GAMEPAD_ID_PREFIX = \"Spatial Controller (Spatial Interaction Source) \", l.GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/, l;\n  }(kr.WebVRController), kr.WindowsMotionController = Hr, Xr = $a || ($a = {}), jr = function (i) {\n    function e(e) {\n      var t = i.call(this, e) || this;\n      return t._buttonIndexToObservableNameMap = [\"onTrackpadChangedObservable\", \"onTriggerStateChangedObservable\"], t.controllerType = Xr.PoseEnabledControllerType.GEAR_VR, t._calculatedPosition = new Xr.Vector3(\"left\" == t.hand ? -.15 : .15, -.5, .25), t._disableTrackPosition(t._calculatedPosition), t;\n    }\n\n    return T(e, i), e.prototype.initControllerMesh = function (i, r) {\n      var n = this;\n      Xr.SceneLoader.ImportMesh(\"\", e.MODEL_BASE_URL, e.MODEL_FILENAME, i, function (e) {\n        var t = new Xr.Mesh(\"\", i);\n        e[1].parent = t, e[1].position.z = -.15, n._defaultModel = t, n.attachToMesh(n._defaultModel), r && r(n._defaultModel);\n      });\n    }, e.prototype._handleButtonChange = function (e, t, i) {\n      if (e < this._buttonIndexToObservableNameMap.length) {\n        var r = this[this._buttonIndexToObservableNameMap[e]];\n        r && r.notifyObservers(t);\n      }\n    }, e.MODEL_BASE_URL = \"https://controllers.babylonjs.com/generic/\", e.MODEL_FILENAME = \"generic.babylon\", e.GAMEPAD_ID_PREFIX = \"Gear VR\", e;\n  }(Xr.WebVRController), Xr.GearVRController = jr, Yr = $a || ($a = {}), Kr = function (i) {\n    function r(e) {\n      var t = i.call(this, e) || this;\n      return t.controllerType = Yr.PoseEnabledControllerType.DAYDREAM, t;\n    }\n\n    return T(r, i), r.prototype.initControllerMesh = function (e, t) {\n      var i = this;\n      Yr.SceneLoader.ImportMesh(\"\", r.MODEL_BASE_URL, r.MODEL_FILENAME, e, function (e) {\n        i._defaultModel = e[1], i.attachToMesh(i._defaultModel), t && t(i._defaultModel);\n      });\n    }, r.prototype._handleButtonChange = function (e, t, i) {\n      if (0 === e) {\n        var r = this.onTriggerStateChangedObservable;\n        r && r.notifyObservers(t);\n      } else Yr.Tools.Warn(\"Unrecognized Daydream button index: \" + e);\n    }, r.MODEL_BASE_URL = \"https://controllers.babylonjs.com/generic/\", r.MODEL_FILENAME = \"generic.babylon\", r.GAMEPAD_ID_PREFIX = \"Daydream\", r;\n  }(Yr.WebVRController), Yr.DaydreamController = Kr, function (t) {\n    Object.defineProperty(t.Scene.prototype, \"gamepadManager\", {\n      get: function () {\n        if (!this._gamepadManager) {\n          this._gamepadManager = new t.GamepadManager(this);\n\n          var e = this._getComponent(t.SceneComponentConstants.NAME_GAMEPAD);\n\n          e || (e = new i(this), this._addComponent(e));\n        }\n\n        return this._gamepadManager;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.FreeCameraInputsManager.prototype.addGamepad = function () {\n      return this.add(new t.FreeCameraGamepadInput()), this;\n    }, t.ArcRotateCameraInputsManager.prototype.addGamepad = function () {\n      return this.add(new t.ArcRotateCameraGamepadInput()), this;\n    };\n\n    var i = function () {\n      function e(e) {\n        this.name = t.SceneComponentConstants.NAME_GAMEPAD, this.scene = e;\n      }\n\n      return e.prototype.register = function () {\n        this.scene._beforeCameraUpdateStage.registerStep(t.SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD, this, this._beforeCameraUpdate);\n      }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {\n        var e = this.scene._gamepadManager;\n        e && (e.dispose(), this.scene._gamepadManager = null);\n      }, e.prototype._beforeCameraUpdate = function () {\n        var e = this.scene._gamepadManager;\n        e && e._isMonitoring && e._checkGamepadsStatus();\n      }, e;\n    }();\n\n    t.GamepadSystemSceneComponent = i;\n  }($a || ($a = {})), function (f) {\n    f.Node.AddNodeConstructor(\"FollowCamera\", function (e, t) {\n      return function () {\n        return new i(e, f.Vector3.Zero(), t);\n      };\n    }), f.Node.AddNodeConstructor(\"ArcFollowCamera\", function (e, t) {\n      return function () {\n        return new r(e, 0, 0, 1, null, t);\n      };\n    });\n\n    var i = function (o) {\n      function e(e, t, i, r) {\n        void 0 === r && (r = null);\n        var n = o.call(this, e, t, i) || this;\n        return n.radius = 12, n.rotationOffset = 0, n.heightOffset = 4, n.cameraAcceleration = .05, n.maxCameraSpeed = 20, n.lockedTarget = r, n;\n      }\n\n      return T(e, o), e.prototype._follow = function (e) {\n        if (e) {\n          var t;\n\n          if (e.rotationQuaternion) {\n            var i = new f.Matrix();\n            e.rotationQuaternion.toRotationMatrix(i), t = Math.atan2(i.m[8], i.m[10]);\n          } else t = e.rotation.y;\n\n          var r = f.Tools.ToRadians(this.rotationOffset) + t,\n              n = e.getAbsolutePosition(),\n              o = n.x + Math.sin(r) * this.radius,\n              s = n.z + Math.cos(r) * this.radius,\n              a = o - this.position.x,\n              l = n.y + this.heightOffset - this.position.y,\n              c = s - this.position.z,\n              h = a * this.cameraAcceleration * 2,\n              u = l * this.cameraAcceleration,\n              d = c * this.cameraAcceleration * 2;\n          (h > this.maxCameraSpeed || h < -this.maxCameraSpeed) && (h = h < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed), (u > this.maxCameraSpeed || u < -this.maxCameraSpeed) && (u = u < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed), (d > this.maxCameraSpeed || d < -this.maxCameraSpeed) && (d = d < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed), this.position = new f.Vector3(this.position.x + h, this.position.y + u, this.position.z + d), this.setTarget(n);\n        }\n      }, e.prototype._checkInputs = function () {\n        o.prototype._checkInputs.call(this), this.lockedTarget && this._follow(this.lockedTarget);\n      }, e.prototype.getClassName = function () {\n        return \"FollowCamera\";\n      }, b([f.serialize()], e.prototype, \"radius\", void 0), b([f.serialize()], e.prototype, \"rotationOffset\", void 0), b([f.serialize()], e.prototype, \"heightOffset\", void 0), b([f.serialize()], e.prototype, \"cameraAcceleration\", void 0), b([f.serialize()], e.prototype, \"maxCameraSpeed\", void 0), b([f.serializeAsMeshReference(\"lockedTargetId\")], e.prototype, \"lockedTarget\", void 0), e;\n    }(f.TargetCamera);\n\n    f.FollowCamera = i;\n\n    var r = function (a) {\n      function e(e, t, i, r, n, o) {\n        var s = a.call(this, e, f.Vector3.Zero(), o) || this;\n        return s.alpha = t, s.beta = i, s.radius = r, s.target = n, s._cartesianCoordinates = f.Vector3.Zero(), s._follow(), s;\n      }\n\n      return T(e, a), e.prototype._follow = function () {\n        if (this.target) {\n          this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta), this._cartesianCoordinates.y = this.radius * Math.sin(this.beta), this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n          var e = this.target.getAbsolutePosition();\n          this.position = e.add(this._cartesianCoordinates), this.setTarget(e);\n        }\n      }, e.prototype._checkInputs = function () {\n        a.prototype._checkInputs.call(this), this._follow();\n      }, e.prototype.getClassName = function () {\n        return \"ArcFollowCamera\";\n      }, e;\n    }(f.TargetCamera);\n\n    f.ArcFollowCamera = r;\n  }($a || ($a = {})), Qr = $a || ($a = {}), Zr = function (n) {\n    function e(e, t, i) {\n      var r = n.call(this, e, t, i) || this;\n      return r.inputs.addGamepad(), r;\n    }\n\n    return T(e, n), Object.defineProperty(e.prototype, \"gamepadAngularSensibility\", {\n      get: function () {\n        var e = this.inputs.attached.gamepad;\n        return e ? e.gamepadAngularSensibility : 0;\n      },\n      set: function (e) {\n        var t = this.inputs.attached.gamepad;\n        t && (t.gamepadAngularSensibility = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"gamepadMoveSensibility\", {\n      get: function () {\n        var e = this.inputs.attached.gamepad;\n        return e ? e.gamepadMoveSensibility : 0;\n      },\n      set: function (e) {\n        var t = this.inputs.attached.gamepad;\n        t && (t.gamepadMoveSensibility = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getClassName = function () {\n      return \"UniversalCamera\";\n    }, e;\n  }(Qr.TouchCamera), Qr.UniversalCamera = Zr, function (i) {\n    i.Node.AddNodeConstructor(\"GamepadCamera\", function (e, t) {\n      return function () {\n        return new r(e, i.Vector3.Zero(), t);\n      };\n    });\n\n    var r = function (r) {\n      function e(e, t, i) {\n        return r.call(this, e, t, i) || this;\n      }\n\n      return T(e, r), e.prototype.getClassName = function () {\n        return \"GamepadCamera\";\n      }, e;\n    }(i.UniversalCamera);\n\n    i.GamepadCamera = r;\n  }($a || ($a = {})), qr = $a || ($a = {}), Jr = function () {\n    function e() {\n      this._renderPipelines = {};\n    }\n\n    return e.prototype.addPipeline = function (e) {\n      this._renderPipelines[e._name] = e;\n    }, e.prototype.attachCamerasToRenderPipeline = function (e, t, i) {\n      void 0 === i && (i = !1);\n      var r = this._renderPipelines[e];\n      r && r._attachCameras(t, i);\n    }, e.prototype.detachCamerasFromRenderPipeline = function (e, t) {\n      var i = this._renderPipelines[e];\n      i && i._detachCameras(t);\n    }, e.prototype.enableEffectInPipeline = function (e, t, i) {\n      var r = this._renderPipelines[e];\n      r && r._enableEffect(t, i);\n    }, e.prototype.disableEffectInPipeline = function (e, t, i) {\n      var r = this._renderPipelines[e];\n      r && r._disableEffect(t, i);\n    }, e.prototype.update = function () {\n      for (var e in this._renderPipelines) if (this._renderPipelines.hasOwnProperty(e)) {\n        var t = this._renderPipelines[e];\n        t.isSupported ? t._update() : (t.dispose(), delete this._renderPipelines[e]);\n      }\n    }, e.prototype._rebuild = function () {\n      for (var e in this._renderPipelines) {\n        if (this._renderPipelines.hasOwnProperty(e)) this._renderPipelines[e]._rebuild();\n      }\n    }, e.prototype.dispose = function () {\n      for (var e in this._renderPipelines) {\n        if (this._renderPipelines.hasOwnProperty(e)) this._renderPipelines[e].dispose();\n      }\n    }, e;\n  }(), qr.PostProcessRenderPipelineManager = Jr, function (t) {\n    Object.defineProperty(t.Scene.prototype, \"postProcessRenderPipelineManager\", {\n      get: function () {\n        if (!this._postProcessRenderPipelineManager) {\n          var e = this._getComponent(t.SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER);\n\n          e || (e = new i(this), this._addComponent(e)), this._postProcessRenderPipelineManager = new t.PostProcessRenderPipelineManager();\n        }\n\n        return this._postProcessRenderPipelineManager;\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n\n    var i = function () {\n      function e(e) {\n        this.name = t.SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER, this.scene = e;\n      }\n\n      return e.prototype.register = function () {\n        this.scene._gatherRenderTargetsStage.registerStep(t.SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);\n      }, e.prototype.rebuild = function () {\n        this.scene._postProcessRenderPipelineManager && this.scene._postProcessRenderPipelineManager._rebuild();\n      }, e.prototype.dispose = function () {\n        this.scene._postProcessRenderPipelineManager && this.scene._postProcessRenderPipelineManager.dispose();\n      }, e.prototype._gatherRenderTargets = function (e) {\n        this.scene._postProcessRenderPipelineManager && this.scene._postProcessRenderPipelineManager.update();\n      }, e;\n    }();\n\n    t.PostProcessRenderPipelineManagerSceneComponent = i;\n  }($a || ($a = {})), $r = $a || ($a = {}), en = function () {\n    function e(e, t, i, r) {\n      this._name = t, this._singleInstance = r || !0, this._getPostProcesses = i, this._cameras = {}, this._indicesForCamera = {}, this._postProcesses = {};\n    }\n\n    return Object.defineProperty(e.prototype, \"isSupported\", {\n      get: function () {\n        for (var e in this._postProcesses) if (this._postProcesses.hasOwnProperty(e)) for (var t = this._postProcesses[e], i = 0; i < t.length; i++) if (!t[i].isSupported) return !1;\n\n        return !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._update = function () {}, e.prototype._attachCameras = function (e) {\n      var t,\n          i = this,\n          r = $r.Tools.MakeArray(e || this._cameras);\n      if (r) for (var n = 0; n < r.length; n++) {\n        var o = r[n],\n            s = o.name;\n\n        if (t = this._singleInstance ? 0 : s, !this._postProcesses[t]) {\n          var a = this._getPostProcesses();\n\n          a && (this._postProcesses[t] = Array.isArray(a) ? a : [a]);\n        }\n\n        this._indicesForCamera[s] || (this._indicesForCamera[s] = []), this._postProcesses[t].forEach(function (e) {\n          var t = o.attachPostProcess(e);\n\n          i._indicesForCamera[s].push(t);\n        }), this._cameras[s] || (this._cameras[s] = o);\n      }\n    }, e.prototype._detachCameras = function (e) {\n      var t = $r.Tools.MakeArray(e || this._cameras);\n      if (t) for (var i = 0; i < t.length; i++) {\n        var r = t[i],\n            n = r.name;\n        this._postProcesses[this._singleInstance ? 0 : n].forEach(function (e) {\n          r.detachPostProcess(e);\n        }), this._cameras[n] && (this._cameras[n] = null);\n      }\n    }, e.prototype._enable = function (e) {\n      var t = this,\n          i = $r.Tools.MakeArray(e || this._cameras);\n      if (i) for (var r = 0; r < i.length; r++) for (var n = i[r], o = n.name, s = 0; s < this._indicesForCamera[o].length; s++) void 0 !== n._postProcesses[this._indicesForCamera[o][s]] && null !== n._postProcesses[this._indicesForCamera[o][s]] || this._postProcesses[this._singleInstance ? 0 : o].forEach(function (e) {\n        i[r].attachPostProcess(e, t._indicesForCamera[o][s]);\n      });\n    }, e.prototype._disable = function (e) {\n      var t = $r.Tools.MakeArray(e || this._cameras);\n      if (t) for (var i = 0; i < t.length; i++) {\n        var r = t[i],\n            n = r.name;\n\n        this._postProcesses[this._singleInstance ? 0 : n].forEach(function (e) {\n          r.detachPostProcess(e);\n        });\n      }\n    }, e.prototype.getPostProcesses = function (e) {\n      return this._singleInstance ? this._postProcesses[0] : e ? this._postProcesses[e.name] : null;\n    }, e;\n  }(), $r.PostProcessRenderEffect = en, tn = $a || ($a = {}), rn = function () {\n    function e(e, t) {\n      this.engine = e, this._name = t, this._renderEffects = {}, this._renderEffectsForIsolatedPass = new Array(), this._cameras = [];\n    }\n\n    return e.prototype.getClassName = function () {\n      return \"PostProcessRenderPipeline\";\n    }, Object.defineProperty(e.prototype, \"isSupported\", {\n      get: function () {\n        for (var e in this._renderEffects) if (this._renderEffects.hasOwnProperty(e) && !this._renderEffects[e].isSupported) return !1;\n\n        return !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.addEffect = function (e) {\n      this._renderEffects[e._name] = e;\n    }, e.prototype._rebuild = function () {}, e.prototype._enableEffect = function (e, t) {\n      var i = this._renderEffects[e];\n      i && i._enable(tn.Tools.MakeArray(t || this._cameras));\n    }, e.prototype._disableEffect = function (e, t) {\n      var i = this._renderEffects[e];\n      i && i._disable(tn.Tools.MakeArray(t || this._cameras));\n    }, e.prototype._attachCameras = function (e, t) {\n      var i = tn.Tools.MakeArray(e || this._cameras);\n\n      if (i) {\n        var r,\n            n = [];\n\n        for (r = 0; r < i.length; r++) {\n          var o = i[r],\n              s = o.name;\n          -1 === this._cameras.indexOf(o) ? this._cameras[s] = o : t && n.push(r);\n        }\n\n        for (r = 0; r < n.length; r++) e.splice(n[r], 1);\n\n        for (var a in this._renderEffects) this._renderEffects.hasOwnProperty(a) && this._renderEffects[a]._attachCameras(i);\n      }\n    }, e.prototype._detachCameras = function (e) {\n      var t = tn.Tools.MakeArray(e || this._cameras);\n\n      if (t) {\n        for (var i in this._renderEffects) this._renderEffects.hasOwnProperty(i) && this._renderEffects[i]._detachCameras(t);\n\n        for (var r = 0; r < t.length; r++) this._cameras.splice(this._cameras.indexOf(t[r]), 1);\n      }\n    }, e.prototype._update = function () {\n      for (var e in this._renderEffects) this._renderEffects.hasOwnProperty(e) && this._renderEffects[e]._update();\n\n      for (var t = 0; t < this._cameras.length; t++) {\n        var i = this._cameras[t].name;\n        this._renderEffectsForIsolatedPass[i] && this._renderEffectsForIsolatedPass[i]._update();\n      }\n    }, e.prototype._reset = function () {\n      this._renderEffects = {}, this._renderEffectsForIsolatedPass = new Array();\n    }, e.prototype._enableMSAAOnFirstPostProcess = function (e) {\n      var t = Object.keys(this._renderEffects);\n\n      if (2 <= this.engine.webGLVersion && 0 < t.length) {\n        var i = this._renderEffects[t[0]].getPostProcesses();\n\n        if (i) return i[0].samples = e, !0;\n      }\n\n      return !1;\n    }, e.prototype.dispose = function () {}, b([tn.serialize()], e.prototype, \"_name\", void 0), e;\n  }(), tn.PostProcessRenderPipeline = rn, nn = $a || ($a = {}), on = function () {\n    function e(e, t, i) {\n      void 0 === t && (t = nn.Engine.TEXTURETYPE_FLOAT), void 0 === i && (i = null);\n      var c = this;\n      this.useOnlyInActiveCamera = !1;\n\n      var r = (this._scene = e)._getComponent(nn.SceneComponentConstants.NAME_DEPTHRENDERER);\n\n      r || (r = new nn.DepthRendererSceneComponent(e), e._addComponent(r)), this._camera = i;\n      var o = e.getEngine();\n      this._depthMap = new nn.RenderTargetTexture(\"depthMap\", {\n        width: o.getRenderWidth(),\n        height: o.getRenderHeight()\n      }, this._scene, !1, !0, t), this._depthMap.wrapU = nn.Texture.CLAMP_ADDRESSMODE, this._depthMap.wrapV = nn.Texture.CLAMP_ADDRESSMODE, this._depthMap.refreshRate = 1, this._depthMap.renderParticles = !1, this._depthMap.renderList = null, this._depthMap.activeCamera = this._camera, this._depthMap.ignoreCameraViewport = !0, this._depthMap.useCameraPostProcesses = !1, this._depthMap.onClearObservable.add(function (e) {\n        e.clear(new nn.Color4(1, 1, 1, 1), !0, !0, !0);\n      });\n\n      var s = function (e) {\n        var t = e.getRenderingMesh(),\n            i = c._scene,\n            r = i.getEngine(),\n            n = e.getMaterial();\n\n        if (n) {\n          r.setState(n.backFaceCulling, 0, !1, i.useRightHandedSystem);\n\n          var o = t._getInstancesRenderList(e._id);\n\n          if (!o.mustReturn) {\n            var s = r.getCaps().instancedArrays && null !== o.visibleInstances[e._id],\n                a = c._camera || i.activeCamera;\n\n            if (c.isReady(e, s) && a) {\n              if (r.enableEffect(c._effect), t._bind(e, c._effect, nn.Material.TriangleFillMode), c._effect.setMatrix(\"viewProjection\", i.getTransformMatrix()), c._effect.setFloat2(\"depthValues\", a.minZ, a.minZ + a.maxZ), n && n.needAlphaTesting()) {\n                var l = n.getAlphaTestTexture();\n                l && (c._effect.setTexture(\"diffuseSampler\", l), c._effect.setMatrix(\"diffuseMatrix\", l.getTextureMatrix()));\n              }\n\n              t.useBones && t.computeBonesUsingShaders && t.skeleton && c._effect.setMatrices(\"mBones\", t.skeleton.getTransformMatrices(t)), t._processRendering(e, c._effect, nn.Material.TriangleFillMode, o, s, function (e, t) {\n                return c._effect.setMatrix(\"world\", t);\n              });\n            }\n          }\n        }\n      };\n\n      this._depthMap.customRenderFunction = function (e, t, i, r) {\n        var n;\n\n        if (r.length) {\n          for (o.setColorWrite(!1), n = 0; n < r.length; n++) s(r.data[n]);\n\n          o.setColorWrite(!0);\n        }\n\n        for (n = 0; n < e.length; n++) s(e.data[n]);\n\n        for (n = 0; n < t.length; n++) s(t.data[n]);\n      };\n    }\n\n    return e.prototype.isReady = function (e, t) {\n      var i = e.getMaterial();\n      if (i.disableDepthWrite) return !1;\n      var r = [],\n          n = [nn.VertexBuffer.PositionKind],\n          o = e.getMesh();\n      i && i.needAlphaTesting() && i.getAlphaTestTexture() && (r.push(\"#define ALPHATEST\"), o.isVerticesDataPresent(nn.VertexBuffer.UVKind) && (n.push(nn.VertexBuffer.UVKind), r.push(\"#define UV1\")), o.isVerticesDataPresent(nn.VertexBuffer.UV2Kind) && (n.push(nn.VertexBuffer.UV2Kind), r.push(\"#define UV2\"))), o.useBones && o.computeBonesUsingShaders ? (n.push(nn.VertexBuffer.MatricesIndicesKind), n.push(nn.VertexBuffer.MatricesWeightsKind), 4 < o.numBoneInfluencers && (n.push(nn.VertexBuffer.MatricesIndicesExtraKind), n.push(nn.VertexBuffer.MatricesWeightsExtraKind)), r.push(\"#define NUM_BONE_INFLUENCERS \" + o.numBoneInfluencers), r.push(\"#define BonesPerMesh \" + (o.skeleton ? o.skeleton.bones.length + 1 : 0))) : r.push(\"#define NUM_BONE_INFLUENCERS 0\"), t && (r.push(\"#define INSTANCES\"), n.push(\"world0\"), n.push(\"world1\"), n.push(\"world2\"), n.push(\"world3\"));\n      var s = r.join(\"\\n\");\n      return this._cachedDefines !== s && (this._cachedDefines = s, this._effect = this._scene.getEngine().createEffect(\"depth\", n, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"depthValues\"], [\"diffuseSampler\"], s)), this._effect.isReady();\n    }, e.prototype.getDepthMap = function () {\n      return this._depthMap;\n    }, e.prototype.dispose = function () {\n      this._depthMap.dispose();\n    }, e;\n  }(), nn.DepthRenderer = on, function (i) {\n    i.Scene.prototype.enableDepthRenderer = function (e) {\n      if (!(e = e || this.activeCamera)) throw \"No camera available to enable depth renderer\";\n\n      if (this._depthRenderer || (this._depthRenderer = {}), !this._depthRenderer[e.id]) {\n        var t = 0;\n        if (this.getEngine().getCaps().textureHalfFloatRender) t = i.Engine.TEXTURETYPE_HALF_FLOAT;else {\n          if (!this.getEngine().getCaps().textureFloatRender) throw \"Depth renderer does not support int texture type\";\n          t = i.Engine.TEXTURETYPE_FLOAT;\n        }\n        this._depthRenderer[e.id] = new i.DepthRenderer(this, t, e);\n      }\n\n      return this._depthRenderer[e.id];\n    }, i.Scene.prototype.disableDepthRenderer = function (e) {\n      (e = e || this.activeCamera) && this._depthRenderer && this._depthRenderer[e.id] && (this._depthRenderer[e.id].dispose(), delete this._depthRenderer[e.id]);\n    };\n\n    var e = function () {\n      function e(e) {\n        this.name = i.SceneComponentConstants.NAME_DEPTHRENDERER, this.scene = e;\n      }\n\n      return e.prototype.register = function () {\n        this.scene._gatherRenderTargetsStage.registerStep(i.SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets), this.scene._gatherActiveCameraRenderTargetsStage.registerStep(i.SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER, this, this._gatherActiveCameraRenderTargets);\n      }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {\n        for (var e in this.scene._depthRenderer) this.scene._depthRenderer[e].dispose();\n      }, e.prototype._gatherRenderTargets = function (e) {\n        if (this.scene._depthRenderer) for (var t in this.scene._depthRenderer) {\n          var i = this.scene._depthRenderer[t];\n          i.useOnlyInActiveCamera || e.push(i.getDepthMap());\n        }\n      }, e.prototype._gatherActiveCameraRenderTargets = function (e) {\n        if (this.scene._depthRenderer) for (var t in this.scene._depthRenderer) {\n          var i = this.scene._depthRenderer[t];\n          i.useOnlyInActiveCamera && this.scene.activeCamera.id === t && e.push(i.getDepthMap());\n        }\n      }, e;\n    }();\n\n    i.DepthRendererSceneComponent = e;\n  }($a || ($a = {})), sn = $a || ($a = {}), an = function () {\n    function e(e, t) {\n      void 0 === t && (t = 1), this._enablePosition = !1, this._scene = e, this._ratio = t;\n\n      var i = e._getComponent(sn.SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);\n\n      i || (i = new sn.GeometryBufferRendererSceneComponent(e), e._addComponent(i)), this._createRenderTargets();\n    }\n\n    return Object.defineProperty(e.prototype, \"renderList\", {\n      set: function (e) {\n        this._multiRenderTarget.renderList = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"isSupported\", {\n      get: function () {\n        return this._multiRenderTarget.isSupported;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"enablePosition\", {\n      get: function () {\n        return this._enablePosition;\n      },\n      set: function (e) {\n        this._enablePosition = e, this.dispose(), this._createRenderTargets();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"scene\", {\n      get: function () {\n        return this._scene;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"ratio\", {\n      get: function () {\n        return this._ratio;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.isReady = function (e, t) {\n      var i = e.getMaterial();\n      if (i && i.disableDepthWrite) return !1;\n      var r = [],\n          n = [sn.VertexBuffer.PositionKind, sn.VertexBuffer.NormalKind],\n          o = e.getMesh();\n      i && i.needAlphaTesting() && (r.push(\"#define ALPHATEST\"), o.isVerticesDataPresent(sn.VertexBuffer.UVKind) && (n.push(sn.VertexBuffer.UVKind), r.push(\"#define UV1\")), o.isVerticesDataPresent(sn.VertexBuffer.UV2Kind) && (n.push(sn.VertexBuffer.UV2Kind), r.push(\"#define UV2\"))), this._enablePosition && r.push(\"#define POSITION\"), o.useBones && o.computeBonesUsingShaders ? (n.push(sn.VertexBuffer.MatricesIndicesKind), n.push(sn.VertexBuffer.MatricesWeightsKind), 4 < o.numBoneInfluencers && (n.push(sn.VertexBuffer.MatricesIndicesExtraKind), n.push(sn.VertexBuffer.MatricesWeightsExtraKind)), r.push(\"#define NUM_BONE_INFLUENCERS \" + o.numBoneInfluencers), r.push(\"#define BonesPerMesh \" + (o.skeleton ? o.skeleton.bones.length + 1 : 0))) : r.push(\"#define NUM_BONE_INFLUENCERS 0\"), t && (r.push(\"#define INSTANCES\"), n.push(\"world0\"), n.push(\"world1\"), n.push(\"world2\"), n.push(\"world3\"));\n      var s = r.join(\"\\n\");\n      return this._cachedDefines !== s && (this._cachedDefines = s, this._effect = this._scene.getEngine().createEffect(\"geometry\", n, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"view\"], [\"diffuseSampler\"], s, void 0, void 0, void 0, {\n        buffersCount: this._enablePosition ? 3 : 2\n      })), this._effect.isReady();\n    }, e.prototype.getGBuffer = function () {\n      return this._multiRenderTarget;\n    }, Object.defineProperty(e.prototype, \"samples\", {\n      get: function () {\n        return this._multiRenderTarget.samples;\n      },\n      set: function (e) {\n        this._multiRenderTarget.samples = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function () {\n      this.getGBuffer().dispose();\n    }, e.prototype._createRenderTargets = function () {\n      var l = this,\n          o = this._scene.getEngine(),\n          e = this._enablePosition ? 3 : 2;\n\n      if (this._multiRenderTarget = new sn.MultiRenderTarget(\"gBuffer\", {\n        width: o.getRenderWidth() * this._ratio,\n        height: o.getRenderHeight() * this._ratio\n      }, e, this._scene, {\n        generateMipMaps: !1,\n        generateDepthTexture: !0,\n        defaultType: sn.Engine.TEXTURETYPE_FLOAT\n      }), this.isSupported) {\n        this._multiRenderTarget.wrapU = sn.Texture.CLAMP_ADDRESSMODE, this._multiRenderTarget.wrapV = sn.Texture.CLAMP_ADDRESSMODE, this._multiRenderTarget.refreshRate = 1, this._multiRenderTarget.renderParticles = !1, this._multiRenderTarget.renderList = null, this._multiRenderTarget.onClearObservable.add(function (e) {\n          e.clear(new sn.Color4(0, 0, 0, 1), !0, !0, !0);\n        });\n\n        var s = function (e) {\n          var t = e.getRenderingMesh(),\n              i = l._scene,\n              r = i.getEngine(),\n              n = e.getMaterial();\n\n          if (n) {\n            r.setState(n.backFaceCulling, 0, !1, i.useRightHandedSystem);\n\n            var o = t._getInstancesRenderList(e._id);\n\n            if (!o.mustReturn) {\n              var s = r.getCaps().instancedArrays && null !== o.visibleInstances[e._id];\n\n              if (l.isReady(e, s)) {\n                if (r.enableEffect(l._effect), t._bind(e, l._effect, sn.Material.TriangleFillMode), l._effect.setMatrix(\"viewProjection\", i.getTransformMatrix()), l._effect.setMatrix(\"view\", i.getViewMatrix()), n && n.needAlphaTesting()) {\n                  var a = n.getAlphaTestTexture();\n                  a && (l._effect.setTexture(\"diffuseSampler\", a), l._effect.setMatrix(\"diffuseMatrix\", a.getTextureMatrix()));\n                }\n\n                t.useBones && t.computeBonesUsingShaders && t.skeleton && l._effect.setMatrices(\"mBones\", t.skeleton.getTransformMatrices(t)), t._processRendering(e, l._effect, sn.Material.TriangleFillMode, o, s, function (e, t) {\n                  return l._effect.setMatrix(\"world\", t);\n                });\n              }\n            }\n          }\n        };\n\n        this._multiRenderTarget.customRenderFunction = function (e, t, i, r) {\n          var n;\n\n          if (r.length) {\n            for (o.setColorWrite(!1), n = 0; n < r.length; n++) s(r.data[n]);\n\n            o.setColorWrite(!0);\n          }\n\n          for (n = 0; n < e.length; n++) s(e.data[n]);\n\n          for (n = 0; n < t.length; n++) s(t.data[n]);\n        };\n      }\n    }, e;\n  }(), sn.GeometryBufferRenderer = an, function (t) {\n    Object.defineProperty(t.Scene.prototype, \"geometryBufferRenderer\", {\n      get: function () {\n        this._geometryBufferRenderer;\n      },\n      set: function (e) {\n        e && e.isSupported && (this._geometryBufferRenderer = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.Scene.prototype.enableGeometryBufferRenderer = function (e) {\n      return void 0 === e && (e = 1), this._geometryBufferRenderer || (this._geometryBufferRenderer = new t.GeometryBufferRenderer(this, e), this._geometryBufferRenderer.isSupported || (this._geometryBufferRenderer = null)), this._geometryBufferRenderer;\n    }, t.Scene.prototype.disableGeometryBufferRenderer = function () {\n      this._geometryBufferRenderer && (this._geometryBufferRenderer.dispose(), this._geometryBufferRenderer = null);\n    };\n\n    var e = function () {\n      function e(e) {\n        this.name = t.SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER, this.scene = e;\n      }\n\n      return e.prototype.register = function () {\n        this.scene._gatherRenderTargetsStage.registerStep(t.SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);\n      }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {}, e.prototype._gatherRenderTargets = function (e) {\n        this.scene._geometryBufferRenderer && e.push(this.scene._geometryBufferRenderer.getGBuffer());\n      }, e;\n    }();\n\n    t.GeometryBufferRendererSceneComponent = e;\n  }($a || ($a = {})), ln = $a || ($a = {}), cn = function (a) {\n    function e(e, t, i, r) {\n      var n = a.call(this, t.getEngine(), e) || this;\n      n.SSAOOriginalSceneColorEffect = \"SSAOOriginalSceneColorEffect\", n.SSAORenderEffect = \"SSAORenderEffect\", n.SSAOBlurHRenderEffect = \"SSAOBlurHRenderEffect\", n.SSAOBlurVRenderEffect = \"SSAOBlurVRenderEffect\", n.SSAOCombineRenderEffect = \"SSAOCombineRenderEffect\", n.totalStrength = 1, n.radius = 1e-4, n.area = .0075, n.fallOff = 1e-6, n.base = .5, n._firstUpdate = !0, n._scene = t, n._createRandomTexture(), n._depthTexture = t.enableDepthRenderer().getDepthMap();\n      var o = i.ssaoRatio || i,\n          s = i.combineRatio || i;\n      return n._originalColorPostProcess = new ln.PassPostProcess(\"SSAOOriginalSceneColor\", s, null, ln.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), !1), n._createSSAOPostProcess(o), n._createBlurPostProcess(o), n._createSSAOCombinePostProcess(s), n.addEffect(new ln.PostProcessRenderEffect(t.getEngine(), n.SSAOOriginalSceneColorEffect, function () {\n        return n._originalColorPostProcess;\n      }, !0)), n.addEffect(new ln.PostProcessRenderEffect(t.getEngine(), n.SSAORenderEffect, function () {\n        return n._ssaoPostProcess;\n      }, !0)), n.addEffect(new ln.PostProcessRenderEffect(t.getEngine(), n.SSAOBlurHRenderEffect, function () {\n        return n._blurHPostProcess;\n      }, !0)), n.addEffect(new ln.PostProcessRenderEffect(t.getEngine(), n.SSAOBlurVRenderEffect, function () {\n        return n._blurVPostProcess;\n      }, !0)), n.addEffect(new ln.PostProcessRenderEffect(t.getEngine(), n.SSAOCombineRenderEffect, function () {\n        return n._ssaoCombinePostProcess;\n      }, !0)), t.postProcessRenderPipelineManager.addPipeline(n), r && t.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(e, r), n;\n    }\n\n    return T(e, a), e.prototype.dispose = function (e) {\n      void 0 === e && (e = !1);\n\n      for (var t = 0; t < this._scene.cameras.length; t++) {\n        var i = this._scene.cameras[t];\n        this._originalColorPostProcess.dispose(i), this._ssaoPostProcess.dispose(i), this._blurHPostProcess.dispose(i), this._blurVPostProcess.dispose(i), this._ssaoCombinePostProcess.dispose(i);\n      }\n\n      this._randomTexture.dispose(), e && this._scene.disableDepthRenderer(), this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras), a.prototype.dispose.call(this);\n    }, e.prototype._createBlurPostProcess = function (e) {\n      var t = this;\n      this._blurHPostProcess = new ln.BlurPostProcess(\"BlurH\", new ln.Vector2(1, 0), 16, e, null, ln.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, ln.Engine.TEXTURETYPE_UNSIGNED_INT), this._blurVPostProcess = new ln.BlurPostProcess(\"BlurV\", new ln.Vector2(0, 1), 16, e, null, ln.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, ln.Engine.TEXTURETYPE_UNSIGNED_INT), this._blurHPostProcess.onActivateObservable.add(function () {\n        var e = t._blurHPostProcess.width / t._scene.getEngine().getRenderWidth();\n\n        t._blurHPostProcess.kernel = 16 * e;\n      }), this._blurVPostProcess.onActivateObservable.add(function () {\n        var e = t._blurVPostProcess.height / t._scene.getEngine().getRenderHeight();\n\n        t._blurVPostProcess.kernel = 16 * e;\n      });\n    }, e.prototype._rebuild = function () {\n      this._firstUpdate = !0, a.prototype._rebuild.call(this);\n    }, e.prototype._createSSAOPostProcess = function (e) {\n      var t = this,\n          i = [.5381, .1856, -.4319, .1379, .2486, .443, .3371, .5679, -.0057, -.6999, -.0451, -.0019, .0689, -.1598, -.8547, .056, .0069, -.1843, -.0146, .1402, .0762, .01, -.1924, -.0344, -.3577, -.5301, -.4358, -.3169, .1063, .0158, .0103, -.5869, .0046, -.0897, -.494, .3287, .7119, -.0154, -.0918, -.0533, .0596, -.5411, .0352, -.0631, .546, -.4776, .2847, -.0271];\n      this._ssaoPostProcess = new ln.PostProcess(\"ssao\", \"ssao\", [\"sampleSphere\", \"samplesFactor\", \"randTextureTiles\", \"totalStrength\", \"radius\", \"area\", \"fallOff\", \"base\", \"range\", \"viewport\"], [\"randomSampler\"], e, null, ln.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, \"#define SAMPLES 16\\n#define SSAO\"), this._ssaoPostProcess.onApply = function (e) {\n        t._firstUpdate && (e.setArray3(\"sampleSphere\", i), e.setFloat(\"samplesFactor\", 1 / 16), e.setFloat(\"randTextureTiles\", 4)), e.setFloat(\"totalStrength\", t.totalStrength), e.setFloat(\"radius\", t.radius), e.setFloat(\"area\", t.area), e.setFloat(\"fallOff\", t.fallOff), e.setFloat(\"base\", t.base), e.setTexture(\"textureSampler\", t._depthTexture), e.setTexture(\"randomSampler\", t._randomTexture);\n      };\n    }, e.prototype._createSSAOCombinePostProcess = function (e) {\n      var t = this;\n      this._ssaoCombinePostProcess = new ln.PostProcess(\"ssaoCombine\", \"ssaoCombine\", [], [\"originalColor\", \"viewport\"], e, null, ln.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1), this._ssaoCombinePostProcess.onApply = function (e) {\n        e.setVector4(\"viewport\", ln.Tmp.Vector4[0].copyFromFloats(0, 0, 1, 1)), e.setTextureFromPostProcess(\"originalColor\", t._originalColorPostProcess);\n      };\n    }, e.prototype._createRandomTexture = function () {\n      this._randomTexture = new ln.DynamicTexture(\"SSAORandomTexture\", 512, this._scene, !1, ln.Texture.TRILINEAR_SAMPLINGMODE), this._randomTexture.wrapU = ln.Texture.WRAP_ADDRESSMODE, this._randomTexture.wrapV = ln.Texture.WRAP_ADDRESSMODE;\n\n      for (var e = this._randomTexture.getContext(), t = function (e, t) {\n        return Math.random() * (t - e) + e;\n      }, i = ln.Vector3.Zero(), r = 0; r < 512; r++) for (var n = 0; n < 512; n++) i.x = Math.floor(255 * t(-1, 1)), i.y = Math.floor(255 * t(-1, 1)), i.z = Math.floor(255 * t(-1, 1)), e.fillStyle = \"rgb(\" + i.x + \", \" + i.y + \", \" + i.z + \")\", e.fillRect(r, n, 1, 1);\n\n      this._randomTexture.update(!1);\n    }, b([ln.serialize()], e.prototype, \"totalStrength\", void 0), b([ln.serialize()], e.prototype, \"radius\", void 0), b([ln.serialize()], e.prototype, \"area\", void 0), b([ln.serialize()], e.prototype, \"fallOff\", void 0), b([ln.serialize()], e.prototype, \"base\", void 0), e;\n  }(ln.PostProcessRenderPipeline), ln.SSAORenderingPipeline = cn, hn = $a || ($a = {}), un = function (l) {\n    function r(e, t, i, r) {\n      var n = l.call(this, t.getEngine(), e) || this;\n      if (n.SSAOOriginalSceneColorEffect = \"SSAOOriginalSceneColorEffect\", n.SSAORenderEffect = \"SSAORenderEffect\", n.SSAOBlurHRenderEffect = \"SSAOBlurHRenderEffect\", n.SSAOBlurVRenderEffect = \"SSAOBlurVRenderEffect\", n.SSAOCombineRenderEffect = \"SSAOCombineRenderEffect\", n.totalStrength = 1, n.maxZ = 100, n.minZAspect = .2, n._samples = 8, n._textureSamples = 1, n._expensiveBlur = !0, n.radius = 2, n.base = 0, n._firstUpdate = !0, n._bits = new Uint32Array(1), n._scene = t, n._ratio = i, !n.isSupported) return hn.Tools.Error(\"SSAO 2 needs WebGL 2 support.\"), n;\n      var o = n._ratio.ssaoRatio || i,\n          s = n._ratio.blurRatio || i,\n          a = t.enableGeometryBufferRenderer();\n      return n._createRandomTexture(), n._depthTexture = a.getGBuffer().textures[0], n._normalTexture = a.getGBuffer().textures[1], n._originalColorPostProcess = new hn.PassPostProcess(\"SSAOOriginalSceneColor\", 1, null, hn.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), !1), n._originalColorPostProcess.samples = n.textureSamples, n._createSSAOPostProcess(1), n._createBlurPostProcess(o, s), n._createSSAOCombinePostProcess(s), n.addEffect(new hn.PostProcessRenderEffect(t.getEngine(), n.SSAOOriginalSceneColorEffect, function () {\n        return n._originalColorPostProcess;\n      }, !0)), n.addEffect(new hn.PostProcessRenderEffect(t.getEngine(), n.SSAORenderEffect, function () {\n        return n._ssaoPostProcess;\n      }, !0)), n.addEffect(new hn.PostProcessRenderEffect(t.getEngine(), n.SSAOBlurHRenderEffect, function () {\n        return n._blurHPostProcess;\n      }, !0)), n.addEffect(new hn.PostProcessRenderEffect(t.getEngine(), n.SSAOBlurVRenderEffect, function () {\n        return n._blurVPostProcess;\n      }, !0)), n.addEffect(new hn.PostProcessRenderEffect(t.getEngine(), n.SSAOCombineRenderEffect, function () {\n        return n._ssaoCombinePostProcess;\n      }, !0)), t.postProcessRenderPipelineManager.addPipeline(n), r && t.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(e, r), n;\n    }\n\n    return T(r, l), Object.defineProperty(r.prototype, \"samples\", {\n      get: function () {\n        return this._samples;\n      },\n      set: function (e) {\n        this._ssaoPostProcess.updateEffect(\"#define SAMPLES \" + e + \"\\n#define SSAO\"), this._samples = e, this._sampleSphere = this._generateHemisphere(), this._firstUpdate = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"textureSamples\", {\n      get: function () {\n        return this._textureSamples;\n      },\n      set: function (e) {\n        this._textureSamples = e, this._originalColorPostProcess.samples = e, this._blurHPostProcess.samples = e, this._blurVPostProcess.samples = e, this._ssaoPostProcess.samples = e, this._ssaoCombinePostProcess.samples = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"expensiveBlur\", {\n      get: function () {\n        return this._expensiveBlur;\n      },\n      set: function (e) {\n        this._blurHPostProcess.updateEffect(\"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_H\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (e ? \"1\" : \"0\") + \"\\n\", null, [\"textureSampler\", \"depthSampler\"]), this._blurVPostProcess.updateEffect(\"#define BILATERAL_BLUR\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (e ? \"1\" : \"0\") + \"\\n\", null, [\"textureSampler\", \"depthSampler\"]), this._expensiveBlur = e, this._firstUpdate = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r, \"IsSupported\", {\n      get: function () {\n        var e = hn.Engine.LastCreatedEngine;\n        return !!e && e.getCaps().drawBuffersExtension;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype.dispose = function (e) {\n      void 0 === e && (e = !1);\n\n      for (var t = 0; t < this._scene.cameras.length; t++) {\n        var i = this._scene.cameras[t];\n        this._originalColorPostProcess.dispose(i), this._ssaoPostProcess.dispose(i), this._blurHPostProcess.dispose(i), this._blurVPostProcess.dispose(i), this._ssaoCombinePostProcess.dispose(i);\n      }\n\n      this._randomTexture.dispose(), e && this._scene.disableGeometryBufferRenderer(), this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras), l.prototype.dispose.call(this);\n    }, r.prototype._createBlurPostProcess = function (e, t) {\n      var i = this;\n      this._samplerOffsets = [];\n\n      for (var r = this.expensiveBlur, n = -8; n < 8; n++) this._samplerOffsets.push(2 * n + .5);\n\n      this._blurHPostProcess = new hn.PostProcess(\"BlurH\", \"ssao2\", [\"outSize\", \"samplerOffsets\", \"near\", \"far\", \"radius\"], [\"depthSampler\"], e, null, hn.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, \"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_H\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (r ? \"1\" : \"0\") + \"\\n\"), this._blurHPostProcess.onApply = function (e) {\n        i._scene.activeCamera && (e.setFloat(\"outSize\", 0 < i._ssaoCombinePostProcess.width ? i._ssaoCombinePostProcess.width : i._originalColorPostProcess.width), e.setFloat(\"near\", i._scene.activeCamera.minZ), e.setFloat(\"far\", i._scene.activeCamera.maxZ), e.setFloat(\"radius\", i.radius), e.setTexture(\"depthSampler\", i._depthTexture), i._firstUpdate && e.setArray(\"samplerOffsets\", i._samplerOffsets));\n      }, this._blurVPostProcess = new hn.PostProcess(\"BlurV\", \"ssao2\", [\"outSize\", \"samplerOffsets\", \"near\", \"far\", \"radius\"], [\"depthSampler\"], t, null, hn.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, \"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_V\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (r ? \"1\" : \"0\") + \"\\n\"), this._blurVPostProcess.onApply = function (e) {\n        i._scene.activeCamera && (e.setFloat(\"outSize\", 0 < i._ssaoCombinePostProcess.height ? i._ssaoCombinePostProcess.height : i._originalColorPostProcess.height), e.setFloat(\"near\", i._scene.activeCamera.minZ), e.setFloat(\"far\", i._scene.activeCamera.maxZ), e.setFloat(\"radius\", i.radius), e.setTexture(\"depthSampler\", i._depthTexture), i._firstUpdate && (e.setArray(\"samplerOffsets\", i._samplerOffsets), i._firstUpdate = !1));\n      }, this._blurHPostProcess.samples = this.textureSamples, this._blurVPostProcess.samples = this.textureSamples;\n    }, r.prototype._rebuild = function () {\n      this._firstUpdate = !0, l.prototype._rebuild.call(this);\n    }, r.prototype._radicalInverse_VdC = function (e) {\n      return this._bits[0] = e, this._bits[0] = (this._bits[0] << 16 | this._bits[0] >> 16) >>> 0, this._bits[0] = (1431655765 & this._bits[0]) << 1 | (2863311530 & this._bits[0]) >>> 1 >>> 0, this._bits[0] = (858993459 & this._bits[0]) << 2 | (3435973836 & this._bits[0]) >>> 2 >>> 0, this._bits[0] = (252645135 & this._bits[0]) << 4 | (4042322160 & this._bits[0]) >>> 4 >>> 0, this._bits[0] = (16711935 & this._bits[0]) << 8 | (4278255360 & this._bits[0]) >>> 8 >>> 0, 2.3283064365386963e-10 * this._bits[0];\n    }, r.prototype._hammersley = function (e, t) {\n      return [e / t, this._radicalInverse_VdC(e)];\n    }, r.prototype._hemisphereSample_uniform = function (e, t) {\n      var i = 2 * t * Math.PI,\n          r = 1 - (.85 * e + .15),\n          n = Math.sqrt(1 - r * r);\n      return new hn.Vector3(Math.cos(i) * n, Math.sin(i) * n, r);\n    }, r.prototype._generateHemisphere = function () {\n      for (var e, t = this.samples, i = [], r = 0; r < t;) {\n        if (t < 16) e = this._hemisphereSample_uniform(Math.random(), Math.random());else {\n          var n = this._hammersley(r, t);\n\n          e = this._hemisphereSample_uniform(n[0], n[1]);\n        }\n        i.push(e.x, e.y, e.z), r++;\n      }\n\n      return i;\n    }, r.prototype._createSSAOPostProcess = function (e) {\n      var t = this,\n          i = this.samples;\n      this._sampleSphere = this._generateHemisphere(), this._ssaoPostProcess = new hn.PostProcess(\"ssao2\", \"ssao2\", [\"sampleSphere\", \"samplesFactor\", \"randTextureTiles\", \"totalStrength\", \"radius\", \"base\", \"range\", \"projection\", \"near\", \"far\", \"texelSize\", \"xViewport\", \"yViewport\", \"maxZ\", \"minZAspect\"], [\"randomSampler\", \"normalSampler\"], e, null, hn.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, \"#define SAMPLES \" + i + \"\\n#define SSAO\"), this._ssaoPostProcess.onApply = function (e) {\n        t._firstUpdate && (e.setArray3(\"sampleSphere\", t._sampleSphere), e.setFloat(\"randTextureTiles\", 32)), t._scene.activeCamera && (e.setFloat(\"samplesFactor\", 1 / t.samples), e.setFloat(\"totalStrength\", t.totalStrength), e.setFloat2(\"texelSize\", 1 / t._ssaoPostProcess.width, 1 / t._ssaoPostProcess.height), e.setFloat(\"radius\", t.radius), e.setFloat(\"maxZ\", t.maxZ), e.setFloat(\"minZAspect\", t.minZAspect), e.setFloat(\"base\", t.base), e.setFloat(\"near\", t._scene.activeCamera.minZ), e.setFloat(\"far\", t._scene.activeCamera.maxZ), e.setFloat(\"xViewport\", Math.tan(t._scene.activeCamera.fov / 2) * t._scene.getEngine().getAspectRatio(t._scene.activeCamera, !0)), e.setFloat(\"yViewport\", Math.tan(t._scene.activeCamera.fov / 2)), e.setMatrix(\"projection\", t._scene.getProjectionMatrix()), e.setTexture(\"textureSampler\", t._depthTexture), e.setTexture(\"normalSampler\", t._normalTexture), e.setTexture(\"randomSampler\", t._randomTexture));\n      }, this._ssaoPostProcess.samples = this.textureSamples;\n    }, r.prototype._createSSAOCombinePostProcess = function (e) {\n      var i = this;\n      this._ssaoCombinePostProcess = new hn.PostProcess(\"ssaoCombine\", \"ssaoCombine\", [], [\"originalColor\", \"viewport\"], e, null, hn.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1), this._ssaoCombinePostProcess.onApply = function (e) {\n        var t = i._scene.activeCamera.viewport;\n        e.setVector4(\"viewport\", hn.Tmp.Vector4[0].copyFromFloats(t.x, t.y, t.width, t.height)), e.setTextureFromPostProcess(\"originalColor\", i._originalColorPostProcess);\n      }, this._ssaoCombinePostProcess.samples = this.textureSamples;\n    }, r.prototype._createRandomTexture = function () {\n      this._randomTexture = new hn.DynamicTexture(\"SSAORandomTexture\", 128, this._scene, !1, hn.Texture.TRILINEAR_SAMPLINGMODE), this._randomTexture.wrapU = hn.Texture.WRAP_ADDRESSMODE, this._randomTexture.wrapV = hn.Texture.WRAP_ADDRESSMODE;\n\n      for (var e = this._randomTexture.getContext(), t = function (e, t) {\n        return Math.random() * (t - e) + e;\n      }, i = hn.Vector3.Zero(), r = 0; r < 128; r++) for (var n = 0; n < 128; n++) i.x = t(0, 1), i.y = t(0, 1), i.z = 0, i.normalize(), i.scaleInPlace(255), i.x = Math.floor(i.x), i.y = Math.floor(i.y), e.fillStyle = \"rgb(\" + i.x + \", \" + i.y + \", \" + i.z + \")\", e.fillRect(r, n, 1, 1);\n\n      this._randomTexture.update(!1);\n    }, r.prototype.serialize = function () {\n      var e = hn.SerializationHelper.Serialize(this);\n      return e.customType = \"SSAO2RenderingPipeline\", e;\n    }, r.Parse = function (e, t, i) {\n      return hn.SerializationHelper.Parse(function () {\n        return new r(e._name, t, e._ratio);\n      }, e, t, i);\n    }, b([hn.serialize()], r.prototype, \"totalStrength\", void 0), b([hn.serialize()], r.prototype, \"maxZ\", void 0), b([hn.serialize()], r.prototype, \"minZAspect\", void 0), b([hn.serialize(\"samples\")], r.prototype, \"_samples\", void 0), b([hn.serialize(\"textureSamples\")], r.prototype, \"_textureSamples\", void 0), b([hn.serialize()], r.prototype, \"_ratio\", void 0), b([hn.serialize(\"expensiveBlur\")], r.prototype, \"_expensiveBlur\", void 0), b([hn.serialize()], r.prototype, \"radius\", void 0), b([hn.serialize()], r.prototype, \"base\", void 0), r;\n  }(hn.PostProcessRenderPipeline), hn.SSAO2RenderingPipeline = un, dn = $a || ($a = {}), fn = function (s) {\n    function e(e, t, i, r, n) {\n      void 0 === r && (r = 1);\n      var o = s.call(this, i.getEngine(), e) || this;\n      return o.LensChromaticAberrationEffect = \"LensChromaticAberrationEffect\", o.HighlightsEnhancingEffect = \"HighlightsEnhancingEffect\", o.LensDepthOfFieldEffect = \"LensDepthOfFieldEffect\", o._scene = i, o._depthTexture = i.enableDepthRenderer().getDepthMap(), t.grain_texture ? o._grainTexture = t.grain_texture : o._createGrainTexture(), o._edgeBlur = t.edge_blur ? t.edge_blur : 0, o._grainAmount = t.grain_amount ? t.grain_amount : 0, o._chromaticAberration = t.chromatic_aberration ? t.chromatic_aberration : 0, o._distortion = t.distortion ? t.distortion : 0, o._highlightsGain = void 0 !== t.dof_gain ? t.dof_gain : -1, o._highlightsThreshold = t.dof_threshold ? t.dof_threshold : 1, o._dofDistance = void 0 !== t.dof_focus_distance ? t.dof_focus_distance : -1, o._dofAperture = t.dof_aperture ? t.dof_aperture : 1, o._dofDarken = t.dof_darken ? t.dof_darken : 0, o._dofPentagon = void 0 === t.dof_pentagon || t.dof_pentagon, o._blurNoise = void 0 === t.blur_noise || t.blur_noise, o._createChromaticAberrationPostProcess(r), o._createHighlightsPostProcess(r), o._createDepthOfFieldPostProcess(r / 4), o.addEffect(new dn.PostProcessRenderEffect(i.getEngine(), o.LensChromaticAberrationEffect, function () {\n        return o._chromaticAberrationPostProcess;\n      }, !0)), o.addEffect(new dn.PostProcessRenderEffect(i.getEngine(), o.HighlightsEnhancingEffect, function () {\n        return o._highlightsPostProcess;\n      }, !0)), o.addEffect(new dn.PostProcessRenderEffect(i.getEngine(), o.LensDepthOfFieldEffect, function () {\n        return o._depthOfFieldPostProcess;\n      }, !0)), -1 === o._highlightsGain && o._disableEffect(o.HighlightsEnhancingEffect, null), i.postProcessRenderPipelineManager.addPipeline(o), n && i.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(e, n), o;\n    }\n\n    return T(e, s), e.prototype.setEdgeBlur = function (e) {\n      this._edgeBlur = e;\n    }, e.prototype.disableEdgeBlur = function () {\n      this._edgeBlur = 0;\n    }, e.prototype.setGrainAmount = function (e) {\n      this._grainAmount = e;\n    }, e.prototype.disableGrain = function () {\n      this._grainAmount = 0;\n    }, e.prototype.setChromaticAberration = function (e) {\n      this._chromaticAberration = e;\n    }, e.prototype.disableChromaticAberration = function () {\n      this._chromaticAberration = 0;\n    }, e.prototype.setEdgeDistortion = function (e) {\n      this._distortion = e;\n    }, e.prototype.disableEdgeDistortion = function () {\n      this._distortion = 0;\n    }, e.prototype.setFocusDistance = function (e) {\n      this._dofDistance = e;\n    }, e.prototype.disableDepthOfField = function () {\n      this._dofDistance = -1;\n    }, e.prototype.setAperture = function (e) {\n      this._dofAperture = e;\n    }, e.prototype.setDarkenOutOfFocus = function (e) {\n      this._dofDarken = e;\n    }, e.prototype.enablePentagonBokeh = function () {\n      this._highlightsPostProcess.updateEffect(\"#define PENTAGON\\n\");\n    }, e.prototype.disablePentagonBokeh = function () {\n      this._highlightsPostProcess.updateEffect();\n    }, e.prototype.enableNoiseBlur = function () {\n      this._blurNoise = !0;\n    }, e.prototype.disableNoiseBlur = function () {\n      this._blurNoise = !1;\n    }, e.prototype.setHighlightsGain = function (e) {\n      this._highlightsGain = e;\n    }, e.prototype.setHighlightsThreshold = function (e) {\n      -1 === this._highlightsGain && (this._highlightsGain = 1), this._highlightsThreshold = e;\n    }, e.prototype.disableHighlights = function () {\n      this._highlightsGain = -1;\n    }, e.prototype.dispose = function (e) {\n      void 0 === e && (e = !1), this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras), this._chromaticAberrationPostProcess = null, this._highlightsPostProcess = null, this._depthOfFieldPostProcess = null, this._grainTexture.dispose(), e && this._scene.disableDepthRenderer();\n    }, e.prototype._createChromaticAberrationPostProcess = function (e) {\n      var t = this;\n      this._chromaticAberrationPostProcess = new dn.PostProcess(\"LensChromaticAberration\", \"chromaticAberration\", [\"chromatic_aberration\", \"screen_width\", \"screen_height\", \"direction\", \"radialIntensity\", \"centerPosition\"], [], e, null, dn.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1), this._chromaticAberrationPostProcess.onApply = function (e) {\n        e.setFloat(\"chromatic_aberration\", t._chromaticAberration), e.setFloat(\"screen_width\", t._scene.getEngine().getRenderWidth()), e.setFloat(\"screen_height\", t._scene.getEngine().getRenderHeight()), e.setFloat(\"radialIntensity\", 1), e.setFloat2(\"direction\", 17, 17), e.setFloat2(\"centerPosition\", .5, .5);\n      };\n    }, e.prototype._createHighlightsPostProcess = function (e) {\n      var t = this;\n      this._highlightsPostProcess = new dn.PostProcess(\"LensHighlights\", \"lensHighlights\", [\"gain\", \"threshold\", \"screen_width\", \"screen_height\"], [], e, null, dn.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, this._dofPentagon ? \"#define PENTAGON\\n\" : \"\"), this._highlightsPostProcess.onApply = function (e) {\n        e.setFloat(\"gain\", t._highlightsGain), e.setFloat(\"threshold\", t._highlightsThreshold), e.setTextureFromPostProcess(\"textureSampler\", t._chromaticAberrationPostProcess), e.setFloat(\"screen_width\", t._scene.getEngine().getRenderWidth()), e.setFloat(\"screen_height\", t._scene.getEngine().getRenderHeight());\n      };\n    }, e.prototype._createDepthOfFieldPostProcess = function (e) {\n      var t = this;\n      this._depthOfFieldPostProcess = new dn.PostProcess(\"LensDepthOfField\", \"depthOfField\", [\"grain_amount\", \"blur_noise\", \"screen_width\", \"screen_height\", \"distortion\", \"dof_enabled\", \"screen_distance\", \"aperture\", \"darken\", \"edge_blur\", \"highlights\", \"near\", \"far\"], [\"depthSampler\", \"grainSampler\", \"highlightsSampler\"], e, null, dn.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1), this._depthOfFieldPostProcess.onApply = function (e) {\n        e.setTexture(\"depthSampler\", t._depthTexture), e.setTexture(\"grainSampler\", t._grainTexture), e.setTextureFromPostProcess(\"textureSampler\", t._highlightsPostProcess), e.setTextureFromPostProcess(\"highlightsSampler\", t._depthOfFieldPostProcess), e.setFloat(\"grain_amount\", t._grainAmount), e.setBool(\"blur_noise\", t._blurNoise), e.setFloat(\"screen_width\", t._scene.getEngine().getRenderWidth()), e.setFloat(\"screen_height\", t._scene.getEngine().getRenderHeight()), e.setFloat(\"distortion\", t._distortion), e.setBool(\"dof_enabled\", -1 !== t._dofDistance), e.setFloat(\"screen_distance\", 1 / (.1 - 1 / t._dofDistance)), e.setFloat(\"aperture\", t._dofAperture), e.setFloat(\"darken\", t._dofDarken), e.setFloat(\"edge_blur\", t._edgeBlur), e.setBool(\"highlights\", -1 !== t._highlightsGain), t._scene.activeCamera && (e.setFloat(\"near\", t._scene.activeCamera.minZ), e.setFloat(\"far\", t._scene.activeCamera.maxZ));\n      };\n    }, e.prototype._createGrainTexture = function () {\n      this._grainTexture = new dn.DynamicTexture(\"LensNoiseTexture\", 512, this._scene, !1, dn.Texture.BILINEAR_SAMPLINGMODE), this._grainTexture.wrapU = dn.Texture.WRAP_ADDRESSMODE, this._grainTexture.wrapV = dn.Texture.WRAP_ADDRESSMODE;\n\n      for (var e, t, i, r = this._grainTexture.getContext(), n = 0; n < 512; n++) for (var o = 0; o < 512; o++) e = Math.floor(255 * (t = .42, i = .58, Math.random() * (i - t) + t)), r.fillStyle = \"rgb(\" + e + \", \" + e + \", \" + e + \")\", r.fillRect(n, o, 1, 1);\n\n      this._grainTexture.update(!1);\n    }, e;\n  }(dn.PostProcessRenderPipeline), dn.LensRenderingPipeline = fn, pn = $a || ($a = {}), _n = function (s) {\n    function c(e, t, i, r, n) {\n      void 0 === r && (r = null);\n      var o = s.call(this, t.getEngine(), e) || this;\n      return o.downSampleX4PostProcess = null, o.brightPassPostProcess = null, o.blurHPostProcesses = [], o.blurVPostProcesses = [], o.textureAdderPostProcess = null, o.volumetricLightPostProcess = null, o.volumetricLightSmoothXPostProcess = null, o.volumetricLightSmoothYPostProcess = null, o.volumetricLightMergePostProces = null, o.volumetricLightFinalPostProcess = null, o.luminancePostProcess = null, o.luminanceDownSamplePostProcesses = [], o.hdrPostProcess = null, o.textureAdderFinalPostProcess = null, o.lensFlareFinalPostProcess = null, o.hdrFinalPostProcess = null, o.lensFlarePostProcess = null, o.lensFlareComposePostProcess = null, o.motionBlurPostProcess = null, o.depthOfFieldPostProcess = null, o.fxaaPostProcess = null, o.brightThreshold = 1, o.blurWidth = 512, o.horizontalBlur = !1, o.exposure = 1, o.lensTexture = null, o.volumetricLightCoefficient = .2, o.volumetricLightPower = 4, o.volumetricLightBlurScale = 64, o.sourceLight = null, o.hdrMinimumLuminance = 1, o.hdrDecreaseRate = .5, o.hdrIncreaseRate = .5, o.lensColorTexture = null, o.lensFlareStrength = 20, o.lensFlareGhostDispersal = 1.4, o.lensFlareHaloWidth = .7, o.lensFlareDistortionStrength = 16, o.lensStarTexture = null, o.lensFlareDirtTexture = null, o.depthOfFieldDistance = 10, o.depthOfFieldBlurWidth = 64, o.motionStrength = 1, o.animations = [], o._currentDepthOfFieldSource = null, o._hdrCurrentLuminance = 1, o._bloomEnabled = !1, o._depthOfFieldEnabled = !1, o._vlsEnabled = !1, o._lensFlareEnabled = !1, o._hdrEnabled = !1, o._motionBlurEnabled = !1, o._fxaaEnabled = !1, o._motionBlurSamples = 64, o._volumetricLightStepsCount = 50, o._samples = 1, o._cameras = n || [], o._scene = t, o._basePostProcess = r, o._ratio = i, o._floatTextureType = t.getEngine().getCaps().textureFloatRender ? pn.Engine.TEXTURETYPE_FLOAT : pn.Engine.TEXTURETYPE_HALF_FLOAT, t.postProcessRenderPipelineManager.addPipeline(o), o._buildPipeline(), o;\n    }\n\n    return T(c, s), Object.defineProperty(c.prototype, \"BloomEnabled\", {\n      get: function () {\n        return this._bloomEnabled;\n      },\n      set: function (e) {\n        this._bloomEnabled !== e && (this._bloomEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"DepthOfFieldEnabled\", {\n      get: function () {\n        return this._depthOfFieldEnabled;\n      },\n      set: function (e) {\n        this._depthOfFieldEnabled !== e && (this._depthOfFieldEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"LensFlareEnabled\", {\n      get: function () {\n        return this._lensFlareEnabled;\n      },\n      set: function (e) {\n        this._lensFlareEnabled !== e && (this._lensFlareEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"HDREnabled\", {\n      get: function () {\n        return this._hdrEnabled;\n      },\n      set: function (e) {\n        this._hdrEnabled !== e && (this._hdrEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"VLSEnabled\", {\n      get: function () {\n        return this._vlsEnabled;\n      },\n      set: function (e) {\n        if (this._vlsEnabled !== e) {\n          if (e) if (!this._scene.enableGeometryBufferRenderer()) return void pn.Tools.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\n          this._vlsEnabled = e, this._buildPipeline();\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"MotionBlurEnabled\", {\n      get: function () {\n        return this._motionBlurEnabled;\n      },\n      set: function (e) {\n        this._motionBlurEnabled !== e && (this._motionBlurEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"fxaaEnabled\", {\n      get: function () {\n        return this._fxaaEnabled;\n      },\n      set: function (e) {\n        this._fxaaEnabled !== e && (this._fxaaEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"volumetricLightStepsCount\", {\n      get: function () {\n        return this._volumetricLightStepsCount;\n      },\n      set: function (e) {\n        this.volumetricLightPostProcess && this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + e.toFixed(1)), this._volumetricLightStepsCount = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"motionBlurSamples\", {\n      get: function () {\n        return this._motionBlurSamples;\n      },\n      set: function (e) {\n        this.motionBlurPostProcess && this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + e.toFixed(1)), this._motionBlurSamples = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(c.prototype, \"samples\", {\n      get: function () {\n        return this._samples;\n      },\n      set: function (e) {\n        this._samples !== e && (this._samples = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), c.prototype._buildPipeline = function () {\n      var t = this,\n          e = this._ratio,\n          i = this._scene;\n      this._disposePostProcesses(), this._reset(), this._basePostProcess ? this.originalPostProcess = this._basePostProcess : (this.originalPostProcess = new pn.PostProcess(\"HDRPass\", \"standard\", [], [], e, null, pn.Texture.BILINEAR_SAMPLINGMODE, i.getEngine(), !1, \"#define PASS_POST_PROCESS\", this._floatTextureType), this.originalPostProcess.onApply = function (e) {\n        t._currentDepthOfFieldSource = t.originalPostProcess;\n      }), (this._bloomEnabled || this._vlsEnabled || this._lensFlareEnabled || this._depthOfFieldEnabled || this._motionBlurEnabled) && this.addEffect(new pn.PostProcessRenderEffect(i.getEngine(), \"HDRPassPostProcess\", function () {\n        return t.originalPostProcess;\n      }, !0)), this._currentDepthOfFieldSource = this.originalPostProcess, this._bloomEnabled && (this._createDownSampleX4PostProcess(i, e / 2), this._createBrightPassPostProcess(i, e / 2), this._createBlurPostProcesses(i, e / 4, 1), this._createTextureAdderPostProcess(i, e), this.textureAdderFinalPostProcess = new pn.PostProcess(\"HDRDepthOfFieldSource\", \"standard\", [], [], e, null, pn.Texture.BILINEAR_SAMPLINGMODE, i.getEngine(), !1, \"#define PASS_POST_PROCESS\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new pn.PostProcessRenderEffect(i.getEngine(), \"HDRBaseDepthOfFieldSource\", function () {\n        return t.textureAdderFinalPostProcess;\n      }, !0))), this._vlsEnabled && (this._createVolumetricLightPostProcess(i, e), this.volumetricLightFinalPostProcess = new pn.PostProcess(\"HDRVLSFinal\", \"standard\", [], [], e, null, pn.Texture.BILINEAR_SAMPLINGMODE, i.getEngine(), !1, \"#define PASS_POST_PROCESS\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new pn.PostProcessRenderEffect(i.getEngine(), \"HDRVLSFinal\", function () {\n        return t.volumetricLightFinalPostProcess;\n      }, !0))), this._lensFlareEnabled && (this._createLensFlarePostProcess(i, e), this.lensFlareFinalPostProcess = new pn.PostProcess(\"HDRPostLensFlareDepthOfFieldSource\", \"standard\", [], [], e, null, pn.Texture.BILINEAR_SAMPLINGMODE, i.getEngine(), !1, \"#define PASS_POST_PROCESS\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new pn.PostProcessRenderEffect(i.getEngine(), \"HDRPostLensFlareDepthOfFieldSource\", function () {\n        return t.lensFlareFinalPostProcess;\n      }, !0))), this._hdrEnabled && (this._createLuminancePostProcesses(i, this._floatTextureType), this._createHdrPostProcess(i, e), this.hdrFinalPostProcess = new pn.PostProcess(\"HDRPostHDReDepthOfFieldSource\", \"standard\", [], [], e, null, pn.Texture.BILINEAR_SAMPLINGMODE, i.getEngine(), !1, \"#define PASS_POST_PROCESS\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new pn.PostProcessRenderEffect(i.getEngine(), \"HDRPostHDReDepthOfFieldSource\", function () {\n        return t.hdrFinalPostProcess;\n      }, !0))), this._depthOfFieldEnabled && (this._createBlurPostProcesses(i, e / 2, 3, \"depthOfFieldBlurWidth\"), this._createDepthOfFieldPostProcess(i, e)), this._motionBlurEnabled && this._createMotionBlurPostProcess(i, e), this._fxaaEnabled && (this.fxaaPostProcess = new pn.FxaaPostProcess(\"fxaa\", 1, null, pn.Texture.BILINEAR_SAMPLINGMODE, i.getEngine(), !1, pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new pn.PostProcessRenderEffect(i.getEngine(), \"HDRFxaa\", function () {\n        return t.fxaaPostProcess;\n      }, !0))), null !== this._cameras && this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras), !this._enableMSAAOnFirstPostProcess(this._samples) && 1 < this._samples && pn.Tools.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }, c.prototype._createDownSampleX4PostProcess = function (e, t) {\n      var s = this,\n          a = new Array(32);\n      this.downSampleX4PostProcess = new pn.PostProcess(\"HDRDownSampleX4\", \"standard\", [\"dsOffsets\"], [], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define DOWN_SAMPLE_X4\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.downSampleX4PostProcess.onApply = function (e) {\n        for (var t = 0, i = s.downSampleX4PostProcess.width, r = s.downSampleX4PostProcess.height, n = -2; n < 2; n++) for (var o = -2; o < 2; o++) a[t] = (n + .5) * (1 / i), a[t + 1] = (o + .5) * (1 / r), t += 2;\n\n        e.setArray2(\"dsOffsets\", a);\n      }, this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRDownSampleX4\", function () {\n        return s.downSampleX4PostProcess;\n      }, !0));\n    }, c.prototype._createBrightPassPostProcess = function (e, t) {\n      var r = this,\n          n = new Array(8);\n      this.brightPassPostProcess = new pn.PostProcess(\"HDRBrightPass\", \"standard\", [\"dsOffsets\", \"brightThreshold\"], [], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define BRIGHT_PASS\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.brightPassPostProcess.onApply = function (e) {\n        var t = 1 / r.brightPassPostProcess.width,\n            i = 1 / r.brightPassPostProcess.height;\n        n[0] = -.5 * t, n[1] = .5 * i, n[2] = .5 * t, n[3] = .5 * i, n[4] = -.5 * t, n[5] = -.5 * i, n[6] = .5 * t, n[7] = -.5 * i, e.setArray2(\"dsOffsets\", n), e.setFloat(\"brightThreshold\", r.brightThreshold);\n      }, this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRBrightPass\", function () {\n        return r.brightPassPostProcess;\n      }, !0));\n    }, c.prototype._createBlurPostProcesses = function (e, t, i, r) {\n      var n = this;\n      void 0 === r && (r = \"blurWidth\");\n      var o = e.getEngine(),\n          s = new pn.BlurPostProcess(\"HDRBlurH_\" + i, new pn.Vector2(1, 0), this[r], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, pn.Engine.TEXTURETYPE_UNSIGNED_INT),\n          a = new pn.BlurPostProcess(\"HDRBlurV_\" + i, new pn.Vector2(0, 1), this[r], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, pn.Engine.TEXTURETYPE_UNSIGNED_INT);\n      s.onActivateObservable.add(function () {\n        var e = s.width / o.getRenderWidth();\n        s.kernel = n[r] * e;\n      }), a.onActivateObservable.add(function () {\n        var e = a.height / o.getRenderHeight();\n        a.kernel = n.horizontalBlur ? 64 * e : n[r] * e;\n      }), this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRBlurH\" + i, function () {\n        return s;\n      }, !0)), this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRBlurV\" + i, function () {\n        return a;\n      }, !0)), this.blurHPostProcesses.push(s), this.blurVPostProcesses.push(a);\n    }, c.prototype._createTextureAdderPostProcess = function (e, t) {\n      var i = this;\n      this.textureAdderPostProcess = new pn.PostProcess(\"HDRTextureAdder\", \"standard\", [\"exposure\"], [\"otherSampler\", \"lensSampler\"], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define TEXTURE_ADDER\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.textureAdderPostProcess.onApply = function (e) {\n        e.setTextureFromPostProcess(\"otherSampler\", i._vlsEnabled ? i._currentDepthOfFieldSource : i.originalPostProcess), e.setTexture(\"lensSampler\", i.lensTexture), e.setFloat(\"exposure\", i.exposure), i._currentDepthOfFieldSource = i.textureAdderFinalPostProcess;\n      }, this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRTextureAdder\", function () {\n        return i.textureAdderPostProcess;\n      }, !0));\n    }, c.prototype._createVolumetricLightPostProcess = function (e, t) {\n      var i = this,\n          r = e.enableGeometryBufferRenderer();\n      r.enablePosition = !0;\n      var n = r.getGBuffer();\n      this.volumetricLightPostProcess = new pn.PostProcess(\"HDRVLS\", \"standard\", [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"], [\"shadowMapSampler\", \"positionSampler\"], t / 8, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1));\n      var o = pn.Vector2.Zero();\n      this.volumetricLightPostProcess.onApply = function (e) {\n        if (i.sourceLight && i.sourceLight.getShadowGenerator() && i._scene.activeCamera) {\n          var t = i.sourceLight.getShadowGenerator();\n          e.setTexture(\"shadowMapSampler\", t.getShadowMap()), e.setTexture(\"positionSampler\", n.textures[2]), e.setColor3(\"sunColor\", i.sourceLight.diffuse), e.setVector3(\"sunDirection\", i.sourceLight.getShadowDirection()), e.setVector3(\"cameraPosition\", i._scene.activeCamera.globalPosition), e.setMatrix(\"shadowViewProjection\", t.getTransformMatrix()), e.setFloat(\"scatteringCoefficient\", i.volumetricLightCoefficient), e.setFloat(\"scatteringPower\", i.volumetricLightPower), o.x = i.sourceLight.getDepthMinZ(i._scene.activeCamera), o.y = i.sourceLight.getDepthMaxZ(i._scene.activeCamera), e.setVector2(\"depthValues\", o);\n        }\n      }, this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRVLS\", function () {\n        return i.volumetricLightPostProcess;\n      }, !0)), this._createBlurPostProcesses(e, t / 4, 0, \"volumetricLightBlurScale\"), this.volumetricLightMergePostProces = new pn.PostProcess(\"HDRVLSMerge\", \"standard\", [], [\"originalSampler\"], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define VLSMERGE\"), this.volumetricLightMergePostProces.onApply = function (e) {\n        e.setTextureFromPostProcess(\"originalSampler\", i._bloomEnabled ? i.textureAdderFinalPostProcess : i.originalPostProcess), i._currentDepthOfFieldSource = i.volumetricLightFinalPostProcess;\n      }, this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRVLSMerge\", function () {\n        return i.volumetricLightMergePostProces;\n      }, !0));\n    }, c.prototype._createLuminancePostProcesses = function (r, e) {\n      var a = this,\n          t = Math.pow(3, c.LuminanceSteps);\n      this.luminancePostProcess = new pn.PostProcess(\"HDRLuminance\", \"standard\", [\"lumOffsets\"], [], {\n        width: t,\n        height: t\n      }, null, pn.Texture.BILINEAR_SAMPLINGMODE, r.getEngine(), !1, \"#define LUMINANCE\", e);\n      var n = [];\n      this.luminancePostProcess.onApply = function (e) {\n        var t = 1 / a.luminancePostProcess.width,\n            i = 1 / a.luminancePostProcess.height;\n        n[0] = -.5 * t, n[1] = .5 * i, n[2] = .5 * t, n[3] = .5 * i, n[4] = -.5 * t, n[5] = -.5 * i, n[6] = .5 * t, n[7] = -.5 * i, e.setArray2(\"lumOffsets\", n);\n      }, this.addEffect(new pn.PostProcessRenderEffect(r.getEngine(), \"HDRLuminance\", function () {\n        return a.luminancePostProcess;\n      }, !0));\n\n      for (var i = c.LuminanceSteps - 1; 0 <= i; i--) {\n        t = Math.pow(3, i);\n        var o = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\n        0 === i && (o += \"#define FINAL_DOWN_SAMPLER\");\n        var s = new pn.PostProcess(\"HDRLuminanceDownSample\" + i, \"standard\", [\"dsOffsets\", \"halfDestPixelSize\"], [], {\n          width: t,\n          height: t\n        }, null, pn.Texture.BILINEAR_SAMPLINGMODE, r.getEngine(), !1, o, e);\n        this.luminanceDownSamplePostProcesses.push(s);\n      }\n\n      var l = this.luminancePostProcess;\n      this.luminanceDownSamplePostProcesses.forEach(function (n, o) {\n        var s = new Array(18);\n        n.onApply = function (e) {\n          if (l) {\n            for (var t = 0, i = -1; i < 2; i++) for (var r = -1; r < 2; r++) s[t] = i / l.width, s[t + 1] = r / l.height, t += 2;\n\n            e.setArray2(\"dsOffsets\", s), e.setFloat(\"halfDestPixelSize\", .5 / l.width), l = o === a.luminanceDownSamplePostProcesses.length - 1 ? a.luminancePostProcess : n;\n          }\n        }, o === a.luminanceDownSamplePostProcesses.length - 1 && (n.onAfterRender = function (e) {\n          var t = r.getEngine().readPixels(0, 0, 1, 1),\n              i = new pn.Vector4(1 / 16581375, 1 / 65025, 1 / 255, 1);\n          a._hdrCurrentLuminance = (t[0] * i.x + t[1] * i.y + t[2] * i.z + t[3] * i.w) / 100;\n        }), a.addEffect(new pn.PostProcessRenderEffect(r.getEngine(), \"HDRLuminanceDownSample\" + o, function () {\n          return n;\n        }, !0));\n      });\n    }, c.prototype._createHdrPostProcess = function (i, e) {\n      var r = this;\n      this.hdrPostProcess = new pn.PostProcess(\"HDR\", \"standard\", [\"averageLuminance\"], [\"textureAdderSampler\"], e, null, pn.Texture.BILINEAR_SAMPLINGMODE, i.getEngine(), !1, \"#define HDR\", pn.Engine.TEXTURETYPE_UNSIGNED_INT);\n      var n = 1,\n          o = 0,\n          s = 0;\n      this.hdrPostProcess.onApply = function (e) {\n        if (e.setTextureFromPostProcess(\"textureAdderSampler\", r._currentDepthOfFieldSource), o += i.getEngine().getDeltaTime(), n < 0) n = r._hdrCurrentLuminance;else {\n          var t = (s - o) / 1e3;\n          r._hdrCurrentLuminance < n + r.hdrDecreaseRate * t ? n += r.hdrDecreaseRate * t : r._hdrCurrentLuminance > n - r.hdrIncreaseRate * t ? n -= r.hdrIncreaseRate * t : n = r._hdrCurrentLuminance;\n        }\n        n = pn.Scalar.Clamp(n, r.hdrMinimumLuminance, 1e20), e.setFloat(\"averageLuminance\", n), s = o, r._currentDepthOfFieldSource = r.hdrFinalPostProcess;\n      }, this.addEffect(new pn.PostProcessRenderEffect(i.getEngine(), \"HDR\", function () {\n        return r.hdrPostProcess;\n      }, !0));\n    }, c.prototype._createLensFlarePostProcess = function (e, t) {\n      var s = this;\n      this.lensFlarePostProcess = new pn.PostProcess(\"HDRLensFlare\", \"standard\", [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"], [\"lensColorSampler\"], t / 2, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define LENS_FLARE\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRLensFlare\", function () {\n        return s.lensFlarePostProcess;\n      }, !0)), this._createBlurPostProcesses(e, t / 4, 2), this.lensFlareComposePostProcess = new pn.PostProcess(\"HDRLensFlareCompose\", \"standard\", [\"lensStarMatrix\"], [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define LENS_FLARE_COMPOSE\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRLensFlareCompose\", function () {\n        return s.lensFlareComposePostProcess;\n      }, !0));\n      var i = new pn.Vector2(0, 0);\n\n      this.lensFlarePostProcess.onApply = function (e) {\n        e.setTextureFromPostProcess(\"textureSampler\", s._bloomEnabled ? s.blurHPostProcesses[0] : s.originalPostProcess), e.setTexture(\"lensColorSampler\", s.lensColorTexture), e.setFloat(\"strength\", s.lensFlareStrength), e.setFloat(\"ghostDispersal\", s.lensFlareGhostDispersal), e.setFloat(\"haloWidth\", s.lensFlareHaloWidth), i.x = s.lensFlarePostProcess.width, i.y = s.lensFlarePostProcess.height, e.setVector2(\"resolution\", i), e.setFloat(\"distortionStrength\", s.lensFlareDistortionStrength);\n      };\n\n      var a = pn.Matrix.FromValues(2, 0, -1, 0, 0, 2, -1, 0, 0, 0, 1, 0, 0, 0, 0, 1),\n          l = pn.Matrix.FromValues(.5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\n      this.lensFlareComposePostProcess.onApply = function (e) {\n        if (s._scene.activeCamera) {\n          e.setTextureFromPostProcess(\"otherSampler\", s._currentDepthOfFieldSource), e.setTexture(\"lensDirtSampler\", s.lensFlareDirtTexture), e.setTexture(\"lensStarSampler\", s.lensStarTexture);\n\n          var t = s._scene.activeCamera.getViewMatrix().getRow(0),\n              i = s._scene.activeCamera.getViewMatrix().getRow(2),\n              r = pn.Vector3.Dot(t.toVector3(), new pn.Vector3(1, 0, 0)) + pn.Vector3.Dot(i.toVector3(), new pn.Vector3(0, 0, 1));\n\n          r *= 4;\n          var n = pn.Matrix.FromValues(.5 * Math.cos(r), -Math.sin(r), 0, 0, Math.sin(r), .5 * Math.cos(r), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),\n              o = l.multiply(n).multiply(a);\n          e.setMatrix(\"lensStarMatrix\", o), s._currentDepthOfFieldSource = s.lensFlareFinalPostProcess;\n        }\n      };\n    }, c.prototype._createDepthOfFieldPostProcess = function (e, t) {\n      var i = this;\n      this.depthOfFieldPostProcess = new pn.PostProcess(\"HDRDepthOfField\", \"standard\", [\"distance\"], [\"otherSampler\", \"depthSampler\"], t, null, pn.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, \"#define DEPTH_OF_FIELD\", pn.Engine.TEXTURETYPE_UNSIGNED_INT), this.depthOfFieldPostProcess.onApply = function (e) {\n        e.setTextureFromPostProcess(\"otherSampler\", i._currentDepthOfFieldSource), e.setTexture(\"depthSampler\", i._getDepthTexture()), e.setFloat(\"distance\", i.depthOfFieldDistance);\n      }, this.addEffect(new pn.PostProcessRenderEffect(e.getEngine(), \"HDRDepthOfField\", function () {\n        return i.depthOfFieldPostProcess;\n      }, !0));\n    }, c.prototype._createMotionBlurPostProcess = function (t, e) {\n      var i = this;\n      this.motionBlurPostProcess = new pn.PostProcess(\"HDRMotionBlur\", \"standard\", [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"], [\"depthSampler\"], e, null, pn.Texture.BILINEAR_SAMPLINGMODE, t.getEngine(), !1, \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1), pn.Engine.TEXTURETYPE_UNSIGNED_INT);\n      var r = 0,\n          n = pn.Matrix.Identity(),\n          o = pn.Matrix.Identity(),\n          s = pn.Matrix.Identity(),\n          a = pn.Vector2.Zero();\n      this.motionBlurPostProcess.onApply = function (e) {\n        (s = t.getProjectionMatrix().multiply(t.getViewMatrix())).invertToRef(o), e.setMatrix(\"inverseViewProjection\", o), e.setMatrix(\"prevViewProjection\", n), n = s, a.x = i.motionBlurPostProcess.width, a.y = i.motionBlurPostProcess.height, e.setVector2(\"screenSize\", a), r = t.getEngine().getFps() / 60, e.setFloat(\"motionScale\", r), e.setFloat(\"motionStrength\", i.motionStrength), e.setTexture(\"depthSampler\", i._getDepthTexture());\n      }, this.addEffect(new pn.PostProcessRenderEffect(t.getEngine(), \"HDRMotionBlur\", function () {\n        return i.motionBlurPostProcess;\n      }, !0));\n    }, c.prototype._getDepthTexture = function () {\n      return this._scene.getEngine().getCaps().drawBuffersExtension ? this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0] : this._scene.enableDepthRenderer().getDepthMap();\n    }, c.prototype._disposePostProcesses = function () {\n      for (var e = 0; e < this._cameras.length; e++) {\n        var t = this._cameras[e];\n        this.originalPostProcess && this.originalPostProcess.dispose(t), this.downSampleX4PostProcess && this.downSampleX4PostProcess.dispose(t), this.brightPassPostProcess && this.brightPassPostProcess.dispose(t), this.textureAdderPostProcess && this.textureAdderPostProcess.dispose(t), this.textureAdderFinalPostProcess && this.textureAdderFinalPostProcess.dispose(t), this.volumetricLightPostProcess && this.volumetricLightPostProcess.dispose(t), this.volumetricLightSmoothXPostProcess && this.volumetricLightSmoothXPostProcess.dispose(t), this.volumetricLightSmoothYPostProcess && this.volumetricLightSmoothYPostProcess.dispose(t), this.volumetricLightMergePostProces && this.volumetricLightMergePostProces.dispose(t), this.volumetricLightFinalPostProcess && this.volumetricLightFinalPostProcess.dispose(t), this.lensFlarePostProcess && this.lensFlarePostProcess.dispose(t), this.lensFlareComposePostProcess && this.lensFlareComposePostProcess.dispose(t);\n\n        for (var i = 0; i < this.luminanceDownSamplePostProcesses.length; i++) this.luminanceDownSamplePostProcesses[i].dispose(t);\n\n        this.luminancePostProcess && this.luminancePostProcess.dispose(t), this.hdrPostProcess && this.hdrPostProcess.dispose(t), this.hdrFinalPostProcess && this.hdrFinalPostProcess.dispose(t), this.depthOfFieldPostProcess && this.depthOfFieldPostProcess.dispose(t), this.motionBlurPostProcess && this.motionBlurPostProcess.dispose(t), this.fxaaPostProcess && this.fxaaPostProcess.dispose(t);\n\n        for (i = 0; i < this.blurHPostProcesses.length; i++) this.blurHPostProcesses[i].dispose(t);\n\n        for (i = 0; i < this.blurVPostProcesses.length; i++) this.blurVPostProcesses[i].dispose(t);\n      }\n\n      this.originalPostProcess = null, this.downSampleX4PostProcess = null, this.brightPassPostProcess = null, this.textureAdderPostProcess = null, this.textureAdderFinalPostProcess = null, this.volumetricLightPostProcess = null, this.volumetricLightSmoothXPostProcess = null, this.volumetricLightSmoothYPostProcess = null, this.volumetricLightMergePostProces = null, this.volumetricLightFinalPostProcess = null, this.lensFlarePostProcess = null, this.lensFlareComposePostProcess = null, this.luminancePostProcess = null, this.hdrPostProcess = null, this.hdrFinalPostProcess = null, this.depthOfFieldPostProcess = null, this.motionBlurPostProcess = null, this.fxaaPostProcess = null, this.luminanceDownSamplePostProcesses = [], this.blurHPostProcesses = [], this.blurVPostProcesses = [];\n    }, c.prototype.dispose = function () {\n      this._disposePostProcesses(), this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras), s.prototype.dispose.call(this);\n    }, c.prototype.serialize = function () {\n      var e = pn.SerializationHelper.Serialize(this);\n      return this.sourceLight && (e.sourceLightId = this.sourceLight.id), e.customType = \"StandardRenderingPipeline\", e;\n    }, c.Parse = function (e, t, i) {\n      var r = pn.SerializationHelper.Parse(function () {\n        return new c(e._name, t, e._ratio);\n      }, e, t, i);\n      return e.sourceLightId && (r.sourceLight = t.getLightByID(e.sourceLightId)), r;\n    }, c.LuminanceSteps = 6, b([pn.serialize()], c.prototype, \"brightThreshold\", void 0), b([pn.serialize()], c.prototype, \"blurWidth\", void 0), b([pn.serialize()], c.prototype, \"horizontalBlur\", void 0), b([pn.serialize()], c.prototype, \"exposure\", void 0), b([pn.serializeAsTexture(\"lensTexture\")], c.prototype, \"lensTexture\", void 0), b([pn.serialize()], c.prototype, \"volumetricLightCoefficient\", void 0), b([pn.serialize()], c.prototype, \"volumetricLightPower\", void 0), b([pn.serialize()], c.prototype, \"volumetricLightBlurScale\", void 0), b([pn.serialize()], c.prototype, \"hdrMinimumLuminance\", void 0), b([pn.serialize()], c.prototype, \"hdrDecreaseRate\", void 0), b([pn.serialize()], c.prototype, \"hdrIncreaseRate\", void 0), b([pn.serializeAsTexture(\"lensColorTexture\")], c.prototype, \"lensColorTexture\", void 0), b([pn.serialize()], c.prototype, \"lensFlareStrength\", void 0), b([pn.serialize()], c.prototype, \"lensFlareGhostDispersal\", void 0), b([pn.serialize()], c.prototype, \"lensFlareHaloWidth\", void 0), b([pn.serialize()], c.prototype, \"lensFlareDistortionStrength\", void 0), b([pn.serializeAsTexture(\"lensStarTexture\")], c.prototype, \"lensStarTexture\", void 0), b([pn.serializeAsTexture(\"lensFlareDirtTexture\")], c.prototype, \"lensFlareDirtTexture\", void 0), b([pn.serialize()], c.prototype, \"depthOfFieldDistance\", void 0), b([pn.serialize()], c.prototype, \"depthOfFieldBlurWidth\", void 0), b([pn.serialize()], c.prototype, \"motionStrength\", void 0), b([pn.serialize()], c.prototype, \"_ratio\", void 0), b([pn.serialize()], c.prototype, \"BloomEnabled\", null), b([pn.serialize()], c.prototype, \"DepthOfFieldEnabled\", null), b([pn.serialize()], c.prototype, \"LensFlareEnabled\", null), b([pn.serialize()], c.prototype, \"HDREnabled\", null), b([pn.serialize()], c.prototype, \"VLSEnabled\", null), b([pn.serialize()], c.prototype, \"MotionBlurEnabled\", null), b([pn.serialize()], c.prototype, \"fxaaEnabled\", null), b([pn.serialize()], c.prototype, \"volumetricLightStepsCount\", null), b([pn.serialize()], c.prototype, \"motionBlurSamples\", null), b([pn.serialize()], c.prototype, \"samples\", null), c;\n  }(pn.PostProcessRenderPipeline), pn.StandardRenderingPipeline = _n, mn = $a || ($a = {}), gn = function (c) {\n    function e(e, t, i, r, n, o, s) {\n      void 0 === i && (i = null), void 0 === s && (s = mn.Engine.TEXTURETYPE_UNSIGNED_INT);\n\n      var a = c.call(this, e, \"fxaa\", [\"texelSize\"], null, t, i, r || mn.Texture.BILINEAR_SAMPLINGMODE, n, o, null, s, \"fxaa\", void 0, !0) || this,\n          l = a._getDefines();\n\n      return a.updateEffect(l), a.onApplyObservable.add(function (e) {\n        var t = a.texelSize;\n        e.setFloat2(\"texelSize\", t.x, t.y);\n      }), a;\n    }\n\n    return T(e, c), e.prototype._getDefines = function () {\n      var e = this.getEngine();\n      if (!e) return null;\n      var t = e.getGlInfo();\n      return t && t.renderer && -1 < t.renderer.toLowerCase().indexOf(\"mali\") ? \"#define MALI 1\\n\" : null;\n    }, e;\n  }(mn.PostProcess), mn.FxaaPostProcess = gn, vn = $a || ($a = {}), yn = function (u) {\n    function e(e, t, i, r, n, o, s, a, l, c) {\n      void 0 === l && (l = vn.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === c && (c = !1);\n      var h = u.call(this, e, \"chromaticAberration\", [\"chromatic_aberration\", \"screen_width\", \"screen_height\", \"direction\", \"radialIntensity\", \"centerPosition\"], [], r, n, o, s, a, null, l, void 0, null, c) || this;\n      return h.aberrationAmount = 30, h.radialIntensity = 0, h.direction = new vn.Vector2(.707, .707), h.centerPosition = new vn.Vector2(.5, .5), h.onApplyObservable.add(function (e) {\n        e.setFloat(\"chromatic_aberration\", h.aberrationAmount), e.setFloat(\"screen_width\", t), e.setFloat(\"screen_height\", i), e.setFloat(\"radialIntensity\", h.radialIntensity), e.setFloat2(\"direction\", h.direction.x, h.direction.y), e.setFloat2(\"centerPosition\", h.centerPosition.x, h.centerPosition.y);\n      }), h;\n    }\n\n    return T(e, u), e;\n  }(vn.PostProcess), vn.ChromaticAberrationPostProcess = yn, bn = $a || ($a = {}), Tn = function (c) {\n    function e(e, t, i, r, n, o, s, a) {\n      void 0 === s && (s = bn.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === a && (a = !1);\n      var l = c.call(this, e, \"grain\", [\"intensity\", \"animatedSeed\"], [], t, i, r, n, o, null, s, void 0, null, a) || this;\n      return l.intensity = 30, l.animated = !1, l.onApplyObservable.add(function (e) {\n        e.setFloat(\"intensity\", l.intensity), e.setFloat(\"animatedSeed\", l.animated ? Math.random() + 1 : 1);\n      }), l;\n    }\n\n    return T(e, c), e;\n  }(bn.PostProcess), bn.GrainPostProcess = Tn, En = $a || ($a = {}), xn = function (c) {\n    function e(e, t, i, r, n, o, s, a) {\n      void 0 === s && (s = En.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === a && (a = !1);\n      var l = c.call(this, e, \"sharpen\", [\"sharpnessAmounts\", \"screenSize\"], null, t, i, r, n, o, null, s, void 0, null, a) || this;\n      return l.colorAmount = 1, l.edgeAmount = .3, l.onApply = function (e) {\n        e.setFloat2(\"screenSize\", l.width, l.height), e.setFloat2(\"sharpnessAmounts\", l.edgeAmount, l.colorAmount);\n      }, l;\n    }\n\n    return T(e, c), e;\n  }(En.PostProcess), En.SharpenPostProcess = xn, Pn = $a || ($a = {}), An = function (E) {\n    function e(e, t, i, r, n, o, s, a, l, c, h) {\n      void 0 === o && (o = Pn.Texture.BILINEAR_SAMPLINGMODE), void 0 === l && (l = Pn.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === c && (c = \"\"), void 0 === h && (h = !1);\n      var u = E.call(this, e, \"kernelBlur\", [\"delta\", \"direction\", \"cameraMinMaxZ\"], [\"circleOfConfusionSampler\"], r, n, o, s, a, null, l, \"kernelBlur\", {\n        varyingCount: 0,\n        depCount: 0\n      }, !0) || this;\n      return u.direction = t, u.blockCompilation = h, u._packedFloat = !1, u._staticDefines = \"\", u._staticDefines = c, u.onApplyObservable.add(function (e) {\n        u._outputTexture ? e.setFloat2(\"delta\", 1 / u._outputTexture.width * u.direction.x, 1 / u._outputTexture.height * u.direction.y) : e.setFloat2(\"delta\", 1 / u.width * u.direction.x, 1 / u.height * u.direction.y);\n      }), u.kernel = i, u;\n    }\n\n    return T(e, E), Object.defineProperty(e.prototype, \"kernel\", {\n      get: function () {\n        return this._idealKernel;\n      },\n      set: function (e) {\n        this._idealKernel !== e && (e = Math.max(e, 1), this._idealKernel = e, this._kernel = this._nearestBestKernel(e), this.blockCompilation || this._updateParameters());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"packedFloat\", {\n      get: function () {\n        return this._packedFloat;\n      },\n      set: function (e) {\n        this._packedFloat !== e && (this._packedFloat = e, this.blockCompilation || this._updateParameters());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.updateEffect = function (e, t, i, r, n, o) {\n      void 0 === e && (e = null), void 0 === t && (t = null), void 0 === i && (i = null), this._updateParameters(n, o);\n    }, e.prototype._updateParameters = function (e, t) {\n      for (var i = this._kernel, r = (i - 1) / 2, n = [], o = [], s = 0, a = 0; a < i; a++) {\n        var l = a / (i - 1),\n            c = this._gaussianWeight(2 * l - 1);\n\n        n[a] = a - r, s += o[a] = c;\n      }\n\n      for (a = 0; a < o.length; a++) o[a] /= s;\n\n      var h = [],\n          u = [],\n          d = [];\n\n      for (a = 0; a <= r; a += 2) {\n        var f = Math.min(a + 1, Math.floor(r));\n        if (a === f) d.push({\n          o: n[a],\n          w: o[a]\n        });else {\n          var p = f === r,\n              _ = o[a] + o[f] * (p ? .5 : 1),\n              m = n[a] + 1 / (1 + o[a] / o[f]);\n\n          0 === m ? (d.push({\n            o: n[a],\n            w: o[a]\n          }), d.push({\n            o: n[a + 1],\n            w: o[a + 1]\n          })) : (d.push({\n            o: m,\n            w: _\n          }), d.push({\n            o: -m,\n            w: _\n          }));\n        }\n      }\n\n      for (a = 0; a < d.length; a++) u[a] = d[a].o, h[a] = d[a].w;\n\n      n = u, o = h;\n      var g = this.getEngine().getCaps().maxVaryingVectors,\n          v = Math.max(g, 0) - 1,\n          y = Math.min(n.length, v),\n          b = \"\";\n      b += this._staticDefines, -1 != this._staticDefines.indexOf(\"DOF\") && (b += \"#define CENTER_WEIGHT \" + this._glslFloat(o[y - 1]) + \"\\r\\n\", y--);\n\n      for (a = 0; a < y; a++) b += \"#define KERNEL_OFFSET\" + a + \" \" + this._glslFloat(n[a]) + \"\\r\\n\", b += \"#define KERNEL_WEIGHT\" + a + \" \" + this._glslFloat(o[a]) + \"\\r\\n\";\n\n      var T = 0;\n\n      for (a = v; a < n.length; a++) b += \"#define KERNEL_DEP_OFFSET\" + T + \" \" + this._glslFloat(n[a]) + \"\\r\\n\", b += \"#define KERNEL_DEP_WEIGHT\" + T + \" \" + this._glslFloat(o[a]) + \"\\r\\n\", T++;\n\n      this.packedFloat && (b += \"#define PACKEDFLOAT 1\"), this.blockCompilation = !1, E.prototype.updateEffect.call(this, b, null, null, {\n        varyingCount: y,\n        depCount: T\n      }, e, t);\n    }, e.prototype._nearestBestKernel = function (e) {\n      for (var t = Math.round(e), i = 0, r = [t, t - 1, t + 1, t - 2, t + 2]; i < r.length; i++) {\n        var n = r[i];\n        if (n % 2 != 0 && Math.floor(n / 2) % 2 == 0 && 0 < n) return Math.max(n, 3);\n      }\n\n      return Math.max(t, 3);\n    }, e.prototype._gaussianWeight = function (e) {\n      var t = -e * e / (1 / 3 * 2 * (1 / 3));\n      return 1 / (Math.sqrt(2 * Math.PI) * (1 / 3)) * Math.exp(t);\n    }, e.prototype._glslFloat = function (e, t) {\n      return void 0 === t && (t = 8), e.toFixed(t).replace(/0+$/, \"\");\n    }, e;\n  }(Pn.PostProcess), Pn.BlurPostProcess = An, Sn = $a || ($a = {}), Mn = function (p) {\n    function e(e, t, i, r, n, o, s, a, l, c, h, u, d) {\n      void 0 === a && (a = null), void 0 === l && (l = Sn.Texture.BILINEAR_SAMPLINGMODE), void 0 === u && (u = Sn.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === d && (d = !1);\n      var f = p.call(this, e, i, r, n, o, l = Sn.Texture.BILINEAR_SAMPLINGMODE, c, h, u = Sn.Engine.TEXTURETYPE_UNSIGNED_INT, \"#define DOF 1\\r\\n\", d) || this;\n      return f.direction = i, f.onApplyObservable.add(function (e) {\n        null != a && e.setTextureFromPostProcess(\"textureSampler\", a), e.setTextureFromPostProcessOutput(\"circleOfConfusionSampler\", s), t.activeCamera && e.setFloat2(\"cameraMinMaxZ\", t.activeCamera.minZ, t.activeCamera.maxZ);\n      }), f;\n    }\n\n    return T(e, p), e;\n  }(Sn.BlurPostProcess), Sn.DepthOfFieldBlurPostProcess = Mn, function (f) {\n    var e = function () {};\n\n    f.DepthOfFieldMergePostProcessOptions = e;\n\n    var t = function (d) {\n      function e(e, t, r, n, i, o, s, a, l, c, h) {\n        void 0 === c && (c = f.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === h && (h = !1);\n        var u = d.call(this, e, \"depthOfFieldMerge\", [], [\"circleOfConfusionSampler\", \"blurStep0\", \"blurStep1\", \"blurStep2\"], i, o, s, a, l, null, c, void 0, null, !0) || this;\n        return u.blurSteps = n, u.onApplyObservable.add(function (i) {\n          i.setTextureFromPostProcess(\"textureSampler\", t), i.setTextureFromPostProcessOutput(\"circleOfConfusionSampler\", r), n.forEach(function (e, t) {\n            i.setTextureFromPostProcessOutput(\"blurStep\" + (n.length - t - 1), e);\n          });\n        }), h || u.updateEffect(), u;\n      }\n\n      return T(e, d), e.prototype.updateEffect = function (e, t, i, r, n, o) {\n        void 0 === e && (e = null), void 0 === t && (t = null), void 0 === i && (i = null), e || (e = \"\", e += \"#define BLUR_LEVEL \" + (this.blurSteps.length - 1) + \"\\n\"), d.prototype.updateEffect.call(this, e, t, i, r, n, o);\n      }, e;\n    }(f.PostProcess);\n\n    f.DepthOfFieldMergePostProcess = t;\n  }($a || ($a = {})), Rn = $a || ($a = {}), Cn = function (h) {\n    function e(e, t, i, r, n, o, s, a, l) {\n      void 0 === a && (a = Rn.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === l && (l = !1);\n      var c = h.call(this, e, \"circleOfConfusion\", [\"cameraMinMaxZ\", \"focusDistance\", \"cocPrecalculation\"], [\"depthSampler\"], i, r, n, o, s, null, a, void 0, null, l) || this;\n      return c.lensSize = 50, c.fStop = 1.4, c.focusDistance = 2e3, c.focalLength = 50, c._depthTexture = null, c._depthTexture = t, c.onApplyObservable.add(function (e) {\n        if (c._depthTexture) {\n          e.setTexture(\"depthSampler\", c._depthTexture);\n          var t = c.lensSize / c.fStop * c.focalLength / (c.focusDistance - c.focalLength);\n          e.setFloat(\"focusDistance\", c.focusDistance), e.setFloat(\"cocPrecalculation\", t), e.setFloat2(\"cameraMinMaxZ\", c._depthTexture.activeCamera.minZ, c._depthTexture.activeCamera.maxZ);\n        } else Rn.Tools.Warn(\"No depth texture set on CircleOfConfusionPostProcess\");\n      }), c;\n    }\n\n    return T(e, h), Object.defineProperty(e.prototype, \"depthTexture\", {\n      set: function (e) {\n        this._depthTexture = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e;\n  }(Rn.PostProcess), Rn.CircleOfConfusionPostProcess = Cn, function (p) {\n    var _, e;\n\n    (e = _ = p.DepthOfFieldEffectBlurLevel || (p.DepthOfFieldEffectBlurLevel = {}))[e.Low = 0] = \"Low\", e[e.Medium = 1] = \"Medium\", e[e.High = 2] = \"High\";\n\n    var t = function (f) {\n      function e(e, t, i, r, n) {\n        void 0 === i && (i = _.Low), void 0 === r && (r = 0), void 0 === n && (n = !1);\n        var o = f.call(this, e.getEngine(), \"depth of field\", function () {\n          return o._effects;\n        }, !0) || this;\n        o._effects = [], o._circleOfConfusion = new p.CircleOfConfusionPostProcess(\"circleOfConfusion\", t, 1, null, p.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, r, n), o._depthOfFieldBlurY = [], o._depthOfFieldBlurX = [];\n        var s = 1,\n            a = 15;\n\n        switch (i) {\n          case _.High:\n            s = 3, a = 51;\n            break;\n\n          case _.Medium:\n            s = 2, a = 31;\n            break;\n\n          default:\n            a = 15, s = 1;\n        }\n\n        for (var l = a / Math.pow(2, s - 1), c = 1, h = 0; h < s; h++) {\n          var u = new p.DepthOfFieldBlurPostProcess(\"verticle blur\", e, new p.Vector2(0, 1), l, c, null, o._circleOfConfusion, 0 == h ? o._circleOfConfusion : null, p.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, r, n);\n          u.autoClear = !1, c = .75 / Math.pow(2, h);\n          var d = new p.DepthOfFieldBlurPostProcess(\"horizontal blur\", e, new p.Vector2(1, 0), l, c, null, o._circleOfConfusion, null, p.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, r, n);\n          d.autoClear = !1, o._depthOfFieldBlurY.push(u), o._depthOfFieldBlurX.push(d);\n        }\n\n        o._effects = [o._circleOfConfusion];\n\n        for (h = 0; h < o._depthOfFieldBlurX.length; h++) o._effects.push(o._depthOfFieldBlurY[h]), o._effects.push(o._depthOfFieldBlurX[h]);\n\n        return o._dofMerge = new p.DepthOfFieldMergePostProcess(\"dofMerge\", o._circleOfConfusion, o._circleOfConfusion, o._depthOfFieldBlurX, c, null, p.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, r, n), o._dofMerge.autoClear = !1, o._effects.push(o._dofMerge), o;\n      }\n\n      return T(e, f), Object.defineProperty(e.prototype, \"focalLength\", {\n        get: function () {\n          return this._circleOfConfusion.focalLength;\n        },\n        set: function (e) {\n          this._circleOfConfusion.focalLength = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"fStop\", {\n        get: function () {\n          return this._circleOfConfusion.fStop;\n        },\n        set: function (e) {\n          this._circleOfConfusion.fStop = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"focusDistance\", {\n        get: function () {\n          return this._circleOfConfusion.focusDistance;\n        },\n        set: function (e) {\n          this._circleOfConfusion.focusDistance = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"lensSize\", {\n        get: function () {\n          return this._circleOfConfusion.lensSize;\n        },\n        set: function (e) {\n          this._circleOfConfusion.lensSize = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"depthTexture\", {\n        set: function (e) {\n          this._circleOfConfusion.depthTexture = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.disposeEffects = function (e) {\n        for (var t = 0; t < this._effects.length; t++) this._effects[t].dispose(e);\n      }, e.prototype._updateEffects = function () {\n        for (var e = 0; e < this._effects.length; e++) this._effects[e].updateEffect();\n      }, e.prototype._isReady = function () {\n        for (var e = 0; e < this._effects.length; e++) if (!this._effects[e].isReady()) return !1;\n\n        return !0;\n      }, e;\n    }(p.PostProcessRenderEffect);\n\n    p.DepthOfFieldEffect = t;\n  }($a || ($a = {})), On = $a || ($a = {}), Dn = function (d) {\n    function e(e, t, i, r, n, o, s, a, l, c, h) {\n      void 0 === c && (c = On.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === h && (h = !1);\n      var u = d.call(this, e, \"bloomMerge\", [\"bloomWeight\"], [\"circleOfConfusionSampler\", \"blurStep0\", \"blurStep1\", \"blurStep2\", \"bloomBlur\"], n, o, s, a, l, null, c, void 0, null, !0) || this;\n      return u.weight = r, u.onApplyObservable.add(function (e) {\n        e.setTextureFromPostProcess(\"textureSampler\", t), e.setTextureFromPostProcessOutput(\"bloomBlur\", i), e.setFloat(\"bloomWeight\", u.weight);\n      }), h || u.updateEffect(), u;\n    }\n\n    return T(e, d), e;\n  }(On.PostProcess), On.BloomMergePostProcess = Dn, In = $a || ($a = {}), wn = function (c) {\n    function e(e, t, i, r, n, o, s, a) {\n      void 0 === s && (s = In.Engine.TEXTURETYPE_UNSIGNED_INT), void 0 === a && (a = !1);\n      var l = c.call(this, e, \"extractHighlights\", [\"threshold\", \"exposure\"], null, t, i, r, n, o, null, s, void 0, null, a) || this;\n      return l.threshold = .9, l._exposure = 1, l._inputPostProcess = null, l.onApplyObservable.add(function (e) {\n        l._inputPostProcess && e.setTextureFromPostProcess(\"textureSampler\", l._inputPostProcess), e.setFloat(\"threshold\", Math.pow(l.threshold, In.ToGammaSpace)), e.setFloat(\"exposure\", l._exposure);\n      }), l;\n    }\n\n    return T(e, c), e;\n  }(In.PostProcess), In.ExtractHighlightsPostProcess = wn, Ln = $a || ($a = {}), Fn = function (a) {\n    function e(e, t, i, r, n, o) {\n      void 0 === n && (n = 0), void 0 === o && (o = !1);\n      var s = a.call(this, e.getEngine(), \"bloom\", function () {\n        return s._effects;\n      }, !0) || this;\n      return s.bloomScale = t, s._effects = [], s._downscale = new Ln.ExtractHighlightsPostProcess(\"highlights\", 1, null, Ln.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, n, o), s._blurX = new Ln.BlurPostProcess(\"horizontal blur\", new Ln.Vector2(1, 0), 10, t, null, Ln.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, n, void 0, o), s._blurX.alwaysForcePOT = !0, s._blurX.autoClear = !1, s._blurY = new Ln.BlurPostProcess(\"vertical blur\", new Ln.Vector2(0, 1), 10, t, null, Ln.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, n, void 0, o), s._blurY.alwaysForcePOT = !0, s._blurY.autoClear = !1, s.kernel = r, s._effects = [s._downscale, s._blurX, s._blurY], s._merge = new Ln.BloomMergePostProcess(\"bloomMerge\", s._downscale, s._blurY, i, t, null, Ln.Texture.BILINEAR_SAMPLINGMODE, e.getEngine(), !1, n, o), s._merge.autoClear = !1, s._effects.push(s._merge), s;\n    }\n\n    return T(e, a), Object.defineProperty(e.prototype, \"threshold\", {\n      get: function () {\n        return this._downscale.threshold;\n      },\n      set: function (e) {\n        this._downscale.threshold = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"weight\", {\n      get: function () {\n        return this._merge.weight;\n      },\n      set: function (e) {\n        this._merge.weight = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"kernel\", {\n      get: function () {\n        return this._blurX.kernel / this.bloomScale;\n      },\n      set: function (e) {\n        this._blurX.kernel = e * this.bloomScale, this._blurY.kernel = e * this.bloomScale;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.disposeEffects = function (e) {\n      for (var t = 0; t < this._effects.length; t++) this._effects[t].dispose(e);\n    }, e.prototype._updateEffects = function () {\n      for (var e = 0; e < this._effects.length; e++) this._effects[e].updateEffect();\n    }, e.prototype._isReady = function () {\n      for (var e = 0; e < this._effects.length; e++) if (!this._effects[e].isReady()) return !1;\n\n      return !0;\n    }, e;\n  }(Ln.PostProcessRenderEffect), Ln.BloomEffect = Fn, Bn = $a || ($a = {}), Nn = function (l) {\n    function r(e, t, i, r, n) {\n      void 0 === e && (e = \"\"), void 0 === t && (t = !0), void 0 === i && (i = Bn.Engine.LastCreatedScene), void 0 === n && (n = !0);\n      var o = l.call(this, i.getEngine(), e) || this;\n      o._camerasToBeAttached = [], o.SharpenPostProcessId = \"SharpenPostProcessEffect\", o.ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\", o.FxaaPostProcessId = \"FxaaPostProcessEffect\", o.ChromaticAberrationPostProcessId = \"ChromaticAberrationPostProcessEffect\", o.GrainPostProcessId = \"GrainPostProcessEffect\", o._glowLayer = null, o.animations = [], o._imageProcessingConfigurationObserver = null, o._sharpenEnabled = !1, o._bloomEnabled = !1, o._depthOfFieldEnabled = !1, o._depthOfFieldBlurLevel = Bn.DepthOfFieldEffectBlurLevel.Low, o._fxaaEnabled = !1, o._imageProcessingEnabled = !0, o._bloomScale = .5, o._chromaticAberrationEnabled = !1, o._grainEnabled = !1, o._buildAllowed = !0, o._resizeObserver = null, o._hardwareScaleLevel = 1, o._bloomKernel = 64, o._bloomWeight = .15, o._bloomThreshold = .9, o._samples = 1, o._hasCleared = !1, o._prevPostProcess = null, o._prevPrevPostProcess = null, o._depthOfFieldSceneObserver = null, o._cameras = r || i.cameras, o._cameras = o._cameras.slice(), o._camerasToBeAttached = o._cameras.slice(), o._buildAllowed = n, o._scene = i;\n\n      var s = o._scene.getEngine().getCaps();\n\n      o._hdr = t && (s.textureHalfFloatRender || s.textureFloatRender), o._hdr ? s.textureHalfFloatRender ? o._defaultPipelineTextureType = Bn.Engine.TEXTURETYPE_HALF_FLOAT : s.textureFloatRender && (o._defaultPipelineTextureType = Bn.Engine.TEXTURETYPE_FLOAT) : o._defaultPipelineTextureType = Bn.Engine.TEXTURETYPE_UNSIGNED_INT, i.postProcessRenderPipelineManager.addPipeline(o);\n\n      var a = o._scene.getEngine();\n\n      return o.sharpen = new Bn.SharpenPostProcess(\"sharpen\", 1, null, Bn.Texture.BILINEAR_SAMPLINGMODE, a, !1, o._defaultPipelineTextureType, !0), o._sharpenEffect = new Bn.PostProcessRenderEffect(a, o.SharpenPostProcessId, function () {\n        return o.sharpen;\n      }, !0), o.depthOfField = new Bn.DepthOfFieldEffect(o._scene, null, o._depthOfFieldBlurLevel, o._defaultPipelineTextureType, !0), o.bloom = new Bn.BloomEffect(o._scene, o._bloomScale, o._bloomWeight, o.bloomKernel, o._defaultPipelineTextureType, !0), o.chromaticAberration = new Bn.ChromaticAberrationPostProcess(\"ChromaticAberration\", a.getRenderWidth(), a.getRenderHeight(), 1, null, Bn.Texture.BILINEAR_SAMPLINGMODE, a, !1, o._defaultPipelineTextureType, !0), o._chromaticAberrationEffect = new Bn.PostProcessRenderEffect(a, o.ChromaticAberrationPostProcessId, function () {\n        return o.chromaticAberration;\n      }, !0), o.grain = new Bn.GrainPostProcess(\"Grain\", 1, null, Bn.Texture.BILINEAR_SAMPLINGMODE, a, !1, o._defaultPipelineTextureType, !0), o._grainEffect = new Bn.PostProcessRenderEffect(a, o.GrainPostProcessId, function () {\n        return o.grain;\n      }, !0), o._resizeObserver = a.onResizeObservable.add(function () {\n        o._hardwareScaleLevel = a.getHardwareScalingLevel(), o.bloomKernel = o.bloomKernel;\n      }), o._imageProcessingConfigurationObserver = o._scene.imageProcessingConfiguration.onUpdateParameters.add(function () {\n        o.bloom._downscale._exposure = o._scene.imageProcessingConfiguration.exposure;\n      }), o._buildPipeline(), o;\n    }\n\n    return T(r, l), Object.defineProperty(r.prototype, \"sharpenEnabled\", {\n      get: function () {\n        return this._sharpenEnabled;\n      },\n      set: function (e) {\n        this._sharpenEnabled !== e && (this._sharpenEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"bloomKernel\", {\n      get: function () {\n        return this._bloomKernel;\n      },\n      set: function (e) {\n        this._bloomKernel = e, this.bloom.kernel = e / this._hardwareScaleLevel;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"bloomWeight\", {\n      get: function () {\n        return this._bloomWeight;\n      },\n      set: function (e) {\n        this._bloomWeight !== e && (this.bloom.weight = e, this._bloomWeight = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"bloomThreshold\", {\n      get: function () {\n        return this._bloomThreshold;\n      },\n      set: function (e) {\n        this._bloomThreshold !== e && (this.bloom.threshold = e, this._bloomThreshold = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"bloomScale\", {\n      get: function () {\n        return this._bloomScale;\n      },\n      set: function (e) {\n        this._bloomScale !== e && (this._bloomScale = e, this._rebuildBloom(), this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"bloomEnabled\", {\n      get: function () {\n        return this._bloomEnabled;\n      },\n      set: function (e) {\n        this._bloomEnabled !== e && (this._bloomEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype._rebuildBloom = function () {\n      var e = this.bloom;\n      this.bloom = new Bn.BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel, this._defaultPipelineTextureType, !1), this.bloom.threshold = e.threshold;\n\n      for (var t = 0; t < this._cameras.length; t++) e.disposeEffects(this._cameras[t]);\n    }, Object.defineProperty(r.prototype, \"depthOfFieldEnabled\", {\n      get: function () {\n        return this._depthOfFieldEnabled;\n      },\n      set: function (e) {\n        this._depthOfFieldEnabled !== e && (this._depthOfFieldEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"depthOfFieldBlurLevel\", {\n      get: function () {\n        return this._depthOfFieldBlurLevel;\n      },\n      set: function (e) {\n        if (this._depthOfFieldBlurLevel !== e) {\n          this._depthOfFieldBlurLevel = e;\n          var t = this.depthOfField;\n          this.depthOfField = new Bn.DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, !1), this.depthOfField.focalLength = t.focalLength, this.depthOfField.focusDistance = t.focusDistance, this.depthOfField.fStop = t.fStop, this.depthOfField.lensSize = t.lensSize;\n\n          for (var i = 0; i < this._cameras.length; i++) t.disposeEffects(this._cameras[i]);\n\n          this._buildPipeline();\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"fxaaEnabled\", {\n      get: function () {\n        return this._fxaaEnabled;\n      },\n      set: function (e) {\n        this._fxaaEnabled !== e && (this._fxaaEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"samples\", {\n      get: function () {\n        return this._samples;\n      },\n      set: function (e) {\n        this._samples !== e && (this._samples = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"imageProcessingEnabled\", {\n      get: function () {\n        return this._imageProcessingEnabled;\n      },\n      set: function (e) {\n        this._imageProcessingEnabled !== e && (this._imageProcessingEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"glowLayerEnabled\", {\n      get: function () {\n        return null == this._glowLayer;\n      },\n      set: function (e) {\n        e && !this._glowLayer ? this._glowLayer = new Bn.GlowLayer(\"\", this._scene) : !e && this._glowLayer && (this._glowLayer.dispose(), this._glowLayer = null);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"chromaticAberrationEnabled\", {\n      get: function () {\n        return this._chromaticAberrationEnabled;\n      },\n      set: function (e) {\n        this._chromaticAberrationEnabled !== e && (this._chromaticAberrationEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"grainEnabled\", {\n      get: function () {\n        return this._grainEnabled;\n      },\n      set: function (e) {\n        this._grainEnabled !== e && (this._grainEnabled = e, this._buildPipeline());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype.prepare = function () {\n      var e = this._buildAllowed;\n      this._buildAllowed = !0, this._buildPipeline(), this._buildAllowed = e;\n    }, r.prototype._setAutoClearAndTextureSharing = function (e, t) {\n      void 0 === t && (t = !1), this._hasCleared ? e.autoClear = !1 : (e.autoClear = !0, this._scene.autoClear = !1, this._hasCleared = !0), t || (this._prevPrevPostProcess ? e.shareOutputWith(this._prevPrevPostProcess) : e.useOwnOutput(), this._prevPostProcess && (this._prevPrevPostProcess = this._prevPostProcess), this._prevPostProcess = e);\n    }, r.prototype._buildPipeline = function () {\n      var t = this;\n\n      if (this._buildAllowed) {\n        this._scene.autoClear = !0;\n\n        var e = this._scene.getEngine();\n\n        if (this._disposePostProcesses(), null !== this._cameras && (this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras), this._cameras = this._camerasToBeAttached.slice()), this._reset(), this._prevPostProcess = null, this._prevPrevPostProcess = null, this._hasCleared = !1, this.depthOfFieldEnabled) {\n          if (1 < this._cameras.length) {\n            for (var i = 0, r = this._cameras; i < r.length; i++) {\n              var n = r[i];\n              (o = this._scene.enableDepthRenderer(n)).useOnlyInActiveCamera = !0;\n            }\n\n            this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add(function (e) {\n              -1 < t._cameras.indexOf(e.activeCamera) && (t.depthOfField.depthTexture = e.enableDepthRenderer(e.activeCamera).getDepthMap());\n            });\n          } else {\n            this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n\n            var o = this._scene.enableDepthRenderer(this._cameras[0]);\n\n            this.depthOfField.depthTexture = o.getDepthMap();\n          }\n\n          this.depthOfField._isReady() || this.depthOfField._updateEffects(), this.addEffect(this.depthOfField), this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], !0);\n        } else this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n\n        this.bloomEnabled && (this.bloom._isReady() || this.bloom._updateEffects(), this.addEffect(this.bloom), this._setAutoClearAndTextureSharing(this.bloom._effects[0], !0)), this._imageProcessingEnabled && (this.imageProcessing = new Bn.ImageProcessingPostProcess(\"imageProcessing\", 1, null, Bn.Texture.BILINEAR_SAMPLINGMODE, e, !1, this._defaultPipelineTextureType), this._hdr ? (this.addEffect(new Bn.PostProcessRenderEffect(e, this.ImageProcessingPostProcessId, function () {\n          return t.imageProcessing;\n        }, !0)), this._setAutoClearAndTextureSharing(this.imageProcessing)) : this._scene.imageProcessingConfiguration.applyByPostProcess = !1), this.sharpenEnabled && (this.sharpen.isReady() || this.sharpen.updateEffect(), this.addEffect(this._sharpenEffect), this._setAutoClearAndTextureSharing(this.sharpen)), this.grainEnabled && (this.grain.isReady() || this.grain.updateEffect(), this.addEffect(this._grainEffect), this._setAutoClearAndTextureSharing(this.grain)), this.chromaticAberrationEnabled && (this.chromaticAberration.isReady() || this.chromaticAberration.updateEffect(), this.addEffect(this._chromaticAberrationEffect), this._setAutoClearAndTextureSharing(this.chromaticAberration)), this.fxaaEnabled && (this.fxaa = new Bn.FxaaPostProcess(\"fxaa\", 1, null, Bn.Texture.BILINEAR_SAMPLINGMODE, e, !1, this._defaultPipelineTextureType), this.addEffect(new Bn.PostProcessRenderEffect(e, this.FxaaPostProcessId, function () {\n          return t.fxaa;\n        }, !0)), this._setAutoClearAndTextureSharing(this.fxaa, !0)), null !== this._cameras && this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras), !this._enableMSAAOnFirstPostProcess(this.samples) && 1 < this.samples && Bn.Tools.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n      }\n    }, r.prototype._disposePostProcesses = function (e) {\n      void 0 === e && (e = !1);\n\n      for (var t = 0; t < this._cameras.length; t++) {\n        var i = this._cameras[t];\n        this.imageProcessing && this.imageProcessing.dispose(i), this.fxaa && this.fxaa.dispose(i), e && (this.sharpen && this.sharpen.dispose(i), this.depthOfField && (this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver), this.depthOfField.disposeEffects(i)), this.bloom && this.bloom.disposeEffects(i), this.chromaticAberration && this.chromaticAberration.dispose(i), this.grain && this.grain.dispose(i), this._glowLayer && this._glowLayer.dispose());\n      }\n\n      this.imageProcessing = null, this.fxaa = null, e && (this.sharpen = null, this._sharpenEffect = null, this.depthOfField = null, this.bloom = null, this.chromaticAberration = null, this._chromaticAberrationEffect = null, this.grain = null, this._grainEffect = null, this._glowLayer = null);\n    }, r.prototype.addCamera = function (e) {\n      this._camerasToBeAttached.push(e), this._buildPipeline();\n    }, r.prototype.removeCamera = function (e) {\n      var t = this._camerasToBeAttached.indexOf(e);\n\n      this._camerasToBeAttached.splice(t, 1), this._buildPipeline();\n    }, r.prototype.dispose = function () {\n      this._disposePostProcesses(!0), this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras), this._scene.autoClear = !0, this._resizeObserver && (this._scene.getEngine().onResizeObservable.remove(this._resizeObserver), this._resizeObserver = null), this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver), l.prototype.dispose.call(this);\n    }, r.prototype.serialize = function () {\n      var e = Bn.SerializationHelper.Serialize(this);\n      return e.customType = \"DefaultRenderingPipeline\", e;\n    }, r.Parse = function (e, t, i) {\n      return Bn.SerializationHelper.Parse(function () {\n        return new r(e._name, e._name._hdr, t);\n      }, e, t, i);\n    }, b([Bn.serialize()], r.prototype, \"sharpenEnabled\", null), b([Bn.serialize()], r.prototype, \"bloomKernel\", null), b([Bn.serialize()], r.prototype, \"_bloomWeight\", void 0), b([Bn.serialize()], r.prototype, \"_bloomThreshold\", void 0), b([Bn.serialize()], r.prototype, \"_hdr\", void 0), b([Bn.serialize()], r.prototype, \"bloomWeight\", null), b([Bn.serialize()], r.prototype, \"bloomThreshold\", null), b([Bn.serialize()], r.prototype, \"bloomScale\", null), b([Bn.serialize()], r.prototype, \"bloomEnabled\", null), b([Bn.serialize()], r.prototype, \"depthOfFieldEnabled\", null), b([Bn.serialize()], r.prototype, \"depthOfFieldBlurLevel\", null), b([Bn.serialize()], r.prototype, \"fxaaEnabled\", null), b([Bn.serialize()], r.prototype, \"samples\", null), b([Bn.serialize()], r.prototype, \"imageProcessingEnabled\", null), b([Bn.serialize()], r.prototype, \"glowLayerEnabled\", null), b([Bn.serialize()], r.prototype, \"chromaticAberrationEnabled\", null), b([Bn.serialize()], r.prototype, \"grainEnabled\", null), r;\n  }(Bn.PostProcessRenderPipeline), Bn.DefaultRenderingPipeline = Nn, function (c) {\n    var e = function (t) {\n      function e() {\n        var e = t.call(this) || this;\n        return e.IMAGEPROCESSING = !1, e.VIGNETTE = !1, e.VIGNETTEBLENDMODEMULTIPLY = !1, e.VIGNETTEBLENDMODEOPAQUE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = !1, e.SAMPLER3DBGRMAP = !1, e.IMAGEPROCESSINGPOSTPROCESS = !1, e.EXPOSURE = !1, e.rebuild(), e;\n      }\n\n      return T(e, t), e;\n    }(c.MaterialDefines);\n\n    c.ImageProcessingConfigurationDefines = e;\n\n    var t = function () {\n      function i() {\n        this.colorCurves = new c.ColorCurves(), this._colorCurvesEnabled = !1, this._colorGradingEnabled = !1, this._colorGradingWithGreenDepth = !0, this._colorGradingBGR = !0, this._exposure = 1, this._toneMappingEnabled = !1, this._toneMappingType = i.TONEMAPPING_STANDARD, this._contrast = 1, this.vignetteStretch = 0, this.vignetteCentreX = 0, this.vignetteCentreY = 0, this.vignetteWeight = 1.5, this.vignetteColor = new c.Color4(0, 0, 0, 0), this.vignetteCameraFov = .5, this._vignetteBlendMode = i.VIGNETTEMODE_MULTIPLY, this._vignetteEnabled = !1, this._applyByPostProcess = !1, this._isEnabled = !0, this.onUpdateParameters = new c.Observable();\n      }\n\n      return Object.defineProperty(i.prototype, \"colorCurvesEnabled\", {\n        get: function () {\n          return this._colorCurvesEnabled;\n        },\n        set: function (e) {\n          this._colorCurvesEnabled !== e && (this._colorCurvesEnabled = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"colorGradingTexture\", {\n        get: function () {\n          return this._colorGradingTexture;\n        },\n        set: function (e) {\n          this._colorGradingTexture !== e && (this._colorGradingTexture = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"colorGradingEnabled\", {\n        get: function () {\n          return this._colorGradingEnabled;\n        },\n        set: function (e) {\n          this._colorGradingEnabled !== e && (this._colorGradingEnabled = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"colorGradingWithGreenDepth\", {\n        get: function () {\n          return this._colorGradingWithGreenDepth;\n        },\n        set: function (e) {\n          this._colorGradingWithGreenDepth !== e && (this._colorGradingWithGreenDepth = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"colorGradingBGR\", {\n        get: function () {\n          return this._colorGradingBGR;\n        },\n        set: function (e) {\n          this._colorGradingBGR !== e && (this._colorGradingBGR = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"exposure\", {\n        get: function () {\n          return this._exposure;\n        },\n        set: function (e) {\n          this._exposure !== e && (this._exposure = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"toneMappingEnabled\", {\n        get: function () {\n          return this._toneMappingEnabled;\n        },\n        set: function (e) {\n          this._toneMappingEnabled !== e && (this._toneMappingEnabled = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"toneMappingType\", {\n        get: function () {\n          return this._toneMappingType;\n        },\n        set: function (e) {\n          this._toneMappingType !== e && (this._toneMappingType = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"contrast\", {\n        get: function () {\n          return this._contrast;\n        },\n        set: function (e) {\n          this._contrast !== e && (this._contrast = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"vignetteBlendMode\", {\n        get: function () {\n          return this._vignetteBlendMode;\n        },\n        set: function (e) {\n          this._vignetteBlendMode !== e && (this._vignetteBlendMode = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"vignetteEnabled\", {\n        get: function () {\n          return this._vignetteEnabled;\n        },\n        set: function (e) {\n          this._vignetteEnabled !== e && (this._vignetteEnabled = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"applyByPostProcess\", {\n        get: function () {\n          return this._applyByPostProcess;\n        },\n        set: function (e) {\n          this._applyByPostProcess !== e && (this._applyByPostProcess = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i.prototype, \"isEnabled\", {\n        get: function () {\n          return this._isEnabled;\n        },\n        set: function (e) {\n          this._isEnabled !== e && (this._isEnabled = e, this._updateParameters());\n        },\n        enumerable: !0,\n        configurable: !0\n      }), i.prototype._updateParameters = function () {\n        this.onUpdateParameters.notifyObservers(this);\n      }, i.prototype.getClassName = function () {\n        return \"ImageProcessingConfiguration\";\n      }, i.PrepareUniforms = function (e, t) {\n        t.EXPOSURE && e.push(\"exposureLinear\"), t.CONTRAST && e.push(\"contrast\"), t.COLORGRADING && e.push(\"colorTransformSettings\"), t.VIGNETTE && (e.push(\"vInverseScreenSize\"), e.push(\"vignetteSettings1\"), e.push(\"vignetteSettings2\")), t.COLORCURVES && c.ColorCurves.PrepareUniforms(e);\n      }, i.PrepareSamplers = function (e, t) {\n        t.COLORGRADING && e.push(\"txColorTransform\");\n      }, i.prototype.prepareDefines = function (e, t) {\n        if (void 0 === t && (t = !1), t !== this.applyByPostProcess || !this._isEnabled) return e.VIGNETTE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.EXPOSURE = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.IMAGEPROCESSING = !1, void (e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled);\n\n        switch (e.VIGNETTE = this.vignetteEnabled, e.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === i._VIGNETTEMODE_MULTIPLY, e.VIGNETTEBLENDMODEOPAQUE = !e.VIGNETTEBLENDMODEMULTIPLY, e.TONEMAPPING = this.toneMappingEnabled, this._toneMappingType) {\n          case i.TONEMAPPING_ACES:\n            e.TONEMAPPING_ACES = !0;\n        }\n\n        e.CONTRAST = 1 !== this.contrast, e.EXPOSURE = 1 !== this.exposure, e.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves, e.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture, e.COLORGRADING ? e.COLORGRADING3D = this.colorGradingTexture.is3D : e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth, e.SAMPLER3DBGRMAP = this.colorGradingBGR, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess, e.IMAGEPROCESSING = e.VIGNETTE || e.TONEMAPPING || e.CONTRAST || e.EXPOSURE || e.COLORCURVES || e.COLORGRADING;\n      }, i.prototype.isReady = function () {\n        return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();\n      }, i.prototype.bind = function (e, t) {\n        if (void 0 === t && (t = 1), this._colorCurvesEnabled && this.colorCurves && c.ColorCurves.Bind(this.colorCurves, e), this._vignetteEnabled) {\n          var i = 1 / e.getEngine().getRenderWidth(),\n              r = 1 / e.getEngine().getRenderHeight();\n          e.setFloat2(\"vInverseScreenSize\", i, r);\n          var n = Math.tan(.5 * this.vignetteCameraFov),\n              o = n * t,\n              s = Math.sqrt(o * n);\n          o = c.Tools.Mix(o, s, this.vignetteStretch), n = c.Tools.Mix(n, s, this.vignetteStretch), e.setFloat4(\"vignetteSettings1\", o, n, -o * this.vignetteCentreX, -n * this.vignetteCentreY);\n          var a = -2 * this.vignetteWeight;\n          e.setFloat4(\"vignetteSettings2\", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, a);\n        }\n\n        if (e.setFloat(\"exposureLinear\", this.exposure), e.setFloat(\"contrast\", this.contrast), this.colorGradingTexture) {\n          e.setTexture(\"txColorTransform\", this.colorGradingTexture);\n          var l = this.colorGradingTexture.getSize().height;\n          e.setFloat4(\"colorTransformSettings\", (l - 1) / l, .5 / l, l, this.colorGradingTexture.level);\n        }\n      }, i.prototype.clone = function () {\n        return c.SerializationHelper.Clone(function () {\n          return new i();\n        }, this);\n      }, i.prototype.serialize = function () {\n        return c.SerializationHelper.Serialize(this);\n      }, i.Parse = function (e) {\n        return c.SerializationHelper.Parse(function () {\n          return new i();\n        }, e, null, null);\n      }, Object.defineProperty(i, \"VIGNETTEMODE_MULTIPLY\", {\n        get: function () {\n          return this._VIGNETTEMODE_MULTIPLY;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(i, \"VIGNETTEMODE_OPAQUE\", {\n        get: function () {\n          return this._VIGNETTEMODE_OPAQUE;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), i.TONEMAPPING_STANDARD = 0, i.TONEMAPPING_ACES = 1, i._VIGNETTEMODE_MULTIPLY = 0, i._VIGNETTEMODE_OPAQUE = 1, b([c.serializeAsColorCurves()], i.prototype, \"colorCurves\", void 0), b([c.serialize()], i.prototype, \"_colorCurvesEnabled\", void 0), b([c.serializeAsTexture(\"colorGradingTexture\")], i.prototype, \"_colorGradingTexture\", void 0), b([c.serialize()], i.prototype, \"_colorGradingEnabled\", void 0), b([c.serialize()], i.prototype, \"_colorGradingWithGreenDepth\", void 0), b([c.serialize()], i.prototype, \"_colorGradingBGR\", void 0), b([c.serialize()], i.prototype, \"_exposure\", void 0), b([c.serialize()], i.prototype, \"_toneMappingEnabled\", void 0), b([c.serialize()], i.prototype, \"_toneMappingType\", void 0), b([c.serialize()], i.prototype, \"_contrast\", void 0), b([c.serialize()], i.prototype, \"vignetteStretch\", void 0), b([c.serialize()], i.prototype, \"vignetteCentreX\", void 0), b([c.serialize()], i.prototype, \"vignetteCentreY\", void 0), b([c.serialize()], i.prototype, \"vignetteWeight\", void 0), b([c.serializeAsColor4()], i.prototype, \"vignetteColor\", void 0), b([c.serialize()], i.prototype, \"vignetteCameraFov\", void 0), b([c.serialize()], i.prototype, \"_vignetteBlendMode\", void 0), b([c.serialize()], i.prototype, \"_vignetteEnabled\", void 0), b([c.serialize()], i.prototype, \"_applyByPostProcess\", void 0), b([c.serialize()], i.prototype, \"_isEnabled\", void 0), i;\n    }();\n\n    c.ImageProcessingConfiguration = t;\n  }($a || ($a = {})), Vn = $a || ($a = {}), Un = function (r) {\n    function y(e, t) {\n      var i = r.call(this, t) || this;\n      return e && (i._engine = t.getEngine(), i._textureMatrix = Vn.Matrix.Identity(), i.name = e, i.url = e, i.hasAlpha = !1, i.isCube = !1, i.is3D = 1 < i._engine.webGLVersion, i.wrapU = Vn.Texture.CLAMP_ADDRESSMODE, i.wrapV = Vn.Texture.CLAMP_ADDRESSMODE, i.wrapR = Vn.Texture.CLAMP_ADDRESSMODE, i.anisotropicFilteringLevel = 1, i._texture = i._getFromCache(e, !0), i._texture || (t.useDelayedTextureLoading ? i.delayLoadState = Vn.Engine.DELAYLOADSTATE_NOTLOADED : i.loadTexture())), i;\n    }\n\n    return T(y, r), y.prototype.getTextureMatrix = function () {\n      return this._textureMatrix;\n    }, y.prototype.load3dlTexture = function () {\n      var g,\n          v = this._engine;\n      g = 1 === v.webGLVersion ? v.createRawTexture(null, 1, 1, Vn.Engine.TEXTUREFORMAT_RGBA, !1, !1, Vn.Texture.BILINEAR_SAMPLINGMODE) : v.createRawTexture3D(null, 1, 1, 1, Vn.Engine.TEXTUREFORMAT_RGBA, !1, !1, Vn.Texture.BILINEAR_SAMPLINGMODE), this._texture = g;\n\n      var e = function (e) {\n        if (\"string\" == typeof e) {\n          for (var t, i = null, r = null, n = e.split(\"\\n\"), o = 0, s = 0, a = 0, l = 0, c = 0, h = 0; h < n.length; h++) if (t = n[h], y._noneEmptyLineRegex.test(t) && 0 !== t.indexOf(\"#\")) {\n            var u = t.split(\" \");\n\n            if (0 !== o) {\n              if (0 != o) {\n                var d = Math.max(parseInt(u[0]), 0),\n                    f = Math.max(parseInt(u[1]), 0),\n                    p = Math.max(parseInt(u[2]), 0);\n                c = Math.max(d, c), c = Math.max(f, c), c = Math.max(p, c);\n\n                var _ = 4 * (s + l * o + a * o * o);\n\n                r && (r[_ + 0] = d, r[_ + 1] = f, r[_ + 2] = p), ++a % o == 0 && ++l % o == (a = 0) && (s++, l = 0);\n              }\n            } else o = u.length, i = new Uint8Array(o * o * o * 4), r = new Float32Array(o * o * o * 4);\n          }\n\n          if (r && i) for (h = 0; h < r.length; h++) if (0 < h && (h + 1) % 4 == 0) i[h] = 255;else {\n            var m = r[h];\n            i[h] = m / c * 255;\n          }\n          g.is3D ? (g.updateSize(o, o, o), v.updateRawTexture3D(g, i, Vn.Engine.TEXTUREFORMAT_RGBA, !1)) : (g.updateSize(o * o, o), v.updateRawTexture(g, i, Vn.Engine.TEXTUREFORMAT_RGBA, !1));\n        }\n      },\n          t = this.getScene();\n\n      return t ? t._loadFile(this.url, e) : this._engine._loadFile(this.url, e), this._texture;\n    }, y.prototype.loadTexture = function () {\n      this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4 && this.load3dlTexture();\n    }, y.prototype.clone = function () {\n      var e = new y(this.url, this.getScene());\n      return e.level = this.level, e;\n    }, y.prototype.delayLoad = function () {\n      this.delayLoadState === Vn.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = Vn.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, !0), this._texture || this.loadTexture());\n    }, y.Parse = function (e, t, i) {\n      var r = null;\n      return e.name && !e.isRenderTarget && ((r = new y(e.name, t)).name = e.name, r.level = e.level), r;\n    }, y.prototype.serialize = function () {\n      if (!this.name) return null;\n      var e = {};\n      return e.name = this.name, e.level = this.level, e.customType = \"BABYLON.ColorGradingTexture\", e;\n    }, y._noneEmptyLineRegex = /\\S+/, y;\n  }(Vn.BaseTexture), Vn.ColorGradingTexture = Un, zn = $a || ($a = {}), Gn = function () {\n    function d() {\n      this._dirty = !0, this._tempColor = new zn.Color4(0, 0, 0, 0), this._globalCurve = new zn.Color4(0, 0, 0, 0), this._highlightsCurve = new zn.Color4(0, 0, 0, 0), this._midtonesCurve = new zn.Color4(0, 0, 0, 0), this._shadowsCurve = new zn.Color4(0, 0, 0, 0), this._positiveCurve = new zn.Color4(0, 0, 0, 0), this._negativeCurve = new zn.Color4(0, 0, 0, 0), this._globalHue = 30, this._globalDensity = 0, this._globalSaturation = 0, this._globalExposure = 0, this._highlightsHue = 30, this._highlightsDensity = 0, this._highlightsSaturation = 0, this._highlightsExposure = 0, this._midtonesHue = 30, this._midtonesDensity = 0, this._midtonesSaturation = 0, this._midtonesExposure = 0, this._shadowsHue = 30, this._shadowsDensity = 0, this._shadowsSaturation = 0, this._shadowsExposure = 0;\n    }\n\n    return Object.defineProperty(d.prototype, \"globalHue\", {\n      get: function () {\n        return this._globalHue;\n      },\n      set: function (e) {\n        this._globalHue = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"globalDensity\", {\n      get: function () {\n        return this._globalDensity;\n      },\n      set: function (e) {\n        this._globalDensity = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"globalSaturation\", {\n      get: function () {\n        return this._globalSaturation;\n      },\n      set: function (e) {\n        this._globalSaturation = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"globalExposure\", {\n      get: function () {\n        return this._globalExposure;\n      },\n      set: function (e) {\n        this._globalExposure = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"highlightsHue\", {\n      get: function () {\n        return this._highlightsHue;\n      },\n      set: function (e) {\n        this._highlightsHue = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"highlightsDensity\", {\n      get: function () {\n        return this._highlightsDensity;\n      },\n      set: function (e) {\n        this._highlightsDensity = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"highlightsSaturation\", {\n      get: function () {\n        return this._highlightsSaturation;\n      },\n      set: function (e) {\n        this._highlightsSaturation = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"highlightsExposure\", {\n      get: function () {\n        return this._highlightsExposure;\n      },\n      set: function (e) {\n        this._highlightsExposure = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"midtonesHue\", {\n      get: function () {\n        return this._midtonesHue;\n      },\n      set: function (e) {\n        this._midtonesHue = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"midtonesDensity\", {\n      get: function () {\n        return this._midtonesDensity;\n      },\n      set: function (e) {\n        this._midtonesDensity = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"midtonesSaturation\", {\n      get: function () {\n        return this._midtonesSaturation;\n      },\n      set: function (e) {\n        this._midtonesSaturation = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"midtonesExposure\", {\n      get: function () {\n        return this._midtonesExposure;\n      },\n      set: function (e) {\n        this._midtonesExposure = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"shadowsHue\", {\n      get: function () {\n        return this._shadowsHue;\n      },\n      set: function (e) {\n        this._shadowsHue = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"shadowsDensity\", {\n      get: function () {\n        return this._shadowsDensity;\n      },\n      set: function (e) {\n        this._shadowsDensity = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"shadowsSaturation\", {\n      get: function () {\n        return this._shadowsSaturation;\n      },\n      set: function (e) {\n        this._shadowsSaturation = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"shadowsExposure\", {\n      get: function () {\n        return this._shadowsExposure;\n      },\n      set: function (e) {\n        this._shadowsExposure = e, this._dirty = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), d.prototype.getClassName = function () {\n      return \"ColorCurves\";\n    }, d.Bind = function (e, t, i, r, n) {\n      void 0 === i && (i = \"vCameraColorCurvePositive\"), void 0 === r && (r = \"vCameraColorCurveNeutral\"), void 0 === n && (n = \"vCameraColorCurveNegative\"), e._dirty && (e._dirty = !1, e.getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve), e.getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve), e.getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve), e.getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve), e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve), e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)), t && (t.setFloat4(i, e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a), t.setFloat4(r, e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a), t.setFloat4(n, e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a));\n    }, d.PrepareUniforms = function (e) {\n      e.push(\"vCameraColorCurveNeutral\", \"vCameraColorCurvePositive\", \"vCameraColorCurveNegative\");\n    }, d.prototype.getColorGradingDataToRef = function (e, t, i, r, n) {\n      null != e && (e = d.clamp(e, 0, 360), t = d.clamp(t, -100, 100), i = d.clamp(i, -100, 100), r = d.clamp(r, -100, 100), t = d.applyColorGradingSliderNonlinear(t), t *= .5, r = d.applyColorGradingSliderNonlinear(r), t < 0 && (t *= -1, e = (e + 180) % 360), d.fromHSBToRef(e, t, 50 + .25 * r, n), n.scaleToRef(2, n), n.a = 1 + .01 * i);\n    }, d.applyColorGradingSliderNonlinear = function (e) {\n      e /= 100;\n      var t = Math.abs(e);\n      return t = Math.pow(t, 2), e < 0 && (t *= -1), t *= 100;\n    }, d.fromHSBToRef = function (e, t, i, r) {\n      var n = d.clamp(e, 0, 360),\n          o = d.clamp(t / 100, 0, 1),\n          s = d.clamp(i / 100, 0, 1);\n      if (0 === o) r.r = s, r.g = s, r.b = s;else {\n        n /= 60;\n        var a = Math.floor(n),\n            l = n - a,\n            c = s * (1 - o),\n            h = s * (1 - o * l),\n            u = s * (1 - o * (1 - l));\n\n        switch (a) {\n          case 0:\n            r.r = s, r.g = u, r.b = c;\n            break;\n\n          case 1:\n            r.r = h, r.g = s, r.b = c;\n            break;\n\n          case 2:\n            r.r = c, r.g = s, r.b = u;\n            break;\n\n          case 3:\n            r.r = c, r.g = h, r.b = s;\n            break;\n\n          case 4:\n            r.r = u, r.g = c, r.b = s;\n            break;\n\n          default:\n            r.r = s, r.g = c, r.b = h;\n        }\n      }\n      r.a = 1;\n    }, d.clamp = function (e, t, i) {\n      return Math.min(Math.max(e, t), i);\n    }, d.prototype.clone = function () {\n      return zn.SerializationHelper.Clone(function () {\n        return new d();\n      }, this);\n    }, d.prototype.serialize = function () {\n      return zn.SerializationHelper.Serialize(this);\n    }, d.Parse = function (e) {\n      return zn.SerializationHelper.Parse(function () {\n        return new d();\n      }, e, null, null);\n    }, b([zn.serialize()], d.prototype, \"_globalHue\", void 0), b([zn.serialize()], d.prototype, \"_globalDensity\", void 0), b([zn.serialize()], d.prototype, \"_globalSaturation\", void 0), b([zn.serialize()], d.prototype, \"_globalExposure\", void 0), b([zn.serialize()], d.prototype, \"_highlightsHue\", void 0), b([zn.serialize()], d.prototype, \"_highlightsDensity\", void 0), b([zn.serialize()], d.prototype, \"_highlightsSaturation\", void 0), b([zn.serialize()], d.prototype, \"_highlightsExposure\", void 0), b([zn.serialize()], d.prototype, \"_midtonesHue\", void 0), b([zn.serialize()], d.prototype, \"_midtonesDensity\", void 0), b([zn.serialize()], d.prototype, \"_midtonesSaturation\", void 0), b([zn.serialize()], d.prototype, \"_midtonesExposure\", void 0), d;\n  }(), zn.ColorCurves = Gn, kn = $a || ($a = {}), Wn = function (u) {\n    function e(e, t, i, r, n, o, s, a, l, c) {\n      var h = u.call(this, e, \"refraction\", [\"baseColor\", \"depth\", \"colorLevel\"], [\"refractionSampler\"], o, s, a, l, c) || this;\n      return h.color = i, h.depth = r, h.colorLevel = n, h._ownRefractionTexture = !0, h.onActivateObservable.add(function (e) {\n        h._refTexture = h._refTexture || new kn.Texture(t, e.getScene());\n      }), h.onApplyObservable.add(function (e) {\n        e.setColor3(\"baseColor\", h.color), e.setFloat(\"depth\", h.depth), e.setFloat(\"colorLevel\", h.colorLevel), e.setTexture(\"refractionSampler\", h._refTexture);\n      }), h;\n    }\n\n    return T(e, u), Object.defineProperty(e.prototype, \"refractionTexture\", {\n      get: function () {\n        return this._refTexture;\n      },\n      set: function (e) {\n        this._refTexture && this._ownRefractionTexture && this._refTexture.dispose(), this._refTexture = e, this._ownRefractionTexture = !1;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function (e) {\n      this._refTexture && this._ownRefractionTexture && (this._refTexture.dispose(), this._refTexture = null), u.prototype.dispose.call(this, e);\n    }, e;\n  }(kn.PostProcess), kn.RefractionPostProcess = Wn, Hn = $a || ($a = {}), Xn = function (a) {\n    function e(e, t, i, r, n, o) {\n      var s = a.call(this, e, \"blackAndWhite\", [\"degree\"], null, t, i, r, n, o) || this;\n      return s.degree = 1, s.onApplyObservable.add(function (e) {\n        e.setFloat(\"degree\", s.degree);\n      }), s;\n    }\n\n    return T(e, a), e;\n  }(Hn.PostProcess), Hn.BlackAndWhitePostProcess = Xn, jn = $a || ($a = {}), Yn = function (c) {\n    function e(e, t, i, r, n, o, s, a) {\n      void 0 === a && (a = jn.Engine.TEXTURETYPE_UNSIGNED_INT);\n      var l = c.call(this, e, \"convolution\", [\"kernel\", \"screenSize\"], null, i, r, n, o, s, null, a) || this;\n      return l.kernel = t, l.onApply = function (e) {\n        e.setFloat2(\"screenSize\", l.width, l.height), e.setArray(\"kernel\", l.kernel);\n      }, l;\n    }\n\n    return T(e, c), e.EdgeDetect0Kernel = [1, 0, -1, 0, 0, 0, -1, 0, 1], e.EdgeDetect1Kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0], e.EdgeDetect2Kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1], e.SharpenKernel = [0, -1, 0, -1, 5, -1, 0, -1, 0], e.EmbossKernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2], e.GaussianKernel = [0, 1, 0, 1, 1, 1, 0, 1, 0], e;\n  }(jn.PostProcess), jn.ConvolutionPostProcess = Yn, Kn = $a || ($a = {}), Qn = function (l) {\n    function e(e, t, i, r, n, o, s) {\n      var a = l.call(this, e, \"filter\", [\"kernelMatrix\"], null, i, r, n, o, s) || this;\n      return a.kernelMatrix = t, a.onApply = function (e) {\n        e.setMatrix(\"kernelMatrix\", a.kernelMatrix);\n      }, a;\n    }\n\n    return T(e, l), e;\n  }(Kn.PostProcess), Kn.FilterPostProcess = Qn, Zn = $a || ($a = {}), qn = function (h) {\n    function u(e, t, i, r, n, o, s, a, l) {\n      void 0 === n && (n = 100), void 0 === o && (o = Zn.Texture.BILINEAR_SAMPLINGMODE);\n      var c = h.call(this, e, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], t.postProcessRatio || t, i, o, s, a, \"#define NUM_SAMPLES \" + n) || this;\n      return c._screenCoordinates = Zn.Vector2.Zero(), c.customMeshPosition = Zn.Vector3.Zero(), c.useCustomMeshPosition = !1, c.invert = !0, c.excludedMeshes = new Array(), c.exposure = .3, c.decay = .96815, c.weight = .58767, c.density = .926, s = (l = null === i ? l : i.getScene()).getEngine(), c._viewPort = new Zn.Viewport(0, 0, 1, 1).toGlobal(s.getRenderWidth(), s.getRenderHeight()), c.mesh = null !== r ? r : u.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", l), c._createPass(l, t.passRatio || t), c.onActivate = function (e) {\n        c.isSupported || c.dispose(e), c.onActivate = null;\n      }, c.onApplyObservable.add(function (e) {\n        c._updateMeshScreenCoordinates(l), e.setTexture(\"lightScatteringSampler\", c._volumetricLightScatteringRTT), e.setFloat(\"exposure\", c.exposure), e.setFloat(\"decay\", c.decay), e.setFloat(\"weight\", c.weight), e.setFloat(\"density\", c.density), e.setVector2(\"meshPositionOnScreen\", c._screenCoordinates);\n      }), c;\n    }\n\n    return T(u, h), Object.defineProperty(u.prototype, \"useDiffuseColor\", {\n      get: function () {\n        return Zn.Tools.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\"), !1;\n      },\n      set: function (e) {\n        Zn.Tools.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n      },\n      enumerable: !0,\n      configurable: !0\n    }), u.prototype.getClassName = function () {\n      return \"VolumetricLightScatteringPostProcess\";\n    }, u.prototype._isReady = function (e, t) {\n      var i = e.getMesh();\n      if (i === this.mesh && i.material) return i.material.isReady(i);\n      var r = [],\n          n = [Zn.VertexBuffer.PositionKind],\n          o = e.getMaterial();\n      o && (o.needAlphaTesting() && r.push(\"#define ALPHATEST\"), i.isVerticesDataPresent(Zn.VertexBuffer.UVKind) && (n.push(Zn.VertexBuffer.UVKind), r.push(\"#define UV1\")), i.isVerticesDataPresent(Zn.VertexBuffer.UV2Kind) && (n.push(Zn.VertexBuffer.UV2Kind), r.push(\"#define UV2\"))), i.useBones && i.computeBonesUsingShaders ? (n.push(Zn.VertexBuffer.MatricesIndicesKind), n.push(Zn.VertexBuffer.MatricesWeightsKind), r.push(\"#define NUM_BONE_INFLUENCERS \" + i.numBoneInfluencers), r.push(\"#define BonesPerMesh \" + (i.skeleton ? i.skeleton.bones.length + 1 : 0))) : r.push(\"#define NUM_BONE_INFLUENCERS 0\"), t && (r.push(\"#define INSTANCES\"), n.push(\"world0\"), n.push(\"world1\"), n.push(\"world2\"), n.push(\"world3\"));\n      var s = r.join(\"\\n\");\n      return this._cachedDefines !== s && (this._cachedDefines = s, this._volumetricLightScatteringPass = i.getScene().getEngine().createEffect({\n        vertexElement: \"depth\",\n        fragmentElement: \"volumetricLightScatteringPass\"\n      }, n, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], s)), this._volumetricLightScatteringPass.isReady();\n    }, u.prototype.setCustomMeshPosition = function (e) {\n      this.customMeshPosition = e;\n    }, u.prototype.getCustomMeshPosition = function () {\n      return this.customMeshPosition;\n    }, u.prototype.dispose = function (e) {\n      var t = e.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n      -1 !== t && e.getScene().customRenderTargets.splice(t, 1), this._volumetricLightScatteringRTT.dispose(), h.prototype.dispose.call(this, e);\n    }, u.prototype.getPass = function () {\n      return this._volumetricLightScatteringRTT;\n    }, u.prototype._meshExcluded = function (e) {\n      return 0 < this.excludedMeshes.length && -1 !== this.excludedMeshes.indexOf(e);\n    }, u.prototype._createPass = function (c, e) {\n      var h = this,\n          t = c.getEngine();\n      this._volumetricLightScatteringRTT = new Zn.RenderTargetTexture(\"volumetricLightScatteringMap\", {\n        width: t.getRenderWidth() * e,\n        height: t.getRenderHeight() * e\n      }, c, !1, !0, Zn.Engine.TEXTURETYPE_UNSIGNED_INT), this._volumetricLightScatteringRTT.wrapU = Zn.Texture.CLAMP_ADDRESSMODE, this._volumetricLightScatteringRTT.wrapV = Zn.Texture.CLAMP_ADDRESSMODE, this._volumetricLightScatteringRTT.renderList = null, this._volumetricLightScatteringRTT.renderParticles = !1, this._volumetricLightScatteringRTT.ignoreCameraViewport = !0;\n      var i = this.getCamera();\n      i ? i.customRenderTargets.push(this._volumetricLightScatteringRTT) : c.customRenderTargets.push(this._volumetricLightScatteringRTT);\n\n      var r,\n          u = function (e) {\n        var t = e.getRenderingMesh();\n\n        if (!h._meshExcluded(t)) {\n          var i = e.getMaterial();\n\n          if (i) {\n            var r = t.getScene(),\n                n = r.getEngine();\n            n.setState(i.backFaceCulling);\n\n            var o = t._getInstancesRenderList(e._id);\n\n            if (!o.mustReturn) {\n              var s = n.getCaps().instancedArrays && null !== o.visibleInstances[e._id];\n\n              if (h._isReady(e, s)) {\n                var a = h._volumetricLightScatteringPass;\n                if (t === h.mesh && (a = e.effect ? e.effect : i.getEffect()), n.enableEffect(a), t._bind(e, a, Zn.Material.TriangleFillMode), t === h.mesh) i.bind(t.getWorldMatrix(), t);else {\n                  if (h._volumetricLightScatteringPass.setMatrix(\"viewProjection\", r.getTransformMatrix()), i && i.needAlphaTesting()) {\n                    var l = i.getAlphaTestTexture();\n                    h._volumetricLightScatteringPass.setTexture(\"diffuseSampler\", l), l && h._volumetricLightScatteringPass.setMatrix(\"diffuseMatrix\", l.getTextureMatrix());\n                  }\n\n                  t.useBones && t.computeBonesUsingShaders && t.skeleton && h._volumetricLightScatteringPass.setMatrices(\"mBones\", t.skeleton.getTransformMatrices(t));\n                }\n\n                t._processRendering(e, h._volumetricLightScatteringPass, Zn.Material.TriangleFillMode, o, s, function (e, t) {\n                  return a.setMatrix(\"world\", t);\n                });\n              }\n            }\n          }\n        }\n      },\n          n = new Zn.Color4(0, 0, 0, 1);\n\n      this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(function () {\n        r = c.clearColor, c.clearColor = n;\n      }), this._volumetricLightScatteringRTT.onAfterRenderObservable.add(function () {\n        c.clearColor = r;\n      }), this._volumetricLightScatteringRTT.customRenderFunction = function (e, t, i, r) {\n        var n,\n            o = c.getEngine();\n\n        if (r.length) {\n          for (o.setColorWrite(!1), n = 0; n < r.length; n++) u(r.data[n]);\n\n          o.setColorWrite(!0);\n        }\n\n        for (n = 0; n < e.length; n++) u(e.data[n]);\n\n        for (n = 0; n < t.length; n++) u(t.data[n]);\n\n        if (i.length) {\n          for (n = 0; n < i.length; n++) {\n            var s = i.data[n],\n                a = s.getBoundingInfo();\n            a && c.activeCamera && (s._alphaIndex = s.getMesh().alphaIndex, s._distanceToCamera = a.boundingSphere.centerWorld.subtract(c.activeCamera.position).length());\n          }\n\n          var l = i.data.slice(0, i.length);\n\n          for (l.sort(function (e, t) {\n            return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0;\n          }), o.setAlphaMode(Zn.Engine.ALPHA_COMBINE), n = 0; n < l.length; n++) u(l[n]);\n\n          o.setAlphaMode(Zn.Engine.ALPHA_DISABLE);\n        }\n      };\n    }, u.prototype._updateMeshScreenCoordinates = function (e) {\n      var t,\n          i = e.getTransformMatrix();\n      t = this.useCustomMeshPosition ? this.customMeshPosition : this.attachedNode ? this.attachedNode.position : this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n      var r = Zn.Vector3.Project(t, Zn.Matrix.Identity(), i, this._viewPort);\n      this._screenCoordinates.x = r.x / this._viewPort.width, this._screenCoordinates.y = r.y / this._viewPort.height, this.invert && (this._screenCoordinates.y = 1 - this._screenCoordinates.y);\n    }, u.CreateDefaultMesh = function (e, t) {\n      var i = Zn.Mesh.CreatePlane(e, 1, t);\n      i.billboardMode = Zn.AbstractMesh.BILLBOARDMODE_ALL;\n      var r = new Zn.StandardMaterial(e + \"Material\", t);\n      return r.emissiveColor = new Zn.Color3(1, 1, 1), i.material = r, i;\n    }, b([Zn.serializeAsVector3()], u.prototype, \"customMeshPosition\", void 0), b([Zn.serialize()], u.prototype, \"useCustomMeshPosition\", void 0), b([Zn.serialize()], u.prototype, \"invert\", void 0), b([Zn.serializeAsMeshReference()], u.prototype, \"mesh\", void 0), b([Zn.serialize()], u.prototype, \"excludedMeshes\", void 0), b([Zn.serialize()], u.prototype, \"exposure\", void 0), b([Zn.serialize()], u.prototype, \"decay\", void 0), b([Zn.serialize()], u.prototype, \"weight\", void 0), b([Zn.serialize()], u.prototype, \"density\", void 0), u;\n  }(Zn.PostProcess), Zn.VolumetricLightScatteringPostProcess = qn, Jn = $a || ($a = {}), $n = function (l) {\n    function e(e, t, i, r, n, o, s) {\n      var a = l.call(this, e, \"colorCorrection\", null, [\"colorTable\"], i, r, n, o, s) || this;\n      return a._colorTableTexture = new Jn.Texture(t, r.getScene(), !0, !1, Jn.Texture.TRILINEAR_SAMPLINGMODE), a._colorTableTexture.anisotropicFilteringLevel = 1, a._colorTableTexture.wrapU = Jn.Texture.CLAMP_ADDRESSMODE, a._colorTableTexture.wrapV = Jn.Texture.CLAMP_ADDRESSMODE, a.onApply = function (e) {\n        e.setTexture(\"colorTable\", a._colorTableTexture);\n      }, a;\n    }\n\n    return T(e, l), e;\n  }(Jn.PostProcess), Jn.ColorCorrectionPostProcess = $n, function (h) {\n    var u, e;\n    (e = u = h.TonemappingOperator || (h.TonemappingOperator = {}))[e.Hable = 0] = \"Hable\", e[e.Reinhard = 1] = \"Reinhard\", e[e.HejiDawson = 2] = \"HejiDawson\", e[e.Photographic = 3] = \"Photographic\";\n\n    var t = function (c) {\n      function e(e, t, i, r, n, o, s) {\n        void 0 === n && (n = h.Texture.BILINEAR_SAMPLINGMODE), void 0 === s && (s = h.Engine.TEXTURETYPE_UNSIGNED_INT);\n        var a = c.call(this, e, \"tonemap\", [\"_ExposureAdjustment\"], null, 1, r, n, o, !0, null, s) || this;\n        a._operator = t, a.exposureAdjustment = i;\n        var l = \"#define \";\n        return a._operator === u.Hable ? l += \"HABLE_TONEMAPPING\" : a._operator === u.Reinhard ? l += \"REINHARD_TONEMAPPING\" : a._operator === u.HejiDawson ? l += \"OPTIMIZED_HEJIDAWSON_TONEMAPPING\" : a._operator === u.Photographic && (l += \"PHOTOGRAPHIC_TONEMAPPING\"), a.updateEffect(l), a.onApply = function (e) {\n          e.setFloat(\"_ExposureAdjustment\", a.exposureAdjustment);\n        }, a;\n      }\n\n      return T(e, c), e;\n    }(h.PostProcess);\n\n    h.TonemapPostProcess = t;\n  }($a || ($a = {})), eo = $a || ($a = {}), to = function (s) {\n    function e(e, t, i, r, n, o) {\n      return s.call(this, e, \"displayPass\", [\"passSampler\"], [\"passSampler\"], t, i, r, n, o) || this;\n    }\n\n    return T(e, s), e;\n  }(eo.PostProcess), eo.DisplayPassPostProcess = to, io = $a || ($a = {}), ro = function (a) {\n    function e(e, t, i, r, n, o, s) {\n      return void 0 === s && (s = io.Engine.TEXTURETYPE_UNSIGNED_INT), a.call(this, e, \"highlights\", null, null, t, i, r, n, o, null, s) || this;\n    }\n\n    return T(e, a), e;\n  }(io.PostProcess), io.HighlightsPostProcess = ro, no = $a || ($a = {}), oo = function (c) {\n    function e(e, t, i, r, n, o, s, a) {\n      void 0 === i && (i = null), void 0 === s && (s = no.Engine.TEXTURETYPE_UNSIGNED_INT);\n      var l = c.call(this, e, \"imageProcessing\", [], [], t, i, r, n, o, null, s, \"postprocess\", null, !0) || this;\n      return l._fromLinearSpace = !0, l._defines = {\n        IMAGEPROCESSING: !1,\n        VIGNETTE: !1,\n        VIGNETTEBLENDMODEMULTIPLY: !1,\n        VIGNETTEBLENDMODEOPAQUE: !1,\n        TONEMAPPING: !1,\n        TONEMAPPING_ACES: !1,\n        CONTRAST: !1,\n        COLORCURVES: !1,\n        COLORGRADING: !1,\n        COLORGRADING3D: !1,\n        FROMLINEARSPACE: !1,\n        SAMPLER3DGREENDEPTH: !1,\n        SAMPLER3DBGRMAP: !1,\n        IMAGEPROCESSINGPOSTPROCESS: !1,\n        EXPOSURE: !1\n      }, a ? (a.applyByPostProcess = !0, l._attachImageProcessingConfiguration(a, !0), l.fromLinearSpace = !1) : (l._attachImageProcessingConfiguration(null, !0), l.imageProcessingConfiguration.applyByPostProcess = !0), l.onApply = function (e) {\n        l.imageProcessingConfiguration.bind(e, l.aspectRatio);\n      }, l;\n    }\n\n    return T(e, c), Object.defineProperty(e.prototype, \"imageProcessingConfiguration\", {\n      get: function () {\n        return this._imageProcessingConfiguration;\n      },\n      set: function (e) {\n        this._attachImageProcessingConfiguration(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._attachImageProcessingConfiguration = function (e, t) {\n      var i = this;\n\n      if (void 0 === t && (t = !1), e !== this._imageProcessingConfiguration) {\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), e) this._imageProcessingConfiguration = e;else {\n          var r = null,\n              n = this.getEngine(),\n              o = this.getCamera();\n          if (o) r = o.getScene();else if (n && n.scenes) {\n            var s = n.scenes;\n            r = s[s.length - 1];\n          } else r = no.Engine.LastCreatedScene;\n          this._imageProcessingConfiguration = r.imageProcessingConfiguration;\n        }\n        this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function (e) {\n          i._updateParameters();\n        })), t || this._updateParameters();\n      }\n    }, Object.defineProperty(e.prototype, \"colorCurves\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorCurves;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorCurves = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"colorCurvesEnabled\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"colorGradingTexture\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorGradingTexture;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorGradingTexture = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"colorGradingEnabled\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorGradingEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"exposure\", {\n      get: function () {\n        return this.imageProcessingConfiguration.exposure;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.exposure = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"toneMappingEnabled\", {\n      get: function () {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.toneMappingEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"contrast\", {\n      get: function () {\n        return this.imageProcessingConfiguration.contrast;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.contrast = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteStretch\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteStretch;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteStretch = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteCentreX\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteCentreX;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteCentreX = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteCentreY\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteCentreY;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteCentreY = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteWeight\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteWeight;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteWeight = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteColor\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteColor;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteColor = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteCameraFov\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteCameraFov;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteCameraFov = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteBlendMode\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteBlendMode;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteBlendMode = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vignetteEnabled\", {\n      get: function () {\n        return this.imageProcessingConfiguration.vignetteEnabled;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.vignetteEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"fromLinearSpace\", {\n      get: function () {\n        return this._fromLinearSpace;\n      },\n      set: function (e) {\n        this._fromLinearSpace !== e && (this._fromLinearSpace = e, this._updateParameters());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getClassName = function () {\n      return \"ImageProcessingPostProcess\";\n    }, e.prototype._updateParameters = function () {\n      this._defines.FROMLINEARSPACE = this._fromLinearSpace, this.imageProcessingConfiguration.prepareDefines(this._defines, !0);\n      var e = \"\";\n\n      for (var t in this._defines) this._defines[t] && (e += \"#define \" + t + \";\\r\\n\");\n\n      var i = [\"textureSampler\"],\n          r = [\"scale\"];\n      no.ImageProcessingConfiguration && (no.ImageProcessingConfiguration.PrepareSamplers(i, this._defines), no.ImageProcessingConfiguration.PrepareUniforms(r, this._defines)), this.updateEffect(e, r, i);\n    }, e.prototype.dispose = function (e) {\n      c.prototype.dispose.call(this, e), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingConfiguration && (this.imageProcessingConfiguration.applyByPostProcess = !1);\n    }, b([no.serialize()], e.prototype, \"_fromLinearSpace\", void 0), e;\n  }(no.PostProcess), no.ImageProcessingPostProcess = oo, so = $a || ($a = {}), ao = function (l) {\n    function d(e, t, i, r, n, o, s) {\n      void 0 === i && (i = null), void 0 === r && (r = null), void 0 === n && (n = null), void 0 === o && (o = null), void 0 === s && (s = null);\n      var a = l.call(this, e, t.getScene()) || this;\n      return a.name = e, a.children = new Array(), a.animations = new Array(), a._index = null, a._absoluteTransform = new so.Matrix(), a._invertedAbsoluteTransform = new so.Matrix(), a._scalingDeterminant = 1, a._worldTransform = new so.Matrix(), a._needToDecompose = !0, a._needToCompose = !1, a._skeleton = t, a._localMatrix = r ? r.clone() : so.Matrix.Identity(), a._restPose = n || a._localMatrix.clone(), a._baseMatrix = o || a._localMatrix.clone(), a._index = s, t.bones.push(a), a.setParent(i, !1), (o || r) && a._updateDifferenceMatrix(), a;\n    }\n\n    return T(d, l), Object.defineProperty(d.prototype, \"_matrix\", {\n      get: function () {\n        return this._compose(), this._localMatrix;\n      },\n      set: function (e) {\n        this._localMatrix.copyFrom(e), this._needToDecompose = !0;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), d.prototype.getSkeleton = function () {\n      return this._skeleton;\n    }, d.prototype.getParent = function () {\n      return this._parent;\n    }, d.prototype.setParent = function (e, t) {\n      if (void 0 === t && (t = !0), this._parent !== e) {\n        if (this._parent) {\n          var i = this._parent.children.indexOf(this);\n\n          -1 !== i && this._parent.children.splice(i, 1);\n        }\n\n        this._parent = e, this._parent && this._parent.children.push(this), t && this._updateDifferenceMatrix(), this.markAsDirty();\n      }\n    }, d.prototype.getLocalMatrix = function () {\n      return this._compose(), this._localMatrix;\n    }, d.prototype.getBaseMatrix = function () {\n      return this._baseMatrix;\n    }, d.prototype.getRestPose = function () {\n      return this._restPose;\n    }, d.prototype.getWorldMatrix = function () {\n      return this._worldTransform;\n    }, d.prototype.returnToRest = function () {\n      this.updateMatrix(this._restPose.clone());\n    }, d.prototype.getInvertedAbsoluteTransform = function () {\n      return this._invertedAbsoluteTransform;\n    }, d.prototype.getAbsoluteTransform = function () {\n      return this._absoluteTransform;\n    }, Object.defineProperty(d.prototype, \"position\", {\n      get: function () {\n        return this._decompose(), this._localPosition;\n      },\n      set: function (e) {\n        this._decompose(), this._localPosition.copyFrom(e), this._markAsDirtyAndCompose();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"rotation\", {\n      get: function () {\n        return this.getRotation();\n      },\n      set: function (e) {\n        this.setRotation(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"rotationQuaternion\", {\n      get: function () {\n        return this._decompose(), this._localRotation;\n      },\n      set: function (e) {\n        this.setRotationQuaternion(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"scaling\", {\n      get: function () {\n        return this.getScale();\n      },\n      set: function (e) {\n        this.setScale(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(d.prototype, \"animationPropertiesOverride\", {\n      get: function () {\n        return this._skeleton.animationPropertiesOverride;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), d.prototype._decompose = function () {\n      this._needToDecompose && (this._needToDecompose = !1, this._localScaling || (this._localScaling = so.Vector3.Zero(), this._localRotation = so.Quaternion.Zero(), this._localPosition = so.Vector3.Zero()), this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition));\n    }, d.prototype._compose = function () {\n      this._needToCompose && (this._needToCompose = !1, so.Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix));\n    }, d.prototype.updateMatrix = function (e, t, i) {\n      void 0 === t && (t = !0), void 0 === i && (i = !0), this._baseMatrix.copyFrom(e), t && this._updateDifferenceMatrix(), i ? (this._localMatrix.copyFrom(e), this._markAsDirtyAndDecompose()) : this.markAsDirty();\n    }, d.prototype._updateDifferenceMatrix = function (e, t) {\n      if (void 0 === t && (t = !0), e || (e = this._baseMatrix), this._parent ? e.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform) : this._absoluteTransform.copyFrom(e), this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform), t) for (var i = 0; i < this.children.length; i++) this.children[i]._updateDifferenceMatrix();\n      this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\n    }, d.prototype.markAsDirty = function () {\n      this._currentRenderId++, this._childRenderId++, this._skeleton._markAsDirty();\n    }, d.prototype._markAsDirtyAndCompose = function () {\n      this.markAsDirty(), this._needToCompose = !0;\n    }, d.prototype._markAsDirtyAndDecompose = function () {\n      this.markAsDirty(), this._needToDecompose = !0;\n    }, d.prototype.copyAnimationRange = function (e, t, i, r, n) {\n      void 0 === r && (r = !1), void 0 === n && (n = null), 0 === this.animations.length && (this.animations.push(new so.Animation(this.name, \"_matrix\", e.animations[0].framePerSecond, so.Animation.ANIMATIONTYPE_MATRIX, 0)), this.animations[0].setKeys([]));\n      var o = e.animations[0].getRange(t);\n      if (!o) return !1;\n\n      for (var s, a, l, c = o.from, h = o.to, u = e.animations[0].getKeys(), d = e.length, f = e.getParent(), p = this.getParent(), _ = r && f && d && this.length && d !== this.length, m = _ && p && f ? p.length / f.length : 1, g = r && !p && n && (1 !== n.x || 1 !== n.y || 1 !== n.z), v = this.animations[0].getKeys(), y = 0, b = u.length; y < b; y++) (s = u[y]).frame >= c && s.frame <= h && (r ? (l = s.value.clone(), _ ? (a = l.getTranslation(), l.setTranslation(a.scaleInPlace(m))) : g && n ? (a = l.getTranslation(), l.setTranslation(a.multiplyInPlace(n))) : l = s.value) : l = s.value, v.push({\n        frame: s.frame + i,\n        value: l\n      }));\n\n      return this.animations[0].createRange(t, c + i, h + i), !0;\n    }, d.prototype.translate = function (e, t, i) {\n      void 0 === t && (t = so.Space.LOCAL);\n      var r = this.getLocalMatrix();\n      if (t == so.Space.LOCAL) r.m[12] += e.x, r.m[13] += e.y, r.m[14] += e.z;else {\n        var n = null;\n        i && (n = i.getWorldMatrix()), this._skeleton.computeAbsoluteTransforms();\n        var o = d._tmpMats[0],\n            s = d._tmpVecs[0];\n        this._parent && (i && n ? (o.copyFrom(this._parent.getAbsoluteTransform()), o.multiplyToRef(n, o)) : o.copyFrom(this._parent.getAbsoluteTransform())), o.m[12] = 0, o.m[13] = 0, o.m[14] = 0, o.invert(), so.Vector3.TransformCoordinatesToRef(e, o, s), r.m[12] += s.x, r.m[13] += s.y, r.m[14] += s.z;\n      }\n\n      this._markAsDirtyAndDecompose();\n    }, d.prototype.setPosition = function (e, t, i) {\n      void 0 === t && (t = so.Space.LOCAL);\n      var r = this.getLocalMatrix();\n      if (t == so.Space.LOCAL) r.m[12] = e.x, r.m[13] = e.y, r.m[14] = e.z;else {\n        var n = null;\n        i && (n = i.getWorldMatrix()), this._skeleton.computeAbsoluteTransforms();\n        var o = d._tmpMats[0],\n            s = d._tmpVecs[0];\n        this._parent && (i && n ? (o.copyFrom(this._parent.getAbsoluteTransform()), o.multiplyToRef(n, o)) : o.copyFrom(this._parent.getAbsoluteTransform())), o.invert(), so.Vector3.TransformCoordinatesToRef(e, o, s), r.m[12] = s.x, r.m[13] = s.y, r.m[14] = s.z;\n      }\n\n      this._markAsDirtyAndDecompose();\n    }, d.prototype.setAbsolutePosition = function (e, t) {\n      this.setPosition(e, so.Space.WORLD, t);\n    }, d.prototype.scale = function (e, t, i, r) {\n      void 0 === r && (r = !1);\n      var n = this.getLocalMatrix(),\n          o = d._tmpMats[0];\n      so.Matrix.ScalingToRef(e, t, i, o), o.multiplyToRef(n, n), o.invert();\n\n      for (var s = 0, a = this.children; s < a.length; s++) {\n        var l = (u = a[s]).getLocalMatrix();\n        l.multiplyToRef(o, l), l.m[12] *= e, l.m[13] *= t, l.m[14] *= i, u._markAsDirtyAndDecompose();\n      }\n\n      if (this._markAsDirtyAndDecompose(), r) for (var c = 0, h = this.children; c < h.length; c++) {\n        var u;\n        (u = h[c]).scale(e, t, i, r);\n      }\n    }, d.prototype.setScale = function (e) {\n      this._decompose(), this._localScaling.copyFrom(e), this._markAsDirtyAndCompose();\n    }, d.prototype.getScale = function () {\n      return this._decompose(), this._localScaling;\n    }, d.prototype.getScaleToRef = function (e) {\n      this._decompose(), e.copyFrom(this._localScaling);\n    }, d.prototype.setYawPitchRoll = function (e, t, i, r, n) {\n      if (void 0 === r && (r = so.Space.LOCAL), r === so.Space.LOCAL) {\n        var o = d._tmpQuat;\n        return so.Quaternion.RotationYawPitchRollToRef(e, t, i, o), void this.setRotationQuaternion(o, r, n);\n      }\n\n      var s = d._tmpMats[0];\n\n      if (this._getNegativeRotationToRef(s, n)) {\n        var a = d._tmpMats[1];\n        so.Matrix.RotationYawPitchRollToRef(e, t, i, a), s.multiplyToRef(a, a), this._rotateWithMatrix(a, r, n);\n      }\n    }, d.prototype.rotate = function (e, t, i, r) {\n      void 0 === i && (i = so.Space.LOCAL);\n      var n = d._tmpMats[0];\n      n.m[12] = 0, n.m[13] = 0, n.m[14] = 0, so.Matrix.RotationAxisToRef(e, t, n), this._rotateWithMatrix(n, i, r);\n    }, d.prototype.setAxisAngle = function (e, t, i, r) {\n      if (void 0 === i && (i = so.Space.LOCAL), i === so.Space.LOCAL) {\n        var n = d._tmpQuat;\n        return so.Quaternion.RotationAxisToRef(e, t, n), void this.setRotationQuaternion(n, i, r);\n      }\n\n      var o = d._tmpMats[0];\n\n      if (this._getNegativeRotationToRef(o, r)) {\n        var s = d._tmpMats[1];\n        so.Matrix.RotationAxisToRef(e, t, s), o.multiplyToRef(s, s), this._rotateWithMatrix(s, i, r);\n      }\n    }, d.prototype.setRotation = function (e, t, i) {\n      void 0 === t && (t = so.Space.LOCAL), this.setYawPitchRoll(e.y, e.x, e.z, t, i);\n    }, d.prototype.setRotationQuaternion = function (e, t, i) {\n      if (void 0 === t && (t = so.Space.LOCAL), t === so.Space.LOCAL) return this._decompose(), this._localRotation.copyFrom(e), void this._markAsDirtyAndCompose();\n      var r = d._tmpMats[0];\n\n      if (this._getNegativeRotationToRef(r, i)) {\n        var n = d._tmpMats[1];\n        so.Matrix.FromQuaternionToRef(e, n), r.multiplyToRef(n, n), this._rotateWithMatrix(n, t, i);\n      }\n    }, d.prototype.setRotationMatrix = function (e, t, i) {\n      if (void 0 === t && (t = so.Space.LOCAL), t === so.Space.LOCAL) {\n        var r = d._tmpQuat;\n        return so.Quaternion.FromRotationMatrixToRef(e, r), void this.setRotationQuaternion(r, t, i);\n      }\n\n      var n = d._tmpMats[0];\n\n      if (this._getNegativeRotationToRef(n, i)) {\n        var o = d._tmpMats[1];\n        o.copyFrom(e), n.multiplyToRef(e, o), this._rotateWithMatrix(o, t, i);\n      }\n    }, d.prototype._rotateWithMatrix = function (e, t, i) {\n      void 0 === t && (t = so.Space.LOCAL);\n      var r = this.getLocalMatrix(),\n          n = r.m[12],\n          o = r.m[13],\n          s = r.m[14],\n          a = this.getParent(),\n          l = d._tmpMats[3],\n          c = d._tmpMats[4];\n      a && t == so.Space.WORLD ? (i ? (l.copyFrom(i.getWorldMatrix()), a.getAbsoluteTransform().multiplyToRef(l, l)) : l.copyFrom(a.getAbsoluteTransform()), c.copyFrom(l), c.invert(), r.multiplyToRef(l, r), r.multiplyToRef(e, r), r.multiplyToRef(c, r)) : t == so.Space.WORLD && i ? (l.copyFrom(i.getWorldMatrix()), c.copyFrom(l), c.invert(), r.multiplyToRef(l, r), r.multiplyToRef(e, r), r.multiplyToRef(c, r)) : r.multiplyToRef(e, r), r.m[12] = n, r.m[13] = o, r.m[14] = s, this.computeAbsoluteTransforms(), this._markAsDirtyAndDecompose();\n    }, d.prototype._getNegativeRotationToRef = function (e, t) {\n      var i = d._tmpMats[2];\n      return e.copyFrom(this.getAbsoluteTransform()), t && (e.multiplyToRef(t.getWorldMatrix(), e), so.Matrix.ScalingToRef(t.scaling.x, t.scaling.y, t.scaling.z, i)), e.invert(), !isNaN(e.m[0]) && (i.m[0] *= this._scalingDeterminant, e.multiplyToRef(i, e), !0);\n    }, d.prototype.getPosition = function (e, t) {\n      void 0 === e && (e = so.Space.LOCAL), void 0 === t && (t = null);\n      var i = so.Vector3.Zero();\n      return this.getPositionToRef(e, t, i), i;\n    }, d.prototype.getPositionToRef = function (e, t, i) {\n      if (void 0 === e && (e = so.Space.LOCAL), e == so.Space.LOCAL) {\n        var r = this.getLocalMatrix();\n        i.x = r.m[12], i.y = r.m[13], i.z = r.m[14];\n      } else {\n        var n = null;\n        t && (n = t.getWorldMatrix()), this._skeleton.computeAbsoluteTransforms();\n        var o = d._tmpMats[0];\n        t && n ? (o.copyFrom(this.getAbsoluteTransform()), o.multiplyToRef(n, o)) : o = this.getAbsoluteTransform(), i.x = o.m[12], i.y = o.m[13], i.z = o.m[14];\n      }\n    }, d.prototype.getAbsolutePosition = function (e) {\n      void 0 === e && (e = null);\n      var t = so.Vector3.Zero();\n      return this.getPositionToRef(so.Space.WORLD, e, t), t;\n    }, d.prototype.getAbsolutePositionToRef = function (e, t) {\n      this.getPositionToRef(so.Space.WORLD, e, t);\n    }, d.prototype.computeAbsoluteTransforms = function () {\n      if (this._compose(), this._parent) this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);else {\n        this._absoluteTransform.copyFrom(this._localMatrix);\n\n        var e = this._skeleton.getPoseMatrix();\n\n        e && this._absoluteTransform.multiplyToRef(e, this._absoluteTransform);\n      }\n\n      for (var t = this.children, i = t.length, r = 0; r < i; r++) t[r].computeAbsoluteTransforms();\n    }, d.prototype.getDirection = function (e, t) {\n      void 0 === t && (t = null);\n      var i = so.Vector3.Zero();\n      return this.getDirectionToRef(e, t, i), i;\n    }, d.prototype.getDirectionToRef = function (e, t, i) {\n      void 0 === t && (t = null);\n      var r = null;\n      t && (r = t.getWorldMatrix()), this._skeleton.computeAbsoluteTransforms();\n      var n = d._tmpMats[0];\n      n.copyFrom(this.getAbsoluteTransform()), t && r && n.multiplyToRef(r, n), so.Vector3.TransformNormalToRef(e, n, i), i.normalize();\n    }, d.prototype.getRotation = function (e, t) {\n      void 0 === e && (e = so.Space.LOCAL), void 0 === t && (t = null);\n      var i = so.Vector3.Zero();\n      return this.getRotationToRef(e, t, i), i;\n    }, d.prototype.getRotationToRef = function (e, t, i) {\n      void 0 === e && (e = so.Space.LOCAL), void 0 === t && (t = null);\n      var r = d._tmpQuat;\n      this.getRotationQuaternionToRef(e, t, r), r.toEulerAnglesToRef(i);\n    }, d.prototype.getRotationQuaternion = function (e, t) {\n      void 0 === e && (e = so.Space.LOCAL), void 0 === t && (t = null);\n      var i = so.Quaternion.Identity();\n      return this.getRotationQuaternionToRef(e, t, i), i;\n    }, d.prototype.getRotationQuaternionToRef = function (e, t, i) {\n      if (void 0 === e && (e = so.Space.LOCAL), void 0 === t && (t = null), e == so.Space.LOCAL) this._decompose(), i.copyFrom(this._localRotation);else {\n        var r = d._tmpMats[0],\n            n = this.getAbsoluteTransform();\n        t ? n.multiplyToRef(t.getWorldMatrix(), r) : r.copyFrom(n), r.m[0] *= this._scalingDeterminant, r.m[1] *= this._scalingDeterminant, r.m[2] *= this._scalingDeterminant, r.decompose(void 0, i, void 0);\n      }\n    }, d.prototype.getRotationMatrix = function (e, t) {\n      void 0 === e && (e = so.Space.LOCAL);\n      var i = so.Matrix.Identity();\n      return this.getRotationMatrixToRef(e, t, i), i;\n    }, d.prototype.getRotationMatrixToRef = function (e, t, i) {\n      if (void 0 === e && (e = so.Space.LOCAL), e == so.Space.LOCAL) this.getLocalMatrix().getRotationMatrixToRef(i);else {\n        var r = d._tmpMats[0],\n            n = this.getAbsoluteTransform();\n        t ? n.multiplyToRef(t.getWorldMatrix(), r) : r.copyFrom(n), r.m[0] *= this._scalingDeterminant, r.m[1] *= this._scalingDeterminant, r.m[2] *= this._scalingDeterminant, r.getRotationMatrixToRef(i);\n      }\n    }, d.prototype.getAbsolutePositionFromLocal = function (e, t) {\n      void 0 === t && (t = null);\n      var i = so.Vector3.Zero();\n      return this.getAbsolutePositionFromLocalToRef(e, t, i), i;\n    }, d.prototype.getAbsolutePositionFromLocalToRef = function (e, t, i) {\n      void 0 === t && (t = null);\n      var r = null;\n      t && (r = t.getWorldMatrix()), this._skeleton.computeAbsoluteTransforms();\n      var n = d._tmpMats[0];\n      t && r ? (n.copyFrom(this.getAbsoluteTransform()), n.multiplyToRef(r, n)) : n = this.getAbsoluteTransform(), so.Vector3.TransformCoordinatesToRef(e, n, i);\n    }, d.prototype.getLocalPositionFromAbsolute = function (e, t) {\n      void 0 === t && (t = null);\n      var i = so.Vector3.Zero();\n      return this.getLocalPositionFromAbsoluteToRef(e, t, i), i;\n    }, d.prototype.getLocalPositionFromAbsoluteToRef = function (e, t, i) {\n      void 0 === t && (t = null);\n      var r = null;\n      t && (r = t.getWorldMatrix()), this._skeleton.computeAbsoluteTransforms();\n      var n = d._tmpMats[0];\n      n.copyFrom(this.getAbsoluteTransform()), t && r && n.multiplyToRef(r, n), n.invert(), so.Vector3.TransformCoordinatesToRef(e, n, i);\n    }, d._tmpVecs = [so.Vector3.Zero(), so.Vector3.Zero()], d._tmpQuat = so.Quaternion.Identity(), d._tmpMats = [so.Matrix.Identity(), so.Matrix.Identity(), so.Matrix.Identity(), so.Matrix.Identity(), so.Matrix.Identity()], d;\n  }(so.Node), so.Bone = ao, lo = $a || ($a = {}), co = function () {\n    function b(e, t, i) {\n      if (this.targetPosition = lo.Vector3.Zero(), this.poleTargetPosition = lo.Vector3.Zero(), this.poleTargetLocalOffset = lo.Vector3.Zero(), this.poleAngle = 0, this.slerpAmount = 1, this._bone1Quat = lo.Quaternion.Identity(), this._bone1Mat = lo.Matrix.Identity(), this._bone2Ang = Math.PI, this._maxAngle = Math.PI, this._rightHandedSystem = !1, this._bendAxis = lo.Vector3.Right(), this._slerping = !1, this._adjustRoll = 0, this._bone2 = t, this._bone1 = t.getParent(), this._bone1) {\n        this.mesh = e;\n        var r = t.getPosition();\n\n        if (0 < t.getAbsoluteTransform().determinant() && (this._rightHandedSystem = !0, this._bendAxis.x = 0, this._bendAxis.y = 0, this._bendAxis.z = -1, r.x > r.y && r.x > r.z && (this._adjustRoll = .5 * Math.PI, this._bendAxis.z = 1)), this._bone1.length) {\n          var n = this._bone1.getScale(),\n              o = this._bone2.getScale();\n\n          this._bone1Length = this._bone1.length * n.y * this.mesh.scaling.y, this._bone2Length = this._bone2.length * o.y * this.mesh.scaling.y;\n        } else if (this._bone1.children[0]) {\n          e.computeWorldMatrix(!0);\n\n          var s = this._bone2.children[0].getAbsolutePosition(e),\n              a = this._bone2.getAbsolutePosition(e),\n              l = this._bone1.getAbsolutePosition(e);\n\n          this._bone1Length = lo.Vector3.Distance(s, a), this._bone2Length = lo.Vector3.Distance(a, l);\n        }\n\n        this._bone1.getRotationMatrixToRef(lo.Space.WORLD, e, this._bone1Mat), this.maxAngle = Math.PI, i && (i.targetMesh && (this.targetMesh = i.targetMesh, this.targetMesh.computeWorldMatrix(!0)), i.poleTargetMesh ? (this.poleTargetMesh = i.poleTargetMesh, this.poleTargetMesh.computeWorldMatrix(!0)) : i.poleTargetBone ? this.poleTargetBone = i.poleTargetBone : this._bone1.getParent() && (this.poleTargetBone = this._bone1.getParent()), i.poleTargetLocalOffset && this.poleTargetLocalOffset.copyFrom(i.poleTargetLocalOffset), i.poleAngle && (this.poleAngle = i.poleAngle), i.bendAxis && this._bendAxis.copyFrom(i.bendAxis), i.maxAngle && (this.maxAngle = i.maxAngle), i.slerpAmount && (this.slerpAmount = i.slerpAmount));\n      }\n    }\n\n    return Object.defineProperty(b.prototype, \"maxAngle\", {\n      get: function () {\n        return this._maxAngle;\n      },\n      set: function (e) {\n        this._setMaxAngle(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), b.prototype._setMaxAngle = function (e) {\n      e < 0 && (e = 0), (e > Math.PI || null == e) && (e = Math.PI), this._maxAngle = e;\n      var t = this._bone1Length,\n          i = this._bone2Length;\n      this._maxReach = Math.sqrt(t * t + i * i - 2 * t * i * Math.cos(e));\n    }, b.prototype.update = function () {\n      var e = this._bone1;\n\n      if (e) {\n        var t = this.targetPosition,\n            i = this.poleTargetPosition,\n            r = b._tmpMats[0],\n            n = b._tmpMats[1];\n        this.targetMesh && t.copyFrom(this.targetMesh.getAbsolutePosition()), this.poleTargetBone ? this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, i) : this.poleTargetMesh && lo.Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), i);\n        var o = b._tmpVecs[0],\n            s = b._tmpVecs[1],\n            a = b._tmpVecs[2],\n            l = b._tmpVecs[3],\n            c = b._tmpVecs[4],\n            h = b._tmpQuat;\n        e.getAbsolutePositionToRef(this.mesh, o), i.subtractToRef(o, c), 0 == c.x && 0 == c.y && 0 == c.z ? c.y = 1 : c.normalize(), t.subtractToRef(o, l), l.normalize(), lo.Vector3.CrossToRef(l, c, s), s.normalize(), lo.Vector3.CrossToRef(l, s, a), a.normalize(), lo.Matrix.FromXYZAxesToRef(a, l, s, r);\n        var u = this._bone1Length,\n            d = this._bone2Length,\n            f = lo.Vector3.Distance(o, t);\n        0 < this._maxReach && (f = Math.min(this._maxReach, f));\n\n        var p = (d * d + f * f - u * u) / (2 * d * f),\n            _ = (f * f + u * u - d * d) / (2 * f * u);\n\n        1 < p && (p = 1), 1 < _ && (_ = 1), p < -1 && (p = -1), _ < -1 && (_ = -1);\n        var m = Math.acos(p),\n            g = Math.acos(_),\n            v = -m - g;\n        if (this._rightHandedSystem) lo.Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, n), n.multiplyToRef(r, r), lo.Matrix.RotationAxisToRef(this._bendAxis, g, n), n.multiplyToRef(r, r);else {\n          var y = b._tmpVecs[5];\n          y.copyFrom(this._bendAxis), y.x *= -1, lo.Matrix.RotationAxisToRef(y, -g, n), n.multiplyToRef(r, r);\n        }\n        this.poleAngle && (lo.Matrix.RotationAxisToRef(l, this.poleAngle, n), r.multiplyToRef(n, r)), this._bone1 && (this.slerpAmount < 1 ? (this._slerping || lo.Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat), lo.Quaternion.FromRotationMatrixToRef(r, h), lo.Quaternion.SlerpToRef(this._bone1Quat, h, this.slerpAmount, this._bone1Quat), v = this._bone2Ang * (1 - this.slerpAmount) + v * this.slerpAmount, this._bone1.setRotationQuaternion(this._bone1Quat, lo.Space.WORLD, this.mesh), this._slerping = !0) : (this._bone1.setRotationMatrix(r, lo.Space.WORLD, this.mesh), this._bone1Mat.copyFrom(r), this._slerping = !1)), this._bone2.setAxisAngle(this._bendAxis, v, lo.Space.LOCAL), this._bone2Ang = v;\n      }\n    }, b._tmpVecs = [lo.Vector3.Zero(), lo.Vector3.Zero(), lo.Vector3.Zero(), lo.Vector3.Zero(), lo.Vector3.Zero(), lo.Vector3.Zero()], b._tmpQuat = lo.Quaternion.Identity(), b._tmpMats = [lo.Matrix.Identity(), lo.Matrix.Identity()], b;\n  }(), lo.BoneIKController = co, ho = $a || ($a = {}), uo = function () {\n    function C(e, t, i, r) {\n      if (this.upAxis = ho.Vector3.Up(), this.upAxisSpace = ho.Space.LOCAL, this.adjustYaw = 0, this.adjustPitch = 0, this.adjustRoll = 0, this.slerpAmount = 1, this._boneQuat = ho.Quaternion.Identity(), this._slerping = !1, this._firstFrameSkipped = !1, this._fowardAxis = ho.Vector3.Forward(), this.mesh = e, this.bone = t, this.target = i, r && (r.adjustYaw && (this.adjustYaw = r.adjustYaw), r.adjustPitch && (this.adjustPitch = r.adjustPitch), r.adjustRoll && (this.adjustRoll = r.adjustRoll), null != r.maxYaw ? this.maxYaw = r.maxYaw : this.maxYaw = Math.PI, null != r.minYaw ? this.minYaw = r.minYaw : this.minYaw = -Math.PI, null != r.maxPitch ? this.maxPitch = r.maxPitch : this.maxPitch = Math.PI, null != r.minPitch ? this.minPitch = r.minPitch : this.minPitch = -Math.PI, null != r.slerpAmount && (this.slerpAmount = r.slerpAmount), null != r.upAxis && (this.upAxis = r.upAxis), null != r.upAxisSpace && (this.upAxisSpace = r.upAxisSpace), null != r.yawAxis || null != r.pitchAxis)) {\n        var n = ho.Axis.Y,\n            o = ho.Axis.X;\n        null != r.yawAxis && (n = r.yawAxis.clone()).normalize(), null != r.pitchAxis && (o = r.pitchAxis.clone()).normalize();\n        var s = ho.Vector3.Cross(o, n);\n        this._transformYawPitch = ho.Matrix.Identity(), ho.Matrix.FromXYZAxesToRef(o, n, s, this._transformYawPitch), this._transformYawPitchInv = this._transformYawPitch.clone(), this._transformYawPitch.invert();\n      }\n\n      t.getParent() || this.upAxisSpace != ho.Space.BONE || (this.upAxisSpace = ho.Space.LOCAL);\n    }\n\n    return Object.defineProperty(C.prototype, \"minYaw\", {\n      get: function () {\n        return this._minYaw;\n      },\n      set: function (e) {\n        this._minYaw = e, this._minYawSin = Math.sin(e), this._minYawCos = Math.cos(e), null != this._maxYaw && (this._midYawConstraint = .5 * this._getAngleDiff(this._minYaw, this._maxYaw) + this._minYaw, this._yawRange = this._maxYaw - this._minYaw);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(C.prototype, \"maxYaw\", {\n      get: function () {\n        return this._maxYaw;\n      },\n      set: function (e) {\n        this._maxYaw = e, this._maxYawSin = Math.sin(e), this._maxYawCos = Math.cos(e), null != this._minYaw && (this._midYawConstraint = .5 * this._getAngleDiff(this._minYaw, this._maxYaw) + this._minYaw, this._yawRange = this._maxYaw - this._minYaw);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(C.prototype, \"minPitch\", {\n      get: function () {\n        return this._minPitch;\n      },\n      set: function (e) {\n        this._minPitch = e, this._minPitchTan = Math.tan(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(C.prototype, \"maxPitch\", {\n      get: function () {\n        return this._maxPitch;\n      },\n      set: function (e) {\n        this._maxPitch = e, this._maxPitchTan = Math.tan(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), C.prototype.update = function () {\n      if (this.slerpAmount < 1 && !this._firstFrameSkipped) this._firstFrameSkipped = !0;else {\n        var e = this.bone,\n            t = C._tmpVecs[0];\n        e.getAbsolutePositionToRef(this.mesh, t);\n        var i = this.target,\n            r = C._tmpMats[0],\n            n = C._tmpMats[1],\n            o = this.mesh,\n            s = e.getParent(),\n            a = C._tmpVecs[1];\n        a.copyFrom(this.upAxis), this.upAxisSpace == ho.Space.BONE && s ? (this._transformYawPitch && ho.Vector3.TransformCoordinatesToRef(a, this._transformYawPitchInv, a), s.getDirectionToRef(a, this.mesh, a)) : this.upAxisSpace == ho.Space.LOCAL && (o.getDirectionToRef(a, a), 1 == o.scaling.x && 1 == o.scaling.y && 1 == o.scaling.z || a.normalize());\n        var l = !1,\n            c = !1;\n\n        if (this._maxYaw == Math.PI && this._minYaw == -Math.PI || (l = !0), this._maxPitch == Math.PI && this._minPitch == -Math.PI || (c = !0), l || c) {\n          var h = C._tmpMats[2],\n              u = C._tmpMats[3];\n          if (this.upAxisSpace == ho.Space.BONE && 1 == a.y && s) s.getRotationMatrixToRef(ho.Space.WORLD, this.mesh, h);else if (this.upAxisSpace != ho.Space.LOCAL || 1 != a.y || s) {\n            (f = C._tmpVecs[2]).copyFrom(this._fowardAxis), this._transformYawPitch && ho.Vector3.TransformCoordinatesToRef(f, this._transformYawPitchInv, f), s ? s.getDirectionToRef(f, this.mesh, f) : o.getDirectionToRef(f, f);\n            var d = ho.Vector3.Cross(a, f);\n            d.normalize();\n            var f = ho.Vector3.Cross(d, a);\n            ho.Matrix.FromXYZAxesToRef(d, a, f, h);\n          } else h.copyFrom(o.getWorldMatrix());\n          h.invertToRef(u);\n          var p = null;\n\n          if (c) {\n            var _ = C._tmpVecs[3];\n            i.subtractToRef(t, _), ho.Vector3.TransformCoordinatesToRef(_, u, _), p = Math.sqrt(_.x * _.x + _.z * _.z);\n            var m = Math.atan2(_.y, p),\n                g = m;\n            m > this._maxPitch ? (_.y = this._maxPitchTan * p, g = this._maxPitch) : m < this._minPitch && (_.y = this._minPitchTan * p, g = this._minPitch), m != g && (ho.Vector3.TransformCoordinatesToRef(_, h, _), _.addInPlace(t), i = _);\n          }\n\n          if (l) {\n            _ = C._tmpVecs[4];\n            i.subtractToRef(t, _), ho.Vector3.TransformCoordinatesToRef(_, u, _);\n            var v = Math.atan2(_.x, _.z),\n                y = v;\n\n            if ((v > this._maxYaw || v < this._minYaw) && (null == p && (p = Math.sqrt(_.x * _.x + _.z * _.z)), this._yawRange > Math.PI ? this._isAngleBetween(v, this._maxYaw, this._midYawConstraint) ? (_.z = this._maxYawCos * p, _.x = this._maxYawSin * p, y = this._maxYaw) : this._isAngleBetween(v, this._midYawConstraint, this._minYaw) && (_.z = this._minYawCos * p, _.x = this._minYawSin * p, y = this._minYaw) : v > this._maxYaw ? (_.z = this._maxYawCos * p, _.x = this._maxYawSin * p, y = this._maxYaw) : v < this._minYaw && (_.z = this._minYawCos * p, _.x = this._minYawSin * p, y = this._minYaw)), this._slerping && this._yawRange > Math.PI) {\n              var b = C._tmpVecs[8];\n              b.copyFrom(ho.Axis.Z), this._transformYawPitch && ho.Vector3.TransformCoordinatesToRef(b, this._transformYawPitchInv, b);\n              var T = C._tmpMats[4];\n              this._boneQuat.toRotationMatrix(T), this.mesh.getWorldMatrix().multiplyToRef(T, T), ho.Vector3.TransformCoordinatesToRef(b, T, b), ho.Vector3.TransformCoordinatesToRef(b, u, b);\n\n              var E = Math.atan2(b.x, b.z),\n                  x = this._getAngleBetween(E, v);\n\n              if (this._getAngleBetween(E, this._midYawConstraint) < x) {\n                null == p && (p = Math.sqrt(_.x * _.x + _.z * _.z));\n\n                var P = this._getAngleBetween(E, this._maxYaw);\n\n                y = this._getAngleBetween(E, this._minYaw) < P ? E + .75 * Math.PI : E - .75 * Math.PI, _.z = Math.cos(y) * p, _.x = Math.sin(y) * p;\n              }\n            }\n\n            v != y && (ho.Vector3.TransformCoordinatesToRef(_, h, _), _.addInPlace(t), i = _);\n          }\n        }\n\n        var A = C._tmpVecs[5],\n            S = C._tmpVecs[6],\n            M = C._tmpVecs[7],\n            R = C._tmpQuat;\n        i.subtractToRef(t, A), A.normalize(), ho.Vector3.CrossToRef(a, A, S), S.normalize(), ho.Vector3.CrossToRef(A, S, M), M.normalize(), ho.Matrix.FromXYZAxesToRef(S, M, A, r), 0 === S.x && 0 === S.y && 0 === S.z || 0 === M.x && 0 === M.y && 0 === M.z || 0 === A.x && 0 === A.y && 0 === A.z || ((this.adjustYaw || this.adjustPitch || this.adjustRoll) && (ho.Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, n), n.multiplyToRef(r, r)), this.slerpAmount < 1 ? (this._slerping || this.bone.getRotationQuaternionToRef(ho.Space.WORLD, this.mesh, this._boneQuat), this._transformYawPitch && this._transformYawPitch.multiplyToRef(r, r), ho.Quaternion.FromRotationMatrixToRef(r, R), ho.Quaternion.SlerpToRef(this._boneQuat, R, this.slerpAmount, this._boneQuat), this.bone.setRotationQuaternion(this._boneQuat, ho.Space.WORLD, this.mesh), this._slerping = !0) : (this._transformYawPitch && this._transformYawPitch.multiplyToRef(r, r), this.bone.setRotationMatrix(r, ho.Space.WORLD, this.mesh), this._slerping = !1));\n      }\n    }, C.prototype._getAngleDiff = function (e, t) {\n      var i = t - e;\n      return (i %= 2 * Math.PI) > Math.PI ? i -= 2 * Math.PI : i < -Math.PI && (i += 2 * Math.PI), i;\n    }, C.prototype._getAngleBetween = function (e, t) {\n      var i = 0;\n      return (i = (e = (e %= 2 * Math.PI) < 0 ? e + 2 * Math.PI : e) < (t = (t %= 2 * Math.PI) < 0 ? t + 2 * Math.PI : t) ? t - e : e - t) > Math.PI && (i = 2 * Math.PI - i), i;\n    }, C.prototype._isAngleBetween = function (e, t, i) {\n      if (e = (e %= 2 * Math.PI) < 0 ? e + 2 * Math.PI : e, (t = (t %= 2 * Math.PI) < 0 ? t + 2 * Math.PI : t) < (i = (i %= 2 * Math.PI) < 0 ? i + 2 * Math.PI : i)) {\n        if (t < e && e < i) return !0;\n      } else if (i < e && e < t) return !0;\n\n      return !1;\n    }, C._tmpVecs = [ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero(), ho.Vector3.Zero()], C._tmpQuat = ho.Quaternion.Identity(), C._tmpMats = [ho.Matrix.Identity(), ho.Matrix.Identity(), ho.Matrix.Identity(), ho.Matrix.Identity(), ho.Matrix.Identity()], C;\n  }(), ho.BoneLookController = uo, fo = $a || ($a = {}), po = function () {\n    function u(e, t, i) {\n      this.name = e, this.id = t, this.bones = new Array(), this.needInitialSkinMatrix = !1, this._isDirty = !0, this._meshesWithPoseMatrix = new Array(), this._identity = fo.Matrix.Identity(), this._ranges = {}, this._lastAbsoluteTransformsUpdateId = -1, this.doNotSerialize = !1, this._animationPropertiesOverride = null, this.onBeforeComputeObservable = new fo.Observable(), this.bones = [], this._scene = i || fo.Engine.LastCreatedScene, i.skeletons.push(this), this._isDirty = !0;\n    }\n\n    return Object.defineProperty(u.prototype, \"animationPropertiesOverride\", {\n      get: function () {\n        return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride;\n      },\n      set: function (e) {\n        this._animationPropertiesOverride = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), u.prototype.getTransformMatrices = function (e) {\n      return this.needInitialSkinMatrix && e._bonesTransformMatrices ? e._bonesTransformMatrices : (this._transformMatrices || this.prepare(), this._transformMatrices);\n    }, u.prototype.getScene = function () {\n      return this._scene;\n    }, u.prototype.toString = function (e) {\n      var t = \"Name: \" + this.name + \", nBones: \" + this.bones.length;\n\n      if (t += \", nAnimationRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\"), e) {\n        t += \", Ranges: {\";\n        var i = !0;\n\n        for (var r in this._ranges) i && (t += \", \", i = !1), t += r;\n\n        t += \"}\";\n      }\n\n      return t;\n    }, u.prototype.getBoneIndexByName = function (e) {\n      for (var t = 0, i = this.bones.length; t < i; t++) if (this.bones[t].name === e) return t;\n\n      return -1;\n    }, u.prototype.createAnimationRange = function (e, t, i) {\n      if (!this._ranges[e]) {\n        this._ranges[e] = new fo.AnimationRange(e, t, i);\n\n        for (var r = 0, n = this.bones.length; r < n; r++) this.bones[r].animations[0] && this.bones[r].animations[0].createRange(e, t, i);\n      }\n    }, u.prototype.deleteAnimationRange = function (e, t) {\n      void 0 === t && (t = !0);\n\n      for (var i = 0, r = this.bones.length; i < r; i++) this.bones[i].animations[0] && this.bones[i].animations[0].deleteRange(e, t);\n\n      this._ranges[e] = null;\n    }, u.prototype.getAnimationRange = function (e) {\n      return this._ranges[e];\n    }, u.prototype.getAnimationRanges = function () {\n      var e,\n          t = [],\n          i = 0;\n\n      for (e in this._ranges) t[i] = this._ranges[e], i++;\n\n      return t;\n    }, u.prototype.copyAnimationRange = function (e, t, i) {\n      if (void 0 === i && (i = !1), this._ranges[t] || !e.getAnimationRange(t)) return !1;\n      var r,\n          n,\n          o = !0,\n          s = this._getHighestAnimationFrame() + 1,\n          a = {},\n          l = e.bones;\n\n      for (n = 0, r = l.length; n < r; n++) a[l[n].name] = l[n];\n\n      this.bones.length !== l.length && (fo.Tools.Warn(\"copyAnimationRange: this rig has \" + this.bones.length + \" bones, while source as \" + l.length), o = !1);\n      var c = i && this.dimensionsAtRest && e.dimensionsAtRest ? this.dimensionsAtRest.divide(e.dimensionsAtRest) : null;\n\n      for (n = 0, r = this.bones.length; n < r; n++) {\n        var h = this.bones[n].name,\n            u = a[h];\n        u ? o = o && this.bones[n].copyAnimationRange(u, t, s, i, c) : (fo.Tools.Warn(\"copyAnimationRange: not same rig, missing source bone \" + h), o = !1);\n      }\n\n      var d = e.getAnimationRange(t);\n      return d && (this._ranges[t] = new fo.AnimationRange(t, d.from + s, d.to + s)), o;\n    }, u.prototype.returnToRest = function () {\n      for (var e = 0; e < this.bones.length; e++) this.bones[e].returnToRest();\n    }, u.prototype._getHighestAnimationFrame = function () {\n      for (var e = 0, t = 0, i = this.bones.length; t < i; t++) if (this.bones[t].animations[0]) {\n        var r = this.bones[t].animations[0].getHighestFrame();\n        e < r && (e = r);\n      }\n\n      return e;\n    }, u.prototype.beginAnimation = function (e, t, i, r) {\n      var n = this.getAnimationRange(e);\n      return n ? this._scene.beginAnimation(this, n.from, n.to, t, i, r) : null;\n    }, u.prototype._markAsDirty = function () {\n      this._isDirty = !0;\n    }, u.prototype._registerMeshWithPoseMatrix = function (e) {\n      this._meshesWithPoseMatrix.push(e);\n    }, u.prototype._unregisterMeshWithPoseMatrix = function (e) {\n      var t = this._meshesWithPoseMatrix.indexOf(e);\n\n      -1 < t && this._meshesWithPoseMatrix.splice(t, 1);\n    }, u.prototype._computeTransformMatrices = function (e, t) {\n      this.onBeforeComputeObservable.notifyObservers(this);\n\n      for (var i = 0; i < this.bones.length; i++) {\n        var r = this.bones[i],\n            n = r.getParent();\n\n        if (n ? r.getLocalMatrix().multiplyToRef(n.getWorldMatrix(), r.getWorldMatrix()) : t ? r.getLocalMatrix().multiplyToRef(t, r.getWorldMatrix()) : r.getWorldMatrix().copyFrom(r.getLocalMatrix()), -1 !== r._index) {\n          var o = null === r._index ? i : r._index;\n          r.getInvertedAbsoluteTransform().multiplyToArray(r.getWorldMatrix(), e, 16 * o);\n        }\n      }\n\n      this._identity.copyToArray(e, 16 * this.bones.length);\n    }, u.prototype.prepare = function () {\n      if (this._isDirty) {\n        if (this.needInitialSkinMatrix) for (var e = 0; e < this._meshesWithPoseMatrix.length; e++) {\n          var t = this._meshesWithPoseMatrix[e],\n              i = t.getPoseMatrix();\n\n          if (t._bonesTransformMatrices && t._bonesTransformMatrices.length === 16 * (this.bones.length + 1) || (t._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1))), this._synchronizedWithMesh !== t) {\n            this._synchronizedWithMesh = t;\n\n            for (var r = 0; r < this.bones.length; r++) {\n              var n = this.bones[r];\n              if (!n.getParent()) n.getBaseMatrix().multiplyToRef(i, fo.Tmp.Matrix[1]), n._updateDifferenceMatrix(fo.Tmp.Matrix[1]);\n            }\n          }\n\n          this._computeTransformMatrices(t._bonesTransformMatrices, i);\n        } else this._transformMatrices && this._transformMatrices.length === 16 * (this.bones.length + 1) || (this._transformMatrices = new Float32Array(16 * (this.bones.length + 1))), this._computeTransformMatrices(this._transformMatrices, null);\n        this._isDirty = !1, this._scene._activeBones.addCount(this.bones.length, !1);\n      }\n    }, u.prototype.getAnimatables = function () {\n      if (!this._animatables || this._animatables.length !== this.bones.length) {\n        this._animatables = [];\n\n        for (var e = 0; e < this.bones.length; e++) this._animatables.push(this.bones[e]);\n      }\n\n      return this._animatables;\n    }, u.prototype.clone = function (e, t) {\n      var i = new u(e, t || e, this._scene);\n      i.needInitialSkinMatrix = this.needInitialSkinMatrix;\n\n      for (var r = 0; r < this.bones.length; r++) {\n        var n = this.bones[r],\n            o = null,\n            s = n.getParent();\n\n        if (s) {\n          var a = this.bones.indexOf(s);\n          o = i.bones[a];\n        }\n\n        var l = new fo.Bone(n.name, i, o, n.getBaseMatrix().clone(), n.getRestPose().clone());\n        fo.Tools.DeepCopy(n.animations, l.animations);\n      }\n\n      if (this._ranges) for (var c in i._ranges = {}, this._ranges) {\n        var h = this._ranges[c];\n        h && (i._ranges[c] = h.clone());\n      }\n      return this._isDirty = !0, i;\n    }, u.prototype.enableBlending = function (t) {\n      void 0 === t && (t = .01), this.bones.forEach(function (e) {\n        e.animations.forEach(function (e) {\n          e.enableBlending = !0, e.blendingSpeed = t;\n        });\n      });\n    }, u.prototype.dispose = function () {\n      this._meshesWithPoseMatrix = [], this.getScene().stopAnimation(this), this.getScene().removeSkeleton(this);\n    }, u.prototype.serialize = function () {\n      var e = {};\n      e.name = this.name, e.id = this.id, this.dimensionsAtRest && (e.dimensionsAtRest = this.dimensionsAtRest.asArray()), e.bones = [], e.needInitialSkinMatrix = this.needInitialSkinMatrix;\n\n      for (var t = 0; t < this.bones.length; t++) {\n        var i = this.bones[t],\n            r = i.getParent(),\n            n = {\n          parentBoneIndex: r ? this.bones.indexOf(r) : -1,\n          name: i.name,\n          matrix: i.getBaseMatrix().toArray(),\n          rest: i.getRestPose().toArray()\n        };\n\n        for (var o in e.bones.push(n), i.length && (n.length = i.length), i.metadata && (n.metadata = i.metadata), i.animations && 0 < i.animations.length && (n.animation = i.animations[0].serialize()), e.ranges = [], this._ranges) {\n          var s = this._ranges[o];\n\n          if (s) {\n            var a = {};\n            a.name = o, a.from = s.from, a.to = s.to, e.ranges.push(a);\n          }\n        }\n      }\n\n      return e;\n    }, u.Parse = function (e, t) {\n      var i,\n          r = new u(e.name, e.id, t);\n\n      for (e.dimensionsAtRest && (r.dimensionsAtRest = fo.Vector3.FromArray(e.dimensionsAtRest)), r.needInitialSkinMatrix = e.needInitialSkinMatrix, i = 0; i < e.bones.length; i++) {\n        var n = e.bones[i],\n            o = null;\n        -1 < n.parentBoneIndex && (o = r.bones[n.parentBoneIndex]);\n        var s = n.rest ? fo.Matrix.FromArray(n.rest) : null,\n            a = new fo.Bone(n.name, r, o, fo.Matrix.FromArray(n.matrix), s);\n        void 0 !== n.id && null !== n.id && (a.id = n.id), n.length && (a.length = n.length), n.metadata && (a.metadata = n.metadata), n.animation && a.animations.push(fo.Animation.Parse(n.animation));\n      }\n\n      if (e.ranges) for (i = 0; i < e.ranges.length; i++) {\n        var l = e.ranges[i];\n        r.createAnimationRange(l.name, l.from, l.to);\n      }\n      return r;\n    }, u.prototype.computeAbsoluteTransforms = function (e) {\n      void 0 === e && (e = !1);\n\n      var t = this._scene.getRenderId();\n\n      (this._lastAbsoluteTransformsUpdateId != t || e) && (this.bones[0].computeAbsoluteTransforms(), this._lastAbsoluteTransformsUpdateId = t);\n    }, u.prototype.getPoseMatrix = function () {\n      var e = null;\n      return 0 < this._meshesWithPoseMatrix.length && (e = this._meshesWithPoseMatrix[0].getPoseMatrix()), e;\n    }, u.prototype.sortBones = function () {\n      for (var e = new Array(), t = new Array(this.bones.length), i = 0; i < this.bones.length; i++) this._sortBones(i, e, t);\n\n      this.bones = e;\n    }, u.prototype._sortBones = function (e, t, i) {\n      if (!i[e]) {\n        i[e] = !0;\n        var r = this.bones[e];\n        void 0 === r._index && (r._index = e);\n        var n = r.getParent();\n        n && this._sortBones(this.bones.indexOf(n), t, i), t.push(r);\n      }\n    }, u;\n  }(), fo.Skeleton = po, _o = $a || ($a = {}), mo = function () {\n    function e() {}\n\n    return e.Ldexp = function (e, t) {\n      return 1023 < t ? e * Math.pow(2, 1023) * Math.pow(2, t - 1023) : t < -1074 ? e * Math.pow(2, -1074) * Math.pow(2, t + 1074) : e * Math.pow(2, t);\n    }, e.Rgbe2float = function (e, t, i, r, n, o) {\n      0 < n ? (n = this.Ldexp(1, n - 136), e[o + 0] = t * n, e[o + 1] = i * n, e[o + 2] = r * n) : (e[o + 0] = 0, e[o + 1] = 0, e[o + 2] = 0);\n    }, e.readStringLine = function (e, t) {\n      for (var i = \"\", r = \"\", n = t; n < e.length - t && \"\\n\" != (r = String.fromCharCode(e[n])); n++) i += r;\n\n      return i;\n    }, e.RGBE_ReadHeader = function (e) {\n      var t,\n          i,\n          r = this.readStringLine(e, 0);\n      if (\"#\" != r[0] || \"?\" != r[1]) throw \"Bad HDR Format.\";\n\n      for (var n = !1, o = !1, s = 0; s += r.length + 1, \"FORMAT=32-bit_rle_rgbe\" == (r = this.readStringLine(e, s)) ? o = !0 : 0 == r.length && (n = !0), !n;);\n\n      if (!o) throw \"HDR Bad header format, unsupported FORMAT\";\n      s += r.length + 1, r = this.readStringLine(e, s);\n      var a = /^\\-Y (.*) \\+X (.*)$/g.exec(r);\n      if (!a || a.length < 3) throw \"HDR Bad header format, no size\";\n      if (i = parseInt(a[2]), t = parseInt(a[1]), i < 8 || 32767 < i) throw \"HDR Bad header format, unsupported size\";\n      return {\n        height: t,\n        width: i,\n        dataPosition: s += r.length + 1\n      };\n    }, e.GetCubeMapTextureData = function (e, t) {\n      var i = new Uint8Array(e),\n          r = this.RGBE_ReadHeader(i),\n          n = this.RGBE_ReadPixels_RLE(i, r);\n      return _o.PanoramaToCubeMapTools.ConvertPanoramaToCubemap(n, r.width, r.height, t);\n    }, e.RGBE_ReadPixels = function (e, t) {\n      return this.RGBE_ReadPixels_RLE(e, t);\n    }, e.RGBE_ReadPixels_RLE = function (e, t) {\n      for (var i, r, n, o, s, a = t.height, l = t.width, c = t.dataPosition, h = 0, u = 0, d = 0, f = new ArrayBuffer(4 * l), p = new Uint8Array(f), _ = new ArrayBuffer(t.width * t.height * 4 * 3), m = new Float32Array(_); 0 < a;) {\n        if (i = e[c++], r = e[c++], n = e[c++], o = e[c++], 2 != i || 2 != r || 128 & n) throw \"HDR Bad header format, not RLE\";\n        if ((n << 8 | o) != l) throw \"HDR Bad header format, wrong scan line width\";\n\n        for (d = h = 0; d < 4; d++) for (u = (d + 1) * l; h < u;) if (i = e[c++], r = e[c++], 128 < i) {\n          if (0 == (s = i - 128) || u - h < s) throw \"HDR Bad Format, bad scanline data (run)\";\n\n          for (; 0 < s--;) p[h++] = r;\n        } else {\n          if (0 == (s = i) || u - h < s) throw \"HDR Bad Format, bad scanline data (non-run)\";\n          if (p[h++] = r, 0 < --s) for (var g = 0; g < s; g++) p[h++] = e[c++];\n        }\n\n        for (d = 0; d < l; d++) i = p[d], r = p[d + l], n = p[d + 2 * l], o = p[d + 3 * l], this.Rgbe2float(m, i, r, n, o, (t.height - a) * l * 3 + 3 * d);\n\n        a--;\n      }\n\n      return m;\n    }, e;\n  }(), _o.HDRTools = mo, go = $a || ($a = {}), vo = function (h) {\n    function m(e, t, i, r, n, o, s, a, l) {\n      void 0 === r && (r = !1), void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === a && (a = null), void 0 === l && (l = null);\n      var c = h.call(this, t) || this;\n      return c._generateHarmonics = !0, c._onLoad = null, c._onError = null, c.coordinatesMode = go.Texture.CUBIC_MODE, c._isBlocking = !0, c._rotationY = 0, c.boundingBoxPosition = go.Vector3.Zero(), e && (c.name = e, c.url = e, c.hasAlpha = !1, c.isCube = !0, c._textureMatrix = go.Matrix.Identity(), c._onLoad = a, c._onError = l, c.gammaSpace = o, c._noMipmap = r, c._size = i, c._texture = c._getFromCache(e, c._noMipmap), c._texture || (t.useDelayedTextureLoading ? c.delayLoadState = go.Engine.DELAYLOADSTATE_NOTLOADED : c.loadTexture())), c;\n    }\n\n    return T(m, h), Object.defineProperty(m.prototype, \"isBlocking\", {\n      get: function () {\n        return this._isBlocking;\n      },\n      set: function (e) {\n        this._isBlocking = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(m.prototype, \"rotationY\", {\n      get: function () {\n        return this._rotationY;\n      },\n      set: function (e) {\n        this._rotationY = e, this.setReflectionTextureMatrix(go.Matrix.RotationY(this._rotationY));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(m.prototype, \"boundingBoxSize\", {\n      get: function () {\n        return this._boundingBoxSize;\n      },\n      set: function (e) {\n        if (!this._boundingBoxSize || !this._boundingBoxSize.equals(e)) {\n          this._boundingBoxSize = e;\n          var t = this.getScene();\n          t && t.markAllMaterialsAsDirty(go.Material.TextureDirtyFlag);\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), m.prototype.loadTexture = function () {\n      var _ = this,\n          e = this.getScene();\n\n      e && (this._texture = e.getEngine().createRawCubeTextureFromUrl(this.url, e, this._size, go.Engine.TEXTUREFORMAT_RGB, e.getEngine().getCaps().textureFloat ? go.Engine.TEXTURETYPE_FLOAT : go.Engine.TEXTURETYPE_UNSIGNED_INT, this._noMipmap, function (e) {\n        _.lodGenerationOffset = 0, _.lodGenerationScale = .8;\n\n        var t = _.getScene();\n\n        if (!t) return null;\n        var i = go.HDRTools.GetCubeMapTextureData(e, _._size);\n\n        if (_._generateHarmonics) {\n          var r = go.CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(i);\n          _.sphericalPolynomial = r;\n        }\n\n        for (var n = [], o = null, s = 0; s < 6; s++) {\n          if (!t.getEngine().getCaps().textureFloat) {\n            var a = new ArrayBuffer(_._size * _._size * 3);\n            o = new Uint8Array(a);\n          }\n\n          var l = i[m._facesMapping[s]];\n          if (_.gammaSpace || o) for (var c = 0; c < _._size * _._size; c++) if (_.gammaSpace && (l[3 * c + 0] = Math.pow(l[3 * c + 0], go.ToGammaSpace), l[3 * c + 1] = Math.pow(l[3 * c + 1], go.ToGammaSpace), l[3 * c + 2] = Math.pow(l[3 * c + 2], go.ToGammaSpace)), o) {\n            var h = Math.max(255 * l[3 * c + 0], 0),\n                u = Math.max(255 * l[3 * c + 1], 0),\n                d = Math.max(255 * l[3 * c + 2], 0),\n                f = Math.max(Math.max(h, u), d);\n\n            if (255 < f) {\n              var p = 255 / f;\n              h *= p, u *= p, d *= p;\n            }\n\n            o[3 * c + 0] = h, o[3 * c + 1] = u, o[3 * c + 2] = d;\n          }\n          o ? n.push(o) : n.push(l);\n        }\n\n        return n;\n      }, null, this._onLoad, this._onError));\n    }, m.prototype.clone = function () {\n      var e = this.getScene();\n      if (!e) return this;\n      var t = new m(this.url, e, this._size, this._noMipmap, this._generateHarmonics, this.gammaSpace);\n      return t.level = this.level, t.wrapU = this.wrapU, t.wrapV = this.wrapV, t.coordinatesIndex = this.coordinatesIndex, t.coordinatesMode = this.coordinatesMode, t;\n    }, m.prototype.delayLoad = function () {\n      this.delayLoadState === go.Engine.DELAYLOADSTATE_NOTLOADED && (this.delayLoadState = go.Engine.DELAYLOADSTATE_LOADED, this._texture = this._getFromCache(this.url, this._noMipmap), this._texture || this.loadTexture());\n    }, m.prototype.getReflectionTextureMatrix = function () {\n      return this._textureMatrix;\n    }, m.prototype.setReflectionTextureMatrix = function (e) {\n      this._textureMatrix = e;\n    }, m.Parse = function (e, t, i) {\n      var r = null;\n      return e.name && !e.isRenderTarget && ((r = new m(i + e.name, t, e.size, e.noMipmap, e.generateHarmonics, e.useInGammaSpace)).name = e.name, r.hasAlpha = e.hasAlpha, r.level = e.level, r.coordinatesMode = e.coordinatesMode, r.isBlocking = e.isBlocking), r && (e.boundingBoxPosition && (r.boundingBoxPosition = go.Vector3.FromArray(e.boundingBoxPosition)), e.boundingBoxSize && (r.boundingBoxSize = go.Vector3.FromArray(e.boundingBoxSize)), e.rotationY && (r.rotationY = e.rotationY)), r;\n    }, m.prototype.serialize = function () {\n      if (!this.name) return null;\n      var e = {};\n      return e.name = this.name, e.hasAlpha = this.hasAlpha, e.isCube = !0, e.level = this.level, e.size = this._size, e.coordinatesMode = this.coordinatesMode, e.useInGammaSpace = this.gammaSpace, e.generateHarmonics = this._generateHarmonics, e.customType = \"BABYLON.HDRCubeTexture\", e.noMipmap = this._noMipmap, e.isBlocking = this._isBlocking, e.rotationY = this._rotationY, e;\n    }, m._facesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"], m;\n  }(go.BaseTexture), go.HDRCubeTexture = vo, yo = $a || ($a = {}), bo = function () {\n    function e() {}\n\n    return e.ConvertPanoramaToCubemap = function (e, t, i, r) {\n      if (!e) throw \"ConvertPanoramaToCubemap: input cannot be null\";\n      if (e.length != t * i * 3) throw \"ConvertPanoramaToCubemap: input size is wrong\";\n      return {\n        front: this.CreateCubemapTexture(r, this.FACE_FRONT, e, t, i),\n        back: this.CreateCubemapTexture(r, this.FACE_BACK, e, t, i),\n        left: this.CreateCubemapTexture(r, this.FACE_LEFT, e, t, i),\n        right: this.CreateCubemapTexture(r, this.FACE_RIGHT, e, t, i),\n        up: this.CreateCubemapTexture(r, this.FACE_UP, e, t, i),\n        down: this.CreateCubemapTexture(r, this.FACE_DOWN, e, t, i),\n        size: r,\n        type: yo.Engine.TEXTURETYPE_FLOAT,\n        format: yo.Engine.TEXTUREFORMAT_RGB,\n        gammaSpace: !1\n      };\n    }, e.CreateCubemapTexture = function (e, t, i, r, n) {\n      for (var o = new ArrayBuffer(e * e * 4 * 3), s = new Float32Array(o), a = t[1].subtract(t[0]).scale(1 / e), l = t[3].subtract(t[2]).scale(1 / e), c = 1 / e, h = 0, u = 0; u < e; u++) {\n        for (var d = t[0], f = t[2], p = 0; p < e; p++) {\n          var _ = f.subtract(d).scale(h).add(d);\n\n          _.normalize();\n\n          var m = this.CalcProjectionSpherical(_, i, r, n);\n          s[u * e * 3 + 3 * p + 0] = m.r, s[u * e * 3 + 3 * p + 1] = m.g, s[u * e * 3 + 3 * p + 2] = m.b, d = d.add(a), f = f.add(l);\n        }\n\n        h += c;\n      }\n\n      return s;\n    }, e.CalcProjectionSpherical = function (e, t, i, r) {\n      for (var n = Math.atan2(e.z, e.x), o = Math.acos(e.y); n < -Math.PI;) n += 2 * Math.PI;\n\n      for (; n > Math.PI;) n -= 2 * Math.PI;\n\n      var s = n / Math.PI,\n          a = o / Math.PI;\n      s = .5 * s + .5;\n      var l = Math.round(s * i);\n      l < 0 ? l = 0 : i <= l && (l = i - 1);\n      var c = Math.round(a * r);\n      c < 0 ? c = 0 : r <= c && (c = r - 1);\n      var h = r - c - 1;\n      return {\n        r: t[h * i * 3 + 3 * l + 0],\n        g: t[h * i * 3 + 3 * l + 1],\n        b: t[h * i * 3 + 3 * l + 2]\n      };\n    }, e.FACE_FRONT = [new yo.Vector3(-1, -1, -1), new yo.Vector3(1, -1, -1), new yo.Vector3(-1, 1, -1), new yo.Vector3(1, 1, -1)], e.FACE_BACK = [new yo.Vector3(1, -1, 1), new yo.Vector3(-1, -1, 1), new yo.Vector3(1, 1, 1), new yo.Vector3(-1, 1, 1)], e.FACE_RIGHT = [new yo.Vector3(1, -1, -1), new yo.Vector3(1, -1, 1), new yo.Vector3(1, 1, -1), new yo.Vector3(1, 1, 1)], e.FACE_LEFT = [new yo.Vector3(-1, -1, 1), new yo.Vector3(-1, -1, -1), new yo.Vector3(-1, 1, 1), new yo.Vector3(-1, 1, -1)], e.FACE_DOWN = [new yo.Vector3(-1, 1, -1), new yo.Vector3(1, 1, -1), new yo.Vector3(-1, 1, 1), new yo.Vector3(1, 1, 1)], e.FACE_UP = [new yo.Vector3(-1, -1, 1), new yo.Vector3(1, -1, 1), new yo.Vector3(-1, -1, -1), new yo.Vector3(1, -1, -1)], e;\n  }(), yo.PanoramaToCubeMapTools = bo, function (g) {\n    var n = function (r) {\n      function e(e, t) {\n        var i = r.call(this, e.x, e.y) || this;\n        return i.index = t, i;\n      }\n\n      return T(e, r), e;\n    }(g.Vector2),\n        o = function () {\n      function e() {\n        this.elements = new Array();\n      }\n\n      return e.prototype.add = function (e) {\n        var i = this,\n            r = new Array();\n        return e.forEach(function (e) {\n          if (0 === r.length || !e.equalsWithEpsilon(r[0])) {\n            var t = new n(e, i.elements.length);\n            r.push(t), i.elements.push(t);\n          }\n        }), r;\n      }, e.prototype.computeBounds = function () {\n        var t = new g.Vector2(this.elements[0].x, this.elements[0].y),\n            i = new g.Vector2(this.elements[0].x, this.elements[0].y);\n        return this.elements.forEach(function (e) {\n          e.x < t.x ? t.x = e.x : e.x > i.x && (i.x = e.x), e.y < t.y ? t.y = e.y : e.y > i.y && (i.y = e.y);\n        }), {\n          min: t,\n          max: i,\n          width: i.x - t.x,\n          height: i.y - t.y\n        };\n      }, e;\n    }(),\n        e = function () {\n      function e() {}\n\n      return e.Rectangle = function (e, t, i, r) {\n        return [new g.Vector2(e, t), new g.Vector2(i, t), new g.Vector2(i, r), new g.Vector2(e, r)];\n      }, e.Circle = function (e, t, i, r) {\n        void 0 === t && (t = 0), void 0 === i && (i = 0), void 0 === r && (r = 32);\n\n        for (var n = new Array(), o = 0, s = 2 * Math.PI / r, a = 0; a < r; a++) n.push(new g.Vector2(t + Math.cos(o) * e, i + Math.sin(o) * e)), o -= s;\n\n        return n;\n      }, e.Parse = function (e) {\n        var t,\n            i = e.split(/[^-+eE\\.\\d]+/).map(parseFloat).filter(function (e) {\n          return !isNaN(e);\n        }),\n            r = [];\n\n        for (t = 0; t < (2147483646 & i.length); t += 2) r.push(new g.Vector2(i[t], i[t + 1]));\n\n        return r;\n      }, e.StartingAt = function (e, t) {\n        return g.Path2.StartingAt(e, t);\n      }, e;\n    }();\n\n    g.Polygon = e;\n\n    var t = function () {\n      function e(e, t, i) {\n        var r;\n        this._points = new o(), this._outlinepoints = new o(), this._holes = new Array(), this._epoints = new Array(), this._eholes = new Array(), this._name = e, this._scene = i, r = t instanceof g.Path2 ? t.getPoints() : t, this._addToepoint(r), this._points.add(r), this._outlinepoints.add(r), void 0 === m && g.Tools.Warn(\"Earcut was not found, the polygon will not be built.\");\n      }\n\n      return e.prototype._addToepoint = function (e) {\n        for (var t = 0, i = e; t < i.length; t++) {\n          var r = i[t];\n\n          this._epoints.push(r.x, r.y);\n        }\n      }, e.prototype.addHole = function (e) {\n        this._points.add(e);\n\n        var t = new o();\n        return t.add(e), this._holes.push(t), this._eholes.push(this._epoints.length / 2), this._addToepoint(e), this;\n      }, e.prototype.build = function (e, t) {\n        var i = this;\n        void 0 === e && (e = !1), void 0 === t && (t = 0);\n\n        var r = new g.Mesh(this._name, this._scene),\n            n = new Array(),\n            o = new Array(),\n            s = new Array(),\n            a = this._points.computeBounds();\n\n        this._points.elements.forEach(function (e) {\n          n.push(0, 1, 0), o.push(e.x, 0, e.y), s.push((e.x - a.min.x) / a.width, (e.y - a.min.y) / a.height);\n        });\n\n        for (var l = new Array(), c = m(this._epoints, this._eholes, 2), h = 0; h < c.length; h++) l.push(c[h]);\n\n        if (0 < t) {\n          var u = o.length / 3;\n\n          this._points.elements.forEach(function (e) {\n            n.push(0, -1, 0), o.push(e.x, -t, e.y), s.push(1 - (e.x - a.min.x) / a.width, 1 - (e.y - a.min.y) / a.height);\n          });\n\n          var d = l.length;\n\n          for (h = 0; h < d; h += 3) {\n            var f = l[h + 0],\n                p = l[h + 1],\n                _ = l[h + 2];\n            l.push(_ + u), l.push(p + u), l.push(f + u);\n          }\n\n          this.addSide(o, n, s, l, a, this._outlinepoints, t, !1), this._holes.forEach(function (e) {\n            i.addSide(o, n, s, l, a, e, t, !0);\n          });\n        }\n\n        return r.setVerticesData(g.VertexBuffer.PositionKind, o, e), r.setVerticesData(g.VertexBuffer.NormalKind, n, e), r.setVerticesData(g.VertexBuffer.UVKind, s, e), r.setIndices(l), r;\n      }, e.prototype.addSide = function (e, t, i, r, n, o, s, a) {\n        for (var l = e.length / 3, c = 0, h = 0; h < o.elements.length; h++) {\n          var u,\n              d = o.elements[h];\n          u = h + 1 > o.elements.length - 1 ? o.elements[0] : o.elements[h + 1], e.push(d.x, 0, d.y), e.push(d.x, -s, d.y), e.push(u.x, 0, u.y), e.push(u.x, -s, u.y);\n\n          var f = new g.Vector3(d.x, 0, d.y),\n              p = new g.Vector3(u.x, 0, u.y).subtract(f),\n              _ = new g.Vector3(0, 1, 0),\n              m = g.Vector3.Cross(p, _);\n\n          m = m.normalize(), i.push(c / n.width, 0), i.push(c / n.width, 1), c += p.length(), i.push(c / n.width, 0), i.push(c / n.width, 1), a ? (t.push(m.x, m.y, m.z), t.push(m.x, m.y, m.z), t.push(m.x, m.y, m.z), t.push(m.x, m.y, m.z), r.push(l), r.push(l + 2), r.push(l + 1), r.push(l + 1), r.push(l + 2), r.push(l + 3)) : (t.push(-m.x, -m.y, -m.z), t.push(-m.x, -m.y, -m.z), t.push(-m.x, -m.y, -m.z), t.push(-m.x, -m.y, -m.z), r.push(l), r.push(l + 1), r.push(l + 2), r.push(l + 1), r.push(l + 3), r.push(l + 2)), l += 4;\n        }\n      }, e;\n    }();\n\n    g.PolygonMeshBuilder = t;\n  }($a || ($a = {})), To = $a || ($a = {}), Eo = 0, xo = function () {\n    function i(e, t, i) {\n      this.pos = e, this.normal = t, this.uv = i;\n    }\n\n    return i.prototype.clone = function () {\n      return new i(this.pos.clone(), this.normal.clone(), this.uv.clone());\n    }, i.prototype.flip = function () {\n      this.normal = this.normal.scale(-1);\n    }, i.prototype.interpolate = function (e, t) {\n      return new i(To.Vector3.Lerp(this.pos, e.pos, t), To.Vector3.Lerp(this.normal, e.normal, t), To.Vector2.Lerp(this.uv, e.uv, t));\n    }, i;\n  }(), Po = function () {\n    function y(e, t) {\n      this.normal = e, this.w = t;\n    }\n\n    return y.FromPoints = function (e, t, i) {\n      var r = i.subtract(e),\n          n = t.subtract(e);\n      if (0 === r.lengthSquared() || 0 === n.lengthSquared()) return null;\n      var o = To.Vector3.Normalize(To.Vector3.Cross(r, n));\n      return new y(o, To.Vector3.Dot(o, e));\n    }, y.prototype.clone = function () {\n      return new y(this.normal.clone(), this.w);\n    }, y.prototype.flip = function () {\n      this.normal.scaleInPlace(-1), this.w = -this.w;\n    }, y.prototype.splitPolygon = function (e, t, i, r, n) {\n      var o,\n          s,\n          a = 0,\n          l = [];\n\n      for (o = 0; o < e.vertices.length; o++) {\n        var c = (s = To.Vector3.Dot(this.normal, e.vertices[o].pos) - this.w) < -y.EPSILON ? 2 : y.EPSILON < s ? 1 : 0;\n        a |= c, l.push(c);\n      }\n\n      switch (a) {\n        case 0:\n          (0 < To.Vector3.Dot(this.normal, e.plane.normal) ? t : i).push(e);\n          break;\n\n        case 1:\n          r.push(e);\n          break;\n\n        case 2:\n          n.push(e);\n          break;\n\n        case 3:\n          var h,\n              u = [],\n              d = [];\n\n          for (o = 0; o < e.vertices.length; o++) {\n            var f = (o + 1) % e.vertices.length,\n                p = l[o],\n                _ = l[f],\n                m = e.vertices[o],\n                g = e.vertices[f];\n\n            if (2 !== p && u.push(m), 1 !== p && d.push(2 !== p ? m.clone() : m), 3 == (p | _)) {\n              s = (this.w - To.Vector3.Dot(this.normal, m.pos)) / To.Vector3.Dot(this.normal, g.pos.subtract(m.pos));\n              var v = m.interpolate(g, s);\n              u.push(v), d.push(v.clone());\n            }\n          }\n\n          3 <= u.length && (h = new Ao(u, e.shared)).plane && r.push(h), 3 <= d.length && (h = new Ao(d, e.shared)).plane && n.push(h);\n      }\n    }, y.EPSILON = 1e-5, y;\n  }(), Ao = function () {\n    function e(e, t) {\n      this.vertices = e, this.shared = t, this.plane = Po.FromPoints(e[0].pos, e[1].pos, e[2].pos);\n    }\n\n    return e.prototype.clone = function () {\n      return new e(this.vertices.map(function (e) {\n        return e.clone();\n      }), this.shared);\n    }, e.prototype.flip = function () {\n      this.vertices.reverse().map(function (e) {\n        e.flip();\n      }), this.plane.flip();\n    }, e;\n  }(), So = function () {\n    function n(e) {\n      this.plane = null, this.front = null, this.back = null, this.polygons = new Array(), e && this.build(e);\n    }\n\n    return n.prototype.clone = function () {\n      var e = new n();\n      return e.plane = this.plane && this.plane.clone(), e.front = this.front && this.front.clone(), e.back = this.back && this.back.clone(), e.polygons = this.polygons.map(function (e) {\n        return e.clone();\n      }), e;\n    }, n.prototype.invert = function () {\n      for (var e = 0; e < this.polygons.length; e++) this.polygons[e].flip();\n\n      this.plane && this.plane.flip(), this.front && this.front.invert(), this.back && this.back.invert();\n      var t = this.front;\n      this.front = this.back, this.back = t;\n    }, n.prototype.clipPolygons = function (e) {\n      if (!this.plane) return e.slice();\n\n      for (var t = new Array(), i = new Array(), r = 0; r < e.length; r++) this.plane.splitPolygon(e[r], t, i, t, i);\n\n      return this.front && (t = this.front.clipPolygons(t)), i = this.back ? this.back.clipPolygons(i) : [], t.concat(i);\n    }, n.prototype.clipTo = function (e) {\n      this.polygons = e.clipPolygons(this.polygons), this.front && this.front.clipTo(e), this.back && this.back.clipTo(e);\n    }, n.prototype.allPolygons = function () {\n      var e = this.polygons.slice();\n      return this.front && (e = e.concat(this.front.allPolygons())), this.back && (e = e.concat(this.back.allPolygons())), e;\n    }, n.prototype.build = function (e) {\n      if (e.length) {\n        this.plane || (this.plane = e[0].plane.clone());\n\n        for (var t = new Array(), i = new Array(), r = 0; r < e.length; r++) this.plane.splitPolygon(e[r], this.polygons, this.polygons, t, i);\n\n        t.length && (this.front || (this.front = new n()), this.front.build(t)), i.length && (this.back || (this.back = new n()), this.back.build(i));\n      }\n    }, n;\n  }(), Mo = function () {\n    function S() {\n      this.polygons = new Array();\n    }\n\n    return S.FromMesh = function (e) {\n      var t,\n          i,\n          r,\n          n,\n          o,\n          s,\n          a,\n          l,\n          c,\n          h,\n          u = new Array(),\n          d = null;\n      if (!(e instanceof To.Mesh)) throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\n      e.computeWorldMatrix(!0), a = e.getWorldMatrix(), l = e.position.clone(), c = e.rotation.clone(), e.rotationQuaternion && (d = e.rotationQuaternion.clone()), h = e.scaling.clone();\n\n      for (var f = e.getIndices(), p = e.getVerticesData(To.VertexBuffer.PositionKind), _ = e.getVerticesData(To.VertexBuffer.NormalKind), m = e.getVerticesData(To.VertexBuffer.UVKind), g = e.subMeshes, v = 0, y = g.length; v < y; v++) for (var b = g[v].indexStart, T = g[v].indexCount + g[v].indexStart; b < T; b += 3) {\n        s = [];\n\n        for (var E = 0; E < 3; E++) {\n          var x = new To.Vector3(_[3 * f[b + E]], _[3 * f[b + E] + 1], _[3 * f[b + E] + 2]);\n          r = new To.Vector2(m[2 * f[b + E]], m[2 * f[b + E] + 1]);\n          var P = new To.Vector3(p[3 * f[b + E]], p[3 * f[b + E] + 1], p[3 * f[b + E] + 2]);\n          n = To.Vector3.TransformCoordinates(P, a), i = To.Vector3.TransformNormal(x, a), t = new xo(n, i, r), s.push(t);\n        }\n\n        (o = new Ao(s, {\n          subMeshId: v,\n          meshId: Eo,\n          materialIndex: g[v].materialIndex\n        })).plane && u.push(o);\n      }\n\n      var A = S.FromPolygons(u);\n      return A.matrix = a, A.position = l, A.rotation = c, A.scaling = h, A.rotationQuaternion = d, Eo++, A;\n    }, S.FromPolygons = function (e) {\n      var t = new S();\n      return t.polygons = e, t;\n    }, S.prototype.clone = function () {\n      var e = new S();\n      return e.polygons = this.polygons.map(function (e) {\n        return e.clone();\n      }), e.copyTransformAttributes(this), e;\n    }, S.prototype.union = function (e) {\n      var t = new So(this.clone().polygons),\n          i = new So(e.clone().polygons);\n      return t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), S.FromPolygons(t.allPolygons()).copyTransformAttributes(this);\n    }, S.prototype.unionInPlace = function (e) {\n      var t = new So(this.polygons),\n          i = new So(e.polygons);\n      t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), this.polygons = t.allPolygons();\n    }, S.prototype.subtract = function (e) {\n      var t = new So(this.clone().polygons),\n          i = new So(e.clone().polygons);\n      return t.invert(), t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), t.invert(), S.FromPolygons(t.allPolygons()).copyTransformAttributes(this);\n    }, S.prototype.subtractInPlace = function (e) {\n      var t = new So(this.polygons),\n          i = new So(e.polygons);\n      t.invert(), t.clipTo(i), i.clipTo(t), i.invert(), i.clipTo(t), i.invert(), t.build(i.allPolygons()), t.invert(), this.polygons = t.allPolygons();\n    }, S.prototype.intersect = function (e) {\n      var t = new So(this.clone().polygons),\n          i = new So(e.clone().polygons);\n      return t.invert(), i.clipTo(t), i.invert(), t.clipTo(i), i.clipTo(t), t.build(i.allPolygons()), t.invert(), S.FromPolygons(t.allPolygons()).copyTransformAttributes(this);\n    }, S.prototype.intersectInPlace = function (e) {\n      var t = new So(this.polygons),\n          i = new So(e.polygons);\n      t.invert(), i.clipTo(t), i.invert(), t.clipTo(i), i.clipTo(t), t.build(i.allPolygons()), t.invert(), this.polygons = t.allPolygons();\n    }, S.prototype.inverse = function () {\n      var e = this.clone();\n      return e.inverseInPlace(), e;\n    }, S.prototype.inverseInPlace = function () {\n      this.polygons.map(function (e) {\n        e.flip();\n      });\n    }, S.prototype.copyTransformAttributes = function (e) {\n      return this.matrix = e.matrix, this.position = e.position, this.rotation = e.rotation, this.scaling = e.scaling, this.rotationQuaternion = e.rotationQuaternion, this;\n    }, S.prototype.buildMeshGeometry = function (e, t, i) {\n      var r = this.matrix.clone();\n      r.invert();\n      var n,\n          o,\n          s,\n          a = new To.Mesh(e, t),\n          l = [],\n          c = [],\n          h = [],\n          u = [],\n          d = To.Vector3.Zero(),\n          f = To.Vector3.Zero(),\n          p = To.Vector2.Zero(),\n          _ = this.polygons,\n          m = [0, 0, 0],\n          g = {},\n          v = 0,\n          y = {};\n      i && _.sort(function (e, t) {\n        return e.shared.meshId === t.shared.meshId ? e.shared.subMeshId - t.shared.subMeshId : e.shared.meshId - t.shared.meshId;\n      });\n\n      for (var b = 0, T = _.length; b < T; b++) {\n        y[(n = _[b]).shared.meshId] || (y[n.shared.meshId] = {}), y[n.shared.meshId][n.shared.subMeshId] || (y[n.shared.meshId][n.shared.subMeshId] = {\n          indexStart: 1 / 0,\n          indexEnd: -1 / 0,\n          materialIndex: n.shared.materialIndex\n        }), s = y[n.shared.meshId][n.shared.subMeshId];\n\n        for (var E = 2, x = n.vertices.length; E < x; E++) {\n          m[0] = 0, m[1] = E - 1, m[2] = E;\n\n          for (var P = 0; P < 3; P++) {\n            d.copyFrom(n.vertices[m[P]].pos), f.copyFrom(n.vertices[m[P]].normal), p.copyFrom(n.vertices[m[P]].uv);\n            var A = To.Vector3.TransformCoordinates(d, r),\n                S = To.Vector3.TransformNormal(f, r);\n            void 0 !== (o = g[A.x + \",\" + A.y + \",\" + A.z]) && h[3 * o] === S.x && h[3 * o + 1] === S.y && h[3 * o + 2] === S.z && u[2 * o] === p.x && u[2 * o + 1] === p.y || (l.push(A.x, A.y, A.z), u.push(p.x, p.y), h.push(f.x, f.y, f.z), o = g[A.x + \",\" + A.y + \",\" + A.z] = l.length / 3 - 1), c.push(o), s.indexStart = Math.min(v, s.indexStart), s.indexEnd = Math.max(v, s.indexEnd), v++;\n          }\n        }\n      }\n\n      if (a.setVerticesData(To.VertexBuffer.PositionKind, l), a.setVerticesData(To.VertexBuffer.NormalKind, h), a.setVerticesData(To.VertexBuffer.UVKind, u), a.setIndices(c, null), i) {\n        var M,\n            R = 0;\n\n        for (var C in a.subMeshes = new Array(), y) {\n          for (var O in M = -1, y[C]) s = y[C][O], To.SubMesh.CreateFromIndices(s.materialIndex + R, s.indexStart, s.indexEnd - s.indexStart + 1, a), M = Math.max(s.materialIndex, M);\n\n          R += ++M;\n        }\n      }\n\n      return a;\n    }, S.prototype.toMesh = function (e, t, i, r) {\n      var n = this.buildMeshGeometry(e, i, r);\n      return n.material = t, n.position.copyFrom(this.position), n.rotation.copyFrom(this.rotation), this.rotationQuaternion && (n.rotationQuaternion = this.rotationQuaternion.clone()), n.scaling.copyFrom(this.scaling), n.computeWorldMatrix(!0), n;\n    }, S;\n  }(), To.CSG = Mo, Ro = $a || ($a = {}), Co = function () {\n    function o(e, t, i, r, n) {\n      this.size = e, this.position = t, this.alphaMode = Ro.Engine.ALPHA_ONEONE, this.color = i || new Ro.Color3(1, 1, 1), this.texture = r ? new Ro.Texture(r, n.getScene(), !0) : null, (this._system = n).lensFlares.push(this);\n    }\n\n    return o.AddFlare = function (e, t, i, r, n) {\n      return new o(e, t, i, r, n);\n    }, o.prototype.dispose = function () {\n      this.texture && this.texture.dispose();\n\n      var e = this._system.lensFlares.indexOf(this);\n\n      this._system.lensFlares.splice(e, 1);\n    }, o;\n  }(), Ro.LensFlare = Co, function (l) {\n    l.AbstractScene.AddParser(l.SceneComponentConstants.NAME_LENSFLARESYSTEM, function (e, t, i, r) {\n      if (void 0 !== e.lensFlareSystems && null !== e.lensFlareSystems) {\n        i.lensFlareSystems || (i.lensFlareSystems = new Array());\n\n        for (var n = 0, o = e.lensFlareSystems.length; n < o; n++) {\n          var s = e.lensFlareSystems[n],\n              a = l.LensFlareSystem.Parse(s, t, r);\n          i.lensFlareSystems.push(a);\n        }\n      }\n    }), l.AbstractScene.prototype.getLensFlareSystemByName = function (e) {\n      for (var t = 0; t < this.lensFlareSystems.length; t++) if (this.lensFlareSystems[t].name === e) return this.lensFlareSystems[t];\n\n      return null;\n    }, l.AbstractScene.prototype.getLensFlareSystemByID = function (e) {\n      for (var t = 0; t < this.lensFlareSystems.length; t++) if (this.lensFlareSystems[t].id === e) return this.lensFlareSystems[t];\n\n      return null;\n    }, l.AbstractScene.prototype.removeLensFlareSystem = function (e) {\n      var t = this.lensFlareSystems.indexOf(e);\n      return -1 !== t && this.lensFlareSystems.splice(t, 1), t;\n    }, l.AbstractScene.prototype.addLensFlareSystem = function (e) {\n      this.lensFlareSystems.push(e);\n    };\n\n    var e = function () {\n      function e(e) {\n        this.name = l.SceneComponentConstants.NAME_LENSFLARESYSTEM, (this.scene = e).lensFlareSystems = new Array();\n      }\n\n      return e.prototype.register = function () {\n        this.scene._afterCameraDrawStage.registerStep(l.SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM, this, this._draw);\n      }, e.prototype.rebuild = function () {}, e.prototype.addFromContainer = function (e) {\n        var t = this;\n        e.lensFlareSystems && e.lensFlareSystems.forEach(function (e) {\n          t.scene.addLensFlareSystem(e);\n        });\n      }, e.prototype.removeFromContainer = function (e) {\n        var t = this;\n        e.lensFlareSystems && e.lensFlareSystems.forEach(function (e) {\n          t.scene.removeLensFlareSystem(e);\n        });\n      }, e.prototype.serialize = function (e) {\n        e.lensFlareSystems = [];\n\n        for (var t = 0, i = this.scene.lensFlareSystems; t < i.length; t++) {\n          var r = i[t];\n          e.lensFlareSystems.push(r.serialize());\n        }\n      }, e.prototype.dispose = function () {\n        for (var e = this.scene.lensFlareSystems; e.length;) e[0].dispose();\n      }, e.prototype._draw = function (e) {\n        if (this.scene.lensFlaresEnabled) {\n          var t = this.scene.lensFlareSystems;\n          l.Tools.StartPerformanceCounter(\"Lens flares\", 0 < t.length);\n\n          for (var i = 0, r = t; i < r.length; i++) {\n            var n = r[i];\n            0 != (e.layerMask & n.layerMask) && n.render();\n          }\n\n          l.Tools.EndPerformanceCounter(\"Lens flares\", 0 < t.length);\n        }\n      }, e;\n    }();\n\n    l.LensFlareSystemSceneComponent = e;\n  }($a || ($a = {})), Oo = $a || ($a = {}), Do = function () {\n    function l(e, t, i) {\n      this.name = e, this.lensFlares = new Array(), this.borderLimit = 300, this.viewportBorder = 0, this.layerMask = 268435455, this._vertexBuffers = {}, this._isEnabled = !0, this._scene = i || Oo.Engine.LastCreatedScene;\n\n      var r = this._scene._getComponent(Oo.SceneComponentConstants.NAME_LENSFLARESYSTEM);\n\n      r || (r = new Oo.LensFlareSystemSceneComponent(this._scene), i._addComponent(r)), this._emitter = t, this.id = e, i.lensFlareSystems.push(this), this.meshesSelectionPredicate = function (e) {\n        return i.activeCamera && e.material && e.isVisible && e.isEnabled() && e.isBlocker && 0 != (e.layerMask & i.activeCamera.layerMask);\n      };\n      var n = i.getEngine(),\n          o = [];\n      o.push(1, 1), o.push(-1, 1), o.push(-1, -1), o.push(1, -1), this._vertexBuffers[Oo.VertexBuffer.PositionKind] = new Oo.VertexBuffer(n, o, Oo.VertexBuffer.PositionKind, !1, !1, 2);\n      var s = [];\n      s.push(0), s.push(1), s.push(2), s.push(0), s.push(2), s.push(3), this._indexBuffer = n.createIndexBuffer(s), this._effect = n.createEffect(\"lensFlare\", [Oo.VertexBuffer.PositionKind], [\"color\", \"viewportMatrix\"], [\"textureSampler\"], \"\");\n    }\n\n    return Object.defineProperty(l.prototype, \"isEnabled\", {\n      get: function () {\n        return this._isEnabled;\n      },\n      set: function (e) {\n        this._isEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), l.prototype.getScene = function () {\n      return this._scene;\n    }, l.prototype.getEmitter = function () {\n      return this._emitter;\n    }, l.prototype.setEmitter = function (e) {\n      this._emitter = e;\n    }, l.prototype.getEmitterPosition = function () {\n      return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n    }, l.prototype.computeEffectivePosition = function (e) {\n      var t = this.getEmitterPosition();\n      return t = Oo.Vector3.Project(t, Oo.Matrix.Identity(), this._scene.getTransformMatrix(), e), this._positionX = t.x, this._positionY = t.y, t = Oo.Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix()), 0 < this.viewportBorder && (e.x -= this.viewportBorder, e.y -= this.viewportBorder, e.width += 2 * this.viewportBorder, e.height += 2 * this.viewportBorder, t.x += this.viewportBorder, t.y += this.viewportBorder, this._positionX += this.viewportBorder, this._positionY += this.viewportBorder), 0 < t.z && (this._positionX > e.x && this._positionX < e.x + e.width && this._positionY > e.y && (this._positionY, e.y, e.height), !0);\n    }, l.prototype._isVisible = function () {\n      if (!this._isEnabled || !this._scene.activeCamera) return !1;\n      var e = this.getEmitterPosition().subtract(this._scene.activeCamera.globalPosition),\n          t = e.length();\n      e.normalize();\n\n      var i = new Oo.Ray(this._scene.activeCamera.globalPosition, e),\n          r = this._scene.pickWithRay(i, this.meshesSelectionPredicate, !0);\n\n      return !r || !r.hit || r.distance > t;\n    }, l.prototype.render = function () {\n      if (!this._effect.isReady() || !this._scene.activeCamera) return !1;\n\n      var e,\n          t,\n          i = this._scene.getEngine(),\n          r = this._scene.activeCamera.viewport.toGlobal(i.getRenderWidth(!0), i.getRenderHeight(!0));\n\n      if (!this.computeEffectivePosition(r)) return !1;\n      if (!this._isVisible()) return !1;\n      e = this._positionX < this.borderLimit + r.x ? this.borderLimit + r.x - this._positionX : this._positionX > r.x + r.width - this.borderLimit ? this._positionX - r.x - r.width + this.borderLimit : 0;\n      var n = (t = this._positionY < this.borderLimit + r.y ? this.borderLimit + r.y - this._positionY : this._positionY > r.y + r.height - this.borderLimit ? this._positionY - r.y - r.height + this.borderLimit : 0) < e ? e : t;\n      (n -= this.viewportBorder) > this.borderLimit && (n = this.borderLimit);\n      var o = 1 - Oo.Scalar.Clamp(n / this.borderLimit, 0, 1);\n      if (o < 0) return !1;\n      1 < o && (o = 1), 0 < this.viewportBorder && (r.x += this.viewportBorder, r.y += this.viewportBorder, r.width -= 2 * this.viewportBorder, r.height -= 2 * this.viewportBorder, this._positionX -= this.viewportBorder, this._positionY -= this.viewportBorder);\n      var s = r.x + r.width / 2,\n          a = r.y + r.height / 2,\n          l = s - this._positionX,\n          c = a - this._positionY;\n      i.enableEffect(this._effect), i.setState(!1), i.setDepthBuffer(!1), i.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\n\n      for (var h = 0; h < this.lensFlares.length; h++) {\n        var u = this.lensFlares[h];\n        i.setAlphaMode(u.alphaMode);\n\n        var d = s - l * u.position,\n            f = a - c * u.position,\n            p = u.size,\n            _ = u.size * i.getAspectRatio(this._scene.activeCamera, !0),\n            m = d / (r.width + 2 * r.x) * 2 - 1,\n            g = 1 - f / (r.height + 2 * r.y) * 2,\n            v = Oo.Matrix.FromValues(p / 2, 0, 0, 0, 0, _ / 2, 0, 0, 0, 0, 1, 0, m, g, 0, 1);\n\n        this._effect.setMatrix(\"viewportMatrix\", v), this._effect.setTexture(\"textureSampler\", u.texture), this._effect.setFloat4(\"color\", u.color.r * o, u.color.g * o, u.color.b * o, 1), i.drawElementsType(Oo.Material.TriangleFillMode, 0, 6);\n      }\n\n      return i.setDepthBuffer(!0), i.setAlphaMode(Oo.Engine.ALPHA_DISABLE), !0;\n    }, l.prototype.dispose = function () {\n      var e = this._vertexBuffers[Oo.VertexBuffer.PositionKind];\n\n      for (e && (e.dispose(), this._vertexBuffers[Oo.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null); this.lensFlares.length;) this.lensFlares[0].dispose();\n\n      var t = this._scene.lensFlareSystems.indexOf(this);\n\n      this._scene.lensFlareSystems.splice(t, 1);\n    }, l.Parse = function (e, t, i) {\n      var r = t.getLastEntryByID(e.emitterId),\n          n = e.name || \"lensFlareSystem#\" + e.emitterId,\n          o = new l(n, r, t);\n      o.id = e.id || n, o.borderLimit = e.borderLimit;\n\n      for (var s = 0; s < e.flares.length; s++) {\n        var a = e.flares[s];\n        Oo.LensFlare.AddFlare(a.size, a.position, Oo.Color3.FromArray(a.color), a.textureName ? i + a.textureName : \"\", o);\n      }\n\n      return o;\n    }, l.prototype.serialize = function () {\n      var e = {};\n      e.id = this.id, e.name = this.name, e.emitterId = this.getEmitter().id, e.borderLimit = this.borderLimit, e.flares = [];\n\n      for (var t = 0; t < this.lensFlares.length; t++) {\n        var i = this.lensFlares[t];\n        e.flares.push({\n          size: i.size,\n          position: i.position,\n          color: i.color.asArray(),\n          textureName: Oo.Tools.GetFilename(i.texture ? i.texture.name : \"\")\n        });\n      }\n\n      return e;\n    }, l;\n  }(), Oo.LensFlareSystem = Do, function (e) {\n    var i = function () {\n      function e(e, t) {\n        this.type = e, (this.jointData = t).nativeParams = t.nativeParams || {};\n      }\n\n      return Object.defineProperty(e.prototype, \"physicsJoint\", {\n        get: function () {\n          return this._physicsJoint;\n        },\n        set: function (e) {\n          this._physicsJoint, this._physicsJoint = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"physicsPlugin\", {\n        set: function (e) {\n          this._physicsPlugin = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.executeNativeFunction = function (e) {\n        e(this._physicsPlugin.world, this._physicsJoint);\n      }, e.DistanceJoint = 0, e.HingeJoint = 1, e.BallAndSocketJoint = 2, e.WheelJoint = 3, e.SliderJoint = 4, e.PrismaticJoint = 5, e.UniversalJoint = 6, e.Hinge2Joint = e.WheelJoint, e.PointToPointJoint = 8, e.SpringJoint = 9, e.LockJoint = 10, e;\n    }(),\n        t = function (t) {\n      function e(e) {\n        return t.call(this, i.DistanceJoint, e) || this;\n      }\n\n      return T(e, t), e.prototype.updateDistance = function (e, t) {\n        this._physicsPlugin.updateDistanceJoint(this, e, t);\n      }, e;\n    }(e.PhysicsJoint = i);\n\n    e.DistanceJoint = t;\n\n    var r = function (i) {\n      function e(e, t) {\n        return i.call(this, e, t) || this;\n      }\n\n      return T(e, i), e.prototype.setMotor = function (e, t) {\n        this._physicsPlugin.setMotor(this, e || 0, t);\n      }, e.prototype.setLimit = function (e, t) {\n        this._physicsPlugin.setLimit(this, e, t);\n      }, e;\n    }(i),\n        n = function (t) {\n      function e(e) {\n        return t.call(this, i.HingeJoint, e) || this;\n      }\n\n      return T(e, t), e.prototype.setMotor = function (e, t) {\n        this._physicsPlugin.setMotor(this, e || 0, t);\n      }, e.prototype.setLimit = function (e, t) {\n        this._physicsPlugin.setLimit(this, e, t);\n      }, e;\n    }(e.MotorEnabledJoint = r);\n\n    e.HingeJoint = n;\n\n    var o = function (t) {\n      function e(e) {\n        return t.call(this, i.Hinge2Joint, e) || this;\n      }\n\n      return T(e, t), e.prototype.setMotor = function (e, t, i) {\n        void 0 === i && (i = 0), this._physicsPlugin.setMotor(this, e || 0, t, i);\n      }, e.prototype.setLimit = function (e, t, i) {\n        void 0 === i && (i = 0), this._physicsPlugin.setLimit(this, e, t, i);\n      }, e;\n    }(r);\n\n    e.Hinge2Joint = o;\n  }($a || ($a = {})), Io = $a || ($a = {}), wo = function () {\n    function h(e, t, i, r) {\n      void 0 === i && (i = {\n        mass: 0\n      });\n      var n = this;\n      this.object = e, this.type = t, this._options = i, this._scene = r, this._bodyUpdateRequired = !1, this._onBeforePhysicsStepCallbacks = new Array(), this._onAfterPhysicsStepCallbacks = new Array(), this._onPhysicsCollideCallbacks = [], this._deltaPosition = Io.Vector3.Zero(), this._isDisposed = !1, this._tmpQuat = new Io.Quaternion(), this._tmpQuat2 = new Io.Quaternion(), this.beforeStep = function () {\n        n._physicsEngine && (n.object.translate(n._deltaPosition, -1), n._deltaRotationConjugated && n.object.rotationQuaternion && n.object.rotationQuaternion.multiplyToRef(n._deltaRotationConjugated, n.object.rotationQuaternion), n.object.computeWorldMatrix(!1), n.object.parent && n.object.rotationQuaternion ? (n.getParentsRotation(), n._tmpQuat.multiplyToRef(n.object.rotationQuaternion, n._tmpQuat)) : n._tmpQuat.copyFrom(n.object.rotationQuaternion || new Io.Quaternion()), n._options.disableBidirectionalTransformation || n.object.rotationQuaternion && n._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(n, n.object.getAbsolutePivotPoint(), n._tmpQuat), n._onBeforePhysicsStepCallbacks.forEach(function (e) {\n          e(n);\n        }));\n      }, this.afterStep = function () {\n        n._physicsEngine && (n._onAfterPhysicsStepCallbacks.forEach(function (e) {\n          e(n);\n        }), n._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(n), n.object.parent && n.object.rotationQuaternion && (n.getParentsRotation(), n._tmpQuat.conjugateInPlace(), n._tmpQuat.multiplyToRef(n.object.rotationQuaternion, n.object.rotationQuaternion)), n.object.setAbsolutePosition(n.object.position), n._deltaRotation && n.object.rotationQuaternion && n.object.rotationQuaternion.multiplyToRef(n._deltaRotation, n.object.rotationQuaternion), n.object.translate(n._deltaPosition, 1));\n      }, this.onCollideEvent = null, this.onCollide = function (e) {\n        if ((n._onPhysicsCollideCallbacks.length || n.onCollideEvent) && n._physicsEngine) {\n          var t = n._physicsEngine.getImpostorWithPhysicsBody(e.body);\n\n          t && (n.onCollideEvent && n.onCollideEvent(n, t), n._onPhysicsCollideCallbacks.filter(function (e) {\n            return -1 !== e.otherImpostors.indexOf(t);\n          }).forEach(function (e) {\n            e.callback(n, t);\n          }));\n        }\n      }, this.object ? (!this._scene && e.getScene && (this._scene = e.getScene()), this._scene && (this._physicsEngine = this._scene.getPhysicsEngine(), this._physicsEngine ? (this.object.rotationQuaternion || (this.object.rotation ? this.object.rotationQuaternion = Io.Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z) : this.object.rotationQuaternion = new Io.Quaternion()), this._options.mass = void 0 === i.mass ? 0 : i.mass, this._options.friction = void 0 === i.friction ? .2 : i.friction, this._options.restitution = void 0 === i.restitution ? .2 : i.restitution, this._joints = [], !this.object.parent || this._options.ignoreParent ? this._init() : this.object.parent.physicsImpostor && Io.Tools.Warn(\"You must affect impostors to children before affecting impostor to parent.\")) : Io.Tools.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\"))) : Io.Tools.Error(\"No object was provided. A physics object is obligatory\");\n    }\n\n    return Object.defineProperty(h.prototype, \"isDisposed\", {\n      get: function () {\n        return this._isDisposed;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"mass\", {\n      get: function () {\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\n      },\n      set: function (e) {\n        this.setMass(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"friction\", {\n      get: function () {\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\n      },\n      set: function (e) {\n        this._physicsEngine && this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"restitution\", {\n      get: function () {\n        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\n      },\n      set: function (e) {\n        this._physicsEngine && this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), h.prototype._init = function () {\n      this._physicsEngine && (this._physicsEngine.removeImpostor(this), this.physicsBody = null, this._parent = this._parent || this._getPhysicsParent(), this._isDisposed || this.parent && !this._options.ignoreParent || this._physicsEngine.addImpostor(this));\n    }, h.prototype._getPhysicsParent = function () {\n      return this.object.parent instanceof Io.AbstractMesh ? this.object.parent.physicsImpostor : null;\n    }, h.prototype.isBodyInitRequired = function () {\n      return this._bodyUpdateRequired || !this._physicsBody && !this._parent;\n    }, h.prototype.setScalingUpdated = function (e) {\n      this.forceUpdate();\n    }, h.prototype.forceUpdate = function () {\n      this._init(), this.parent && !this._options.ignoreParent && this.parent.forceUpdate();\n    }, Object.defineProperty(h.prototype, \"physicsBody\", {\n      get: function () {\n        return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\n      },\n      set: function (e) {\n        this._physicsBody && this._physicsEngine && this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this), this._physicsBody = e, this.resetUpdateFlags();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.prototype, \"parent\", {\n      get: function () {\n        return !this._options.ignoreParent && this._parent ? this._parent : null;\n      },\n      set: function (e) {\n        this._parent = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), h.prototype.resetUpdateFlags = function () {\n      this._bodyUpdateRequired = !1;\n    }, h.prototype.getObjectExtendSize = function () {\n      if (this.object.getBoundingInfo) {\n        var e = this.object.rotationQuaternion;\n        this.object.rotationQuaternion = h.IDENTITY_QUATERNION, this.object.computeWorldMatrix && this.object.computeWorldMatrix(!0);\n        var t = this.object.getBoundingInfo().boundingBox.extendSizeWorld.scale(2);\n        return this.object.rotationQuaternion = e, this.object.computeWorldMatrix && this.object.computeWorldMatrix(!0), t;\n      }\n\n      return h.DEFAULT_OBJECT_SIZE;\n    }, h.prototype.getObjectCenter = function () {\n      return this.object.getBoundingInfo ? this.object.getBoundingInfo().boundingBox.centerWorld : this.object.position;\n    }, h.prototype.getParam = function (e) {\n      return this._options[e];\n    }, h.prototype.setParam = function (e, t) {\n      this._options[e] = t, this._bodyUpdateRequired = !0;\n    }, h.prototype.setMass = function (e) {\n      this.getParam(\"mass\") !== e && this.setParam(\"mass\", e), this._physicsEngine && this._physicsEngine.getPhysicsPlugin().setBodyMass(this, e);\n    }, h.prototype.getLinearVelocity = function () {\n      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Io.Vector3.Zero();\n    }, h.prototype.setLinearVelocity = function (e) {\n      this._physicsEngine && this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, e);\n    }, h.prototype.getAngularVelocity = function () {\n      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Io.Vector3.Zero();\n    }, h.prototype.setAngularVelocity = function (e) {\n      this._physicsEngine && this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, e);\n    }, h.prototype.executeNativeFunction = function (e) {\n      this._physicsEngine && e(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\n    }, h.prototype.registerBeforePhysicsStep = function (e) {\n      this._onBeforePhysicsStepCallbacks.push(e);\n    }, h.prototype.unregisterBeforePhysicsStep = function (e) {\n      var t = this._onBeforePhysicsStepCallbacks.indexOf(e);\n\n      -1 < t ? this._onBeforePhysicsStepCallbacks.splice(t, 1) : Io.Tools.Warn(\"Function to remove was not found\");\n    }, h.prototype.registerAfterPhysicsStep = function (e) {\n      this._onAfterPhysicsStepCallbacks.push(e);\n    }, h.prototype.unregisterAfterPhysicsStep = function (e) {\n      var t = this._onAfterPhysicsStepCallbacks.indexOf(e);\n\n      -1 < t ? this._onAfterPhysicsStepCallbacks.splice(t, 1) : Io.Tools.Warn(\"Function to remove was not found\");\n    }, h.prototype.registerOnPhysicsCollide = function (e, t) {\n      var i = e instanceof Array ? e : [e];\n\n      this._onPhysicsCollideCallbacks.push({\n        callback: t,\n        otherImpostors: i\n      });\n    }, h.prototype.unregisterOnPhysicsCollide = function (e, r) {\n      var n = e instanceof Array ? e : [e],\n          o = -1;\n      this._onPhysicsCollideCallbacks.some(function (e, t) {\n        if (e.callback === r && e.otherImpostors.length === n.length) {\n          var i = e.otherImpostors.every(function (e) {\n            return -1 < n.indexOf(e);\n          });\n          return i && (o = t), i;\n        }\n\n        return !1;\n      }) ? this._onPhysicsCollideCallbacks.splice(o, 1) : Io.Tools.Warn(\"Function to remove was not found\");\n    }, h.prototype.getParentsRotation = function () {\n      var e = this.object.parent;\n\n      for (this._tmpQuat.copyFromFloats(0, 0, 0, 1); e;) e.rotationQuaternion ? this._tmpQuat2.copyFrom(e.rotationQuaternion) : Io.Quaternion.RotationYawPitchRollToRef(e.rotation.y, e.rotation.x, e.rotation.z, this._tmpQuat2), this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat), e = e.parent;\n\n      return this._tmpQuat;\n    }, h.prototype.applyForce = function (e, t) {\n      return this._physicsEngine && this._physicsEngine.getPhysicsPlugin().applyForce(this, e, t), this;\n    }, h.prototype.applyImpulse = function (e, t) {\n      return this._physicsEngine && this._physicsEngine.getPhysicsPlugin().applyImpulse(this, e, t), this;\n    }, h.prototype.createJoint = function (e, t, i) {\n      var r = new Io.PhysicsJoint(t, i);\n      return this.addJoint(e, r), this;\n    }, h.prototype.addJoint = function (e, t) {\n      return this._joints.push({\n        otherImpostor: e,\n        joint: t\n      }), this._physicsEngine && this._physicsEngine.addJoint(this, e, t), this;\n    }, h.prototype.sleep = function () {\n      return this._physicsEngine && this._physicsEngine.getPhysicsPlugin().sleepBody(this), this;\n    }, h.prototype.wakeUp = function () {\n      return this._physicsEngine && this._physicsEngine.getPhysicsPlugin().wakeUpBody(this), this;\n    }, h.prototype.clone = function (e) {\n      return e ? new h(e, this.type, this._options, this._scene) : null;\n    }, h.prototype.dispose = function () {\n      var t = this;\n      this._physicsEngine && (this._joints.forEach(function (e) {\n        t._physicsEngine && t._physicsEngine.removeJoint(t, e.otherImpostor, e.joint);\n      }), this._physicsEngine.removeImpostor(this), this.parent && this.parent.forceUpdate(), this._isDisposed = !0);\n    }, h.prototype.setDeltaPosition = function (e) {\n      this._deltaPosition.copyFrom(e);\n    }, h.prototype.setDeltaRotation = function (e) {\n      this._deltaRotation || (this._deltaRotation = new Io.Quaternion()), this._deltaRotation.copyFrom(e), this._deltaRotationConjugated = this._deltaRotation.conjugate();\n    }, h.prototype.getBoxSizeToRef = function (e) {\n      return this._physicsEngine && this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, e), this;\n    }, h.prototype.getRadius = function () {\n      return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\n    }, h.prototype.syncBoneWithImpostor = function (e, t, i, r, n) {\n      var o = h._tmpVecs[0],\n          s = this.object;\n      if (s.rotationQuaternion) if (n) {\n        var a = h._tmpQuat;\n        s.rotationQuaternion.multiplyToRef(n, a), e.setRotationQuaternion(a, Io.Space.WORLD, t);\n      } else e.setRotationQuaternion(s.rotationQuaternion, Io.Space.WORLD, t);\n      o.x = 0, o.y = 0, o.z = 0, i && (o.x = i.x, o.y = i.y, o.z = i.z, e.getDirectionToRef(o, t, o), null == r && (r = i.length()), o.x *= r, o.y *= r, o.z *= r), e.getParent() ? (o.addInPlace(s.getAbsolutePosition()), e.setAbsolutePosition(o, t)) : (t.setAbsolutePosition(s.getAbsolutePosition()), t.position.x -= o.x, t.position.y -= o.y, t.position.z -= o.z);\n    }, h.prototype.syncImpostorWithBone = function (e, t, i, r, n, o) {\n      var s = this.object;\n      if (s.rotationQuaternion) if (n) {\n        var a = h._tmpQuat;\n        e.getRotationQuaternionToRef(Io.Space.WORLD, t, a), a.multiplyToRef(n, s.rotationQuaternion);\n      } else e.getRotationQuaternionToRef(Io.Space.WORLD, t, s.rotationQuaternion);\n      var l = h._tmpVecs[0],\n          c = h._tmpVecs[1];\n      o || ((o = h._tmpVecs[2]).x = 0, o.y = 1, o.z = 0), e.getDirectionToRef(o, t, c), e.getAbsolutePositionToRef(t, l), null == r && i && (r = i.length()), null != r && (l.x += c.x * r, l.y += c.y * r, l.z += c.z * r), s.setAbsolutePosition(l);\n    }, h.DEFAULT_OBJECT_SIZE = new Io.Vector3(1, 1, 1), h.IDENTITY_QUATERNION = Io.Quaternion.Identity(), h._tmpVecs = [Io.Vector3.Zero(), Io.Vector3.Zero(), Io.Vector3.Zero()], h._tmpQuat = Io.Quaternion.Identity(), h.NoImpostor = 0, h.SphereImpostor = 1, h.BoxImpostor = 2, h.PlaneImpostor = 3, h.MeshImpostor = 4, h.CylinderImpostor = 7, h.ParticleImpostor = 8, h.HeightmapImpostor = 9, h;\n  }(), Io.PhysicsImpostor = wo, Lo = $a || ($a = {}), Fo = function () {\n    function e(e, t) {\n      if (void 0 === t && (t = new Lo.CannonJSPlugin()), this._physicsPlugin = t, this._impostors = [], this._joints = [], !this._physicsPlugin.isSupported()) throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. Please make sure it is included.\");\n      e = e || new Lo.Vector3(0, -9.807, 0), this.setGravity(e), this.setTimeStep();\n    }\n\n    return e.prototype.setGravity = function (e) {\n      this.gravity = e, this._physicsPlugin.setGravity(this.gravity);\n    }, e.prototype.setTimeStep = function (e) {\n      void 0 === e && (e = 1 / 60), this._physicsPlugin.setTimeStep(e);\n    }, e.prototype.getTimeStep = function () {\n      return this._physicsPlugin.getTimeStep();\n    }, e.prototype.dispose = function () {\n      this._impostors.forEach(function (e) {\n        e.dispose();\n      }), this._physicsPlugin.dispose();\n    }, e.prototype.getPhysicsPluginName = function () {\n      return this._physicsPlugin.name;\n    }, e.prototype.addImpostor = function (e) {\n      e.uniqueId = this._impostors.push(e), e.parent || this._physicsPlugin.generatePhysicsBody(e);\n    }, e.prototype.removeImpostor = function (e) {\n      var t = this._impostors.indexOf(e);\n\n      if (-1 < t) {\n        var i = this._impostors.splice(t, 1);\n\n        i.length && (i[0].physicsBody = null);\n      }\n    }, e.prototype.addJoint = function (e, t, i) {\n      var r = {\n        mainImpostor: e,\n        connectedImpostor: t,\n        joint: i\n      };\n      i.physicsPlugin = this._physicsPlugin, this._joints.push(r), this._physicsPlugin.generateJoint(r);\n    }, e.prototype.removeJoint = function (t, i, r) {\n      var e = this._joints.filter(function (e) {\n        return e.connectedImpostor === i && e.joint === r && e.mainImpostor === t;\n      });\n\n      e.length && this._physicsPlugin.removeJoint(e[0]);\n    }, e.prototype._step = function (e) {\n      var t = this;\n      this._impostors.forEach(function (e) {\n        e.isBodyInitRequired() && t._physicsPlugin.generatePhysicsBody(e);\n      }), .1 < e ? e = .1 : e <= 0 && (e = 1 / 60), this._physicsPlugin.executeStep(e, this._impostors);\n    }, e.prototype.getPhysicsPlugin = function () {\n      return this._physicsPlugin;\n    }, e.prototype.getImpostors = function () {\n      return this._impostors;\n    }, e.prototype.getImpostorForPhysicsObject = function (e) {\n      for (var t = 0; t < this._impostors.length; ++t) if (this._impostors[t].object === e) return this._impostors[t];\n\n      return null;\n    }, e.prototype.getImpostorWithPhysicsBody = function (e) {\n      for (var t = 0; t < this._impostors.length; ++t) if (this._impostors[t].physicsBody === e) return this._impostors[t];\n\n      return null;\n    }, e.Epsilon = .001, e;\n  }(), Lo.PhysicsEngine = Fo, function (f) {\n    var e = function () {\n      function e(e) {\n        this._scene = e, this._physicsEngine = this._scene.getPhysicsEngine(), this._physicsEngine || f.Tools.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\n      }\n\n      return e.prototype.applyRadialExplosionImpulse = function (i, r, n, o) {\n        if (void 0 === o && (o = h.Constant), !this._physicsEngine) return f.Tools.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\"), null;\n\n        var e = this._physicsEngine.getImpostors();\n\n        if (0 === e.length) return null;\n        var s = new t(this._scene);\n        return e.forEach(function (e) {\n          var t = s.getImpostorForceAndContactPoint(e, i, r, n, o);\n          t && e.applyImpulse(t.force, t.contactPoint);\n        }), s.dispose(!1), s;\n      }, e.prototype.applyRadialExplosionForce = function (i, r, n, o) {\n        if (void 0 === o && (o = h.Constant), !this._physicsEngine) return f.Tools.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\"), null;\n\n        var e = this._physicsEngine.getImpostors();\n\n        if (0 === e.length) return null;\n        var s = new t(this._scene);\n        return e.forEach(function (e) {\n          var t = s.getImpostorForceAndContactPoint(e, i, r, n, o);\n          t && e.applyForce(t.force, t.contactPoint);\n        }), s.dispose(!1), s;\n      }, e.prototype.gravitationalField = function (e, t, i, r) {\n        if (void 0 === r && (r = h.Constant), !this._physicsEngine) return f.Tools.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\"), null;\n        if (0 === this._physicsEngine.getImpostors().length) return null;\n        var n = new o(this, this._scene, e, t, i, r);\n        return n.dispose(!1), n;\n      }, e.prototype.updraft = function (e, t, i, r, n) {\n        if (void 0 === n && (n = a.Center), !this._physicsEngine) return f.Tools.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\"), null;\n        if (0 === this._physicsEngine.getImpostors().length) return null;\n        var o = new s(this._scene, e, t, i, r, n);\n        return o.dispose(!1), o;\n      }, e.prototype.vortex = function (e, t, i, r) {\n        if (!this._physicsEngine) return f.Tools.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\"), null;\n        if (0 === this._physicsEngine.getImpostors().length) return null;\n        var n = new l(this._scene, e, t, i, r);\n        return n.dispose(!1), n;\n      }, e;\n    }();\n\n    f.PhysicsHelper = e;\n\n    var t = function () {\n      function e(e) {\n        this._sphereOptions = {\n          segments: 32,\n          diameter: 1\n        }, this._rays = [], this._dataFetched = !1, this._scene = e;\n      }\n\n      return e.prototype.getData = function () {\n        return this._dataFetched = !0, {\n          sphere: this._sphere,\n          rays: this._rays\n        };\n      }, e.prototype.getImpostorForceAndContactPoint = function (e, t, i, r, n) {\n        if (0 === e.mass) return null;\n        if (!this._intersectsWithSphere(e, t, i)) return null;\n        if (\"Mesh\" !== e.object.getClassName() && \"InstancedMesh\" !== e.object.getClassName()) return null;\n        var o = e.getObjectCenter().subtract(t),\n            s = new f.Ray(t, o, i);\n\n        this._rays.push(s);\n\n        var a = s.intersectsMesh(e.object).pickedPoint;\n        if (!a) return null;\n        var l = f.Vector3.Distance(t, a);\n        if (i < l) return null;\n        var c = n === h.Constant ? r : r * (1 - l / i);\n        return {\n          force: o.multiplyByFloats(c, c, c),\n          contactPoint: a\n        };\n      }, e.prototype.dispose = function (e) {\n        var t = this;\n        void 0 === e && (e = !0), e ? this._sphere.dispose() : setTimeout(function () {\n          t._dataFetched || t._sphere.dispose();\n        }, 0);\n      }, e.prototype._prepareSphere = function () {\n        this._sphere || (this._sphere = f.MeshBuilder.CreateSphere(\"radialExplosionEventSphere\", this._sphereOptions, this._scene), this._sphere.isVisible = !1);\n      }, e.prototype._intersectsWithSphere = function (e, t, i) {\n        var r = e.object;\n        return this._prepareSphere(), this._sphere.position = t, this._sphere.scaling = new f.Vector3(2 * i, 2 * i, 2 * i), this._sphere._updateBoundingInfo(), this._sphere.computeWorldMatrix(!0), this._sphere.intersectsMesh(r, !0);\n      }, e;\n    }();\n\n    f.PhysicsRadialExplosionEvent = t;\n\n    var o = function () {\n      function e(e, t, i, r, n, o) {\n        void 0 === o && (o = h.Constant), this._dataFetched = !1, this._physicsHelper = e, this._scene = t, this._origin = i, this._radius = r, this._strength = n, this._falloff = o, this._tickCallback = this._tick.bind(this);\n      }\n\n      return e.prototype.getData = function () {\n        return this._dataFetched = !0, {\n          sphere: this._sphere\n        };\n      }, e.prototype.enable = function () {\n        this._tickCallback.call(this), this._scene.registerBeforeRender(this._tickCallback);\n      }, e.prototype.disable = function () {\n        this._scene.unregisterBeforeRender(this._tickCallback);\n      }, e.prototype.dispose = function (e) {\n        var t = this;\n        void 0 === e && (e = !0), e ? this._sphere.dispose() : setTimeout(function () {\n          t._dataFetched || t._sphere.dispose();\n        }, 0);\n      }, e.prototype._tick = function () {\n        if (this._sphere) this._physicsHelper.applyRadialExplosionForce(this._origin, this._radius, -1 * this._strength, this._falloff);else {\n          var e = this._physicsHelper.applyRadialExplosionForce(this._origin, this._radius, -1 * this._strength, this._falloff);\n\n          e && (this._sphere = e.getData().sphere.clone(\"radialExplosionEventSphereClone\"));\n        }\n      }, e;\n    }();\n\n    f.PhysicsGravitationalFieldEvent = o;\n\n    var s = function () {\n      function e(e, t, i, r, n, o) {\n        this._scene = e, this._origin = t, this._radius = i, this._strength = r, this._height = n, this._updraftMode = o, this._originTop = f.Vector3.Zero(), this._originDirection = f.Vector3.Zero(), this._cylinderPosition = f.Vector3.Zero(), this._dataFetched = !1, this._physicsEngine = this._scene.getPhysicsEngine(), this._origin.addToRef(new f.Vector3(0, this._height / 2, 0), this._cylinderPosition), this._origin.addToRef(new f.Vector3(0, this._height, 0), this._originTop), this._updraftMode === a.Perpendicular && (this._originDirection = this._origin.subtract(this._originTop).normalize()), this._tickCallback = this._tick.bind(this);\n      }\n\n      return e.prototype.getData = function () {\n        return this._dataFetched = !0, {\n          cylinder: this._cylinder\n        };\n      }, e.prototype.enable = function () {\n        this._tickCallback.call(this), this._scene.registerBeforeRender(this._tickCallback);\n      }, e.prototype.disable = function () {\n        this._scene.unregisterBeforeRender(this._tickCallback);\n      }, e.prototype.dispose = function (e) {\n        var t = this;\n        void 0 === e && (e = !0), e ? this._cylinder.dispose() : setTimeout(function () {\n          t._dataFetched || t._cylinder.dispose();\n        }, 0);\n      }, e.prototype.getImpostorForceAndContactPoint = function (e) {\n        if (0 === e.mass) return null;\n        if (!this._intersectsWithCylinder(e)) return null;\n        var t = e.getObjectCenter();\n        if (this._updraftMode === a.Perpendicular) var i = this._originDirection;else i = t.subtract(this._originTop);\n        var r = -1 * this._strength;\n        return {\n          force: i.multiplyByFloats(r, r, r),\n          contactPoint: t\n        };\n      }, e.prototype._tick = function () {\n        var i = this;\n\n        this._physicsEngine.getImpostors().forEach(function (e) {\n          var t = i.getImpostorForceAndContactPoint(e);\n          t && e.applyForce(t.force, t.contactPoint);\n        });\n      }, e.prototype._prepareCylinder = function () {\n        this._cylinder || (this._cylinder = f.MeshBuilder.CreateCylinder(\"updraftEventCylinder\", {\n          height: this._height,\n          diameter: 2 * this._radius\n        }, this._scene), this._cylinder.isVisible = !1);\n      }, e.prototype._intersectsWithCylinder = function (e) {\n        var t = e.object;\n        return this._prepareCylinder(), this._cylinder.position = this._cylinderPosition, this._cylinder.intersectsMesh(t, !0);\n      }, e;\n    }();\n\n    f.PhysicsUpdraftEvent = s;\n\n    var h,\n        i,\n        a,\n        r,\n        l = function () {\n      function e(e, t, i, r, n) {\n        this._scene = e, this._origin = t, this._radius = i, this._strength = r, this._height = n, this._originTop = f.Vector3.Zero(), this._centripetalForceThreshold = .7, this._updraftMultiplier = .02, this._cylinderPosition = f.Vector3.Zero(), this._dataFetched = !1, this._physicsEngine = this._scene.getPhysicsEngine(), this._origin.addToRef(new f.Vector3(0, this._height / 2, 0), this._cylinderPosition), this._origin.addToRef(new f.Vector3(0, this._height, 0), this._originTop), this._tickCallback = this._tick.bind(this);\n      }\n\n      return e.prototype.getData = function () {\n        return this._dataFetched = !0, {\n          cylinder: this._cylinder\n        };\n      }, e.prototype.enable = function () {\n        this._tickCallback.call(this), this._scene.registerBeforeRender(this._tickCallback);\n      }, e.prototype.disable = function () {\n        this._scene.unregisterBeforeRender(this._tickCallback);\n      }, e.prototype.dispose = function (e) {\n        var t = this;\n        void 0 === e && (e = !0), e ? this._cylinder.dispose() : setTimeout(function () {\n          t._dataFetched || t._cylinder.dispose();\n        }, 0);\n      }, e.prototype.getImpostorForceAndContactPoint = function (e) {\n        if (0 === e.mass) return null;\n        if (!this._intersectsWithCylinder(e)) return null;\n        if (\"Mesh\" !== e.object.getClassName() && \"InstancedMesh\" !== e.object.getClassName()) return null;\n        var t = e.getObjectCenter(),\n            i = new f.Vector3(this._origin.x, t.y, this._origin.z),\n            r = t.subtract(i),\n            n = new f.Ray(i, r, this._radius).intersectsMesh(e.object),\n            o = n.pickedPoint;\n        if (!o) return null;\n        var s = n.distance / this._radius,\n            a = f.Vector3.Cross(i, t).normalize(),\n            l = o.normalize();\n        if (s > this._centripetalForceThreshold && (l = l.negate()), s > this._centripetalForceThreshold) var c = l.x * this._strength / 8,\n            h = l.y * this._updraftMultiplier,\n            u = l.z * this._strength / 8;else c = (a.x + l.x) / 2, h = this._originTop.y * this._updraftMultiplier, u = (a.z + l.z) / 2;\n        var d = new f.Vector3(c, h, u);\n        return {\n          force: d = d.multiplyByFloats(this._strength, this._strength, this._strength),\n          contactPoint: t\n        };\n      }, e.prototype._tick = function () {\n        var i = this;\n\n        this._physicsEngine.getImpostors().forEach(function (e) {\n          var t = i.getImpostorForceAndContactPoint(e);\n          t && e.applyForce(t.force, t.contactPoint);\n        });\n      }, e.prototype._prepareCylinder = function () {\n        this._cylinder || (this._cylinder = f.MeshBuilder.CreateCylinder(\"vortexEventCylinder\", {\n          height: this._height,\n          diameter: 2 * this._radius\n        }, this._scene), this._cylinder.isVisible = !1);\n      }, e.prototype._intersectsWithCylinder = function (e) {\n        var t = e.object;\n        return this._prepareCylinder(), this._cylinder.position = this._cylinderPosition, this._cylinder.intersectsMesh(t, !0);\n      }, e;\n    }();\n\n    f.PhysicsVortexEvent = l, (i = h = f.PhysicsRadialImpulseFalloff || (f.PhysicsRadialImpulseFalloff = {}))[i.Constant = 0] = \"Constant\", i[i.Linear = 1] = \"Linear\", (r = a = f.PhysicsUpdraftMode || (f.PhysicsUpdraftMode = {}))[r.Center = 0] = \"Center\", r[r.Perpendicular = 1] = \"Perpendicular\";\n  }($a || ($a = {})), Bo = $a || ($a = {}), No = function () {\n    function e(e, t) {\n      void 0 === e && (e = !0), void 0 === t && (t = 10), this._useDeltaForWorldStep = e, this.name = \"CannonJSPlugin\", this._physicsMaterials = new Array(), this._fixedTimeStep = 1 / 60, this.BJSCANNON = i, this._minus90X = new Bo.Quaternion(-.7071067811865475, 0, 0, .7071067811865475), this._plus90X = new Bo.Quaternion(.7071067811865475, 0, 0, .7071067811865475), this._tmpPosition = Bo.Vector3.Zero(), this._tmpDeltaPosition = Bo.Vector3.Zero(), this._tmpUnityRotation = new Bo.Quaternion(), this.isSupported() ? (this._extendNamespace(), this.world = new this.BJSCANNON.World(), this.world.broadphase = new this.BJSCANNON.NaiveBroadphase(), this.world.solver.iterations = t) : Bo.Tools.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n    }\n\n    return e.prototype.setGravity = function (e) {\n      this.world.gravity.copy(e);\n    }, e.prototype.setTimeStep = function (e) {\n      this._fixedTimeStep = e;\n    }, e.prototype.getTimeStep = function () {\n      return this._fixedTimeStep;\n    }, e.prototype.executeStep = function (e, t) {\n      this.world.step(this._fixedTimeStep, this._useDeltaForWorldStep ? e : 0, 3);\n    }, e.prototype.applyImpulse = function (e, t, i) {\n      var r = new this.BJSCANNON.Vec3(i.x, i.y, i.z),\n          n = new this.BJSCANNON.Vec3(t.x, t.y, t.z);\n      e.physicsBody.applyImpulse(n, r);\n    }, e.prototype.applyForce = function (e, t, i) {\n      var r = new this.BJSCANNON.Vec3(i.x, i.y, i.z),\n          n = new this.BJSCANNON.Vec3(t.x, t.y, t.z);\n      e.physicsBody.applyForce(n, r);\n    }, e.prototype.generatePhysicsBody = function (t) {\n      if (t.parent) t.physicsBody && (this.removePhysicsBody(t), t.forceUpdate());else {\n        if (t.isBodyInitRequired()) {\n          var e = this._createShape(t),\n              i = t.physicsBody;\n\n          i && this.removePhysicsBody(t);\n\n          var r = this._addMaterial(\"mat-\" + t.uniqueId, t.getParam(\"friction\"), t.getParam(\"restitution\")),\n              n = {\n            mass: t.getParam(\"mass\"),\n            material: r\n          },\n              o = t.getParam(\"nativeOptions\");\n\n          for (var s in o) o.hasOwnProperty(s) && (n[s] = o[s]);\n\n          t.physicsBody = new this.BJSCANNON.Body(n), t.physicsBody.addEventListener(\"collide\", t.onCollide), this.world.addEventListener(\"preStep\", t.beforeStep), this.world.addEventListener(\"postStep\", t.afterStep), t.physicsBody.addShape(e), this.world.add(t.physicsBody), i && [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (e) {\n            t.physicsBody[e].copy(i[e]);\n          }), this._processChildMeshes(t);\n        }\n\n        this._updatePhysicsBodyTransformation(t);\n      }\n    }, e.prototype._processChildMeshes = function (o) {\n      var s = this,\n          e = o.object.getChildMeshes ? o.object.getChildMeshes(!0) : [],\n          a = o.object.rotationQuaternion;\n\n      if (e.length) {\n        var l = function (e, t) {\n          if (a && t.rotationQuaternion) {\n            var i = t.getPhysicsImpostor();\n            if (i) if (i.parent !== o) {\n              var r = t.getAbsolutePosition().subtract(o.object.getAbsolutePosition()),\n                  n = t.rotationQuaternion.multiply(Bo.Quaternion.Inverse(a));\n              i.physicsBody && (s.removePhysicsBody(i), i.physicsBody = null), i.parent = o, i.resetUpdateFlags(), o.physicsBody.addShape(s._createShape(i), new s.BJSCANNON.Vec3(r.x, r.y, r.z), new s.BJSCANNON.Quaternion(n.x, n.y, n.z, n.w)), o.physicsBody.mass += i.getParam(\"mass\");\n            }\n            a.multiplyInPlace(t.rotationQuaternion), t.getChildMeshes(!0).filter(function (e) {\n              return !!e.physicsImpostor;\n            }).forEach(l.bind(s, t.getAbsolutePosition()));\n          }\n        };\n\n        e.filter(function (e) {\n          return !!e.physicsImpostor;\n        }).forEach(l.bind(this, o.object.getAbsolutePosition()));\n      }\n    }, e.prototype.removePhysicsBody = function (e) {\n      e.physicsBody.removeEventListener(\"collide\", e.onCollide), this.world.removeEventListener(\"preStep\", e.beforeStep), this.world.removeEventListener(\"postStep\", e.afterStep), this.world.remove(e.physicsBody);\n    }, e.prototype.generateJoint = function (e) {\n      var t = e.mainImpostor.physicsBody,\n          i = e.connectedImpostor.physicsBody;\n\n      if (t && i) {\n        var r,\n            n = e.joint.jointData,\n            o = {\n          pivotA: n.mainPivot ? new this.BJSCANNON.Vec3().copy(n.mainPivot) : null,\n          pivotB: n.connectedPivot ? new this.BJSCANNON.Vec3().copy(n.connectedPivot) : null,\n          axisA: n.mainAxis ? new this.BJSCANNON.Vec3().copy(n.mainAxis) : null,\n          axisB: n.connectedAxis ? new this.BJSCANNON.Vec3().copy(n.connectedAxis) : null,\n          maxForce: n.nativeParams.maxForce,\n          collideConnected: !!n.collision\n        };\n\n        switch (e.joint.type) {\n          case Bo.PhysicsJoint.HingeJoint:\n          case Bo.PhysicsJoint.Hinge2Joint:\n            r = new this.BJSCANNON.HingeConstraint(t, i, o);\n            break;\n\n          case Bo.PhysicsJoint.DistanceJoint:\n            r = new this.BJSCANNON.DistanceConstraint(t, i, n.maxDistance || 2);\n            break;\n\n          case Bo.PhysicsJoint.SpringJoint:\n            var s = n;\n            r = new this.BJSCANNON.Spring(t, i, {\n              restLength: s.length,\n              stiffness: s.stiffness,\n              damping: s.damping,\n              localAnchorA: o.pivotA,\n              localAnchorB: o.pivotB\n            });\n            break;\n\n          case Bo.PhysicsJoint.LockJoint:\n            r = new this.BJSCANNON.LockConstraint(t, i, o);\n            break;\n\n          case Bo.PhysicsJoint.PointToPointJoint:\n          case Bo.PhysicsJoint.BallAndSocketJoint:\n          default:\n            r = new this.BJSCANNON.PointToPointConstraint(t, o.pivotA, i, o.pivotA, o.maxForce);\n        }\n\n        r.collideConnected = !!n.collision, e.joint.physicsJoint = r, e.joint.type !== Bo.PhysicsJoint.SpringJoint ? this.world.addConstraint(r) : (e.joint.jointData.forceApplicationCallback = e.joint.jointData.forceApplicationCallback || function () {\n          r.applyForce();\n        }, e.mainImpostor.registerAfterPhysicsStep(e.joint.jointData.forceApplicationCallback));\n      }\n    }, e.prototype.removeJoint = function (e) {\n      e.joint.type !== Bo.PhysicsJoint.SpringJoint ? this.world.removeConstraint(e.joint.physicsJoint) : e.mainImpostor.unregisterAfterPhysicsStep(e.joint.jointData.forceApplicationCallback);\n    }, e.prototype._addMaterial = function (e, t, i) {\n      var r, n;\n\n      for (r = 0; r < this._physicsMaterials.length; r++) if ((n = this._physicsMaterials[r]).friction === t && n.restitution === i) return n;\n\n      var o = new this.BJSCANNON.Material(e);\n      return o.friction = t, o.restitution = i, this._physicsMaterials.push(o), o;\n    }, e.prototype._checkWithEpsilon = function (e) {\n      return e < Bo.PhysicsEngine.Epsilon ? Bo.PhysicsEngine.Epsilon : e;\n    }, e.prototype._createShape = function (e) {\n      var t,\n          i = e.object,\n          r = e.getObjectExtendSize();\n\n      switch (e.type) {\n        case Bo.PhysicsImpostor.SphereImpostor:\n          var n = r.x,\n              o = r.y,\n              s = r.z;\n          t = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(n), this._checkWithEpsilon(o), this._checkWithEpsilon(s)) / 2);\n          break;\n\n        case Bo.PhysicsImpostor.CylinderImpostor:\n          t = new this.BJSCANNON.Cylinder(this._checkWithEpsilon(r.x) / 2, this._checkWithEpsilon(r.x) / 2, this._checkWithEpsilon(r.y), 16);\n          break;\n\n        case Bo.PhysicsImpostor.BoxImpostor:\n          var a = r.scale(.5);\n          t = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(a.x), this._checkWithEpsilon(a.y), this._checkWithEpsilon(a.z)));\n          break;\n\n        case Bo.PhysicsImpostor.PlaneImpostor:\n          Bo.Tools.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\"), t = new this.BJSCANNON.Plane();\n          break;\n\n        case Bo.PhysicsImpostor.MeshImpostor:\n          var l = i.getVerticesData ? i.getVerticesData(Bo.VertexBuffer.PositionKind) : [],\n              c = i.getIndices ? i.getIndices() : [];\n          if (!l) return;\n          var h = i.position.clone(),\n              u = i.rotation && i.rotation.clone(),\n              d = i.rotationQuaternion && i.rotationQuaternion.clone();\n          i.position.copyFromFloats(0, 0, 0), i.rotation && i.rotation.copyFromFloats(0, 0, 0), i.rotationQuaternion && i.rotationQuaternion.copyFrom(e.getParentsRotation()), i.rotationQuaternion && i.parent && i.rotationQuaternion.conjugateInPlace();\n\n          var f,\n              p = i.computeWorldMatrix(!0),\n              _ = new Array();\n\n          for (f = 0; f < l.length; f += 3) Bo.Vector3.TransformCoordinates(Bo.Vector3.FromArray(l, f), p).toArray(_, f);\n\n          Bo.Tools.Warn(\"MeshImpostor only collides against spheres.\"), t = new this.BJSCANNON.Trimesh(_, c), i.position.copyFrom(h), u && i.rotation && i.rotation.copyFrom(u), d && i.rotationQuaternion && i.rotationQuaternion.copyFrom(d);\n          break;\n\n        case Bo.PhysicsImpostor.HeightmapImpostor:\n          var m = i.position.clone(),\n              g = i.rotation && i.rotation.clone(),\n              v = i.rotationQuaternion && i.rotationQuaternion.clone();\n          i.position.copyFromFloats(0, 0, 0), i.rotation && i.rotation.copyFromFloats(0, 0, 0), i.rotationQuaternion && i.rotationQuaternion.copyFrom(e.getParentsRotation()), i.rotationQuaternion && i.parent && i.rotationQuaternion.conjugateInPlace(), i.rotationQuaternion && i.rotationQuaternion.multiplyInPlace(this._minus90X), t = this._createHeightmap(i), i.position.copyFrom(m), g && i.rotation && i.rotation.copyFrom(g), v && i.rotationQuaternion && i.rotationQuaternion.copyFrom(v), i.computeWorldMatrix(!0);\n          break;\n\n        case Bo.PhysicsImpostor.ParticleImpostor:\n          t = new this.BJSCANNON.Particle();\n      }\n\n      return t;\n    }, e.prototype._createHeightmap = function (e, t) {\n      var i,\n          r = e.getVerticesData(Bo.VertexBuffer.PositionKind),\n          n = e.computeWorldMatrix(!0),\n          o = new Array();\n\n      for (i = 0; i < r.length; i += 3) Bo.Vector3.TransformCoordinates(Bo.Vector3.FromArray(r, i), n).toArray(o, i);\n\n      r = o;\n\n      for (var s = new Array(), a = t || ~~(Math.sqrt(r.length / 3) - 1), l = e.getBoundingInfo(), c = Math.min(l.boundingBox.extendSizeWorld.x, l.boundingBox.extendSizeWorld.y), h = l.boundingBox.extendSizeWorld.z, u = 2 * c / a, d = 0; d < r.length; d += 3) {\n        var f = Math.round(r[d + 0] / u + a / 2),\n            p = Math.round(-1 * (r[d + 1] / u - a / 2)),\n            _ = -r[d + 2] + h;\n\n        s[f] || (s[f] = []), s[f][p] || (s[f][p] = _), s[f][p] = Math.max(_, s[f][p]);\n      }\n\n      for (f = 0; f <= a; ++f) {\n        if (!s[f]) {\n          for (var m = 1; !s[(f + m) % a];) m++;\n\n          s[f] = s[(f + m) % a].slice();\n        }\n\n        for (p = 0; p <= a; ++p) if (!s[f][p]) {\n          var g;\n\n          for (m = 1; void 0 === g;) g = s[f][(p + m++) % a];\n\n          s[f][p] = g;\n        }\n      }\n\n      var v = new this.BJSCANNON.Heightfield(s, {\n        elementSize: u\n      });\n      return v.minY = h, v;\n    }, e.prototype._updatePhysicsBodyTransformation = function (e) {\n      var t = e.object;\n\n      if (t.computeWorldMatrix && t.computeWorldMatrix(!0), t.getBoundingInfo()) {\n        var i = e.getObjectCenter();\n        this._tmpDeltaPosition.copyFrom(t.getAbsolutePivotPoint().subtract(i)), this._tmpDeltaPosition.divideInPlace(e.object.scaling), this._tmpPosition.copyFrom(i);\n        var r = t.rotationQuaternion;\n\n        if (r) {\n          if (e.type !== Bo.PhysicsImpostor.PlaneImpostor && e.type !== Bo.PhysicsImpostor.HeightmapImpostor && e.type !== Bo.PhysicsImpostor.CylinderImpostor || (r = r.multiply(this._minus90X), e.setDeltaRotation(this._plus90X)), e.type === Bo.PhysicsImpostor.HeightmapImpostor) {\n            var n = t,\n                o = n.getBoundingInfo(),\n                s = n.rotationQuaternion;\n            n.rotationQuaternion = this._tmpUnityRotation, n.computeWorldMatrix(!0);\n            var a = i.clone(),\n                l = n.getPivotMatrix() || Bo.Matrix.Translation(0, 0, 0),\n                c = Bo.Matrix.Translation(o.boundingBox.extendSizeWorld.x, 0, -o.boundingBox.extendSizeWorld.z);\n            n.setPreTransformMatrix(c), n.computeWorldMatrix(!0);\n            var h = o.boundingBox.centerWorld.subtract(i).subtract(n.position).negate();\n            this._tmpPosition.copyFromFloats(h.x, h.y - o.boundingBox.extendSizeWorld.y, h.z), this._tmpDeltaPosition.copyFrom(o.boundingBox.centerWorld.subtract(a)), this._tmpDeltaPosition.y += o.boundingBox.extendSizeWorld.y, n.rotationQuaternion = s, n.setPreTransformMatrix(l), n.computeWorldMatrix(!0);\n          } else e.type === Bo.PhysicsImpostor.MeshImpostor && this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n\n          e.setDeltaPosition(this._tmpDeltaPosition), e.physicsBody.position.copy(this._tmpPosition), e.physicsBody.quaternion.copy(r);\n        }\n      }\n    }, e.prototype.setTransformationFromPhysicsBody = function (e) {\n      e.object.position.copyFrom(e.physicsBody.position), e.object.rotationQuaternion && e.object.rotationQuaternion.copyFrom(e.physicsBody.quaternion);\n    }, e.prototype.setPhysicsBodyTransformation = function (e, t, i) {\n      e.physicsBody.position.copy(t), e.physicsBody.quaternion.copy(i);\n    }, e.prototype.isSupported = function () {\n      return void 0 !== this.BJSCANNON;\n    }, e.prototype.setLinearVelocity = function (e, t) {\n      e.physicsBody.velocity.copy(t);\n    }, e.prototype.setAngularVelocity = function (e, t) {\n      e.physicsBody.angularVelocity.copy(t);\n    }, e.prototype.getLinearVelocity = function (e) {\n      var t = e.physicsBody.velocity;\n      return t ? new Bo.Vector3(t.x, t.y, t.z) : null;\n    }, e.prototype.getAngularVelocity = function (e) {\n      var t = e.physicsBody.angularVelocity;\n      return t ? new Bo.Vector3(t.x, t.y, t.z) : null;\n    }, e.prototype.setBodyMass = function (e, t) {\n      e.physicsBody.mass = t, e.physicsBody.updateMassProperties();\n    }, e.prototype.getBodyMass = function (e) {\n      return e.physicsBody.mass;\n    }, e.prototype.getBodyFriction = function (e) {\n      return e.physicsBody.material.friction;\n    }, e.prototype.setBodyFriction = function (e, t) {\n      e.physicsBody.material.friction = t;\n    }, e.prototype.getBodyRestitution = function (e) {\n      return e.physicsBody.material.restitution;\n    }, e.prototype.setBodyRestitution = function (e, t) {\n      e.physicsBody.material.restitution = t;\n    }, e.prototype.sleepBody = function (e) {\n      e.physicsBody.sleep();\n    }, e.prototype.wakeUpBody = function (e) {\n      e.physicsBody.wakeUp();\n    }, e.prototype.updateDistanceJoint = function (e, t, i) {\n      e.physicsJoint.distance = t;\n    }, e.prototype.setMotor = function (e, t, i, r) {\n      r || (e.physicsJoint.enableMotor(), e.physicsJoint.setMotorSpeed(t), i && this.setLimit(e, i));\n    }, e.prototype.setLimit = function (e, t, i) {\n      e.physicsJoint.motorEquation.maxForce = t, e.physicsJoint.motorEquation.minForce = void 0 === i ? -t : i;\n    }, e.prototype.syncMeshWithImpostor = function (e, t) {\n      var i = t.physicsBody;\n      e.position.x = i.position.x, e.position.y = i.position.y, e.position.z = i.position.z, e.rotationQuaternion && (e.rotationQuaternion.x = i.quaternion.x, e.rotationQuaternion.y = i.quaternion.y, e.rotationQuaternion.z = i.quaternion.z, e.rotationQuaternion.w = i.quaternion.w);\n    }, e.prototype.getRadius = function (e) {\n      return e.physicsBody.shapes[0].boundingSphereRadius;\n    }, e.prototype.getBoxSizeToRef = function (e, t) {\n      var i = e.physicsBody.shapes[0];\n      t.x = 2 * i.halfExtents.x, t.y = 2 * i.halfExtents.y, t.z = 2 * i.halfExtents.z;\n    }, e.prototype.dispose = function () {}, e.prototype._extendNamespace = function () {\n      var u = new this.BJSCANNON.Vec3(),\n          d = this.BJSCANNON;\n\n      this.BJSCANNON.World.prototype.step = function (e, t, i) {\n        if (i = i || 10, 0 === (t = t || 0)) this.internalStep(e), this.time += e;else {\n          var r = Math.floor((this.time + t) / e) - Math.floor(this.time / e);\n          r = Math.min(r, i) || 1;\n\n          for (var n = performance.now(), o = 0; o !== r && (this.internalStep(e), !(performance.now() - n > 1e3 * e)); o++);\n\n          this.time += t;\n\n          for (var s = this.time % e / e, a = u, l = this.bodies, c = 0; c !== l.length; c++) {\n            var h = l[c];\n            h.type !== d.Body.STATIC && h.sleepState !== d.Body.SLEEPING ? (h.position.vsub(h.previousPosition, a), a.scale(s, a), h.position.vadd(a, h.interpolatedPosition)) : (h.interpolatedPosition.copy(h.position), h.interpolatedQuaternion.copy(h.quaternion));\n          }\n        }\n      };\n    }, e;\n  }(), Bo.CannonJSPlugin = No, Vo = $a || ($a = {}), Uo = function () {\n    function e(e) {\n      this.name = \"OimoJSPlugin\", this._tmpImpostorsArray = [], this._tmpPositionVector = Vo.Vector3.Zero(), this.BJSOIMO = t, this.world = new this.BJSOIMO.World({\n        iterations: e\n      }), this.world.clear();\n    }\n\n    return e.prototype.setGravity = function (e) {\n      this.world.gravity.copy(e);\n    }, e.prototype.setTimeStep = function (e) {\n      this.world.timeStep = e;\n    }, e.prototype.getTimeStep = function () {\n      return this.world.timeStep;\n    }, e.prototype.executeStep = function (e, t) {\n      var i = this;\n      t.forEach(function (e) {\n        e.beforeStep();\n      }), this.world.step(), t.forEach(function (e) {\n        e.afterStep(), i._tmpImpostorsArray[e.uniqueId] = e;\n      });\n\n      for (var r = this.world.contacts; null !== r;) if (!r.touching || r.body1.sleeping || r.body2.sleeping) {\n        var n = this._tmpImpostorsArray[+r.body1.name],\n            o = this._tmpImpostorsArray[+r.body2.name];\n        n && o && (n.onCollide({\n          body: o.physicsBody\n        }), o.onCollide({\n          body: n.physicsBody\n        })), r = r.next;\n      } else r = r.next;\n    }, e.prototype.applyImpulse = function (e, t, i) {\n      var r = e.physicsBody.mass;\n      e.physicsBody.applyImpulse(i.scale(this.world.invScale), t.scale(this.world.invScale * r));\n    }, e.prototype.applyForce = function (e, t, i) {\n      Vo.Tools.Warn(\"Oimo doesn't support applying force. Using impule instead.\"), this.applyImpulse(e, t, i);\n    }, e.prototype.generatePhysicsBody = function (p) {\n      var _ = this;\n\n      if (p.parent) p.physicsBody && (this.removePhysicsBody(p), p.forceUpdate());else {\n        if (p.isBodyInitRequired()) {\n          var m = {\n            name: p.uniqueId,\n            config: [p.getParam(\"mass\") || 1, p.getParam(\"friction\"), p.getParam(\"restitution\")],\n            size: [],\n            type: [],\n            pos: [],\n            posShape: [],\n            rot: [],\n            rotShape: [],\n            move: 0 !== p.getParam(\"mass\"),\n            density: p.getParam(\"mass\"),\n            friction: p.getParam(\"friction\"),\n            restitution: p.getParam(\"restitution\"),\n            world: this.world\n          },\n              t = [p];\n          (e = p.object).getChildMeshes && e.getChildMeshes().forEach(function (e) {\n            e.physicsImpostor && t.push(e.physicsImpostor);\n          });\n\n          var g = function (e) {\n            return Math.max(e, Vo.PhysicsEngine.Epsilon);\n          },\n              v = new Vo.Quaternion();\n\n          t.forEach(function (e) {\n            if (e.object.rotationQuaternion) {\n              var t = e.object.rotationQuaternion;\n              v = t.clone();\n              var i = t.toEulerAngles(),\n                  r = e.getObjectExtendSize(),\n                  n = 57.29577951308232;\n\n              if (e === p) {\n                var o = p.getObjectCenter();\n                p.object.getAbsolutePivotPoint().subtractToRef(o, _._tmpPositionVector), _._tmpPositionVector.divideInPlace(p.object.scaling), m.pos.push(o.x), m.pos.push(o.y), m.pos.push(o.z), m.posShape.push(0, 0, 0), m.rot.push(0), m.rot.push(0), m.rot.push(0), m.rotShape.push(0, 0, 0);\n              } else {\n                var s = e.object.getAbsolutePosition().subtract(p.object.getAbsolutePosition());\n                m.posShape.push(s.x), m.posShape.push(s.y), m.posShape.push(s.z), m.pos.push(0, 0, 0), m.rot.push(0), m.rot.push(0), m.rot.push(0), m.rotShape.push(i.x * n), m.rotShape.push(i.y * n), m.rotShape.push(i.z * n);\n              }\n\n              switch (e.type) {\n                case Vo.PhysicsImpostor.ParticleImpostor:\n                  Vo.Tools.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\n\n                case Vo.PhysicsImpostor.SphereImpostor:\n                  var a = r.x,\n                      l = r.y,\n                      c = r.z,\n                      h = Math.max(g(a), g(l), g(c)) / 2;\n                  m.type.push(\"sphere\"), m.size.push(h), m.size.push(h), m.size.push(h);\n                  break;\n\n                case Vo.PhysicsImpostor.CylinderImpostor:\n                  var u = g(r.x) / 2,\n                      d = g(r.y);\n                  m.type.push(\"cylinder\"), m.size.push(u), m.size.push(d), m.size.push(d);\n                  break;\n\n                case Vo.PhysicsImpostor.PlaneImpostor:\n                case Vo.PhysicsImpostor.BoxImpostor:\n                default:\n                  u = g(r.x), d = g(r.y);\n                  var f = g(r.z);\n                  m.type.push(\"box\"), m.size.push(u), m.size.push(d), m.size.push(f);\n              }\n\n              e.object.rotationQuaternion = t;\n            }\n          }), p.physicsBody = this.world.add(m), p.physicsBody.resetQuaternion(v), p.physicsBody.updatePosition(0);\n        } else this._tmpPositionVector.copyFromFloats(0, 0, 0);\n\n        var e;\n        p.setDeltaPosition(this._tmpPositionVector);\n      }\n    }, e.prototype.removePhysicsBody = function (e) {\n      this.world.removeRigidBody(e.physicsBody);\n    }, e.prototype.generateJoint = function (e) {\n      var t = e.mainImpostor.physicsBody,\n          i = e.connectedImpostor.physicsBody;\n\n      if (t && i) {\n        var r,\n            n = e.joint.jointData,\n            o = n.nativeParams || {},\n            s = {\n          body1: t,\n          body2: i,\n          axe1: o.axe1 || (n.mainAxis ? n.mainAxis.asArray() : null),\n          axe2: o.axe2 || (n.connectedAxis ? n.connectedAxis.asArray() : null),\n          pos1: o.pos1 || (n.mainPivot ? n.mainPivot.asArray() : null),\n          pos2: o.pos2 || (n.connectedPivot ? n.connectedPivot.asArray() : null),\n          min: o.min,\n          max: o.max,\n          collision: o.collision || n.collision,\n          spring: o.spring,\n          world: this.world\n        };\n\n        switch (e.joint.type) {\n          case Vo.PhysicsJoint.BallAndSocketJoint:\n            r = \"jointBall\";\n            break;\n\n          case Vo.PhysicsJoint.SpringJoint:\n            Vo.Tools.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\n            var a = n;\n            s.min = a.length || s.min, s.max = Math.max(s.min, s.max);\n\n          case Vo.PhysicsJoint.DistanceJoint:\n            r = \"jointDistance\", s.max = n.maxDistance;\n            break;\n\n          case Vo.PhysicsJoint.PrismaticJoint:\n            r = \"jointPrisme\";\n            break;\n\n          case Vo.PhysicsJoint.SliderJoint:\n            r = \"jointSlide\";\n            break;\n\n          case Vo.PhysicsJoint.WheelJoint:\n            r = \"jointWheel\";\n            break;\n\n          case Vo.PhysicsJoint.HingeJoint:\n          default:\n            r = \"jointHinge\";\n        }\n\n        s.type = r, e.joint.physicsJoint = this.world.add(s);\n      }\n    }, e.prototype.removeJoint = function (e) {\n      try {\n        this.world.removeJoint(e.joint.physicsJoint);\n      } catch (e) {\n        Vo.Tools.Warn(e);\n      }\n    }, e.prototype.isSupported = function () {\n      return void 0 !== this.BJSOIMO;\n    }, e.prototype.setTransformationFromPhysicsBody = function (e) {\n      e.physicsBody.sleeping || (e.object.position.copyFrom(e.physicsBody.getPosition()), e.object.rotationQuaternion && e.object.rotationQuaternion.copyFrom(e.physicsBody.getQuaternion()));\n    }, e.prototype.setPhysicsBodyTransformation = function (e, t, i) {\n      var r = e.physicsBody;\n      r.position.copy(t), r.orientation.copy(i), r.syncShapes(), r.awake();\n    }, e.prototype.setLinearVelocity = function (e, t) {\n      e.physicsBody.linearVelocity.copy(t);\n    }, e.prototype.setAngularVelocity = function (e, t) {\n      e.physicsBody.angularVelocity.copy(t);\n    }, e.prototype.getLinearVelocity = function (e) {\n      var t = e.physicsBody.linearVelocity;\n      return t ? new Vo.Vector3(t.x, t.y, t.z) : null;\n    }, e.prototype.getAngularVelocity = function (e) {\n      var t = e.physicsBody.angularVelocity;\n      return t ? new Vo.Vector3(t.x, t.y, t.z) : null;\n    }, e.prototype.setBodyMass = function (e, t) {\n      var i = 0 === t;\n      e.physicsBody.shapes.density = i ? 1 : t, e.physicsBody.setupMass(i ? 2 : 1);\n    }, e.prototype.getBodyMass = function (e) {\n      return e.physicsBody.shapes.density;\n    }, e.prototype.getBodyFriction = function (e) {\n      return e.physicsBody.shapes.friction;\n    }, e.prototype.setBodyFriction = function (e, t) {\n      e.physicsBody.shapes.friction = t;\n    }, e.prototype.getBodyRestitution = function (e) {\n      return e.physicsBody.shapes.restitution;\n    }, e.prototype.setBodyRestitution = function (e, t) {\n      e.physicsBody.shapes.restitution = t;\n    }, e.prototype.sleepBody = function (e) {\n      e.physicsBody.sleep();\n    }, e.prototype.wakeUpBody = function (e) {\n      e.physicsBody.awake();\n    }, e.prototype.updateDistanceJoint = function (e, t, i) {\n      e.physicsJoint.limitMotor.upperLimit = t, void 0 !== i && (e.physicsJoint.limitMotor.lowerLimit = i);\n    }, e.prototype.setMotor = function (e, t, i, r) {\n      var n = r ? e.physicsJoint.rotationalLimitMotor2 : e.physicsJoint.rotationalLimitMotor1 || e.physicsJoint.rotationalLimitMotor || e.physicsJoint.limitMotor;\n      n && n.setMotor(t, i);\n    }, e.prototype.setLimit = function (e, t, i, r) {\n      var n = r ? e.physicsJoint.rotationalLimitMotor2 : e.physicsJoint.rotationalLimitMotor1 || e.physicsJoint.rotationalLimitMotor || e.physicsJoint.limitMotor;\n      n && n.setLimit(t, void 0 === i ? -t : i);\n    }, e.prototype.syncMeshWithImpostor = function (e, t) {\n      var i = t.physicsBody;\n      e.position.x = i.position.x, e.position.y = i.position.y, e.position.z = i.position.z, e.rotationQuaternion && (e.rotationQuaternion.x = i.orientation.x, e.rotationQuaternion.y = i.orientation.y, e.rotationQuaternion.z = i.orientation.z, e.rotationQuaternion.w = i.orientation.s);\n    }, e.prototype.getRadius = function (e) {\n      return e.physicsBody.shapes.radius;\n    }, e.prototype.getBoxSizeToRef = function (e, t) {\n      var i = e.physicsBody.shapes;\n      t.x = 2 * i.halfWidth, t.y = 2 * i.halfHeight, t.z = 2 * i.halfDepth;\n    }, e.prototype.dispose = function () {\n      this.world.clear();\n    }, e;\n  }(), Vo.OimoJSPlugin = Uo, function (n) {\n    n.Scene.prototype.getPhysicsEngine = function () {\n      return this._physicsEngine;\n    }, n.Scene.prototype.enablePhysics = function (e, t) {\n      if (void 0 === e && (e = null), this._physicsEngine) return !0;\n\n      var i = this._getComponent(n.SceneComponentConstants.NAME_PHYSICSENGINE);\n\n      i || (i = new r(this), this._addComponent(i));\n\n      try {\n        return this._physicsEngine = new n.PhysicsEngine(e, t), !0;\n      } catch (e) {\n        return n.Tools.Error(e.message), !1;\n      }\n    }, n.Scene.prototype.disablePhysicsEngine = function () {\n      this._physicsEngine && (this._physicsEngine.dispose(), this._physicsEngine = null);\n    }, n.Scene.prototype.isPhysicsEnabled = function () {\n      return void 0 !== this._physicsEngine;\n    }, n.Scene.prototype.deleteCompoundImpostor = function (e) {\n      var t = e.parts[0].mesh;\n      t.physicsImpostor && (t.physicsImpostor.dispose(), t.physicsImpostor = null);\n    }, n.Scene.prototype._advancePhysicsEngineStep = function (e) {\n      this._physicsEngine && (this.onBeforePhysicsObservable.notifyObservers(this), this._physicsEngine._step(e / 1e3), this.onAfterPhysicsObservable.notifyObservers(this));\n    }, Object.defineProperty(n.AbstractMesh.prototype, \"physicsImpostor\", {\n      get: function () {\n        return this._physicsImpostor;\n      },\n      set: function (e) {\n        var t = this;\n        this._physicsImpostor !== e && (this._disposePhysicsObserver && this.onDisposeObservable.remove(this._disposePhysicsObserver), (this._physicsImpostor = e) && (this._disposePhysicsObserver = this.onDisposeObservable.add(function () {\n          t.physicsImpostor && (t.physicsImpostor.dispose(), t.physicsImpostor = null);\n        })));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.AbstractMesh.prototype.getPhysicsImpostor = function () {\n      return this.physicsImpostor;\n    }, n.AbstractMesh.prototype.applyImpulse = function (e, t) {\n      return this.physicsImpostor && this.physicsImpostor.applyImpulse(e, t), this;\n    }, n.AbstractMesh.prototype.setPhysicsLinkWith = function (e, t, i, r) {\n      return this.physicsImpostor && e.physicsImpostor && this.physicsImpostor.createJoint(e.physicsImpostor, n.PhysicsJoint.HingeJoint, {\n        mainPivot: t,\n        connectedPivot: i,\n        nativeParams: r\n      }), this;\n    };\n\n    var r = function () {\n      function e(e) {\n        var t = this;\n        this.name = n.SceneComponentConstants.NAME_PHYSICSENGINE, this.scene = e, this.scene.onBeforePhysicsObservable = new n.Observable(), this.scene.onAfterPhysicsObservable = new n.Observable(), this.scene.getDeterministicFrameTime = function () {\n          return t.scene._physicsEngine ? 1e3 * t.scene._physicsEngine.getTimeStep() : 1e3 / 60;\n        };\n      }\n\n      return e.prototype.register = function () {}, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {\n        this.scene.onBeforePhysicsObservable.clear(), this.scene.onAfterPhysicsObservable.clear(), this.scene._physicsEngine && this.scene.disablePhysicsEngine();\n      }, e;\n    }();\n\n    n.PhysicsEngineSceneComponent = r;\n  }($a || ($a = {})), function (B) {\n    function e(e) {\n      return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24);\n    }\n\n    var N = e(\"DXT1\"),\n        V = e(\"DXT3\"),\n        U = e(\"DXT5\"),\n        z = e(\"DX10\"),\n        t = function () {\n      function F() {}\n\n      return F.GetDDSInfo = function (e) {\n        var t = new Int32Array(e, 0, 31),\n            i = new Int32Array(e, 0, 35),\n            r = 1;\n        131072 & t[2] && (r = Math.max(1, t[7]));\n        var n = t[21],\n            o = n === z ? i[32] : 0,\n            s = B.Engine.TEXTURETYPE_UNSIGNED_INT;\n\n        switch (n) {\n          case 113:\n            s = B.Engine.TEXTURETYPE_HALF_FLOAT;\n            break;\n\n          case 116:\n            s = B.Engine.TEXTURETYPE_FLOAT;\n            break;\n\n          case z:\n            if (10 === o) {\n              s = B.Engine.TEXTURETYPE_HALF_FLOAT;\n              break;\n            }\n\n        }\n\n        return {\n          width: t[4],\n          height: t[3],\n          mipmapCount: r,\n          isFourCC: 4 == (4 & t[20]),\n          isRGB: 64 == (64 & t[20]),\n          isLuminance: 131072 == (131072 & t[20]),\n          isCube: 512 == (512 & t[28]),\n          isCompressed: n === N || n === V || n === U,\n          dxgiFormat: o,\n          textureType: s\n        };\n      }, F._ToHalfFloat = function (e) {\n        F._FloatView || (F._FloatView = new Float32Array(1), F._Int32View = new Int32Array(F._FloatView.buffer)), F._FloatView[0] = e;\n        var t = F._Int32View[0],\n            i = t >> 16 & 32768,\n            r = t >> 12 & 2047,\n            n = t >> 23 & 255;\n        return n < 103 ? i : 142 < n ? (i |= 31744, i |= (255 == n ? 0 : 1) && 8388607 & t) : n < 113 ? i |= ((r |= 2048) >> 114 - n) + (r >> 113 - n & 1) : (i |= n - 112 << 10 | r >> 1, i += 1 & r);\n      }, F._FromHalfFloat = function (e) {\n        var t = (32768 & e) >> 15,\n            i = (31744 & e) >> 10,\n            r = 1023 & e;\n        return 0 === i ? (t ? -1 : 1) * Math.pow(2, -14) * (r / Math.pow(2, 10)) : 31 == i ? r ? NaN : 1 / 0 * (t ? -1 : 1) : (t ? -1 : 1) * Math.pow(2, i - 15) * (1 + r / Math.pow(2, 10));\n      }, F._GetHalfFloatAsFloatRGBAArrayBuffer = function (e, t, i, r, n, o) {\n        for (var s = new Float32Array(r), a = new Uint16Array(n, i), l = 0, c = 0; c < t; c++) for (var h = 0; h < e; h++) {\n          var u = 4 * (h + c * e);\n          s[l] = F._FromHalfFloat(a[u]), s[l + 1] = F._FromHalfFloat(a[u + 1]), s[l + 2] = F._FromHalfFloat(a[u + 2]), s[l + 3] = F.StoreLODInAlphaChannel ? o : F._FromHalfFloat(a[u + 3]), l += 4;\n        }\n\n        return s;\n      }, F._GetHalfFloatRGBAArrayBuffer = function (e, t, i, r, n, o) {\n        if (F.StoreLODInAlphaChannel) {\n          for (var s = new Uint16Array(r), a = new Uint16Array(n, i), l = 0, c = 0; c < t; c++) for (var h = 0; h < e; h++) {\n            var u = 4 * (h + c * e);\n            s[l] = a[u], s[l + 1] = a[u + 1], s[l + 2] = a[u + 2], s[l + 3] = F._ToHalfFloat(o), l += 4;\n          }\n\n          return s;\n        }\n\n        return new Uint16Array(n, i, r);\n      }, F._GetFloatRGBAArrayBuffer = function (e, t, i, r, n, o) {\n        if (F.StoreLODInAlphaChannel) {\n          for (var s = new Float32Array(r), a = new Float32Array(n, i), l = 0, c = 0; c < t; c++) for (var h = 0; h < e; h++) {\n            var u = 4 * (h + c * e);\n            s[l] = a[u], s[l + 1] = a[u + 1], s[l + 2] = a[u + 2], s[l + 3] = o, l += 4;\n          }\n\n          return s;\n        }\n\n        return new Float32Array(n, i, r);\n      }, F._GetFloatAsUIntRGBAArrayBuffer = function (e, t, i, r, n, o) {\n        for (var s = new Uint8Array(r), a = new Float32Array(n, i), l = 0, c = 0; c < t; c++) for (var h = 0; h < e; h++) {\n          var u = 4 * (h + c * e);\n          s[l] = 255 * B.Scalar.Clamp(a[u]), s[l + 1] = 255 * B.Scalar.Clamp(a[u + 1]), s[l + 2] = 255 * B.Scalar.Clamp(a[u + 2]), s[l + 3] = F.StoreLODInAlphaChannel ? o : 255 * B.Scalar.Clamp(a[u + 3]), l += 4;\n        }\n\n        return s;\n      }, F._GetHalfFloatAsUIntRGBAArrayBuffer = function (e, t, i, r, n, o) {\n        for (var s = new Uint8Array(r), a = new Uint16Array(n, i), l = 0, c = 0; c < t; c++) for (var h = 0; h < e; h++) {\n          var u = 4 * (h + c * e);\n          s[l] = 255 * B.Scalar.Clamp(F._FromHalfFloat(a[u])), s[l + 1] = 255 * B.Scalar.Clamp(F._FromHalfFloat(a[u + 1])), s[l + 2] = 255 * B.Scalar.Clamp(F._FromHalfFloat(a[u + 2])), s[l + 3] = F.StoreLODInAlphaChannel ? o : 255 * B.Scalar.Clamp(F._FromHalfFloat(a[u + 3])), l += 4;\n        }\n\n        return s;\n      }, F._GetRGBAArrayBuffer = function (e, t, i, r, n, o, s, a, l) {\n        for (var c = new Uint8Array(r), h = new Uint8Array(n, i), u = 0, d = 0; d < t; d++) for (var f = 0; f < e; f++) {\n          var p = 4 * (f + d * e);\n          c[u] = h[p + o], c[u + 1] = h[p + s], c[u + 2] = h[p + a], c[u + 3] = h[p + l], u += 4;\n        }\n\n        return c;\n      }, F._ExtractLongWordOrder = function (e) {\n        return 0 === e || 255 === e || -16777216 === e ? 0 : 1 + F._ExtractLongWordOrder(e >> 8);\n      }, F._GetRGBArrayBuffer = function (e, t, i, r, n, o, s, a) {\n        for (var l = new Uint8Array(r), c = new Uint8Array(n, i), h = 0, u = 0; u < t; u++) for (var d = 0; d < e; d++) {\n          var f = 3 * (d + u * e);\n          l[h] = c[f + o], l[h + 1] = c[f + s], l[h + 2] = c[f + a], h += 3;\n        }\n\n        return l;\n      }, F._GetLuminanceArrayBuffer = function (e, t, i, r, n) {\n        for (var o = new Uint8Array(r), s = new Uint8Array(n, i), a = 0, l = 0; l < t; l++) for (var c = 0; c < e; c++) {\n          var h = c + l * e;\n          o[a] = s[h], a++;\n        }\n\n        return o;\n      }, F.UploadDDSLevels = function (e, t, i, r, n, o, s, a) {\n        void 0 === s && (s = -1);\n        var l = null;\n        r.sphericalPolynomial && (l = new Array());\n\n        var c,\n            h,\n            u,\n            d,\n            f,\n            p,\n            _,\n            m = e.getCaps().s3tc,\n            g = new Int32Array(i, 0, 31),\n            v = 0,\n            y = 0,\n            b = 1;\n\n        if (542327876 === g[0]) {\n          if (r.isFourCC || r.isRGB || r.isLuminance) {\n            if (!r.isCompressed || m) {\n              var T = g[22];\n              d = g[1] + 4;\n              var E,\n                  x = !1;\n              if (r.isFourCC) switch (c = g[21]) {\n                case N:\n                  b = 8, y = m.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n                  break;\n\n                case V:\n                  b = 16, y = m.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n                  break;\n\n                case U:\n                  b = 16, y = m.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n                  break;\n\n                case 113:\n                case 116:\n                  x = !0;\n                  break;\n\n                case z:\n                  d += 20;\n                  var P = !1;\n\n                  switch (r.dxgiFormat) {\n                    case 10:\n                      P = x = !0;\n                      break;\n\n                    case 88:\n                      r.isRGB = !0, T = 32, P = !(r.isFourCC = !1);\n                  }\n\n                  if (P) break;\n\n                default:\n                  return void console.error(\"Unsupported FourCC code:\", (E = c, String.fromCharCode(255 & E, E >> 8 & 255, E >> 16 & 255, E >> 24 & 255)));\n              }\n\n              var A = F._ExtractLongWordOrder(g[23]),\n                  S = F._ExtractLongWordOrder(g[24]),\n                  M = F._ExtractLongWordOrder(g[25]),\n                  R = F._ExtractLongWordOrder(g[26]);\n\n              x && (y = e._getRGBABufferInternalSizedFormat(r.textureType)), p = 1, 131072 & g[2] && !1 !== n && (p = Math.max(1, g[7]));\n\n              for (var C = 0; C < o; C++) {\n                for (h = g[4], u = g[3], _ = 0; _ < p; ++_) {\n                  if (-1 === s || s === _) {\n                    var O = -1 === s ? _ : 0;\n\n                    if (!r.isCompressed && r.isFourCC) {\n                      t.format = B.Engine.TEXTUREFORMAT_RGBA, v = h * u * 4;\n                      var D = null;\n                      e._badOS || e._badDesktopOS || !e.getCaps().textureHalfFloat && !e.getCaps().textureFloat ? (128 === T ? (D = F._GetFloatAsUIntRGBAArrayBuffer(h, u, d, v, i, O), l && 0 == O && l.push(F._GetFloatRGBAArrayBuffer(h, u, d, v, i, O))) : 64 === T && (D = F._GetHalfFloatAsUIntRGBAArrayBuffer(h, u, d, v, i, O), l && 0 == O && l.push(F._GetHalfFloatAsFloatRGBAArrayBuffer(h, u, d, v, i, O))), t.type = B.Engine.TEXTURETYPE_UNSIGNED_INT) : 128 === T ? (t.type = B.Engine.TEXTURETYPE_FLOAT, D = F._GetFloatRGBAArrayBuffer(h, u, d, v, i, O), l && 0 == O && l.push(D)) : 64 !== T || e.getCaps().textureHalfFloat ? (t.type = B.Engine.TEXTURETYPE_HALF_FLOAT, D = F._GetHalfFloatRGBAArrayBuffer(h, u, d, v, i, O), l && 0 == O && l.push(F._GetHalfFloatAsFloatRGBAArrayBuffer(h, u, d, v, i, O))) : (t.type = B.Engine.TEXTURETYPE_FLOAT, D = F._GetHalfFloatAsFloatRGBAArrayBuffer(h, u, d, v, i, O), l && 0 == O && l.push(D)), D && e._uploadDataToTextureDirectly(t, D, C, O);\n                    } else if (r.isRGB) t.type = B.Engine.TEXTURETYPE_UNSIGNED_INT, 24 === T ? (t.format = B.Engine.TEXTUREFORMAT_RGB, f = F._GetRGBArrayBuffer(h, u, d, v = h * u * 3, i, A, S, M)) : (t.format = B.Engine.TEXTUREFORMAT_RGBA, f = F._GetRGBAArrayBuffer(h, u, d, v = h * u * 4, i, A, S, M, R)), e._uploadDataToTextureDirectly(t, f, C, O);else if (r.isLuminance) {\n                      var I = e._getUnpackAlignement(),\n                          w = h,\n                          L = Math.floor((h + I - 1) / I) * I;\n\n                      f = F._GetLuminanceArrayBuffer(h, u, d, v = L * (u - 1) + w, i), t.format = B.Engine.TEXTUREFORMAT_LUMINANCE, t.type = B.Engine.TEXTURETYPE_UNSIGNED_INT, e._uploadDataToTextureDirectly(t, f, C, O);\n                    } else v = Math.max(4, h) / 4 * Math.max(4, u) / 4 * b, f = new Uint8Array(i, d, v), t.type = B.Engine.TEXTURETYPE_UNSIGNED_INT, e._uploadCompressedDataToTextureDirectly(t, y, h, u, f, C, O);\n                  }\n\n                  d += T ? h * u * (T / 8) : v, h *= .5, u *= .5, h = Math.max(1, h), u = Math.max(1, u);\n                }\n\n                if (void 0 !== a) break;\n              }\n\n              l && 0 < l.length ? r.sphericalPolynomial = B.CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n                size: g[4],\n                right: l[0],\n                left: l[1],\n                up: l[2],\n                down: l[3],\n                front: l[4],\n                back: l[5],\n                format: B.Engine.TEXTUREFORMAT_RGBA,\n                type: B.Engine.TEXTURETYPE_FLOAT,\n                gammaSpace: !1\n              }) : r.sphericalPolynomial = void 0;\n            } else B.Tools.Error(\"Compressed textures are not supported on this platform.\");\n          } else B.Tools.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n        } else B.Tools.Error(\"Invalid magic number in DDS header\");\n      }, F.StoreLODInAlphaChannel = !1, F;\n    }();\n\n    B.DDSTools = t;\n  }($a || ($a = {})), zo = $a || ($a = {}), Go = function () {\n    function e() {\n      this.supportCascades = !0;\n    }\n\n    return e.prototype.canLoad = function (e, t, i, r, n) {\n      return 0 === e.indexOf(\".dds\");\n    }, e.prototype.transformUrl = function (e, t) {\n      return e;\n    }, e.prototype.getFallbackTextureUrl = function (e, t) {\n      return null;\n    }, e.prototype.loadCubeData = function (e, t, i, r, n) {\n      var o,\n          s = t.getEngine(),\n          a = !1;\n      if (Array.isArray(e)) for (var l = 0; l < e.length; l++) {\n        var c = e[l];\n        o = zo.DDSTools.GetDDSInfo(c), t.width = o.width, t.height = o.height, a = (o.isRGB || o.isLuminance || 1 < o.mipmapCount) && t.generateMipMaps, s._unpackFlipY(o.isCompressed), zo.DDSTools.UploadDDSLevels(s, t, c, o, a, 6, -1, l), o.isFourCC || 1 !== o.mipmapCount || s.generateMipMapsForCubemap(t);\n      } else {\n        var h = e;\n        o = zo.DDSTools.GetDDSInfo(h), t.width = o.width, t.height = o.height, i && (o.sphericalPolynomial = new zo.SphericalPolynomial()), a = (o.isRGB || o.isLuminance || 1 < o.mipmapCount) && t.generateMipMaps, s._unpackFlipY(o.isCompressed), zo.DDSTools.UploadDDSLevels(s, t, h, o, a, 6), o.isFourCC || 1 !== o.mipmapCount || s.generateMipMapsForCubemap(t);\n      }\n      s._setCubeMapTextureParams(a), t.isReady = !0, r && r({\n        isDDS: !0,\n        width: t.width,\n        info: o,\n        data: e,\n        texture: t\n      });\n    }, e.prototype.loadData = function (e, t, i) {\n      var r = zo.DDSTools.GetDDSInfo(e),\n          n = (r.isRGB || r.isLuminance || 1 < r.mipmapCount) && t.generateMipMaps && r.width >> r.mipmapCount - 1 == 1;\n      i(r.width, r.height, n, r.isFourCC, function () {\n        zo.DDSTools.UploadDDSLevels(t.getEngine(), t, e, r, n, 1);\n      });\n    }, e;\n  }(), zo.Engine._TextureLoaders.push(new Go()), ko = $a || ($a = {}), Wo = function () {\n    function x() {}\n\n    return x.GetTGAHeader = function (e) {\n      var t = 0;\n      return {\n        id_length: e[t++],\n        colormap_type: e[t++],\n        image_type: e[t++],\n        colormap_index: e[t++] | e[t++] << 8,\n        colormap_length: e[t++] | e[t++] << 8,\n        colormap_size: e[t++],\n        origin: [e[t++] | e[t++] << 8, e[t++] | e[t++] << 8],\n        width: e[t++] | e[t++] << 8,\n        height: e[t++] | e[t++] << 8,\n        pixel_size: e[t++],\n        flags: e[t++]\n      };\n    }, x.UploadContent = function (e, t) {\n      if (t.length < 19) ko.Tools.Error(\"Unable to load TGA file - Not enough data to contain header\");else {\n        var i = 18,\n            r = x.GetTGAHeader(t);\n        if (r.id_length + i > t.length) ko.Tools.Error(\"Unable to load TGA file - Not enough data\");else {\n          i += r.id_length;\n          var n,\n              o = !1,\n              s = !1,\n              a = !1;\n\n          switch (r.image_type) {\n            case x._TYPE_RLE_INDEXED:\n              o = !0;\n\n            case x._TYPE_INDEXED:\n              s = !0;\n              break;\n\n            case x._TYPE_RLE_RGB:\n              o = !0;\n\n            case x._TYPE_RGB:\n              break;\n\n            case x._TYPE_RLE_GREY:\n              o = !0;\n\n            case x._TYPE_GREY:\n              a = !0;\n          }\n\n          var l,\n              c,\n              h,\n              u,\n              d,\n              f,\n              p,\n              _ = r.pixel_size >> 3,\n              m = r.width * r.height * _;\n\n          if (s && (l = t.subarray(i, i += r.colormap_length * (r.colormap_size >> 3))), o) {\n            var g, v, y;\n            n = new Uint8Array(m);\n\n            for (var b = 0, T = new Uint8Array(_); i < m && b < m;) if (v = 1 + (127 & (g = t[i++])), 128 & g) {\n              for (y = 0; y < _; ++y) T[y] = t[i++];\n\n              for (y = 0; y < v; ++y) n.set(T, b + y * _);\n\n              b += _ * v;\n            } else {\n              for (v *= _, y = 0; y < v; ++y) n[b + y] = t[i++];\n\n              b += v;\n            }\n          } else n = t.subarray(i, i += s ? r.width * r.height : m);\n\n          switch ((r.flags & x._ORIGIN_MASK) >> x._ORIGIN_SHIFT) {\n            default:\n            case x._ORIGIN_UL:\n              c = 0, u = 1, p = r.width, h = 0, d = 1, f = r.height;\n              break;\n\n            case x._ORIGIN_BL:\n              c = 0, u = 1, p = r.width, h = r.height - 1, f = d = -1;\n              break;\n\n            case x._ORIGIN_UR:\n              c = r.width - 1, p = u = -1, h = 0, d = 1, f = r.height;\n              break;\n\n            case x._ORIGIN_BR:\n              c = r.width - 1, p = u = -1, h = r.height - 1, f = d = -1;\n          }\n\n          var E = x[\"_getImageData\" + (a ? \"Grey\" : \"\") + r.pixel_size + \"bits\"](r, l, n, h, d, f, c, u, p);\n\n          e.getEngine()._uploadDataToTextureDirectly(e, E);\n        }\n      }\n    }, x._getImageData8bits = function (e, t, i, r, n, o, s, a, l) {\n      var c,\n          h,\n          u,\n          d = i,\n          f = t,\n          p = e.width,\n          _ = e.height,\n          m = 0,\n          g = new Uint8Array(p * _ * 4);\n\n      for (u = r; u !== o; u += n) for (h = s; h !== l; h += a, m++) c = d[m], g[4 * (h + p * u) + 3] = 255, g[4 * (h + p * u) + 2] = f[3 * c + 0], g[4 * (h + p * u) + 1] = f[3 * c + 1], g[4 * (h + p * u) + 0] = f[3 * c + 2];\n\n      return g;\n    }, x._getImageData16bits = function (e, t, i, r, n, o, s, a, l) {\n      var c,\n          h,\n          u,\n          d = i,\n          f = e.width,\n          p = e.height,\n          _ = 0,\n          m = new Uint8Array(f * p * 4);\n\n      for (u = r; u !== o; u += n) for (h = s; h !== l; h += a, _ += 2) {\n        var g = 255 * ((31744 & (c = d[_ + 0] + (d[_ + 1] << 8))) >> 10) / 31 | 0,\n            v = 255 * ((992 & c) >> 5) / 31 | 0,\n            y = 255 * (31 & c) / 31 | 0;\n        m[4 * (h + f * u) + 0] = g, m[4 * (h + f * u) + 1] = v, m[4 * (h + f * u) + 2] = y, m[4 * (h + f * u) + 3] = 32768 & c ? 0 : 255;\n      }\n\n      return m;\n    }, x._getImageData24bits = function (e, t, i, r, n, o, s, a, l) {\n      var c,\n          h,\n          u = i,\n          d = e.width,\n          f = e.height,\n          p = 0,\n          _ = new Uint8Array(d * f * 4);\n\n      for (h = r; h !== o; h += n) for (c = s; c !== l; c += a, p += 3) _[4 * (c + d * h) + 3] = 255, _[4 * (c + d * h) + 2] = u[p + 0], _[4 * (c + d * h) + 1] = u[p + 1], _[4 * (c + d * h) + 0] = u[p + 2];\n\n      return _;\n    }, x._getImageData32bits = function (e, t, i, r, n, o, s, a, l) {\n      var c,\n          h,\n          u = i,\n          d = e.width,\n          f = e.height,\n          p = 0,\n          _ = new Uint8Array(d * f * 4);\n\n      for (h = r; h !== o; h += n) for (c = s; c !== l; c += a, p += 4) _[4 * (c + d * h) + 2] = u[p + 0], _[4 * (c + d * h) + 1] = u[p + 1], _[4 * (c + d * h) + 0] = u[p + 2], _[4 * (c + d * h) + 3] = u[p + 3];\n\n      return _;\n    }, x._getImageDataGrey8bits = function (e, t, i, r, n, o, s, a, l) {\n      var c,\n          h,\n          u,\n          d = i,\n          f = e.width,\n          p = e.height,\n          _ = 0,\n          m = new Uint8Array(f * p * 4);\n\n      for (u = r; u !== o; u += n) for (h = s; h !== l; h += a, _++) c = d[_], m[4 * (h + f * u) + 0] = c, m[4 * (h + f * u) + 1] = c, m[4 * (h + f * u) + 2] = c, m[4 * (h + f * u) + 3] = 255;\n\n      return m;\n    }, x._getImageDataGrey16bits = function (e, t, i, r, n, o, s, a, l) {\n      var c,\n          h,\n          u = i,\n          d = e.width,\n          f = e.height,\n          p = 0,\n          _ = new Uint8Array(d * f * 4);\n\n      for (h = r; h !== o; h += n) for (c = s; c !== l; c += a, p += 2) _[4 * (c + d * h) + 0] = u[p + 0], _[4 * (c + d * h) + 1] = u[p + 0], _[4 * (c + d * h) + 2] = u[p + 0], _[4 * (c + d * h) + 3] = u[p + 1];\n\n      return _;\n    }, x._TYPE_INDEXED = 1, x._TYPE_RGB = 2, x._TYPE_GREY = 3, x._TYPE_RLE_INDEXED = 9, x._TYPE_RLE_RGB = 10, x._TYPE_RLE_GREY = 11, x._ORIGIN_MASK = 48, x._ORIGIN_SHIFT = 4, x._ORIGIN_BL = 0, x._ORIGIN_BR = 1, x._ORIGIN_UL = 2, x._ORIGIN_UR = 3, x;\n  }(), ko.TGATools = Wo, Ho = $a || ($a = {}), Xo = function () {\n    function e() {\n      this.supportCascades = !1;\n    }\n\n    return e.prototype.canLoad = function (e, t, i, r, n) {\n      return 0 === e.indexOf(\".tga\");\n    }, e.prototype.transformUrl = function (e, t) {\n      return e;\n    }, e.prototype.getFallbackTextureUrl = function (e, t) {\n      return null;\n    }, e.prototype.loadCubeData = function (e, t, i, r, n) {\n      throw \".env not supported in Cube.\";\n    }, e.prototype.loadData = function (e, t, i) {\n      var r = new Uint8Array(e),\n          n = Ho.TGATools.GetTGAHeader(r);\n      i(n.width, n.height, t.generateMipMaps, !1, function () {\n        Ho.TGATools.UploadContent(t, r);\n      });\n    }, e;\n  }(), Ho.Engine._TextureLoaders.push(new Xo()), jo = $a || ($a = {}), Yo = function () {\n    function h(e, t, i, r) {\n      this.arrayBuffer = e;\n      var n = new Uint8Array(this.arrayBuffer, 0, 12);\n\n      if (171 === n[0] && 75 === n[1] && 84 === n[2] && 88 === n[3] && 32 === n[4] && 49 === n[5] && 49 === n[6] && 187 === n[7] && 13 === n[8] && 10 === n[9] && 26 === n[10] && 10 === n[11]) {\n        var o = new Int32Array(this.arrayBuffer, 12, 13),\n            s = 16909060 === o[0];\n        this.glType = s ? this.switchEndianness(o[1]) : o[1], this.glTypeSize = s ? this.switchEndianness(o[2]) : o[2], this.glFormat = s ? this.switchEndianness(o[3]) : o[3], this.glInternalFormat = s ? this.switchEndianness(o[4]) : o[4], this.glBaseInternalFormat = s ? this.switchEndianness(o[5]) : o[5], this.pixelWidth = s ? this.switchEndianness(o[6]) : o[6], this.pixelHeight = s ? this.switchEndianness(o[7]) : o[7], this.pixelDepth = s ? this.switchEndianness(o[8]) : o[8], this.numberOfArrayElements = s ? this.switchEndianness(o[9]) : o[9], this.numberOfFaces = s ? this.switchEndianness(o[10]) : o[10], this.numberOfMipmapLevels = s ? this.switchEndianness(o[11]) : o[11], this.bytesOfKeyValueData = s ? this.switchEndianness(o[12]) : o[12], 0 === this.glType ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels), 0 !== this.pixelHeight && 0 === this.pixelDepth ? 0 === this.numberOfArrayElements ? this.numberOfFaces === t ? this.loadType = h.COMPRESSED_2D : jo.Tools.Error(\"number of faces expected\" + t + \", but found \" + this.numberOfFaces) : jo.Tools.Error(\"texture arrays not currently supported\") : jo.Tools.Error(\"only 2D textures currently supported\")) : jo.Tools.Error(\"only compressed formats currently supported\");\n      } else jo.Tools.Error(\"texture missing KTX identifier\");\n    }\n\n    return h.prototype.switchEndianness = function (e) {\n      return (255 & e) << 24 | (65280 & e) << 8 | e >> 8 & 65280 | e >> 24 & 255;\n    }, h.prototype.uploadLevels = function (e, t) {\n      switch (this.loadType) {\n        case h.COMPRESSED_2D:\n          this._upload2DCompressedLevels(e, t);\n\n      }\n    }, h.prototype._upload2DCompressedLevels = function (e, t) {\n      for (var i = h.HEADER_LEN + this.bytesOfKeyValueData, r = this.pixelWidth, n = this.pixelHeight, o = t ? this.numberOfMipmapLevels : 1, s = 0; s < o; s++) {\n        var a = new Int32Array(this.arrayBuffer, i, 1)[0];\n        i += 4;\n\n        for (var l = 0; l < this.numberOfFaces; l++) {\n          var c = new Uint8Array(this.arrayBuffer, i, a);\n          e.getEngine()._uploadCompressedDataToTextureDirectly(e, this.glInternalFormat, r, n, c, l, s), i += a, i += 3 - (a + 3) % 4;\n        }\n\n        r = Math.max(1, .5 * r), n = Math.max(1, .5 * n);\n      }\n    }, h.HEADER_LEN = 64, h.COMPRESSED_2D = 0, h.COMPRESSED_3D = 1, h.TEX_2D = 2, h.TEX_3D = 3, h;\n  }(), jo.KhronosTextureContainer = Yo, Ko = $a || ($a = {}), Qo = function () {\n    function e() {\n      this.supportCascades = !1;\n    }\n\n    return e.prototype.canLoad = function (e, t, i, r, n) {\n      return !(!t || r || i || n);\n    }, e.prototype.transformUrl = function (e, t) {\n      var i = e.lastIndexOf(\".\");\n      return (-1 < i ? e.substring(0, i) : e) + t;\n    }, e.prototype.getFallbackTextureUrl = function (e, t) {\n      var i = new RegExp(t + \"$\");\n      return e.replace(i, \"\");\n    }, e.prototype.loadCubeData = function (e, t, i, r, n) {\n      if (!Array.isArray(e)) {\n        var o = t.getEngine(),\n            s = new Ko.KhronosTextureContainer(e, 6),\n            a = 1 < s.numberOfMipmapLevels && t.generateMipMaps;\n        o._unpackFlipY(!0), s.uploadLevels(t, t.generateMipMaps), t.width = s.pixelWidth, t.height = s.pixelHeight, o._setCubeMapTextureParams(a), t.isReady = !0;\n      }\n    }, e.prototype.loadData = function (e, t, i) {\n      var r = new Ko.KhronosTextureContainer(e, 1);\n      i(r.pixelWidth, r.pixelHeight, !1, !0, function () {\n        r.uploadLevels(t, t.generateMipMaps);\n      });\n    }, e;\n  }(), Ko.Engine._TextureLoaders.unshift(new Qo()), Zo = $a || ($a = {}), qo = function () {\n    function T() {}\n\n    return T.GetEnvInfo = function (e) {\n      for (var t = new DataView(e), i = 0, r = 0; r < T._MagicBytes.length; r++) if (t.getUint8(i++) !== T._MagicBytes[r]) return Zo.Tools.Error(\"Not a babylon environment map\"), null;\n\n      for (var n = \"\", o = 0; o = t.getUint8(i++);) n += String.fromCharCode(o);\n\n      var s = JSON.parse(n);\n      return s.specular && (s.specular.specularDataPosition = i, s.specular.lodGenerationScale = s.specular.lodGenerationScale || .8), s;\n    }, T.CreateEnvTextureAsync = function (_) {\n      var m = this,\n          e = _.getInternalTexture();\n\n      if (!e) return Promise.reject(\"The cube texture is invalid.\");\n      if (!_._prefiltered) return Promise.reject(\"The cube texture is invalid (not prefiltered).\");\n      var l = e.getEngine();\n      if (l && l.premultipliedAlpha) return Promise.reject(\"Env texture can only be created when the engine is created with the premultipliedAlpha option set to false.\");\n      if (_.textureType === Zo.Engine.TEXTURETYPE_UNSIGNED_INT) return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n      var c = l.getRenderingCanvas();\n      if (!c) return Promise.reject(\"Env texture can only be created when the engine is associated to a canvas.\");\n      var i = Zo.Engine.TEXTURETYPE_FLOAT;\n      if (!l.getCaps().textureFloatRender && (i = Zo.Engine.TEXTURETYPE_HALF_FLOAT, !l.getCaps().textureHalfFloatRender)) return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n      var g = e.width,\n          v = new Zo.Scene(l),\n          y = {},\n          r = [],\n          b = Zo.Scalar.Log2(e.width);\n      b = Math.round(b);\n\n      for (var t = function (s) {\n        for (var a = Math.pow(2, b - s), e = function (n) {\n          var e = _.readPixels(n, s),\n              o = l.createRawTexture(e, a, a, Zo.Engine.TEXTUREFORMAT_RGBA, !1, !1, Zo.Texture.NEAREST_SAMPLINGMODE, null, i),\n              t = new Promise(function (i, e) {\n            var r = new Zo.PostProcess(\"rgbdEncode\", \"rgbdEncode\", null, null, 1, null, Zo.Texture.NEAREST_SAMPLINGMODE, l, !1, void 0, Zo.Engine.TEXTURETYPE_UNSIGNED_INT, void 0, null, !1);\n            r.getEffect().executeWhenCompiled(function () {\n              r.onApply = function (e) {\n                e._bindTexture(\"textureSampler\", o);\n              };\n\n              var e = l.getRenderWidth(),\n                  t = l.getRenderHeight();\n              l.setSize(a, a), v.postProcessManager.directRender([r], null), Zo.Tools.ToBlob(c, function (e) {\n                var t = new FileReader();\n                t.onload = function (e) {\n                  var t = e.target.result;\n                  y[6 * s + n] = t, i();\n                }, t.readAsArrayBuffer(e);\n              }), l.setSize(e, t);\n            });\n          });\n\n          r.push(t);\n        }, t = 0; t < 6; t++) e(t);\n      }, n = 0; n <= b; n++) t(n);\n\n      return Promise.all(r).then(function () {\n        v.dispose();\n\n        for (var e = {\n          version: 1,\n          width: g,\n          irradiance: m._CreateEnvTextureIrradiance(_),\n          specular: {\n            mipmaps: [],\n            lodGenerationScale: _.lodGenerationScale\n          }\n        }, t = 0, i = 0; i <= b; i++) for (var r = 0; r < 6; r++) {\n          var n = y[6 * i + r].byteLength;\n          e.specular.mipmaps.push({\n            length: n,\n            position: t\n          }), t += n;\n        }\n\n        for (var o = JSON.stringify(e), s = new ArrayBuffer(o.length + 1), a = new Uint8Array(s), l = (i = 0, o.length); i < l; i++) a[i] = o.charCodeAt(i);\n\n        a[o.length] = 0;\n        var c = T._MagicBytes.length + t + s.byteLength,\n            h = new ArrayBuffer(c),\n            u = new Uint8Array(h),\n            d = new DataView(h),\n            f = 0;\n\n        for (i = 0; i < T._MagicBytes.length; i++) d.setUint8(f++, T._MagicBytes[i]);\n\n        u.set(new Uint8Array(s), f), f += s.byteLength;\n\n        for (i = 0; i <= b; i++) for (r = 0; r < 6; r++) {\n          var p = y[6 * i + r];\n          u.set(new Uint8Array(p), f), f += p.byteLength;\n        }\n\n        return h;\n      });\n    }, T._CreateEnvTextureIrradiance = function (e) {\n      var t = e.sphericalPolynomial;\n      return null == t ? null : {\n        x: [t.x.x, t.x.y, t.x.z],\n        y: [t.y.x, t.y.y, t.y.z],\n        z: [t.z.x, t.z.y, t.z.z],\n        xx: [t.xx.x, t.xx.y, t.xx.z],\n        yy: [t.yy.x, t.yy.y, t.yy.z],\n        zz: [t.zz.x, t.zz.y, t.zz.z],\n        yz: [t.yz.x, t.yz.y, t.yz.z],\n        zx: [t.zx.x, t.zx.y, t.zx.z],\n        xy: [t.xy.x, t.xy.y, t.xy.z]\n      };\n    }, T.UploadEnvLevelsAsync = function (e, t, i) {\n      if (1 !== i.version) throw new Error('Unsupported babylon environment map version \"' + i.version + '\"');\n      var r = i.specular;\n      if (!r) return Promise.resolve();\n      var n = Zo.Scalar.Log2(i.width);\n      if (n = Math.round(n) + 1, r.mipmaps.length !== 6 * n) throw new Error('Unsupported specular mipmaps number \"' + r.mipmaps.length + '\"');\n      e._lodGenerationScale = r.lodGenerationScale;\n\n      for (var o = new Array(n), s = 0; s < n; s++) {\n        o[s] = new Array(6);\n\n        for (var a = 0; a < 6; a++) {\n          var l = r.mipmaps[6 * s + a];\n          o[s][a] = new Uint8Array(t, r.specularDataPosition + l.position, l.length);\n        }\n      }\n\n      return T.UploadLevelsAsync(e, o);\n    }, T.UploadLevelsAsync = function (l, r) {\n      if (!Zo.Tools.IsExponentOfTwo(l.width)) throw new Error(\"Texture size must be a power of two\");\n      var e = Math.round(Zo.Scalar.Log2(l.width)) + 1,\n          c = l.getEngine(),\n          h = !1,\n          u = !1,\n          d = null,\n          f = null,\n          p = null,\n          t = c.getCaps();\n      if (l.format = Zo.Engine.TEXTUREFORMAT_RGBA, l.type = Zo.Engine.TEXTURETYPE_UNSIGNED_INT, l.generateMipMaps = !0, c.updateTextureSamplingMode(Zo.Texture.TRILINEAR_SAMPLINGMODE, l), t.textureLOD ? c.webGLVersion < 2 ? h = !1 : t.textureHalfFloatRender && t.textureHalfFloatLinearFiltering ? (h = !0, l.type = Zo.Engine.TEXTURETYPE_HALF_FLOAT) : t.textureFloatRender && t.textureFloatLinearFiltering && (h = !0, l.type = Zo.Engine.TEXTURETYPE_FLOAT) : (u = !(h = !1), p = {}), h) d = new Zo.PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, Zo.Texture.TRILINEAR_SAMPLINGMODE, c, !1, void 0, l.type, void 0, null, !1), l._isRGBD = !1, l.invertY = !1, f = c.createRenderTargetCubeTexture(l.width, {\n        generateDepthBuffer: !1,\n        generateMipMaps: !0,\n        generateStencilBuffer: !1,\n        samplingMode: Zo.Texture.TRILINEAR_SAMPLINGMODE,\n        type: l.type,\n        format: Zo.Engine.TEXTUREFORMAT_RGBA\n      });else if (l._isRGBD = !0, l.invertY = !0, u) for (var i = l._lodGenerationScale, n = l._lodGenerationOffset, o = 0; o < 3; o++) {\n        var s = (e - 1) * i + n,\n            a = n + (s - n) * (1 - o / 2),\n            _ = Math.round(Math.min(Math.max(a, 0), s)),\n            m = new Zo.InternalTexture(c, Zo.InternalTexture.DATASOURCE_TEMP);\n\n        m.isCube = !0, m.invertY = !0, m.generateMipMaps = !1, c.updateTextureSamplingMode(Zo.Texture.LINEAR_LINEAR, m);\n        var g = new Zo.BaseTexture(null);\n\n        switch (g.isCube = !0, g._texture = m, p[_] = g, o) {\n          case 0:\n            l._lodTextureLow = g;\n            break;\n\n          case 1:\n            l._lodTextureMid = g;\n            break;\n\n          case 2:\n            l._lodTextureHigh = g;\n        }\n      }\n\n      var v = [],\n          y = function (a) {\n        for (var e = function (n) {\n          var e = r[a][n],\n              t = new Blob([e], {\n            type: \"image/png\"\n          }),\n              o = URL.createObjectURL(t),\n              s = new Image();\n          s.src = o;\n          var i = new Promise(function (i, r) {\n            s.onload = function () {\n              if (h) {\n                var t = c.createTexture(null, !0, !0, null, Zo.Texture.NEAREST_SAMPLINGMODE, null, function (e) {\n                  r(e);\n                }, s);\n                d.getEffect().executeWhenCompiled(function () {\n                  d.onApply = function (e) {\n                    e._bindTexture(\"textureSampler\", t), e.setFloat2(\"scale\", 1, 1);\n                  }, c.scenes[0].postProcessManager.directRender([d], f, !0, n, a), c.restoreDefaultFramebuffer(), t.dispose(), window.URL.revokeObjectURL(o), i();\n                });\n              } else {\n                if (c._uploadImageToTexture(l, s, n, a), u) {\n                  var e = p[a];\n                  e && c._uploadImageToTexture(e._texture, s, n, 0);\n                }\n\n                i();\n              }\n            }, s.onerror = function (e) {\n              r(e);\n            };\n          });\n          v.push(i);\n        }, t = 0; t < 6; t++) e(t);\n      };\n\n      for (o = 0; o < r.length; o++) y(o);\n\n      if (r.length < e) {\n        var b = void 0,\n            T = Math.pow(2, e - 1 - r.length),\n            E = T * T * 4;\n\n        switch (l.type) {\n          case Zo.Engine.TEXTURETYPE_UNSIGNED_INT:\n            b = new Uint8Array(E);\n            break;\n\n          case Zo.Engine.TEXTURETYPE_HALF_FLOAT:\n            b = new Uint16Array(E);\n            break;\n\n          case Zo.Engine.TEXTURETYPE_FLOAT:\n            b = new Float32Array(E);\n        }\n\n        for (o = r.length; o < e; o++) for (var x = 0; x < 6; x++) c._uploadArrayBufferViewToTexture(l, b, x, o);\n      }\n\n      return Promise.all(v).then(function () {\n        f && (c._releaseFramebufferObjects(f), f._swapAndDie(l)), d && d.dispose(), u && (l._lodTextureHigh && l._lodTextureHigh._texture && (l._lodTextureHigh._texture.isReady = !0), l._lodTextureMid && l._lodTextureMid._texture && (l._lodTextureMid._texture.isReady = !0), l._lodTextureLow && l._lodTextureLow._texture && (l._lodTextureLow._texture.isReady = !0));\n      });\n    }, T.UploadEnvSpherical = function (e, t) {\n      1 !== t.version && Zo.Tools.Warn('Unsupported babylon environment map version \"' + t.version + '\"');\n      var i = t.irradiance;\n\n      if (i) {\n        var r = new Zo.SphericalPolynomial();\n        Zo.Vector3.FromArrayToRef(i.x, 0, r.x), Zo.Vector3.FromArrayToRef(i.y, 0, r.y), Zo.Vector3.FromArrayToRef(i.z, 0, r.z), Zo.Vector3.FromArrayToRef(i.xx, 0, r.xx), Zo.Vector3.FromArrayToRef(i.yy, 0, r.yy), Zo.Vector3.FromArrayToRef(i.zz, 0, r.zz), Zo.Vector3.FromArrayToRef(i.yz, 0, r.yz), Zo.Vector3.FromArrayToRef(i.zx, 0, r.zx), Zo.Vector3.FromArrayToRef(i.xy, 0, r.xy), e._sphericalPolynomial = r;\n      }\n    }, T._MagicBytes = [134, 22, 135, 150, 246, 214, 150, 54], T;\n  }(), Zo.EnvironmentTextureTools = qo, Jo = $a || ($a = {}), $o = function () {\n    function e() {\n      this.supportCascades = !1;\n    }\n\n    return e.prototype.canLoad = function (e, t, i, r, n) {\n      return 0 === e.indexOf(\".env\");\n    }, e.prototype.transformUrl = function (e, t) {\n      return e;\n    }, e.prototype.getFallbackTextureUrl = function (e, t) {\n      return null;\n    }, e.prototype.loadCubeData = function (e, t, i, r, n) {\n      if (!Array.isArray(e)) {\n        e = e;\n        var o = Jo.EnvironmentTextureTools.GetEnvInfo(e);\n        o ? (t.width = o.width, t.height = o.width, Jo.EnvironmentTextureTools.UploadEnvSpherical(t, o), Jo.EnvironmentTextureTools.UploadEnvLevelsAsync(t, e, o).then(function () {\n          t.isReady = !0, r && r();\n        })) : n && n(\"Can not parse the environment file\", null);\n      }\n    }, e.prototype.loadData = function (e, t, i) {\n      throw \".env not supported in 2d.\";\n    }, e;\n  }(), Jo.Engine._TextureLoaders.push(new $o()), es = $a || ($a = {}), ts = function () {\n    function e(s) {\n      var a = this;\n      this.originalScene = s, this._pointerCaptures = {}, this._lastPointerEvents = {}, this.shouldRender = !0, this.onlyCheckPointerDownEvents = !0, this.processAllEvents = !1, this.onPointerOutObservable = new es.Observable(), this.utilityLayerScene = new es.Scene(s.getEngine()), this.utilityLayerScene.useRightHandedSystem = s.useRightHandedSystem, this.utilityLayerScene._allowPostProcessClearColor = !1, s.getEngine().scenes.pop(), this.utilityLayerScene.detachControl(), this._originalPointerObserver = s.onPrePointerObservable.add(function (e, t) {\n        if (a.processAllEvents || e.type === es.PointerEventTypes.POINTERMOVE || e.type === es.PointerEventTypes.POINTERUP || e.type === es.PointerEventTypes.POINTERDOWN) {\n          var i = e.event;\n          if (s.isPointerCaptured(i.pointerId)) a._pointerCaptures[i.pointerId] = !1;else {\n            var r = e.ray ? a.utilityLayerScene.pickWithRay(e.ray) : a.utilityLayerScene.pick(s.pointerX, s.pointerY);\n            if (!e.ray && r && (e.ray = r.ray), a.utilityLayerScene.onPrePointerObservable.notifyObservers(e), a.onlyCheckPointerDownEvents && e.type != es.PointerEventTypes.POINTERDOWN) return e.skipOnPointerObservable || a.utilityLayerScene.onPointerObservable.notifyObservers(new es.PointerInfo(e.type, e.event, r)), void (e.type === es.PointerEventTypes.POINTERUP && a._pointerCaptures[i.pointerId] && (a._pointerCaptures[i.pointerId] = !1));\n            if (a.utilityLayerScene.autoClearDepthAndStencil) r && r.hit && (e.skipOnPointerObservable || a.utilityLayerScene.onPointerObservable.notifyObservers(new es.PointerInfo(e.type, e.event, r)), e.skipOnPointerObservable = !0);else {\n              var n = e.ray ? s.pickWithRay(e.ray) : s.pick(s.pointerX, s.pointerY),\n                  o = e.event;\n              n && r && (0 === r.distance && n.pickedMesh ? a.mainSceneTrackerPredicate && a.mainSceneTrackerPredicate(n.pickedMesh) ? (a._notifyObservers(e, n, o), e.skipOnPointerObservable = !0) : e.type === es.PointerEventTypes.POINTERDOWN ? a._pointerCaptures[o.pointerId] = !0 : a._lastPointerEvents[o.pointerId] && (a.onPointerOutObservable.notifyObservers(o.pointerId), delete a._lastPointerEvents[o.pointerId]) : !a._pointerCaptures[o.pointerId] && (r.distance < n.distance || 0 === n.distance) ? (a._notifyObservers(e, r, o), e.skipOnPointerObservable || (e.skipOnPointerObservable = 0 < r.distance)) : !a._pointerCaptures[o.pointerId] && r.distance > n.distance && (a.mainSceneTrackerPredicate && a.mainSceneTrackerPredicate(n.pickedMesh) ? (a._notifyObservers(e, n, o), e.skipOnPointerObservable = !0) : a._lastPointerEvents[o.pointerId] && (a.onPointerOutObservable.notifyObservers(o.pointerId), delete a._lastPointerEvents[o.pointerId])), e.type === es.PointerEventTypes.POINTERUP && a._pointerCaptures[o.pointerId] && (a._pointerCaptures[o.pointerId] = !1));\n            }\n          }\n        }\n      }), this.utilityLayerScene.autoClear = !1, this._afterRenderObserver = this.originalScene.onAfterRenderObservable.add(function () {\n        a.shouldRender && a.render();\n      }), this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(function () {\n        a.dispose();\n      }), this._updateCamera();\n    }\n\n    return Object.defineProperty(e, \"DefaultUtilityLayer\", {\n      get: function () {\n        return null == e._DefaultUtilityLayer && (e._DefaultUtilityLayer = new e(es.Engine.LastCreatedScene)).originalScene.onDisposeObservable.addOnce(function () {\n          e._DefaultUtilityLayer = null;\n        }), e._DefaultUtilityLayer;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e, \"DefaultKeepDepthUtilityLayer\", {\n      get: function () {\n        return null == e._DefaultKeepDepthUtilityLayer && ((e._DefaultKeepDepthUtilityLayer = new e(es.Engine.LastCreatedScene)).utilityLayerScene.autoClearDepthAndStencil = !1, e._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(function () {\n          e._DefaultKeepDepthUtilityLayer = null;\n        })), e._DefaultKeepDepthUtilityLayer;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._notifyObservers = function (e, t, i) {\n      e.skipOnPointerObservable || (this.utilityLayerScene.onPointerObservable.notifyObservers(new es.PointerInfo(e.type, e.event, t)), this._lastPointerEvents[i.pointerId] = !0);\n    }, e.prototype.render = function () {\n      if (this._updateCamera(), this.utilityLayerScene.activeCamera) {\n        var e = this.utilityLayerScene.activeCamera.getScene(),\n            t = this.utilityLayerScene.activeCamera;\n        t._scene = this.utilityLayerScene, t.leftCamera && (t.leftCamera._scene = this.utilityLayerScene), t.rightCamera && (t.rightCamera._scene = this.utilityLayerScene), this.utilityLayerScene.render(!1), t._scene = e, t.leftCamera && (t.leftCamera._scene = e), t.rightCamera && (t.rightCamera._scene = e);\n      }\n    }, e.prototype.dispose = function () {\n      this.onPointerOutObservable.clear(), this._afterRenderObserver && this.originalScene.onAfterRenderObservable.remove(this._afterRenderObserver), this._sceneDisposeObserver && this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver), this._originalPointerObserver && this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver), this.utilityLayerScene.dispose();\n    }, e.prototype._updateCamera = function () {\n      this.utilityLayerScene.activeCamera = this.originalScene.activeCamera;\n    }, e._DefaultUtilityLayer = null, e._DefaultKeepDepthUtilityLayer = null, e;\n  }(), es.UtilityLayerRenderer = ts, is = $a || ($a = {}), rs = function () {\n    function o(e) {\n      this.maxDragAngle = 0, this._useAlternatePickedPointAboveMaxDragAngle = !1, this.currentDraggingPointerID = -1, this.dragging = !1, this.dragDeltaRatio = .2, this.updateDragPlane = !0, this._debugMode = !1, this._moving = !1, this.onDragObservable = new is.Observable(), this.onDragStartObservable = new is.Observable(), this.onDragEndObservable = new is.Observable(), this.moveAttached = !0, this.enabled = !0, this.detachCameraControls = !0, this.useObjectOrienationForDragging = !0, this._tmpVector = new is.Vector3(0, 0, 0), this._alternatePickedPoint = new is.Vector3(0, 0, 0), this._worldDragAxis = new is.Vector3(0, 0, 0), this._targetPosition = new is.Vector3(0, 0, 0), this._attachedElement = null, this._startDragRay = new is.Ray(new is.Vector3(), new is.Vector3()), this._lastPointerRay = {}, this._dragDelta = new is.Vector3(), this._pointA = new is.Vector3(0, 0, 0), this._pointB = new is.Vector3(0, 0, 0), this._pointC = new is.Vector3(0, 0, 0), this._lineA = new is.Vector3(0, 0, 0), this._lineB = new is.Vector3(0, 0, 0), this._localAxis = new is.Vector3(0, 0, 0), this._lookAt = new is.Vector3(0, 0, 0), this._options = e || {};\n      var t = 0;\n      if (this._options.dragAxis && t++, this._options.dragPlaneNormal && t++, 1 < t) throw \"Multiple drag modes specified in dragBehavior options. Only one expected\";\n    }\n\n    return Object.defineProperty(o.prototype, \"name\", {\n      get: function () {\n        return \"PointerDrag\";\n      },\n      enumerable: !0,\n      configurable: !0\n    }), o.prototype.init = function () {}, o.prototype.attach = function (e) {\n      var n = this;\n      this._scene = e.getScene(), this._attachedNode = e, o._planeScene || (this._debugMode ? o._planeScene = this._scene : ((o._planeScene = new is.Scene(this._scene.getEngine())).detachControl(), this._scene.getEngine().scenes.pop(), this._scene.onDisposeObservable.addOnce(function () {\n        o._planeScene.dispose(), o._planeScene = null;\n      }))), this._dragPlane = is.Mesh.CreatePlane(\"pointerDragPlane\", this._debugMode ? 1 : 1e4, o._planeScene, !1, is.Mesh.DOUBLESIDE), this.lastDragPosition = new is.Vector3(0, 0, 0);\n      this._pointerObserver = this._scene.onPointerObservable.add(function (e, t) {\n        var i;\n        if (n.enabled) if (e.type == is.PointerEventTypes.POINTERDOWN) !n.dragging && e.pickInfo && e.pickInfo.hit && e.pickInfo.pickedMesh && e.pickInfo.pickedPoint && e.pickInfo.ray && (i = e.pickInfo.pickedMesh, n._attachedNode == i || i.isDescendantOf(n._attachedNode)) && n._startDrag(e.event.pointerId, e.pickInfo.ray, e.pickInfo.pickedPoint);else if (e.type == is.PointerEventTypes.POINTERUP) n.currentDraggingPointerID == e.event.pointerId && n.releaseDrag();else if (e.type == is.PointerEventTypes.POINTERMOVE) {\n          var r = e.event.pointerId;\n          n.currentDraggingPointerID === o._AnyMouseID && r !== o._AnyMouseID && \"mouse\" == e.event.pointerType && (n._lastPointerRay[n.currentDraggingPointerID] && (n._lastPointerRay[r] = n._lastPointerRay[n.currentDraggingPointerID], delete n._lastPointerRay[n.currentDraggingPointerID]), n.currentDraggingPointerID = r), n._lastPointerRay[r] || (n._lastPointerRay[r] = new is.Ray(new is.Vector3(), new is.Vector3())), e.pickInfo && e.pickInfo.ray && (n._lastPointerRay[r].origin.copyFrom(e.pickInfo.ray.origin), n._lastPointerRay[r].direction.copyFrom(e.pickInfo.ray.direction), n.currentDraggingPointerID == r && n.dragging && n._moveDrag(e.pickInfo.ray));\n        }\n      }), this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n        n._moving && n.moveAttached && (is.BoundingBoxGizmo._RemoveAndStorePivotPoint(n._attachedNode), n._targetPosition.subtractToRef(n._attachedNode.absolutePosition, n._tmpVector), n._tmpVector.scaleInPlace(n.dragDeltaRatio), n._attachedNode.getAbsolutePosition().addToRef(n._tmpVector, n._tmpVector), n._attachedNode.setAbsolutePosition(n._tmpVector), is.BoundingBoxGizmo._RestorePivotPoint(n._attachedNode));\n      });\n    }, o.prototype.releaseDrag = function () {\n      this.dragging = !1, this.onDragEndObservable.notifyObservers({\n        dragPlanePoint: this.lastDragPosition,\n        pointerId: this.currentDraggingPointerID\n      }), this.currentDraggingPointerID = -1, this._moving = !1, this.detachCameraControls && this._attachedElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera && this._scene.activeCamera.attachControl(this._attachedElement, !0);\n    }, o.prototype.startDrag = function (e, t, i) {\n      void 0 === e && (e = o._AnyMouseID), this._startDrag(e, t, i);\n      var r = this._lastPointerRay[e];\n      e === o._AnyMouseID && (r = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]]), r && this._moveDrag(r);\n    }, o.prototype._startDrag = function (e, t, i) {\n      if (this._scene.activeCamera && !this.dragging && this._attachedNode) {\n        is.BoundingBoxGizmo._RemoveAndStorePivotPoint(this._attachedNode), t ? (this._startDragRay.direction.copyFrom(t.direction), this._startDragRay.origin.copyFrom(t.origin)) : (this._startDragRay.origin.copyFrom(this._scene.activeCamera.position), this._attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector), this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction)), this._updateDragPlanePosition(this._startDragRay, i || this._tmpVector);\n\n        var r = this._pickWithRayOnDragPlane(this._startDragRay);\n\n        r && (this.dragging = !0, this.currentDraggingPointerID = e, this.lastDragPosition.copyFrom(r), this.onDragStartObservable.notifyObservers({\n          dragPlanePoint: r,\n          pointerId: this.currentDraggingPointerID\n        }), this._targetPosition.copyFrom(this._attachedNode.absolutePosition), this.detachCameraControls && this._scene.activeCamera && !this._scene.activeCamera.leftCamera && (this._scene.activeCamera.inputs.attachedElement ? (this._attachedElement = this._scene.activeCamera.inputs.attachedElement, this._scene.activeCamera.detachControl(this._scene.activeCamera.inputs.attachedElement)) : this._attachedElement = null)), is.BoundingBoxGizmo._RestorePivotPoint(this._attachedNode);\n      }\n    }, o.prototype._moveDrag = function (e) {\n      this._moving = !0;\n\n      var t = this._pickWithRayOnDragPlane(e);\n\n      if (t) {\n        this.updateDragPlane && this._updateDragPlanePosition(e, t);\n        var i = 0;\n        this._options.dragAxis ? (is.Vector3.TransformCoordinatesToRef(this._options.dragAxis, this._attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis), t.subtractToRef(this.lastDragPosition, this._tmpVector), i = is.Vector3.Dot(this._tmpVector, this._worldDragAxis), this._worldDragAxis.scaleToRef(i, this._dragDelta)) : (i = this._dragDelta.length(), t.subtractToRef(this.lastDragPosition, this._dragDelta)), this._targetPosition.addInPlace(this._dragDelta), this.onDragObservable.notifyObservers({\n          dragDistance: i,\n          delta: this._dragDelta,\n          dragPlanePoint: t,\n          dragPlaneNormal: this._dragPlane.forward,\n          pointerId: this.currentDraggingPointerID\n        }), this.lastDragPosition.copyFrom(t);\n      }\n    }, o.prototype._pickWithRayOnDragPlane = function (e) {\n      var t = this;\n      if (!e) return null;\n      var i = Math.acos(is.Vector3.Dot(this._dragPlane.forward, e.direction));\n\n      if (i > Math.PI / 2 && (i = Math.PI - i), 0 < this.maxDragAngle && i > this.maxDragAngle) {\n        if (this._useAlternatePickedPointAboveMaxDragAngle) {\n          this._tmpVector.copyFrom(e.direction), this._attachedNode.absolutePosition.subtractToRef(e.origin, this._alternatePickedPoint), this._alternatePickedPoint.normalize(), this._alternatePickedPoint.scaleInPlace(-2 * is.Vector3.Dot(this._alternatePickedPoint, this._tmpVector)), this._tmpVector.addInPlace(this._alternatePickedPoint);\n          var r = is.Vector3.Dot(this._dragPlane.forward, this._tmpVector);\n          return this._dragPlane.forward.scaleToRef(-r, this._alternatePickedPoint), this._alternatePickedPoint.addInPlace(this._tmpVector), this._alternatePickedPoint.addInPlace(this._attachedNode.absolutePosition), this._alternatePickedPoint;\n        }\n\n        return null;\n      }\n\n      var n = o._planeScene.pickWithRay(e, function (e) {\n        return e == t._dragPlane;\n      });\n\n      return n && n.hit && n.pickedMesh && n.pickedPoint ? n.pickedPoint : null;\n    }, o.prototype._updateDragPlanePosition = function (e, t) {\n      this._pointA.copyFrom(t), this._options.dragAxis ? (this.useObjectOrienationForDragging ? is.Vector3.TransformCoordinatesToRef(this._options.dragAxis, this._attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis), this._pointA.addToRef(this._localAxis, this._pointB), e.origin.subtractToRef(this._pointA, this._pointC), this._pointA.addToRef(this._pointC.normalize(), this._pointC), this._pointB.subtractToRef(this._pointA, this._lineA), this._pointC.subtractToRef(this._pointA, this._lineB), is.Vector3.CrossToRef(this._lineA, this._lineB, this._lookAt), is.Vector3.CrossToRef(this._lineA, this._lookAt, this._lookAt), this._lookAt.normalize(), this._dragPlane.position.copyFrom(this._pointA), this._pointA.subtractToRef(this._lookAt, this._lookAt), this._dragPlane.lookAt(this._lookAt)) : this._options.dragPlaneNormal ? (this.useObjectOrienationForDragging ? is.Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this._attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal), this._dragPlane.position.copyFrom(this._pointA), this._pointA.subtractToRef(this._localAxis, this._lookAt), this._dragPlane.lookAt(this._lookAt)) : (this._dragPlane.position.copyFrom(this._pointA), this._dragPlane.lookAt(e.origin)), this._dragPlane.computeWorldMatrix(!0);\n    }, o.prototype.detach = function () {\n      this._pointerObserver && this._scene.onPointerObservable.remove(this._pointerObserver), this._beforeRenderObserver && this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }, o._AnyMouseID = -2, o;\n  }(), is.PointerDragBehavior = rs, ns = $a || ($a = {}), os = function () {\n    function e() {\n      this._startDistance = 0, this._initialScale = new ns.Vector3(0, 0, 0), this._targetScale = new ns.Vector3(0, 0, 0), this._sceneRenderObserver = null, this._dragBehaviorA = new ns.PointerDragBehavior({}), this._dragBehaviorA.moveAttached = !1, this._dragBehaviorB = new ns.PointerDragBehavior({}), this._dragBehaviorB.moveAttached = !1;\n    }\n\n    return Object.defineProperty(e.prototype, \"name\", {\n      get: function () {\n        return \"MultiPointerScale\";\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.init = function () {}, e.prototype._getCurrentDistance = function () {\n      return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n    }, e.prototype.attach = function (t) {\n      var i = this;\n      this._ownerNode = t, this._dragBehaviorA.onDragStartObservable.add(function (e) {\n        i._dragBehaviorA.dragging && i._dragBehaviorB.dragging && (i._dragBehaviorA.currentDraggingPointerID == i._dragBehaviorB.currentDraggingPointerID ? i._dragBehaviorA.releaseDrag() : (i._initialScale.copyFrom(t.scaling), i._startDistance = i._getCurrentDistance()));\n      }), this._dragBehaviorB.onDragStartObservable.add(function (e) {\n        i._dragBehaviorA.dragging && i._dragBehaviorB.dragging && (i._dragBehaviorA.currentDraggingPointerID == i._dragBehaviorB.currentDraggingPointerID ? i._dragBehaviorB.releaseDrag() : (i._initialScale.copyFrom(t.scaling), i._startDistance = i._getCurrentDistance()));\n      }), [this._dragBehaviorA, this._dragBehaviorB].forEach(function (e) {\n        e.onDragObservable.add(function () {\n          if (i._dragBehaviorA.dragging && i._dragBehaviorB.dragging) {\n            var e = i._getCurrentDistance() / i._startDistance;\n\n            i._initialScale.scaleToRef(e, i._targetScale);\n          }\n        });\n      }), t.addBehavior(this._dragBehaviorA), t.addBehavior(this._dragBehaviorB), this._sceneRenderObserver = t.getScene().onBeforeRenderObservable.add(function () {\n        if (i._dragBehaviorA.dragging && i._dragBehaviorB.dragging) {\n          var e = i._targetScale.subtract(t.scaling).scaleInPlace(.1);\n\n          .01 < e.length() && t.scaling.addInPlace(e);\n        }\n      });\n    }, e.prototype.detach = function () {\n      var t = this;\n      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver), [this._dragBehaviorA, this._dragBehaviorB].forEach(function (e) {\n        e.onDragStartObservable.clear(), e.onDragObservable.clear(), t._ownerNode.removeBehavior(e);\n      });\n    }, e;\n  }(), ns.MultiPointerScaleBehavior = os, ss = $a || ($a = {}), as = function () {\n    function i() {\n      this._sceneRenderObserver = null, this._targetPosition = new ss.Vector3(0, 0, 0), this._moving = !1, this._startingOrientation = new ss.Quaternion(), this.zDragFactor = 3, this.dragging = !1, this.dragDeltaRatio = .2, this.currentDraggingPointerID = -1, this.detachCameraControls = !0, this.onDragStartObservable = new ss.Observable(), this.onDragEndObservable = new ss.Observable();\n    }\n\n    return Object.defineProperty(i.prototype, \"name\", {\n      get: function () {\n        return \"SixDofDrag\";\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.init = function () {}, i.prototype.attach = function (e) {\n      var a = this;\n      this._ownerNode = e, this._scene = this._ownerNode.getScene(), i._virtualScene || ((i._virtualScene = new ss.Scene(this._scene.getEngine())).detachControl(), this._scene.getEngine().scenes.pop());\n      var l = null,\n          c = new ss.Vector3(0, 0, 0);\n      this._virtualOriginMesh = new ss.AbstractMesh(\"\", i._virtualScene), this._virtualOriginMesh.rotationQuaternion = new ss.Quaternion(), this._virtualDragMesh = new ss.AbstractMesh(\"\", i._virtualScene), this._virtualDragMesh.rotationQuaternion = new ss.Quaternion();\n      var h = null;\n      this._pointerObserver = this._scene.onPointerObservable.add(function (e, t) {\n        if (e.type == ss.PointerEventTypes.POINTERDOWN) {\n          if (!a.dragging && e.pickInfo && e.pickInfo.hit && e.pickInfo.pickedMesh && e.pickInfo.ray && (s = e.pickInfo.pickedMesh, a._ownerNode == s || s.isDescendantOf(a._ownerNode))) {\n            a._scene.activeCamera && a._scene.activeCamera.cameraRigMode == ss.Camera.RIG_MODE_NONE && e.pickInfo.ray.origin.copyFrom(a._scene.activeCamera.position), l = a._ownerNode, ss.BoundingBoxGizmo._RemoveAndStorePivotPoint(l), c.copyFrom(e.pickInfo.ray.origin), a._virtualOriginMesh.position.copyFrom(e.pickInfo.ray.origin), a._virtualOriginMesh.lookAt(e.pickInfo.ray.origin.subtract(e.pickInfo.ray.direction)), a._virtualOriginMesh.removeChild(a._virtualDragMesh), l.computeWorldMatrix(), a._virtualDragMesh.position.copyFrom(l.absolutePosition), l.rotationQuaternion || (l.rotationQuaternion = ss.Quaternion.RotationYawPitchRoll(l.rotation.y, l.rotation.x, l.rotation.z));\n            var i = l.parent;\n            l.setParent(null), a._virtualDragMesh.rotationQuaternion.copyFrom(l.rotationQuaternion), l.setParent(i), a._virtualOriginMesh.addChild(a._virtualDragMesh), a._targetPosition.copyFrom(a._virtualDragMesh.absolutePosition), a.dragging = !0, a.currentDraggingPointerID = e.event.pointerId, a.detachCameraControls && a._scene.activeCamera && !a._scene.activeCamera.leftCamera && (a._scene.activeCamera.inputs.attachedElement ? (h = a._scene.activeCamera.inputs.attachedElement, a._scene.activeCamera.detachControl(a._scene.activeCamera.inputs.attachedElement)) : h = null), ss.BoundingBoxGizmo._RestorePivotPoint(l), a.onDragStartObservable.notifyObservers({});\n          }\n        } else if (e.type == ss.PointerEventTypes.POINTERUP) a.currentDraggingPointerID == e.event.pointerId && (a.dragging = !1, a._moving = !1, a.currentDraggingPointerID = -1, l = null, a._virtualOriginMesh.removeChild(a._virtualDragMesh), a.detachCameraControls && h && a._scene.activeCamera && !a._scene.activeCamera.leftCamera && a._scene.activeCamera.attachControl(h, !0), a.onDragEndObservable.notifyObservers({}));else if (e.type == ss.PointerEventTypes.POINTERMOVE && a.currentDraggingPointerID == e.event.pointerId && a.dragging && e.pickInfo && e.pickInfo.ray && l) {\n          var r = a.zDragFactor;\n          a._scene.activeCamera && a._scene.activeCamera.cameraRigMode == ss.Camera.RIG_MODE_NONE && (e.pickInfo.ray.origin.copyFrom(a._scene.activeCamera.position), r = 0);\n          var n = e.pickInfo.ray.origin.subtract(c);\n          c.copyFrom(e.pickInfo.ray.origin);\n          var o = -ss.Vector3.Dot(n, e.pickInfo.ray.direction);\n          a._virtualOriginMesh.addChild(a._virtualDragMesh), a._virtualDragMesh.position.z -= a._virtualDragMesh.position.z < 1 ? o * a.zDragFactor : o * r * a._virtualDragMesh.position.z, a._virtualDragMesh.position.z < 0 && (a._virtualDragMesh.position.z = 0), a._virtualOriginMesh.position.copyFrom(e.pickInfo.ray.origin), a._virtualOriginMesh.lookAt(e.pickInfo.ray.origin.subtract(e.pickInfo.ray.direction)), a._virtualOriginMesh.removeChild(a._virtualDragMesh), a._targetPosition.copyFrom(a._virtualDragMesh.absolutePosition), l.parent && ss.Vector3.TransformCoordinatesToRef(a._targetPosition, ss.Matrix.Invert(l.parent.getWorldMatrix()), a._targetPosition), a._moving || a._startingOrientation.copyFrom(a._virtualDragMesh.rotationQuaternion), a._moving = !0;\n        }\n\n        var s;\n      });\n      var t = new ss.Quaternion();\n      this._sceneRenderObserver = e.getScene().onBeforeRenderObservable.add(function () {\n        if (a.dragging && a._moving && l) {\n          ss.BoundingBoxGizmo._RemoveAndStorePivotPoint(l), l.position.addInPlace(a._targetPosition.subtract(l.position).scale(a.dragDeltaRatio)), t.copyFrom(a._startingOrientation), t.x = -t.x, t.y = -t.y, t.z = -t.z, a._virtualDragMesh.rotationQuaternion.multiplyToRef(t, t), ss.Quaternion.RotationYawPitchRollToRef(t.toEulerAngles(\"xyz\").y, 0, 0, t), t.multiplyToRef(a._startingOrientation, t);\n          var e = l.parent;\n          l.setParent(null), ss.Quaternion.SlerpToRef(l.rotationQuaternion, t, a.dragDeltaRatio, l.rotationQuaternion), l.setParent(e), ss.BoundingBoxGizmo._RestorePivotPoint(l);\n        }\n      });\n    }, i.prototype.detach = function () {\n      this._scene && this._scene.onPointerObservable.remove(this._pointerObserver), this._ownerNode && this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver), this._virtualOriginMesh && this._virtualOriginMesh.dispose(), this._virtualDragMesh && this._virtualDragMesh.dispose(), this.onDragEndObservable.clear(), this.onDragStartObservable.clear();\n    }, i;\n  }(), ss.SixDofDragBehavior = as, ls = $a || ($a = {}), cs = function (e, t, i, r) {\n    void 0 === t && (t = new ls.Vector3()), void 0 === i && (i = 0), void 0 === r && (r = !1), this.direction = e, this.rotatedDirection = t, this.diff = i, this.ignore = r;\n  }, hs = function () {\n    function e(e) {\n      this.ui = e, this.name = \"AttachToBoxBehavior\", this.distanceAwayFromFace = .15, this.distanceAwayFromBottomOfFace = .15, this._faceVectors = [new cs(ls.Vector3.Up()), new cs(ls.Vector3.Down()), new cs(ls.Vector3.Left()), new cs(ls.Vector3.Right()), new cs(ls.Vector3.Forward()), new cs(ls.Vector3.Forward().scaleInPlace(-1))], this._tmpMatrix = new ls.Matrix(), this._tmpVector = new ls.Vector3(), this._zeroVector = ls.Vector3.Zero(), this._lookAtTmpMatrix = new ls.Matrix();\n    }\n\n    return e.prototype.init = function () {}, e.prototype._closestFace = function (t) {\n      var i = this;\n      return this._faceVectors.forEach(function (e) {\n        i._target.rotationQuaternion || (i._target.rotationQuaternion = ls.Quaternion.RotationYawPitchRoll(i._target.rotation.y, i._target.rotation.x, i._target.rotation.z)), i._target.rotationQuaternion.toRotationMatrix(i._tmpMatrix), ls.Vector3.TransformCoordinatesToRef(e.direction, i._tmpMatrix, e.rotatedDirection), e.diff = ls.Vector3.GetAngleBetweenVectors(e.rotatedDirection, t, ls.Vector3.Cross(e.rotatedDirection, t));\n      }), this._faceVectors.reduce(function (e, t) {\n        return e.ignore ? t : t.ignore ? e : e.diff < t.diff ? e : t;\n      }, this._faceVectors[0]);\n    }, e.prototype._lookAtToRef = function (e, t, i) {\n      void 0 === t && (t = new ls.Vector3(0, 1, 0)), ls.Matrix.LookAtLHToRef(this._zeroVector, e, t, this._lookAtTmpMatrix), this._lookAtTmpMatrix.invert(), ls.Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, i);\n    }, e.prototype.attach = function (r) {\n      var n = this;\n      this._target = r, this._scene = this._target.getScene(), this._onRenderObserver = this._scene.onBeforeRenderObservable.add(function () {\n        if (n._scene.activeCamera) {\n          var e = n._scene.activeCamera.position;\n          n._scene.activeCamera.devicePosition && (e = n._scene.activeCamera.devicePosition);\n\n          var t = n._closestFace(e.subtract(r.position));\n\n          n._scene.activeCamera.leftCamera ? n._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(n._tmpMatrix) : n._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(n._tmpMatrix), ls.Vector3.TransformCoordinatesToRef(ls.Vector3.Up(), n._tmpMatrix, n._tmpVector), n._faceVectors.forEach(function (e) {\n            t.direction.x && e.direction.x && (e.ignore = !0), t.direction.y && e.direction.y && (e.ignore = !0), t.direction.z && e.direction.z && (e.ignore = !0);\n          });\n\n          var i = n._closestFace(n._tmpVector);\n\n          n._faceVectors.forEach(function (e) {\n            e.ignore = !1;\n          }), n.ui.position.copyFrom(r.position), t.direction.x && (t.rotatedDirection.scaleToRef(r.scaling.x / 2 + n.distanceAwayFromFace, n._tmpVector), n.ui.position.addInPlace(n._tmpVector)), t.direction.y && (t.rotatedDirection.scaleToRef(r.scaling.y / 2 + n.distanceAwayFromFace, n._tmpVector), n.ui.position.addInPlace(n._tmpVector)), t.direction.z && (t.rotatedDirection.scaleToRef(r.scaling.z / 2 + n.distanceAwayFromFace, n._tmpVector), n.ui.position.addInPlace(n._tmpVector)), n.ui.rotationQuaternion || (n.ui.rotationQuaternion = ls.Quaternion.RotationYawPitchRoll(n.ui.rotation.y, n.ui.rotation.x, n.ui.rotation.z)), t.rotatedDirection.scaleToRef(-1, n._tmpVector), n._lookAtToRef(n._tmpVector, i.rotatedDirection, n.ui.rotationQuaternion), i.direction.x && n.ui.up.scaleToRef(n.distanceAwayFromBottomOfFace - r.scaling.x / 2, n._tmpVector), i.direction.y && n.ui.up.scaleToRef(n.distanceAwayFromBottomOfFace - r.scaling.y / 2, n._tmpVector), i.direction.z && n.ui.up.scaleToRef(n.distanceAwayFromBottomOfFace - r.scaling.z / 2, n._tmpVector), n.ui.position.addInPlace(n._tmpVector);\n        }\n      });\n    }, e.prototype.detach = function () {\n      this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n    }, e;\n  }(), ls.AttachToBoxBehavior = hs, us = $a || ($a = {}), ds = function () {\n    function e() {\n      var e = this;\n      this.delay = 0, this.fadeInTime = 300, this._millisecondsPerFrame = 1e3 / 60, this._hovered = !1, this._hoverValue = 0, this._ownerNode = null, this._update = function () {\n        if (e._ownerNode) {\n          if (e._hoverValue += e._hovered ? e._millisecondsPerFrame : -e._millisecondsPerFrame, e._setAllVisibility(e._ownerNode, (e._hoverValue - e.delay) / e.fadeInTime), 1 < e._ownerNode.visibility) return e._setAllVisibility(e._ownerNode, 1), void (e._hoverValue = e.fadeInTime + e.delay);\n          if (e._ownerNode.visibility < 0 && (e._setAllVisibility(e._ownerNode, 0), e._hoverValue < 0)) return void (e._hoverValue = 0);\n          setTimeout(e._update, e._millisecondsPerFrame);\n        }\n      };\n    }\n\n    return Object.defineProperty(e.prototype, \"name\", {\n      get: function () {\n        return \"FadeInOut\";\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.init = function () {}, e.prototype.attach = function (e) {\n      this._ownerNode = e, this._setAllVisibility(this._ownerNode, 0);\n    }, e.prototype.detach = function () {\n      this._ownerNode = null;\n    }, e.prototype.fadeIn = function (e) {\n      this._hovered = e, this._update();\n    }, e.prototype._setAllVisibility = function (e, t) {\n      var i = this;\n      e.visibility = t, e.getChildMeshes().forEach(function (e) {\n        i._setAllVisibility(e, t);\n      });\n    }, e;\n  }(), us.FadeInOutBehavior = ds, fs = $a || ($a = {}), ps = function () {\n    function e(e) {\n      void 0 === e && (e = fs.UtilityLayerRenderer.DefaultUtilityLayer);\n      var t = this;\n      this.gizmoLayer = e, this.scaleRatio = 1, this._tmpMatrix = new fs.Matrix(), this._customMeshSet = !1, this.updateGizmoRotationToMatchAttachedMesh = !0, this.updateGizmoPositionToMatchAttachedMesh = !0, this._updateScale = !0, this._interactionsEnabled = !0, this._tempVector = new fs.Vector3(), this._rootMesh = new fs.Mesh(\"gizmoRootNode\", e.utilityLayerScene), this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(function () {\n        t._update();\n      }), this.attachedMesh = null;\n    }\n\n    return Object.defineProperty(e.prototype, \"attachedMesh\", {\n      get: function () {\n        return this._attachedMesh;\n      },\n      set: function (e) {\n        this._attachedMesh = e, this._rootMesh.setEnabled(!!e), this._attachedMeshChanged(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.setCustomMesh = function (e) {\n      if (e.getScene() != this.gizmoLayer.utilityLayerScene) throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n      this._rootMesh.getChildMeshes().forEach(function (e) {\n        e.dispose();\n      }), e.parent = this._rootMesh, this._customMeshSet = !0;\n    }, e.prototype._attachedMeshChanged = function (e) {}, e.prototype._update = function () {\n      if (this.attachedMesh && (this.updateGizmoRotationToMatchAttachedMesh ? (this._rootMesh.rotationQuaternion || (this._rootMesh.rotationQuaternion = fs.Quaternion.RotationYawPitchRoll(this._rootMesh.rotation.y, this._rootMesh.rotation.x, this._rootMesh.rotation.z)), this._tempVector.copyFrom(this.attachedMesh.scaling), this.attachedMesh.scaling.x < 0 && (this.attachedMesh.scaling.x *= -1), this.attachedMesh.scaling.y < 0 && (this.attachedMesh.scaling.y *= -1), this.attachedMesh.scaling.z < 0 && (this.attachedMesh.scaling.z *= -1), this.attachedMesh.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix), this.attachedMesh.scaling.copyFrom(this._tempVector), this.attachedMesh.computeWorldMatrix(), fs.Quaternion.FromRotationMatrixToRef(this._tmpMatrix, this._rootMesh.rotationQuaternion)) : this._rootMesh.rotationQuaternion && this._rootMesh.rotationQuaternion.set(0, 0, 0, 1), this.updateGizmoPositionToMatchAttachedMesh && this._rootMesh.position.copyFrom(this.attachedMesh.absolutePosition), this._updateScale && this.gizmoLayer.utilityLayerScene.activeCamera && this.attachedMesh)) {\n        var e = this.gizmoLayer.utilityLayerScene.activeCamera.position;\n        this.gizmoLayer.utilityLayerScene.activeCamera.devicePosition && (e = this.gizmoLayer.utilityLayerScene.activeCamera.devicePosition), this._rootMesh.position.subtractToRef(e, this._tempVector);\n        var t = this._tempVector.length() * this.scaleRatio;\n\n        this._rootMesh.scaling.set(t, t, t);\n      }\n    }, e.prototype.dispose = function () {\n      this._rootMesh.dispose(), this._beforeRenderObserver && this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }, e;\n  }(), fs.Gizmo = ps, _s = $a || ($a = {}), ms = function (p) {\n    function e(e, t, i) {\n      void 0 === t && (t = _s.Color3.Gray()), void 0 === i && (i = _s.UtilityLayerRenderer.DefaultUtilityLayer);\n      var r = p.call(this, i) || this;\n      r._pointerObserver = null, r.snapDistance = 0, r.onSnapObservable = new _s.Observable();\n      var n = new _s.StandardMaterial(\"\", i.utilityLayerScene);\n      n.disableLighting = !0, n.emissiveColor = t;\n      var o = new _s.StandardMaterial(\"\", i.utilityLayerScene);\n      o.disableLighting = !0, o.emissiveColor = t.add(new _s.Color3(.3, .3, .3));\n\n      var s = new _s.AbstractMesh(\"\", i.utilityLayerScene),\n          a = _s.MeshBuilder.CreateCylinder(\"yPosMesh\", {\n        diameterTop: 0,\n        height: 1.5,\n        diameterBottom: .75,\n        tessellation: 96\n      }, i.utilityLayerScene),\n          l = _s.MeshBuilder.CreateLines(\"yPosMesh\", {\n        points: [new _s.Vector3(0, 0, 0), new _s.Vector3(0, 1.1, 0)]\n      }, i.utilityLayerScene);\n\n      l.color = n.emissiveColor, s.addChild(a), s.addChild(l), a.scaling.scaleInPlace(.05), a.material = n, a.rotation.x = Math.PI / 2, a.position.z += .3, l.scaling.scaleInPlace(.26), l.rotation.x = Math.PI / 2, l.material = n, s.lookAt(r._rootMesh.position.subtract(e)), s.scaling.scaleInPlace(1 / 3), r._rootMesh.addChild(s);\n      var c = 0,\n          h = new _s.Vector3(),\n          u = {\n        snapDistance: 0\n      };\n      r.dragBehavior = new _s.PointerDragBehavior({\n        dragAxis: e\n      }), r.dragBehavior.moveAttached = !1, r._rootMesh.addBehavior(r.dragBehavior);\n      var d = new _s.Vector3(),\n          f = new _s.Matrix();\n      return r.dragBehavior.onDragObservable.add(function (e) {\n        if (r.attachedMesh) if (r.attachedMesh.parent ? (r.attachedMesh.parent.computeWorldMatrix().invertToRef(f), f.setTranslationFromFloats(0, 0, 0), _s.Vector3.TransformCoordinatesToRef(e.delta, f, d)) : d.copyFrom(e.delta), 0 == r.snapDistance) r.attachedMesh.position.addInPlace(d);else if (c += e.dragDistance, Math.abs(c) > r.snapDistance) {\n          var t = Math.floor(Math.abs(c) / r.snapDistance);\n          c %= r.snapDistance, d.normalizeToRef(h), h.scaleInPlace(r.snapDistance * t), r.attachedMesh.position.addInPlace(h), u.snapDistance = r.snapDistance * t, r.onSnapObservable.notifyObservers(u);\n        }\n      }), r._pointerObserver = i.utilityLayerScene.onPointerObservable.add(function (e, t) {\n        if (!r._customMeshSet) {\n          var i = e.pickInfo && -1 != r._rootMesh.getChildMeshes().indexOf(e.pickInfo.pickedMesh) ? o : n;\n\n          r._rootMesh.getChildMeshes().forEach(function (e) {\n            e.material = i, e.color && (e.color = i.emissiveColor);\n          });\n        }\n      }), r;\n    }\n\n    return T(e, p), e.prototype._attachedMeshChanged = function (e) {\n      this.dragBehavior && (this.dragBehavior.enabled = !!e);\n    }, e.prototype.dispose = function () {\n      this.onSnapObservable.clear(), this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver), this.dragBehavior.detach(), p.prototype.dispose.call(this);\n    }, e;\n  }(_s.Gizmo), _s.AxisDragGizmo = ms, gs = $a || ($a = {}), vs = function (u) {\n    function e(r, e, t) {\n      void 0 === e && (e = gs.Color3.Gray()), void 0 === t && (t = gs.UtilityLayerRenderer.DefaultUtilityLayer);\n      var n = u.call(this, t) || this;\n      n._pointerObserver = null, n.snapDistance = 0, n.onSnapObservable = new gs.Observable(), n.uniformScaling = !1, n._coloredMaterial = new gs.StandardMaterial(\"\", t.utilityLayerScene), n._coloredMaterial.disableLighting = !0, n._coloredMaterial.emissiveColor = e;\n      var o = new gs.StandardMaterial(\"\", t.utilityLayerScene);\n      o.disableLighting = !0, o.emissiveColor = e.add(new gs.Color3(.3, .3, .3));\n      var i = new gs.AbstractMesh(\"\", t.utilityLayerScene),\n          s = gs.MeshBuilder.CreateBox(\"yPosMesh\", {\n        size: .4\n      }, t.utilityLayerScene),\n          a = gs.MeshBuilder.CreateLines(\"yPosMesh\", {\n        points: [new gs.Vector3(0, 0, 0), new gs.Vector3(0, 1.1, 0)]\n      }, t.utilityLayerScene);\n      a.color = n._coloredMaterial.emissiveColor, i.addChild(s), i.addChild(a), s.scaling.scaleInPlace(.1), s.material = n._coloredMaterial, s.rotation.x = Math.PI / 2, s.position.z += .3, a.scaling.scaleInPlace(.26), a.rotation.x = Math.PI / 2, a.material = n._coloredMaterial, i.lookAt(n._rootMesh.position.subtract(r)), n._rootMesh.addChild(i), i.scaling.scaleInPlace(1 / 3), n.dragBehavior = new gs.PointerDragBehavior({\n        dragAxis: r\n      }), n.dragBehavior.moveAttached = !1, n._rootMesh.addBehavior(n.dragBehavior);\n      var l = 0,\n          c = new gs.Vector3(),\n          h = {\n        snapDistance: 0\n      };\n      return n.dragBehavior.onDragObservable.add(function (e) {\n        if (n.attachedMesh) {\n          var t = !1,\n              i = 0;\n          n.uniformScaling ? (n.attachedMesh.scaling.normalizeToRef(c), c.y < 0 && c.scaleInPlace(-1)) : c.copyFrom(r), 0 == n.snapDistance ? c.scaleToRef(e.dragDistance, c) : (l += e.dragDistance, Math.abs(l) > n.snapDistance ? (i = Math.floor(l / n.snapDistance), l %= n.snapDistance, c.scaleToRef(n.snapDistance * i, c), t = !0) : c.scaleInPlace(0)), n.attachedMesh.scaling.addInPlace(c), t && (h.snapDistance = n.snapDistance * i, n.onSnapObservable.notifyObservers(h));\n        }\n      }), n._pointerObserver = t.utilityLayerScene.onPointerObservable.add(function (e, t) {\n        if (!n._customMeshSet) {\n          var i = e.pickInfo && -1 != n._rootMesh.getChildMeshes().indexOf(e.pickInfo.pickedMesh) ? o : n._coloredMaterial;\n\n          n._rootMesh.getChildMeshes().forEach(function (e) {\n            e.material = i, e.color && (e.color = i.emissiveColor);\n          });\n        }\n      }), n;\n    }\n\n    return T(e, u), e.prototype._attachedMeshChanged = function (e) {\n      this.dragBehavior && (this.dragBehavior.enabled = !!e);\n    }, e.prototype.dispose = function () {\n      this.onSnapObservable.clear(), this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver), this.dragBehavior.detach(), u.prototype.dispose.call(this);\n    }, e.prototype.setCustomMesh = function (e, t) {\n      var i = this;\n      void 0 === t && (t = !1), u.prototype.setCustomMesh.call(this, e), t && (this._rootMesh.getChildMeshes().forEach(function (e) {\n        e.material = i._coloredMaterial, e.color && (e.color = i._coloredMaterial.emissiveColor);\n      }), this._customMeshSet = !1);\n    }, e;\n  }(gs.Gizmo), gs.AxisScaleGizmo = vs, ys = $a || ($a = {}), bs = function (c) {\n    function e(h, e, u, t) {\n      void 0 === e && (e = ys.Color3.Gray()), void 0 === u && (u = ys.UtilityLayerRenderer.DefaultUtilityLayer), void 0 === t && (t = 32);\n      var d = c.call(this, u) || this;\n      d._pointerObserver = null, d.snapDistance = 0, d.onSnapObservable = new ys.Observable();\n      var r = new ys.StandardMaterial(\"\", u.utilityLayerScene);\n      r.disableLighting = !0, r.emissiveColor = e;\n      var n = new ys.StandardMaterial(\"\", u.utilityLayerScene);\n      n.disableLighting = !0, n.emissiveColor = e.add(new ys.Color3(.3, .3, .3));\n\n      for (var i = new ys.AbstractMesh(\"\", u.utilityLayerScene), o = new Array(), s = 0; s < t; s++) {\n        var a = 2 * Math.PI * (s / (t - 1));\n        o.push(new ys.Vector3(.8 * Math.sin(a), 0, .8 * Math.cos(a)));\n      }\n\n      var l = ys.Mesh.CreateLines(\"\", o, u.utilityLayerScene);\n      l.color = r.emissiveColor, l.scaling.scaleInPlace(.26), l.material = r, l.rotation.x = Math.PI / 2, i.addChild(l), i.lookAt(d._rootMesh.position.subtract(h)), d._rootMesh.addChild(i), i.scaling.scaleInPlace(1 / 3), d.dragBehavior = new ys.PointerDragBehavior({\n        dragPlaneNormal: h\n      }), d.dragBehavior.moveAttached = !1, d.dragBehavior.maxDragAngle = 9 * Math.PI / 20, d.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = !0, d._rootMesh.addBehavior(d.dragBehavior);\n      var f = new ys.Vector3();\n      d.dragBehavior.onDragStartObservable.add(function (e) {\n        d.attachedMesh && f.copyFrom(e.dragPlanePoint);\n      });\n\n      var p = new ys.Matrix(),\n          _ = new ys.Vector3(),\n          m = new ys.Vector3(),\n          g = {\n        snapDistance: 0\n      },\n          v = 0,\n          y = new ys.Matrix(),\n          b = new ys.Vector3(),\n          T = new ys.Quaternion();\n\n      return d.dragBehavior.onDragObservable.add(function (e) {\n        if (d.attachedMesh) {\n          d.attachedMesh.rotationQuaternion || (d.attachedMesh.rotationQuaternion = ys.Quaternion.RotationYawPitchRoll(d.attachedMesh.rotation.y, d.attachedMesh.rotation.x, d.attachedMesh.rotation.z));\n          var t = e.dragPlanePoint.subtract(d.attachedMesh.absolutePosition).normalize(),\n              i = f.subtract(d.attachedMesh.absolutePosition).normalize(),\n              r = ys.Vector3.Cross(t, i),\n              n = ys.Vector3.Dot(t, i),\n              o = Math.atan2(r.length(), n);\n\n          if (_.copyFrom(h), m.copyFrom(h), d.updateGizmoRotationToMatchAttachedMesh && (d.attachedMesh.rotationQuaternion.toRotationMatrix(p), m = ys.Vector3.TransformCoordinates(_, p)), u.utilityLayerScene.activeCamera) {\n            var s = u.utilityLayerScene.activeCamera.position.subtract(d.attachedMesh.position);\n            0 < ys.Vector3.Dot(s, m) && (_.scaleInPlace(-1), m.scaleInPlace(-1));\n          }\n\n          0 < ys.Vector3.Dot(m, r) && (o = -o);\n          var a = !1;\n          if (0 != d.snapDistance) if (v += o, Math.abs(v) > d.snapDistance) {\n            var l = Math.floor(v / d.snapDistance);\n            v %= d.snapDistance, o = d.snapDistance * l, a = !0;\n          } else o = 0;\n          y.reset(), d.attachedMesh.parent && (d.attachedMesh.parent.computeWorldMatrix().invertToRef(y), y.getRotationMatrixToRef(y), ys.Vector3.TransformCoordinatesToRef(_, y, _));\n          var c = Math.sin(o / 2);\n          T.set(_.x * c, _.y * c, _.z * c, Math.cos(o / 2)), 0 < y.determinant() && (T.toEulerAnglesToRef(b), ys.Quaternion.RotationYawPitchRollToRef(b.y, -b.x, -b.z, T)), d.updateGizmoRotationToMatchAttachedMesh ? d.attachedMesh.rotationQuaternion.multiplyToRef(T, d.attachedMesh.rotationQuaternion) : T.multiplyToRef(d.attachedMesh.rotationQuaternion, d.attachedMesh.rotationQuaternion), f.copyFrom(e.dragPlanePoint), a && (g.snapDistance = o, d.onSnapObservable.notifyObservers(g));\n        }\n      }), d._pointerObserver = u.utilityLayerScene.onPointerObservable.add(function (e, t) {\n        if (!d._customMeshSet) {\n          var i = e.pickInfo && -1 != d._rootMesh.getChildMeshes().indexOf(e.pickInfo.pickedMesh) ? n : r;\n\n          d._rootMesh.getChildMeshes().forEach(function (e) {\n            e.material = i, e.color && (e.color = i.emissiveColor);\n          });\n        }\n      }), d;\n    }\n\n    return T(e, c), e.prototype._attachedMeshChanged = function (e) {\n      this.dragBehavior && (this.dragBehavior.enabled = !!e);\n    }, e.prototype.dispose = function () {\n      this.onSnapObservable.clear(), this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver), this.dragBehavior.detach(), c.prototype.dispose.call(this);\n    }, e;\n  }(ys.Gizmo), ys.PlaneRotationGizmo = bs, Ts = $a || ($a = {}), Es = function (i) {\n    function e(e) {\n      void 0 === e && (e = Ts.UtilityLayerRenderer.DefaultUtilityLayer);\n      var t = i.call(this, e) || this;\n      return t.onDragStartObservable = new Ts.Observable(), t.onDragEndObservable = new Ts.Observable(), t.xGizmo = new Ts.AxisDragGizmo(new Ts.Vector3(1, 0, 0), Ts.Color3.Red().scale(.5), e), t.yGizmo = new Ts.AxisDragGizmo(new Ts.Vector3(0, 1, 0), Ts.Color3.Green().scale(.5), e), t.zGizmo = new Ts.AxisDragGizmo(new Ts.Vector3(0, 0, 1), Ts.Color3.Blue().scale(.5), e), [t.xGizmo, t.yGizmo, t.zGizmo].forEach(function (e) {\n        e.dragBehavior.onDragStartObservable.add(function () {\n          t.onDragStartObservable.notifyObservers({});\n        }), e.dragBehavior.onDragEndObservable.add(function () {\n          t.onDragEndObservable.notifyObservers({});\n        });\n      }), t.attachedMesh = null, t;\n    }\n\n    return T(e, i), Object.defineProperty(e.prototype, \"attachedMesh\", {\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.attachedMesh = e, this.yGizmo.attachedMesh = e, this.zGizmo.attachedMesh = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n      get: function () {\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.updateGizmoRotationToMatchAttachedMesh = e, this.yGizmo.updateGizmoRotationToMatchAttachedMesh = e, this.zGizmo.updateGizmoRotationToMatchAttachedMesh = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"snapDistance\", {\n      get: function () {\n        return this.xGizmo.snapDistance;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.snapDistance = e, this.yGizmo.snapDistance = e, this.zGizmo.snapDistance = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"scaleRatio\", {\n      get: function () {\n        return this.xGizmo.scaleRatio;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.scaleRatio = e, this.yGizmo.scaleRatio = e, this.zGizmo.scaleRatio = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function () {\n      this.xGizmo.dispose(), this.yGizmo.dispose(), this.zGizmo.dispose(), this.onDragStartObservable.clear(), this.onDragEndObservable.clear();\n    }, e.prototype.setCustomMesh = function (e) {\n      Ts.Tools.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\n    }, e;\n  }(Ts.Gizmo), Ts.PositionGizmo = Es, xs = $a || ($a = {}), Ps = function (r) {\n    function e(e, t) {\n      void 0 === e && (e = xs.UtilityLayerRenderer.DefaultUtilityLayer), void 0 === t && (t = 32);\n      var i = r.call(this, e) || this;\n      return i.onDragStartObservable = new xs.Observable(), i.onDragEndObservable = new xs.Observable(), i.xGizmo = new xs.PlaneRotationGizmo(new xs.Vector3(1, 0, 0), xs.Color3.Red().scale(.5), e, t), i.yGizmo = new xs.PlaneRotationGizmo(new xs.Vector3(0, 1, 0), xs.Color3.Green().scale(.5), e, t), i.zGizmo = new xs.PlaneRotationGizmo(new xs.Vector3(0, 0, 1), xs.Color3.Blue().scale(.5), e, t), [i.xGizmo, i.yGizmo, i.zGizmo].forEach(function (e) {\n        e.dragBehavior.onDragStartObservable.add(function () {\n          i.onDragStartObservable.notifyObservers({});\n        }), e.dragBehavior.onDragEndObservable.add(function () {\n          i.onDragEndObservable.notifyObservers({});\n        });\n      }), i.attachedMesh = null, i;\n    }\n\n    return T(e, r), Object.defineProperty(e.prototype, \"attachedMesh\", {\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.attachedMesh = e, this.yGizmo.attachedMesh = e, this.zGizmo.attachedMesh = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n      get: function () {\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.updateGizmoRotationToMatchAttachedMesh = e, this.yGizmo.updateGizmoRotationToMatchAttachedMesh = e, this.zGizmo.updateGizmoRotationToMatchAttachedMesh = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"snapDistance\", {\n      get: function () {\n        return this.xGizmo.snapDistance;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.snapDistance = e, this.yGizmo.snapDistance = e, this.zGizmo.snapDistance = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"scaleRatio\", {\n      get: function () {\n        return this.xGizmo.scaleRatio;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.scaleRatio = e, this.yGizmo.scaleRatio = e, this.zGizmo.scaleRatio = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function () {\n      this.xGizmo.dispose(), this.yGizmo.dispose(), this.zGizmo.dispose(), this.onDragStartObservable.clear(), this.onDragEndObservable.clear();\n    }, e.prototype.setCustomMesh = function (e) {\n      xs.Tools.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\n    }, e;\n  }(xs.Gizmo), xs.RotationGizmo = Ps, As = $a || ($a = {}), Ss = function (n) {\n    function e(e) {\n      void 0 === e && (e = As.UtilityLayerRenderer.DefaultUtilityLayer);\n      var t = n.call(this, e) || this;\n      t.onDragStartObservable = new As.Observable(), t.onDragEndObservable = new As.Observable(), t.xGizmo = new As.AxisScaleGizmo(new As.Vector3(1, 0, 0), As.Color3.Red().scale(.5), e), t.yGizmo = new As.AxisScaleGizmo(new As.Vector3(0, 1, 0), As.Color3.Green().scale(.5), e), t.zGizmo = new As.AxisScaleGizmo(new As.Vector3(0, 0, 1), As.Color3.Blue().scale(.5), e), t.uniformScaleGizmo = new As.AxisScaleGizmo(new As.Vector3(0, 1, 0), As.Color3.Yellow().scale(.5), e), t.uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = !1, t.uniformScaleGizmo.uniformScaling = !0;\n      var i = As.Mesh.CreatePolyhedron(\"\", {\n        type: 1\n      }, t.uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n      i.scaling.scaleInPlace(.02), i.visibility = 0;\n      var r = As.Mesh.CreatePolyhedron(\"\", {\n        type: 1\n      }, t.uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n      return r.scaling.scaleInPlace(.007), i.addChild(r), t.uniformScaleGizmo.setCustomMesh(i, !0), [t.xGizmo, t.yGizmo, t.zGizmo, t.uniformScaleGizmo].forEach(function (e) {\n        e.dragBehavior.onDragStartObservable.add(function () {\n          t.onDragStartObservable.notifyObservers({});\n        }), e.dragBehavior.onDragEndObservable.add(function () {\n          t.onDragEndObservable.notifyObservers({});\n        });\n      }), t.attachedMesh = null, t;\n    }\n\n    return T(e, n), Object.defineProperty(e.prototype, \"attachedMesh\", {\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.attachedMesh = e, this.yGizmo.attachedMesh = e, this.zGizmo.attachedMesh = e, this.uniformScaleGizmo.attachedMesh = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"updateGizmoRotationToMatchAttachedMesh\", {\n      get: function () {\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n      },\n      set: function (e) {\n        e || As.Tools.Warn(\"Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.\"), this.xGizmo && (this.xGizmo.updateGizmoRotationToMatchAttachedMesh = e, this.yGizmo.updateGizmoRotationToMatchAttachedMesh = e, this.zGizmo.updateGizmoRotationToMatchAttachedMesh = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"snapDistance\", {\n      get: function () {\n        return this.xGizmo.snapDistance;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.snapDistance = e, this.yGizmo.snapDistance = e, this.zGizmo.snapDistance = e, this.uniformScaleGizmo.snapDistance = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"scaleRatio\", {\n      get: function () {\n        return this.xGizmo.scaleRatio;\n      },\n      set: function (e) {\n        this.xGizmo && (this.xGizmo.scaleRatio = e, this.yGizmo.scaleRatio = e, this.zGizmo.scaleRatio = e, this.uniformScaleGizmo.scaleRatio = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function () {\n      this.xGizmo.dispose(), this.yGizmo.dispose(), this.zGizmo.dispose(), this.uniformScaleGizmo.dispose(), this.onDragStartObservable.clear(), this.onDragEndObservable.clear();\n    }, e;\n  }(As.Gizmo), As.ScaleGizmo = Ss, Ms = $a || ($a = {}), Rs = function (m) {\n    function g(t, i) {\n      void 0 === t && (t = Ms.Color3.Gray()), void 0 === i && (i = Ms.UtilityLayerRenderer.DefaultKeepDepthUtilityLayer);\n      var l = m.call(this, i) || this;\n      l._boundingDimensions = new Ms.Vector3(1, 1, 1), l._renderObserver = null, l._pointerObserver = null, l._scaleDragSpeed = .2, l._tmpQuaternion = new Ms.Quaternion(), l._tmpVector = new Ms.Vector3(0, 0, 0), l._tmpRotationMatrix = new Ms.Matrix(), l.ignoreChildren = !1, l.includeChildPredicate = null, l.rotationSphereSize = .1, l.scaleBoxSize = .1, l.fixedDragMeshScreenSize = !1, l.fixedDragMeshScreenSizeDistanceFactor = 10, l.onDragStartObservable = new Ms.Observable(), l.onScaleBoxDragObservable = new Ms.Observable(), l.onScaleBoxDragEndObservable = new Ms.Observable(), l.onRotationSphereDragObservable = new Ms.Observable(), l.onRotationSphereDragEndObservable = new Ms.Observable(), l.scalePivot = null, l._existingMeshScale = new Ms.Vector3(), l._updateScale = !1, l._anchorMesh = new Ms.AbstractMesh(\"anchor\", i.utilityLayerScene);\n      var n = new Ms.StandardMaterial(\"\", i.utilityLayerScene);\n      n.disableLighting = !0, n.emissiveColor = t;\n      var r = new Ms.StandardMaterial(\"\", i.utilityLayerScene);\n      r.disableLighting = !0, r.emissiveColor = t.clone().add(new Ms.Color3(.3, .3, .3)), l._lineBoundingBox = new Ms.AbstractMesh(\"\", i.utilityLayerScene), l._lineBoundingBox.rotationQuaternion = new Ms.Quaternion();\n      var e = [];\n      e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(0, 0, 0), new Ms.Vector3(l._boundingDimensions.x, 0, 0)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(0, 0, 0), new Ms.Vector3(0, l._boundingDimensions.y, 0)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(0, 0, 0), new Ms.Vector3(0, 0, l._boundingDimensions.z)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(l._boundingDimensions.x, 0, 0), new Ms.Vector3(l._boundingDimensions.x, l._boundingDimensions.y, 0)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(l._boundingDimensions.x, 0, 0), new Ms.Vector3(l._boundingDimensions.x, 0, l._boundingDimensions.z)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(0, l._boundingDimensions.y, 0), new Ms.Vector3(l._boundingDimensions.x, l._boundingDimensions.y, 0)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(0, l._boundingDimensions.y, 0), new Ms.Vector3(0, l._boundingDimensions.y, l._boundingDimensions.z)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(0, 0, l._boundingDimensions.z), new Ms.Vector3(l._boundingDimensions.x, 0, l._boundingDimensions.z)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(0, 0, l._boundingDimensions.z), new Ms.Vector3(0, l._boundingDimensions.y, l._boundingDimensions.z)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(l._boundingDimensions.x, l._boundingDimensions.y, l._boundingDimensions.z), new Ms.Vector3(0, l._boundingDimensions.y, l._boundingDimensions.z)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(l._boundingDimensions.x, l._boundingDimensions.y, l._boundingDimensions.z), new Ms.Vector3(l._boundingDimensions.x, 0, l._boundingDimensions.z)]\n      }, i.utilityLayerScene)), e.push(Ms.MeshBuilder.CreateLines(\"lines\", {\n        points: [new Ms.Vector3(l._boundingDimensions.x, l._boundingDimensions.y, l._boundingDimensions.z), new Ms.Vector3(l._boundingDimensions.x, l._boundingDimensions.y, 0)]\n      }, i.utilityLayerScene)), e.forEach(function (e) {\n        e.color = t, e.position.addInPlace(new Ms.Vector3(-l._boundingDimensions.x / 2, -l._boundingDimensions.y / 2, -l._boundingDimensions.z / 2)), e.isPickable = !1, l._lineBoundingBox.addChild(e);\n      }), l._rootMesh.addChild(l._lineBoundingBox), l._rotateSpheresParent = new Ms.AbstractMesh(\"\", i.utilityLayerScene), l._rotateSpheresParent.rotationQuaternion = new Ms.Quaternion();\n\n      for (var o = function (o) {\n        var t = Ms.MeshBuilder.CreateSphere(\"\", {\n          diameter: 1\n        }, i.utilityLayerScene);\n        t.rotationQuaternion = new Ms.Quaternion(), t.material = n, (u = new Ms.PointerDragBehavior({})).moveAttached = !1, u.updateDragPlane = !1, t.addBehavior(u);\n        var s = new Ms.Vector3(1, 0, 0),\n            a = 0;\n        u.onDragStartObservable.add(function (e) {\n          s.copyFrom(t.forward), a = 0;\n        }), u.onDragObservable.add(function (e) {\n          if (l.onRotationSphereDragObservable.notifyObservers({}), l.attachedMesh) {\n            g._RemoveAndStorePivotPoint(l.attachedMesh);\n\n            var t = s,\n                i = e.dragPlaneNormal.scale(Ms.Vector3.Dot(e.dragPlaneNormal, t)),\n                r = t.subtract(i).normalizeToNew(),\n                n = -Ms.Vector3.Dot(r, e.delta);\n            n = n / l._boundingDimensions.length() * l._anchorMesh.scaling.length(), l.attachedMesh.rotationQuaternion || (l.attachedMesh.rotationQuaternion = Ms.Quaternion.RotationYawPitchRoll(l.attachedMesh.rotation.y, l.attachedMesh.rotation.x, l.attachedMesh.rotation.z)), l._anchorMesh.rotationQuaternion || (l._anchorMesh.rotationQuaternion = Ms.Quaternion.RotationYawPitchRoll(l._anchorMesh.rotation.y, l._anchorMesh.rotation.x, l._anchorMesh.rotation.z)), a += n, Math.abs(a) <= 2 * Math.PI && (8 <= o ? Ms.Quaternion.RotationYawPitchRollToRef(0, 0, n, l._tmpQuaternion) : 4 <= o ? Ms.Quaternion.RotationYawPitchRollToRef(n, 0, 0, l._tmpQuaternion) : Ms.Quaternion.RotationYawPitchRollToRef(0, n, 0, l._tmpQuaternion), l._anchorMesh.addChild(l.attachedMesh), l._anchorMesh.rotationQuaternion.multiplyToRef(l._tmpQuaternion, l._anchorMesh.rotationQuaternion), l._anchorMesh.removeChild(l.attachedMesh)), l.updateBoundingBox(), g._RestorePivotPoint(l.attachedMesh);\n          }\n        }), u.onDragStartObservable.add(function () {\n          l.onDragStartObservable.notifyObservers({}), l._selectNode(t);\n        }), u.onDragEndObservable.add(function () {\n          l.onRotationSphereDragEndObservable.notifyObservers({}), l._selectNode(null);\n        }), c._rotateSpheresParent.addChild(t);\n      }, c = this, s = 0; s < 12; s++) o(s);\n\n      l._rootMesh.addChild(l._rotateSpheresParent), l._scaleBoxesParent = new Ms.AbstractMesh(\"\", i.utilityLayerScene), l._scaleBoxesParent.rotationQuaternion = new Ms.Quaternion();\n\n      for (var a = 0; a < 2; a++) for (var h = 0; h < 2; h++) for (var u, d = function () {\n        var r = Ms.MeshBuilder.CreateBox(\"\", {\n          size: 1\n        }, i.utilityLayerScene);\n        r.material = n;\n        var e = new Ms.Vector3(0 == a ? -1 : 1, 0 == h ? -1 : 1, 0 == p ? -1 : 1);\n        (u = new Ms.PointerDragBehavior({\n          dragAxis: e\n        })).moveAttached = !1, r.addBehavior(u), u.onDragObservable.add(function (e) {\n          if (l.onScaleBoxDragObservable.notifyObservers({}), l.attachedMesh) {\n            g._RemoveAndStorePivotPoint(l.attachedMesh);\n\n            var t = e.dragDistance / l._boundingDimensions.length() * l._anchorMesh.scaling.length(),\n                i = new Ms.Vector3(t, t, t);\n\n            i.scaleInPlace(l._scaleDragSpeed), l.updateBoundingBox(), l.scalePivot ? (l.attachedMesh.getWorldMatrix().getRotationMatrixToRef(l._tmpRotationMatrix), l._boundingDimensions.scaleToRef(.5, l._tmpVector), Ms.Vector3.TransformCoordinatesToRef(l._tmpVector, l._tmpRotationMatrix, l._tmpVector), l._anchorMesh.position.subtractInPlace(l._tmpVector), l._boundingDimensions.multiplyToRef(l.scalePivot, l._tmpVector), Ms.Vector3.TransformCoordinatesToRef(l._tmpVector, l._tmpRotationMatrix, l._tmpVector), l._anchorMesh.position.addInPlace(l._tmpVector)) : (r.absolutePosition.subtractToRef(l._anchorMesh.position, l._tmpVector), l._anchorMesh.position.subtractInPlace(l._tmpVector)), l._anchorMesh.addChild(l.attachedMesh), l._anchorMesh.scaling.addInPlace(i), (l._anchorMesh.scaling.x < 0 || l._anchorMesh.scaling.y < 0 || l._anchorMesh.scaling.z < 0) && l._anchorMesh.scaling.subtractInPlace(i), l._anchorMesh.removeChild(l.attachedMesh), g._RestorePivotPoint(l.attachedMesh);\n          }\n        }), u.onDragStartObservable.add(function () {\n          l.onDragStartObservable.notifyObservers({}), l._selectNode(r);\n        }), u.onDragEndObservable.add(function () {\n          l.onScaleBoxDragEndObservable.notifyObservers({}), l._selectNode(null);\n        }), f._scaleBoxesParent.addChild(r);\n      }, f = this, p = 0; p < 2; p++) d();\n\n      l._rootMesh.addChild(l._scaleBoxesParent);\n\n      var _ = new Array();\n\n      return l._pointerObserver = i.utilityLayerScene.onPointerObservable.add(function (t, e) {\n        _[t.event.pointerId] ? t.pickInfo && t.pickInfo.pickedMesh != _[t.event.pointerId] && (_[t.event.pointerId].material = n, delete _[t.event.pointerId]) : l._rotateSpheresParent.getChildMeshes().concat(l._scaleBoxesParent.getChildMeshes()).forEach(function (e) {\n          t.pickInfo && t.pickInfo.pickedMesh == e && ((_[t.event.pointerId] = e).material = r);\n        });\n      }), l._renderObserver = l.gizmoLayer.originalScene.onBeforeRenderObservable.add(function () {\n        l.attachedMesh && !l._existingMeshScale.equals(l.attachedMesh.scaling) && l.updateBoundingBox();\n      }), l.updateBoundingBox(), l;\n    }\n\n    return T(g, m), g._RemoveAndStorePivotPoint = function (e) {\n      e && 0 === g._PivotCached && (e.getPivotPointToRef(g._OldPivotPoint), g._OldPivotPoint.equalsToFloats(0, 0, 0) || (e.setPivotMatrix(Ms.Matrix.IdentityReadOnly), g._OldPivotPoint.subtractToRef(e.getPivotPoint(), g._PivotTranslation), g._PivotTmpVector.copyFromFloats(1, 1, 1), g._PivotTmpVector.subtractInPlace(e.scaling), g._PivotTmpVector.multiplyInPlace(g._PivotTranslation), e.position.addInPlace(g._PivotTmpVector))), g._PivotCached++;\n    }, g._RestorePivotPoint = function (e) {\n      e && !g._OldPivotPoint.equalsToFloats(0, 0, 0) && 1 === g._PivotCached && (e.setPivotPoint(g._OldPivotPoint), g._PivotTmpVector.copyFromFloats(1, 1, 1), g._PivotTmpVector.subtractInPlace(e.scaling), g._PivotTmpVector.multiplyInPlace(g._PivotTranslation), e.position.subtractInPlace(g._PivotTmpVector)), this._PivotCached--;\n    }, g.prototype._attachedMeshChanged = function (e) {\n      e && (g._RemoveAndStorePivotPoint(e), this._anchorMesh.addChild(e), this._anchorMesh.removeChild(e), g._RestorePivotPoint(e), this.updateBoundingBox());\n    }, g.prototype._selectNode = function (i) {\n      this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(function (e, t) {\n        e.isVisible = !i || e == i;\n      });\n    }, g.prototype.updateBoundingBox = function () {\n      if (this.attachedMesh) {\n        g._RemoveAndStorePivotPoint(this.attachedMesh), this._update(), this.attachedMesh.rotationQuaternion || (this.attachedMesh.rotationQuaternion = Ms.Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z)), this._anchorMesh.rotationQuaternion || (this._anchorMesh.rotationQuaternion = Ms.Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z)), this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion), this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion), this._tmpVector.copyFrom(this.attachedMesh.position), this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1), this.attachedMesh.position.set(0, 0, 0);\n        var e = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\n        e.max.subtractToRef(e.min, this._boundingDimensions), this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions), this._lineBoundingBox.position.set((e.max.x + e.min.x) / 2, (e.max.y + e.min.y) / 2, (e.max.z + e.min.z) / 2), this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position), this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position), this._lineBoundingBox.computeWorldMatrix(), this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition), this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion), this.attachedMesh.position.copyFrom(this._tmpVector);\n      }\n\n      for (var t = this._rotateSpheresParent.getChildMeshes(), i = 0; i < 3; i++) for (var r = 0; r < 2; r++) for (var n = 0; n < 2; n++) {\n        var o = 4 * i + 2 * r + n;\n\n        if (0 == i && (t[o].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * r, this._boundingDimensions.z * n), t[o].position.addInPlace(new Ms.Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2)), t[o].lookAt(Ms.Vector3.Cross(Ms.Vector3.Right(), t[o].position.normalizeToNew()).normalizeToNew().add(t[o].position))), 1 == i && (t[o].position.set(this._boundingDimensions.x * r, this._boundingDimensions.y / 2, this._boundingDimensions.z * n), t[o].position.addInPlace(new Ms.Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2)), t[o].lookAt(Ms.Vector3.Cross(Ms.Vector3.Up(), t[o].position.normalizeToNew()).normalizeToNew().add(t[o].position))), 2 == i && (t[o].position.set(this._boundingDimensions.x * r, this._boundingDimensions.y * n, this._boundingDimensions.z / 2), t[o].position.addInPlace(new Ms.Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2)), t[o].lookAt(Ms.Vector3.Cross(Ms.Vector3.Forward(), t[o].position.normalizeToNew()).normalizeToNew().add(t[o].position))), this.fixedDragMeshScreenSize) {\n          this._rootMesh.computeWorldMatrix(), this._rotateSpheresParent.computeWorldMatrix(), t[o].computeWorldMatrix(), t[o].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n          var s = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n          t[o].scaling.set(s, s, s);\n        } else t[o].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\n      }\n\n      var a = this._scaleBoxesParent.getChildMeshes();\n\n      for (i = 0; i < 2; i++) for (r = 0; r < 2; r++) for (n = 0; n < 2; n++) {\n        if (a[o = 4 * i + 2 * r + n]) if (a[o].position.set(this._boundingDimensions.x * i, this._boundingDimensions.y * r, this._boundingDimensions.z * n), a[o].position.addInPlace(new Ms.Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2)), this.fixedDragMeshScreenSize) {\n          this._rootMesh.computeWorldMatrix(), this._scaleBoxesParent.computeWorldMatrix(), a[o].computeWorldMatrix(), a[o].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n          s = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n          a[o].scaling.set(s, s, s);\n        } else a[o].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\n      }\n\n      this.attachedMesh && (this._existingMeshScale.copyFrom(this.attachedMesh.scaling), g._RestorePivotPoint(this.attachedMesh));\n    }, g.prototype.setEnabledRotationAxis = function (i) {\n      this._rotateSpheresParent.getChildMeshes().forEach(function (e, t) {\n        t < 4 ? e.setEnabled(-1 != i.indexOf(\"x\")) : t < 8 ? e.setEnabled(-1 != i.indexOf(\"y\")) : e.setEnabled(-1 != i.indexOf(\"z\"));\n      });\n    }, g.prototype.dispose = function () {\n      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver), this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver), this._lineBoundingBox.dispose(), this._rotateSpheresParent.dispose(), this._scaleBoxesParent.dispose(), m.prototype.dispose.call(this);\n    }, g.MakeNotPickableAndWrapInBoundingBox = function (e) {\n      var t = function (e) {\n        e.isPickable = !1, e.getChildMeshes().forEach(function (e) {\n          t(e);\n        });\n      };\n\n      t(e), e.rotationQuaternion || (e.rotationQuaternion = Ms.Quaternion.RotationYawPitchRoll(e.rotation.y, e.rotation.x, e.rotation.z));\n      var i = e.position.clone(),\n          r = e.rotationQuaternion.clone();\n      e.rotationQuaternion.set(0, 0, 0, 1), e.position.set(0, 0, 0);\n      var n = Ms.MeshBuilder.CreateBox(\"box\", {\n        size: 1\n      }, e.getScene()),\n          o = e.getHierarchyBoundingVectors();\n      return o.max.subtractToRef(o.min, n.scaling), n.position.set((o.max.x + o.min.x) / 2, (o.max.y + o.min.y) / 2, (o.max.z + o.min.z) / 2), e.addChild(n), e.rotationQuaternion.copyFrom(r), e.position.copyFrom(i), e.removeChild(n), n.addChild(e), n.visibility = 0, n;\n    }, g.prototype.setCustomMesh = function (e) {\n      Ms.Tools.Error(\"Custom meshes are not supported on this gizmo\");\n    }, g._PivotCached = 0, g._OldPivotPoint = new Ms.Vector3(), g._PivotTranslation = new Ms.Vector3(), g._PivotTmpVector = new Ms.Vector3(), g;\n  }(Ms.Gizmo), Ms.BoundingBoxGizmo = Rs, Cs = $a || ($a = {}), Os = function () {\n    function e(e) {\n      var n = this;\n      this.scene = e, this._gizmosEnabled = {\n        positionGizmo: !1,\n        rotationGizmo: !1,\n        scaleGizmo: !1,\n        boundingBoxGizmo: !1\n      }, this._pointerObserver = null, this._attachedMesh = null, this._boundingBoxColor = Cs.Color3.FromHexString(\"#0984e3\"), this.boundingBoxDragBehavior = new Cs.SixDofDragBehavior(), this.attachableMeshes = null, this.usePointerToAttachGizmos = !0, this._defaultKeepDepthUtilityLayer = new Cs.UtilityLayerRenderer(e), this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = !1, this._defaultUtilityLayer = new Cs.UtilityLayerRenderer(e), this.gizmos = {\n        positionGizmo: null,\n        rotationGizmo: null,\n        scaleGizmo: null,\n        boundingBoxGizmo: null\n      }, this._pointerObserver = e.onPointerObservable.add(function (e, t) {\n        if (n.usePointerToAttachGizmos && e.type == Cs.PointerEventTypes.POINTERDOWN) if (e.pickInfo && e.pickInfo.pickedMesh) {\n          var i = e.pickInfo.pickedMesh;\n          if (null == n.attachableMeshes) for (; i && null != i.parent;) i = i.parent;else {\n            var r = !1;\n            n.attachableMeshes.forEach(function (e) {\n              i && (i == e || i.isDescendantOf(e)) && (i = e, r = !0);\n            }), r || (i = null);\n          }\n          i instanceof Cs.AbstractMesh ? n._attachedMesh != i && n.attachToMesh(i) : n.attachToMesh(null);\n        } else n.attachToMesh(null);\n      });\n    }\n\n    return e.prototype.attachToMesh = function (e) {\n      for (var t in this._attachedMesh && this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior), this._attachedMesh = e, this.gizmos) {\n        var i = this.gizmos[t];\n        i && this._gizmosEnabled[t] && (i.attachedMesh = e);\n      }\n\n      this.boundingBoxGizmoEnabled && this._attachedMesh && this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n    }, Object.defineProperty(e.prototype, \"positionGizmoEnabled\", {\n      get: function () {\n        return this._gizmosEnabled.positionGizmo;\n      },\n      set: function (e) {\n        e ? (this.gizmos.positionGizmo || (this.gizmos.positionGizmo = new Cs.PositionGizmo(this._defaultUtilityLayer)), this.gizmos.positionGizmo.attachedMesh = this._attachedMesh) : this.gizmos.positionGizmo && (this.gizmos.positionGizmo.attachedMesh = null), this._gizmosEnabled.positionGizmo = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"rotationGizmoEnabled\", {\n      get: function () {\n        return this._gizmosEnabled.rotationGizmo;\n      },\n      set: function (e) {\n        e ? (this.gizmos.rotationGizmo || (this.gizmos.rotationGizmo = new Cs.RotationGizmo(this._defaultUtilityLayer)), this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh) : this.gizmos.rotationGizmo && (this.gizmos.rotationGizmo.attachedMesh = null), this._gizmosEnabled.rotationGizmo = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"scaleGizmoEnabled\", {\n      get: function () {\n        return this._gizmosEnabled.scaleGizmo;\n      },\n      set: function (e) {\n        e ? (this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new Cs.ScaleGizmo(this._defaultUtilityLayer), this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh) : this.gizmos.scaleGizmo && (this.gizmos.scaleGizmo.attachedMesh = null), this._gizmosEnabled.scaleGizmo = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"boundingBoxGizmoEnabled\", {\n      get: function () {\n        return this._gizmosEnabled.boundingBoxGizmo;\n      },\n      set: function (e) {\n        e ? (this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new Cs.BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer), this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh, this._attachedMesh && (this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior), this._attachedMesh.addBehavior(this.boundingBoxDragBehavior))) : this.gizmos.boundingBoxGizmo && (this.gizmos.boundingBoxGizmo.attachedMesh = null), this._gizmosEnabled.boundingBoxGizmo = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function () {\n      for (var e in this.scene.onPointerObservable.remove(this._pointerObserver), this.gizmos) {\n        var t = this.gizmos[e];\n        t && t.dispose();\n      }\n\n      this._defaultKeepDepthUtilityLayer.dispose(), this._defaultUtilityLayer.dispose(), this.boundingBoxDragBehavior.detach();\n    }, e;\n  }(), Cs.GizmoManager = Os, Ds = $a || ($a = {}), Is = function () {\n    function n(e, t, i) {\n      void 0 === t && (t = 0), void 0 === i && (i = null), this.name = e, this.animations = new Array(), this._positions = null, this._normals = null, this._tangents = null, this.onInfluenceChanged = new Ds.Observable(), this._onDataLayoutChanged = new Ds.Observable(), this._animationPropertiesOverride = null, this._scene = i || Ds.Engine.LastCreatedScene, this.influence = t;\n    }\n\n    return Object.defineProperty(n.prototype, \"influence\", {\n      get: function () {\n        return this._influence;\n      },\n      set: function (e) {\n        if (this._influence !== e) {\n          var t = this._influence;\n          this._influence = e, this.onInfluenceChanged.hasObservers && this.onInfluenceChanged.notifyObservers(0 === t || 0 === e);\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"animationPropertiesOverride\", {\n      get: function () {\n        return !this._animationPropertiesOverride && this._scene ? this._scene.animationPropertiesOverride : this._animationPropertiesOverride;\n      },\n      set: function (e) {\n        this._animationPropertiesOverride = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"hasPositions\", {\n      get: function () {\n        return !!this._positions;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"hasNormals\", {\n      get: function () {\n        return !!this._normals;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"hasTangents\", {\n      get: function () {\n        return !!this._tangents;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.prototype.setPositions = function (e) {\n      var t = this.hasPositions;\n      this._positions = e, t !== this.hasPositions && this._onDataLayoutChanged.notifyObservers(void 0);\n    }, n.prototype.getPositions = function () {\n      return this._positions;\n    }, n.prototype.setNormals = function (e) {\n      var t = this.hasNormals;\n      this._normals = e, t !== this.hasNormals && this._onDataLayoutChanged.notifyObservers(void 0);\n    }, n.prototype.getNormals = function () {\n      return this._normals;\n    }, n.prototype.setTangents = function (e) {\n      var t = this.hasTangents;\n      this._tangents = e, t !== this.hasTangents && this._onDataLayoutChanged.notifyObservers(void 0);\n    }, n.prototype.getTangents = function () {\n      return this._tangents;\n    }, n.prototype.serialize = function () {\n      var e = {};\n      return e.name = this.name, e.influence = this.influence, e.positions = Array.prototype.slice.call(this.getPositions()), this.hasNormals && (e.normals = Array.prototype.slice.call(this.getNormals())), this.hasTangents && (e.tangents = Array.prototype.slice.call(this.getTangents())), Ds.Animation.AppendSerializedAnimations(this, e), e;\n    }, n.Parse = function (e) {\n      var t = new n(e.name, e.influence);\n      if (t.setPositions(e.positions), e.normals && t.setNormals(e.normals), e.tangents && t.setTangents(e.tangents), e.animations) for (var i = 0; i < e.animations.length; i++) {\n        var r = e.animations[i];\n        t.animations.push(Ds.Animation.Parse(r));\n      }\n      return t;\n    }, n.FromMesh = function (e, t, i) {\n      t || (t = e.name);\n      var r = new n(t, i, e.getScene());\n      return r.setPositions(e.getVerticesData(Ds.VertexBuffer.PositionKind)), e.isVerticesDataPresent(Ds.VertexBuffer.NormalKind) && r.setNormals(e.getVerticesData(Ds.VertexBuffer.NormalKind)), e.isVerticesDataPresent(Ds.VertexBuffer.TangentKind) && r.setTangents(e.getVerticesData(Ds.VertexBuffer.TangentKind)), r;\n    }, n;\n  }(), Ds.MorphTarget = Is, ws = $a || ($a = {}), Ls = function () {\n    function s(e) {\n      void 0 === e && (e = null), this._targets = new Array(), this._targetInfluenceChangedObservers = new Array(), this._targetDataLayoutChangedObservers = new Array(), this._activeTargets = new ws.SmartArray(16), this._supportsNormals = !1, this._supportsTangents = !1, this._vertexCount = 0, this._uniqueId = 0, this._tempInfluences = new Array(), e || (e = ws.Engine.LastCreatedScene), this._scene = e, this._scene && (this._scene.morphTargetManagers.push(this), this._uniqueId = this._scene.getUniqueId());\n    }\n\n    return Object.defineProperty(s.prototype, \"uniqueId\", {\n      get: function () {\n        return this._uniqueId;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"vertexCount\", {\n      get: function () {\n        return this._vertexCount;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"supportsNormals\", {\n      get: function () {\n        return this._supportsNormals;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"supportsTangents\", {\n      get: function () {\n        return this._supportsTangents;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"numTargets\", {\n      get: function () {\n        return this._targets.length;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"numInfluencers\", {\n      get: function () {\n        return this._activeTargets.length;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(s.prototype, \"influences\", {\n      get: function () {\n        return this._influences;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), s.prototype.getActiveTarget = function (e) {\n      return this._activeTargets.data[e];\n    }, s.prototype.getTarget = function (e) {\n      return this._targets[e];\n    }, s.prototype.addTarget = function (e) {\n      var t = this;\n      this._targets.push(e), this._targetInfluenceChangedObservers.push(e.onInfluenceChanged.add(function (e) {\n        t._syncActiveTargets(e);\n      })), this._targetDataLayoutChangedObservers.push(e._onDataLayoutChanged.add(function () {\n        t._syncActiveTargets(!0);\n      })), this._syncActiveTargets(!0);\n    }, s.prototype.removeTarget = function (e) {\n      var t = this._targets.indexOf(e);\n\n      0 <= t && (this._targets.splice(t, 1), e.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(t, 1)[0]), e._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(t, 1)[0]), this._syncActiveTargets(!0));\n    }, s.prototype.serialize = function () {\n      var e = {};\n      e.id = this.uniqueId, e.targets = [];\n\n      for (var t = 0, i = this._targets; t < i.length; t++) {\n        var r = i[t];\n        e.targets.push(r.serialize());\n      }\n\n      return e;\n    }, s.prototype._syncActiveTargets = function (e) {\n      var t = 0;\n      this._activeTargets.reset(), this._supportsNormals = !0, this._supportsTangents = !0;\n\n      for (var i = this._vertexCount = 0, r = this._targets; i < r.length; i++) {\n        var n = r[i];\n\n        if (0 !== n.influence) {\n          this._activeTargets.push(n), this._tempInfluences[t++] = n.influence, this._supportsNormals = this._supportsNormals && n.hasNormals, this._supportsTangents = this._supportsTangents && n.hasTangents;\n          var o = n.getPositions();\n\n          if (o) {\n            var s = o.length / 3;\n            if (0 === this._vertexCount) this._vertexCount = s;else if (this._vertexCount !== s) return void ws.Tools.Error(\"Incompatible target. Targets must all have the same vertices count.\");\n          }\n        }\n      }\n\n      this._influences && this._influences.length === t || (this._influences = new Float32Array(t));\n\n      for (var a = 0; a < t; a++) this._influences[a] = this._tempInfluences[a];\n\n      e && this.synchronize();\n    }, s.prototype.synchronize = function () {\n      if (this._scene) for (var e = 0, t = this._scene.meshes; e < t.length; e++) {\n        var i = t[e];\n        i.morphTargetManager === this && i._syncGeometryWithMorphTargetManager();\n      }\n    }, s.Parse = function (e, t) {\n      var i = new s(t);\n      i._uniqueId = e.id;\n\n      for (var r = 0, n = e.targets; r < n.length; r++) {\n        var o = n[r];\n        i.addTarget(ws.MorphTarget.Parse(o));\n      }\n\n      return i;\n    }, s;\n  }(), ws.MorphTargetManager = Ls, Fs = $a || ($a = {}), Bs = function () {\n    function r(e, t, i) {\n      void 0 === i && (i = 2), this.maxDepth = i, this.dynamicContent = new Array(), this._maxBlockCapacity = t || 64, this._selectionContent = new Fs.SmartArrayNoDuplicate(1024), this._creationFunc = e;\n    }\n\n    return r.prototype.update = function (e, t, i) {\n      r._CreateBlocks(e, t, i, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\n    }, r.prototype.addMesh = function (e) {\n      for (var t = 0; t < this.blocks.length; t++) {\n        this.blocks[t].addEntry(e);\n      }\n    }, r.prototype.select = function (e, t) {\n      this._selectionContent.reset();\n\n      for (var i = 0; i < this.blocks.length; i++) {\n        this.blocks[i].select(e, this._selectionContent, t);\n      }\n\n      return t ? this._selectionContent.concat(this.dynamicContent) : this._selectionContent.concatWithNoDuplicate(this.dynamicContent), this._selectionContent;\n    }, r.prototype.intersects = function (e, t, i) {\n      this._selectionContent.reset();\n\n      for (var r = 0; r < this.blocks.length; r++) {\n        this.blocks[r].intersects(e, t, this._selectionContent, i);\n      }\n\n      return i ? this._selectionContent.concat(this.dynamicContent) : this._selectionContent.concatWithNoDuplicate(this.dynamicContent), this._selectionContent;\n    }, r.prototype.intersectsRay = function (e) {\n      this._selectionContent.reset();\n\n      for (var t = 0; t < this.blocks.length; t++) {\n        this.blocks[t].intersectsRay(e, this._selectionContent);\n      }\n\n      return this._selectionContent.concatWithNoDuplicate(this.dynamicContent), this._selectionContent;\n    }, r._CreateBlocks = function (e, t, i, r, n, o, s, a) {\n      s.blocks = new Array();\n\n      for (var l = new Fs.Vector3((t.x - e.x) / 2, (t.y - e.y) / 2, (t.z - e.z) / 2), c = 0; c < 2; c++) for (var h = 0; h < 2; h++) for (var u = 0; u < 2; u++) {\n        var d = e.add(l.multiplyByFloats(c, h, u)),\n            f = e.add(l.multiplyByFloats(c + 1, h + 1, u + 1)),\n            p = new Fs.OctreeBlock(d, f, r, n + 1, o, a);\n        p.addEntries(i), s.blocks.push(p);\n      }\n    }, r.CreationFuncForMeshes = function (e, t) {\n      var i = e.getBoundingInfo();\n      !e.isBlocked && i.boundingBox.intersectsMinMax(t.minPoint, t.maxPoint) && t.entries.push(e);\n    }, r.CreationFuncForSubMeshes = function (e, t) {\n      e.getBoundingInfo().boundingBox.intersectsMinMax(t.minPoint, t.maxPoint) && t.entries.push(e);\n    }, r;\n  }(), Fs.Octree = Bs, Ns = $a || ($a = {}), Vs = function () {\n    function e(e, t, i, r, n, o) {\n      this.entries = new Array(), this._boundingVectors = new Array(), this._capacity = i, this._depth = r, this._maxDepth = n, this._creationFunc = o, this._minPoint = e, this._maxPoint = t, this._boundingVectors.push(e.clone()), this._boundingVectors.push(t.clone()), this._boundingVectors.push(e.clone()), this._boundingVectors[2].x = t.x, this._boundingVectors.push(e.clone()), this._boundingVectors[3].y = t.y, this._boundingVectors.push(e.clone()), this._boundingVectors[4].z = t.z, this._boundingVectors.push(t.clone()), this._boundingVectors[5].z = e.z, this._boundingVectors.push(t.clone()), this._boundingVectors[6].x = e.x, this._boundingVectors.push(t.clone()), this._boundingVectors[7].y = e.y;\n    }\n\n    return Object.defineProperty(e.prototype, \"capacity\", {\n      get: function () {\n        return this._capacity;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"minPoint\", {\n      get: function () {\n        return this._minPoint;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"maxPoint\", {\n      get: function () {\n        return this._maxPoint;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.addEntry = function (e) {\n      if (this.blocks) for (var t = 0; t < this.blocks.length; t++) {\n        this.blocks[t].addEntry(e);\n      } else this._creationFunc(e, this), this.entries.length > this.capacity && this._depth < this._maxDepth && this.createInnerBlocks();\n    }, e.prototype.addEntries = function (e) {\n      for (var t = 0; t < e.length; t++) {\n        var i = e[t];\n        this.addEntry(i);\n      }\n    }, e.prototype.select = function (e, t, i) {\n      if (Ns.BoundingBox.IsInFrustum(this._boundingVectors, e)) {\n        if (this.blocks) {\n          for (var r = 0; r < this.blocks.length; r++) {\n            this.blocks[r].select(e, t, i);\n          }\n\n          return;\n        }\n\n        i ? t.concat(this.entries) : t.concatWithNoDuplicate(this.entries);\n      }\n    }, e.prototype.intersects = function (e, t, i, r) {\n      if (Ns.BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, e, t)) {\n        if (this.blocks) {\n          for (var n = 0; n < this.blocks.length; n++) {\n            this.blocks[n].intersects(e, t, i, r);\n          }\n\n          return;\n        }\n\n        r ? i.concat(this.entries) : i.concatWithNoDuplicate(this.entries);\n      }\n    }, e.prototype.intersectsRay = function (e, t) {\n      if (e.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {\n        if (this.blocks) {\n          for (var i = 0; i < this.blocks.length; i++) {\n            this.blocks[i].intersectsRay(e, t);\n          }\n\n          return;\n        }\n\n        t.concatWithNoDuplicate(this.entries);\n      }\n    }, e.prototype.createInnerBlocks = function () {\n      Ns.Octree._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);\n    }, e;\n  }(), Ns.OctreeBlock = Vs, function (o) {\n    o.Scene.prototype.createOrUpdateSelectionOctree = function (e, t) {\n      void 0 === e && (e = 64), void 0 === t && (t = 2);\n\n      var i = this._getComponent(o.SceneComponentConstants.NAME_OCTREE);\n\n      i || (i = new s(this), this._addComponent(i)), this._selectionOctree || (this._selectionOctree = new o.Octree(o.Octree.CreationFuncForMeshes, e, t));\n      var r = this.getWorldExtends();\n      return this._selectionOctree.update(r.min, r.max, this.meshes), this._selectionOctree;\n    }, Object.defineProperty(o.Scene.prototype, \"selectionOctree\", {\n      get: function () {\n        return this._selectionOctree;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), o.AbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (e, t) {\n      void 0 === e && (e = 64), void 0 === t && (t = 2);\n\n      var i = this.getScene(),\n          r = i._getComponent(o.SceneComponentConstants.NAME_OCTREE);\n\n      r || (r = new s(i), i._addComponent(r)), this._submeshesOctree || (this._submeshesOctree = new o.Octree(o.Octree.CreationFuncForSubMeshes, e, t)), this.computeWorldMatrix(!0);\n      var n = this.getBoundingInfo().boundingBox;\n      return this._submeshesOctree.update(n.minimumWorld, n.maximumWorld, this.subMeshes), this._submeshesOctree;\n    };\n\n    var s = function () {\n      function e(e) {\n        this.name = o.SceneComponentConstants.NAME_OCTREE, this.checksIsEnabled = !0, this._tempRay = new o.Ray(o.Vector3.Zero(), new o.Vector3(1, 1, 1)), this.scene = e, this.scene.getActiveMeshCandidates = this.getActiveMeshCandidates.bind(this), this.scene.getActiveSubMeshCandidates = this.getActiveSubMeshCandidates.bind(this), this.scene.getCollidingSubMeshCandidates = this.getCollidingSubMeshCandidates.bind(this), this.scene.getIntersectingSubMeshCandidates = this.getIntersectingSubMeshCandidates.bind(this);\n      }\n\n      return e.prototype.register = function () {\n        var r = this;\n        this.scene.onMeshRemovedObservable.add(function (e) {\n          var t = r.scene.selectionOctree;\n\n          if (null != t) {\n            var i = t.dynamicContent.indexOf(e);\n            -1 !== i && t.dynamicContent.splice(i, 1);\n          }\n        }), this.scene.onMeshImportedObservable.add(function (e) {\n          var t = r.scene.selectionOctree;\n          null != t && t.addMesh(e);\n        });\n      }, e.prototype.getActiveMeshCandidates = function () {\n        return this.scene._selectionOctree ? this.scene._selectionOctree.select(this.scene.frustumPlanes) : this.scene._getDefaultMeshCandidates();\n      }, e.prototype.getActiveSubMeshCandidates = function (e) {\n        return e._submeshesOctree && e.useOctreeForRenderingSelection ? e._submeshesOctree.select(this.scene.frustumPlanes) : this.scene._getDefaultSubMeshCandidates(e);\n      }, e.prototype.getIntersectingSubMeshCandidates = function (e, t) {\n        return e._submeshesOctree && e.useOctreeForPicking ? (o.Ray.TransformToRef(t, e.getWorldMatrix(), this._tempRay), e._submeshesOctree.intersectsRay(this._tempRay)) : this.scene._getDefaultSubMeshCandidates(e);\n      }, e.prototype.getCollidingSubMeshCandidates = function (e, t) {\n        if (e._submeshesOctree && e.useOctreeForCollisions) {\n          var i = t._velocityWorldLength + Math.max(t._radius.x, t._radius.y, t._radius.z);\n          return e._submeshesOctree.intersects(t._basePointWorld, i);\n        }\n\n        return this.scene._getDefaultSubMeshCandidates(e);\n      }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {}, e;\n    }();\n\n    o.OctreeSceneComponent = s;\n  }($a || ($a = {})), Us = $a || ($a = {}), zs = function (a) {\n    function e(e, t, i, r, n, o) {\n      var s = a.call(this, e, \"anaglyph\", null, [\"leftSampler\"], t, i[1], r, n, o) || this;\n      return s._passedProcess = i[0]._rigPostProcess, s.onApplyObservable.add(function (e) {\n        e.setTextureFromPostProcess(\"leftSampler\", s._passedProcess);\n      }), s;\n    }\n\n    return T(e, a), e;\n  }(Us.PostProcess), Us.AnaglyphPostProcess = zs, function (c) {\n    c.Node.AddNodeConstructor(\"AnaglyphArcRotateCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, 0, 0, 1, c.Vector3.Zero(), i.interaxial_distance, t);\n      };\n    });\n\n    var r = function (l) {\n      function e(e, t, i, r, n, o, s) {\n        var a = l.call(this, e, t, i, r, n, s) || this;\n        return a.interaxialDistance = o, a.setCameraRigMode(c.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {\n          interaxialDistance: o\n        }), a;\n      }\n\n      return T(e, l), e.prototype.getClassName = function () {\n        return \"AnaglyphArcRotateCamera\";\n      }, e;\n    }(c.ArcRotateCamera);\n\n    c.AnaglyphArcRotateCamera = r;\n  }($a || ($a = {})), function (s) {\n    s.Node.AddNodeConstructor(\"AnaglyphFreeCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, s.Vector3.Zero(), i.interaxial_distance, t);\n      };\n    });\n\n    var r = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e, t, r) || this;\n        return n.interaxialDistance = i, n.setCameraRigMode(s.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {\n          interaxialDistance: i\n        }), n;\n      }\n\n      return T(e, o), e.prototype.getClassName = function () {\n        return \"AnaglyphFreeCamera\";\n      }, e;\n    }(s.FreeCamera);\n\n    s.AnaglyphFreeCamera = r;\n  }($a || ($a = {})), function (s) {\n    s.Node.AddNodeConstructor(\"AnaglyphGamepadCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, s.Vector3.Zero(), i.interaxial_distance, t);\n      };\n    });\n\n    var r = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e, t, r) || this;\n        return n.interaxialDistance = i, n.setCameraRigMode(s.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {\n          interaxialDistance: i\n        }), n;\n      }\n\n      return T(e, o), e.prototype.getClassName = function () {\n        return \"AnaglyphGamepadCamera\";\n      }, e;\n    }(s.GamepadCamera);\n\n    s.AnaglyphGamepadCamera = r;\n  }($a || ($a = {})), function (s) {\n    s.Node.AddNodeConstructor(\"AnaglyphUniversalCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, s.Vector3.Zero(), i.interaxial_distance, t);\n      };\n    });\n\n    var r = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e, t, r) || this;\n        return n.interaxialDistance = i, n.setCameraRigMode(s.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, {\n          interaxialDistance: i\n        }), n;\n      }\n\n      return T(e, o), e.prototype.getClassName = function () {\n        return \"AnaglyphUniversalCamera\";\n      }, e;\n    }(s.UniversalCamera);\n\n    s.AnaglyphUniversalCamera = r;\n  }($a || ($a = {})), Gs = $a || ($a = {}), ks = function (a) {\n    function e(e, t, i, r, n, o) {\n      var s = a.call(this, e, \"stereoscopicInterlace\", [\"stepSize\"], [\"camASampler\"], 1, t[1], r, n, o, i ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : void 0) || this;\n      return s._passedProcess = t[0]._rigPostProcess, s._stepSize = new Gs.Vector2(1 / s.width, 1 / s.height), s.onSizeChangedObservable.add(function () {\n        s._stepSize = new Gs.Vector2(1 / s.width, 1 / s.height);\n      }), s.onApplyObservable.add(function (e) {\n        e.setTextureFromPostProcess(\"camASampler\", s._passedProcess), e.setFloat2(\"stepSize\", s._stepSize.x, s._stepSize.y);\n      }), s;\n    }\n\n    return T(e, a), e;\n  }(Gs.PostProcess), Gs.StereoscopicInterlacePostProcess = ks, function (h) {\n    h.Node.AddNodeConstructor(\"StereoscopicArcRotateCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, 0, 0, 1, h.Vector3.Zero(), i.interaxial_distance, i.isStereoscopicSideBySide, t);\n      };\n    });\n\n    var r = function (c) {\n      function e(e, t, i, r, n, o, s, a) {\n        var l = c.call(this, e, t, i, r, n, a) || this;\n        return l.interaxialDistance = o, l.isStereoscopicSideBySide = s, l.setCameraRigMode(s ? h.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : h.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n          interaxialDistance: o\n        }), l;\n      }\n\n      return T(e, c), e.prototype.getClassName = function () {\n        return \"StereoscopicArcRotateCamera\";\n      }, e;\n    }(h.ArcRotateCamera);\n\n    h.StereoscopicArcRotateCamera = r;\n  }($a || ($a = {})), function (a) {\n    a.Node.AddNodeConstructor(\"StereoscopicFreeCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, a.Vector3.Zero(), i.interaxial_distance, i.isStereoscopicSideBySide, t);\n      };\n    });\n\n    var r = function (s) {\n      function e(e, t, i, r, n) {\n        var o = s.call(this, e, t, n) || this;\n        return o.interaxialDistance = i, o.isStereoscopicSideBySide = r, o.setCameraRigMode(r ? a.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : a.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n          interaxialDistance: i\n        }), o;\n      }\n\n      return T(e, s), e.prototype.getClassName = function () {\n        return \"StereoscopicFreeCamera\";\n      }, e;\n    }(a.FreeCamera);\n\n    a.StereoscopicFreeCamera = r;\n  }($a || ($a = {})), function (a) {\n    a.Node.AddNodeConstructor(\"StereoscopicGamepadCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, a.Vector3.Zero(), i.interaxial_distance, i.isStereoscopicSideBySide, t);\n      };\n    });\n\n    var r = function (s) {\n      function e(e, t, i, r, n) {\n        var o = s.call(this, e, t, n) || this;\n        return o.interaxialDistance = i, o.isStereoscopicSideBySide = r, o.setCameraRigMode(r ? a.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : a.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n          interaxialDistance: i\n        }), o;\n      }\n\n      return T(e, s), e.prototype.getClassName = function () {\n        return \"StereoscopicGamepadCamera\";\n      }, e;\n    }(a.GamepadCamera);\n\n    a.StereoscopicGamepadCamera = r;\n  }($a || ($a = {})), function (a) {\n    a.Node.AddNodeConstructor(\"StereoscopicFreeCamera\", function (e, t, i) {\n      return function () {\n        return new r(e, a.Vector3.Zero(), i.interaxial_distance, i.isStereoscopicSideBySide, t);\n      };\n    });\n\n    var r = function (s) {\n      function e(e, t, i, r, n) {\n        var o = s.call(this, e, t, n) || this;\n        return o.interaxialDistance = i, o.isStereoscopicSideBySide = r, o.setCameraRigMode(r ? a.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : a.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, {\n          interaxialDistance: i\n        }), o;\n      }\n\n      return T(e, s), e.prototype.getClassName = function () {\n        return \"StereoscopicUniversalCamera\";\n      }, e;\n    }(a.UniversalCamera);\n\n    a.StereoscopicUniversalCamera = r;\n  }($a || ($a = {})), Ws = $a || ($a = {}), Hs = function (o) {\n    function e(e, t, i, r) {\n      var n = o.call(this, e, \"vrDistortionCorrection\", [\"LensCenter\", \"Scale\", \"ScaleIn\", \"HmdWarpParam\"], null, r.postProcessScaleFactor, t, Ws.Texture.BILINEAR_SAMPLINGMODE) || this;\n      return n._isRightEye = i, n._distortionFactors = r.distortionK, n._postProcessScaleFactor = r.postProcessScaleFactor, n._lensCenterOffset = r.lensCenterOffset, n.adaptScaleToCurrentViewport = !0, n.onSizeChangedObservable.add(function () {\n        n._scaleIn = new Ws.Vector2(2, 2 / n.aspectRatio), n._scaleFactor = new Ws.Vector2(1 / n._postProcessScaleFactor * .5, 1 / n._postProcessScaleFactor * .5 * n.aspectRatio), n._lensCenter = new Ws.Vector2(n._isRightEye ? .5 - .5 * n._lensCenterOffset : .5 + .5 * n._lensCenterOffset, .5);\n      }), n.onApplyObservable.add(function (e) {\n        e.setFloat2(\"LensCenter\", n._lensCenter.x, n._lensCenter.y), e.setFloat2(\"Scale\", n._scaleFactor.x, n._scaleFactor.y), e.setFloat2(\"ScaleIn\", n._scaleIn.x, n._scaleIn.y), e.setFloat4(\"HmdWarpParam\", n._distortionFactors[0], n._distortionFactors[1], n._distortionFactors[2], n._distortionFactors[3]);\n      }), n;\n    }\n\n    return T(e, o), e;\n  }(Ws.PostProcess), Ws.VRDistortionCorrectionPostProcess = Hs, Xs = $a || ($a = {}), js = function () {\n    function e() {\n      var t = this;\n      this._screenOrientationAngle = 0, this._screenQuaternion = new Xs.Quaternion(), this._alpha = 0, this._beta = 0, this._gamma = 0, this._orientationChanged = function () {\n        t._screenOrientationAngle = void 0 !== window.orientation ? +window.orientation : window.screen.orientation && window.screen.orientation.angle ? window.screen.orientation.angle : 0, t._screenOrientationAngle = -Xs.Tools.ToRadians(t._screenOrientationAngle / 2), t._screenQuaternion.copyFromFloats(0, Math.sin(t._screenOrientationAngle), 0, Math.cos(t._screenOrientationAngle));\n      }, this._deviceOrientation = function (e) {\n        t._alpha = null !== e.alpha ? e.alpha : 0, t._beta = null !== e.beta ? e.beta : 0, t._gamma = null !== e.gamma ? e.gamma : 0;\n      }, this._constantTranform = new Xs.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)), this._orientationChanged();\n    }\n\n    return Object.defineProperty(e.prototype, \"camera\", {\n      get: function () {\n        return this._camera;\n      },\n      set: function (e) {\n        this._camera = e, null == this._camera || this._camera.rotationQuaternion || (this._camera.rotationQuaternion = new Xs.Quaternion());\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.attachControl = function (e, t) {\n      window.addEventListener(\"orientationchange\", this._orientationChanged), window.addEventListener(\"deviceorientation\", this._deviceOrientation), this._orientationChanged();\n    }, e.prototype.detachControl = function (e) {\n      window.removeEventListener(\"orientationchange\", this._orientationChanged), window.removeEventListener(\"deviceorientation\", this._deviceOrientation);\n    }, e.prototype.checkInputs = function () {\n      this._alpha && (Xs.Quaternion.RotationYawPitchRollToRef(Xs.Tools.ToRadians(this._alpha), Xs.Tools.ToRadians(this._beta), -Xs.Tools.ToRadians(this._gamma), this.camera.rotationQuaternion), this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion), this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform), this._camera.rotationQuaternion.z *= -1, this._camera.rotationQuaternion.w *= -1);\n    }, e.prototype.getClassName = function () {\n      return \"FreeCameraDeviceOrientationInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"deviceOrientation\";\n    }, e;\n  }(), Xs.FreeCameraDeviceOrientationInput = js, Xs.CameraInputTypes.FreeCameraDeviceOrientationInput = js, Ys = $a || ($a = {}), Ks = function () {\n    function e() {\n      this.alphaCorrection = 1, this.betaCorrection = 1, this.gammaCorrection = 1, this._alpha = 0, this._gamma = 0, this._dirty = !1, this._deviceOrientationHandler = this._onOrientationEvent.bind(this);\n    }\n\n    return e.prototype.attachControl = function (e, t) {\n      this.camera.attachControl(e, t), window.addEventListener(\"deviceorientation\", this._deviceOrientationHandler);\n    }, e.prototype._onOrientationEvent = function (e) {\n      null !== e.alpha && (this._alpha = 0 | +e.alpha), null !== e.gamma && (this._gamma = 0 | +e.gamma), this._dirty = !0;\n    }, e.prototype.checkInputs = function () {\n      this._dirty && (this._dirty = !1, this._gamma < 0 && (this._gamma = 180 + this._gamma), this.camera.alpha = -this._alpha / 180 * Math.PI % Math.PI * 2, this.camera.beta = this._gamma / 180 * Math.PI);\n    }, e.prototype.detachControl = function (e) {\n      window.removeEventListener(\"deviceorientation\", this._deviceOrientationHandler);\n    }, e.prototype.getClassName = function () {\n      return \"ArcRotateCameraVRDeviceOrientationInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"VRDeviceOrientation\";\n    }, e;\n  }(), Ys.ArcRotateCameraVRDeviceOrientationInput = Ks, Ys.CameraInputTypes.ArcRotateCameraVRDeviceOrientationInput = Ks, Qs = $a || ($a = {}), Zs = function () {\n    function t() {\n      this.compensateDistortion = !0;\n    }\n\n    return Object.defineProperty(t.prototype, \"aspectRatio\", {\n      get: function () {\n        return this.hResolution / (2 * this.vResolution);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"aspectRatioFov\", {\n      get: function () {\n        return 2 * Math.atan(this.postProcessScaleFactor * this.vScreenSize / (2 * this.eyeToScreenDistance));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"leftHMatrix\", {\n      get: function () {\n        var e = 4 * (this.hScreenSize / 4 - this.lensSeparationDistance / 2) / this.hScreenSize;\n        return Qs.Matrix.Translation(e, 0, 0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"rightHMatrix\", {\n      get: function () {\n        var e = 4 * (this.hScreenSize / 4 - this.lensSeparationDistance / 2) / this.hScreenSize;\n        return Qs.Matrix.Translation(-e, 0, 0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"leftPreViewMatrix\", {\n      get: function () {\n        return Qs.Matrix.Translation(.5 * this.interpupillaryDistance, 0, 0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"rightPreViewMatrix\", {\n      get: function () {\n        return Qs.Matrix.Translation(-.5 * this.interpupillaryDistance, 0, 0);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), t.GetDefault = function () {\n      var e = new t();\n      return e.hResolution = 1280, e.vResolution = 800, e.hScreenSize = .149759993, e.vScreenSize = .0935999975, e.vScreenCenter = .0467999987, e.eyeToScreenDistance = .0410000011, e.lensSeparationDistance = .063500002, e.interpupillaryDistance = .064000003, e.distortionK = [1, .219999999, .239999995, 0], e.chromaAbCorrection = [.995999992, -.00400000019, 1.01400006, 0], e.postProcessScaleFactor = 1.714605507808412, e.lensCenterOffset = .151976421, e;\n    }, t;\n  }(), Qs.VRCameraMetrics = Zs, function (a) {\n    a.Node.AddNodeConstructor(\"WebVRFreeCamera\", function (e, t) {\n      return function () {\n        return new i(e, a.Vector3.Zero(), t);\n      };\n    }), a.Node.AddNodeConstructor(\"WebVRGamepadCamera\", function (e, t) {\n      return function () {\n        return new i(e, a.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (s) {\n      function e(e, t, i, r) {\n        void 0 === r && (r = {});\n        var n = s.call(this, e, t, i) || this;\n        n.webVROptions = r, n._vrDevice = null, n.rawPose = null, n._specsVersion = \"1.1\", n._attached = !1, n._descendants = [], n._deviceRoomPosition = a.Vector3.Zero(), n._deviceRoomRotationQuaternion = a.Quaternion.Identity(), n._standingMatrix = null, n.devicePosition = a.Vector3.Zero(), n.deviceRotationQuaternion = a.Quaternion.Identity(), n.deviceScaleFactor = 1, n._deviceToWorld = a.Matrix.Identity(), n._worldToDevice = a.Matrix.Identity(), n.controllers = [], n.onControllersAttachedObservable = new a.Observable(), n.onControllerMeshLoadedObservable = new a.Observable(), n.onPoseUpdatedFromDeviceObservable = new a.Observable(), n._poseSet = !1, n.rigParenting = !0, n._defaultHeight = void 0, n._htmlElementAttached = null, n._detachIfAttached = function () {\n          var e = n.getEngine().getVRDevice();\n          e && !e.isPresenting && n._htmlElementAttached && n.detachControl(n._htmlElementAttached);\n        }, n._workingVector = a.Vector3.Zero(), n._oneVector = a.Vector3.One(), n._workingMatrix = a.Matrix.Identity(), n._tmpMatrix = new a.Matrix(), n._cache.position = a.Vector3.Zero(), r.defaultHeight && (n._defaultHeight = r.defaultHeight, n.position.y = n._defaultHeight), n.minZ = .1, 5 === arguments.length && (n.webVROptions = arguments[4]), null == n.webVROptions.trackPosition && (n.webVROptions.trackPosition = !0), null == n.webVROptions.controllerMeshes && (n.webVROptions.controllerMeshes = !0), null == n.webVROptions.defaultLightingOnControllers && (n.webVROptions.defaultLightingOnControllers = !0), n.rotationQuaternion = new a.Quaternion(), n.webVROptions && n.webVROptions.positionScale && (n.deviceScaleFactor = n.webVROptions.positionScale);\n        var o = n.getEngine();\n        return n._onVREnabled = function (e) {\n          e && n.initControllers();\n        }, o.onVRRequestPresentComplete.add(n._onVREnabled), o.initWebVR().add(function (e) {\n          e.vrDisplay && n._vrDevice !== e.vrDisplay && (n._vrDevice = e.vrDisplay, n.setCameraRigMode(a.Camera.RIG_MODE_WEBVR, {\n            parentCamera: n,\n            vrDisplay: n._vrDevice,\n            frameData: n._frameData,\n            specs: n._specsVersion\n          }), n._attached && n.getEngine().enableVR());\n        }), \"undefined\" != typeof VRFrameData && (n._frameData = new VRFrameData()), i.onBeforeCameraRenderObservable.add(function (t) {\n          t.parent === n && n.rigParenting && (n._descendants = n.getDescendants(!0, function (t) {\n            var e = n.controllers.some(function (e) {\n              return e._mesh === t;\n            }),\n                i = -1 !== n._rigCameras.indexOf(t);\n\n            return !e && !i;\n          }), n._descendants.forEach(function (e) {\n            e.parent = t;\n          }));\n        }), i.onAfterCameraRenderObservable.add(function (e) {\n          e.parent === n && n.rigParenting && n._descendants.forEach(function (e) {\n            e.parent = n;\n          });\n        }), n;\n      }\n\n      return T(e, s), e.prototype.deviceDistanceToRoomGround = function () {\n        return this._standingMatrix ? (this._standingMatrix.getTranslationToRef(this._workingVector), this._deviceRoomPosition.y + this._workingVector.y) : this._defaultHeight || 0;\n      }, e.prototype.useStandingMatrix = function (t) {\n        var i = this;\n        void 0 === t && (t = function (e) {}), this.getEngine().initWebVRAsync().then(function (e) {\n          e.vrDisplay && e.vrDisplay.stageParameters && e.vrDisplay.stageParameters.sittingToStandingTransform && i.webVROptions.trackPosition ? (i._standingMatrix = new a.Matrix(), a.Matrix.FromFloat32ArrayToRefScaled(e.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, i._standingMatrix), i.getScene().useRightHandedSystem || [2, 6, 8, 9, 14].forEach(function (e) {\n            i._standingMatrix && (i._standingMatrix.m[e] *= -1);\n          }), t(!0)) : t(!1);\n        });\n      }, e.prototype.useStandingMatrixAsync = function () {\n        var i = this;\n        return new Promise(function (t, e) {\n          i.useStandingMatrix(function (e) {\n            t(e);\n          });\n        });\n      }, e.prototype.dispose = function () {\n        this._detachIfAttached(), this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled), this._updateCacheWhenTrackingDisabledObserver && this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver), s.prototype.dispose.call(this);\n      }, e.prototype.getControllerByName = function (e) {\n        for (var t = 0, i = this.controllers; t < i.length; t++) {\n          var r = i[t];\n          if (r.hand === e) return r;\n        }\n\n        return null;\n      }, Object.defineProperty(e.prototype, \"leftController\", {\n        get: function () {\n          return this._leftController || (this._leftController = this.getControllerByName(\"left\")), this._leftController;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"rightController\", {\n        get: function () {\n          return this._rightController || (this._rightController = this.getControllerByName(\"right\")), this._rightController;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype.getForwardRay = function (e) {\n        return void 0 === e && (e = 100), this.leftCamera ? s.prototype.getForwardRay.call(this, e, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition) : s.prototype.getForwardRay.call(this, e);\n      }, e.prototype._checkInputs = function () {\n        this._vrDevice && this._vrDevice.isPresenting && (this._vrDevice.getFrameData(this._frameData), this.updateFromDevice(this._frameData.pose)), s.prototype._checkInputs.call(this);\n      }, e.prototype.updateFromDevice = function (e) {\n        e && e.orientation && (this.rawPose = e, this._deviceRoomRotationQuaternion.copyFromFloats(e.orientation[0], e.orientation[1], -e.orientation[2], -e.orientation[3]), this.getScene().useRightHandedSystem && (this._deviceRoomRotationQuaternion.z *= -1, this._deviceRoomRotationQuaternion.w *= -1), this.webVROptions.trackPosition && this.rawPose.position && (this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]), this.getScene().useRightHandedSystem && (this._deviceRoomPosition.z *= -1)), this._poseSet = !0);\n      }, e.prototype.attachControl = function (e, t) {\n        s.prototype.attachControl.call(this, e, t), this._attached = !0, this._htmlElementAttached = e, t = !a.Camera.ForceAttachControlToAlwaysPreventDefault && t, this._vrDevice && this.getEngine().enableVR(), window.addEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n      }, e.prototype.detachControl = function (e) {\n        this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver), this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver), s.prototype.detachControl.call(this, e), this._attached = !1, this.getEngine().disableVR(), window.removeEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n      }, e.prototype.getClassName = function () {\n        return \"WebVRFreeCamera\";\n      }, e.prototype.resetToCurrentRotation = function () {\n        this._vrDevice.resetPose();\n      }, e.prototype._updateRigCameras = function () {\n        var e = this._rigCameras[0],\n            t = this._rigCameras[1];\n        e.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion), t.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion), e.position.copyFrom(this._deviceRoomPosition), t.position.copyFrom(this._deviceRoomPosition);\n      }, e.prototype._correctPositionIfNotTrackPosition = function (e, t) {\n        void 0 === t && (t = !1), this.rawPose && this.rawPose.position && !this.webVROptions.trackPosition && (a.Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix), t || this._tmpMatrix.invert(), this._tmpMatrix.multiplyToRef(e, e));\n      }, e.prototype._updateCache = function (e) {\n        var t = this;\n        this.rotationQuaternion.equals(this._cache.rotationQuaternion) && this.position.equals(this._cache.position) || (this.updateCacheCalled || (this.updateCacheCalled = !0, this.update()), this.rotationQuaternion.toRotationMatrix(this._workingMatrix), a.Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector), this.devicePosition.subtractToRef(this._workingVector, this._workingVector), a.Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld), this._deviceToWorld.getTranslationToRef(this._workingVector), this._workingVector.addInPlace(this.position), this._workingVector.subtractInPlace(this._cache.position), this._deviceToWorld.setTranslation(this._workingVector), this._deviceToWorld.invertToRef(this._worldToDevice), this.controllers.forEach(function (e) {\n          e._deviceToWorld.copyFrom(t._deviceToWorld), t._correctPositionIfNotTrackPosition(e._deviceToWorld), e.update();\n        })), e || s.prototype._updateCache.call(this), this.updateCacheCalled = !1;\n      }, e.prototype._computeDevicePosition = function () {\n        a.Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\n      }, e.prototype.update = function () {\n        this._computeDevicePosition(), a.Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix), this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix), a.Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion), this._poseSet && this.onPoseUpdatedFromDeviceObservable.notifyObservers(null), s.prototype.update.call(this);\n      }, e.prototype._getViewMatrix = function () {\n        return a.Matrix.Identity();\n      }, e.prototype._getWebVRViewMatrix = function () {\n        var t = this,\n            e = this._cameraRigParams.parentCamera;\n\n        e._updateCache();\n\n        var i = this._cameraRigParams.left ? this._cameraRigParams.frameData.leftViewMatrix : this._cameraRigParams.frameData.rightViewMatrix;\n        return a.Matrix.FromArrayToRef(i, 0, this._webvrViewMatrix), this.getScene().useRightHandedSystem || [2, 6, 8, 9, 14].forEach(function (e) {\n          t._webvrViewMatrix.m[e] *= -1;\n        }), this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix), a.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget), 1 !== e.deviceScaleFactor && (this._webvrViewMatrix.invert(), e.deviceScaleFactor && (this._webvrViewMatrix.m[12] *= e.deviceScaleFactor, this._webvrViewMatrix.m[13] *= e.deviceScaleFactor, this._webvrViewMatrix.m[14] *= e.deviceScaleFactor), this._webvrViewMatrix.invert()), e._correctPositionIfNotTrackPosition(this._webvrViewMatrix, !0), e._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix), this._workingMatrix = this._workingMatrix || a.Matrix.Identity(), this._webvrViewMatrix.invertToRef(this._workingMatrix), this._workingMatrix.multiplyToRef(e.getWorldMatrix(), this._workingMatrix), this._workingMatrix.getTranslationToRef(this._globalPosition), this._markSyncedWithParent(), this._webvrViewMatrix;\n      }, e.prototype._getWebVRProjectionMatrix = function () {\n        var t = this,\n            e = this.parent;\n        e._vrDevice.depthNear = e.minZ, e._vrDevice.depthFar = e.maxZ;\n        var i = this._cameraRigParams.left ? this._cameraRigParams.frameData.leftProjectionMatrix : this._cameraRigParams.frameData.rightProjectionMatrix;\n        return a.Matrix.FromArrayToRef(i, 0, this._projectionMatrix), this.getScene().useRightHandedSystem || [8, 9, 10, 11].forEach(function (e) {\n          t._projectionMatrix.m[e] *= -1;\n        }), this._projectionMatrix;\n      }, e.prototype.initControllers = function () {\n        var n = this;\n        this.controllers = [];\n        var e = this.getScene().gamepadManager;\n        this._onGamepadDisconnectedObserver = e.onGamepadDisconnectedObservable.add(function (e) {\n          if (e.type === a.Gamepad.POSE_ENABLED) {\n            var t = e;\n            t.defaultModel && t.defaultModel.setEnabled(!1), \"right\" === t.hand && (n._rightController = null), \"left\" === t.hand && (n._leftController = null);\n            var i = n.controllers.indexOf(t);\n            -1 !== i && n.controllers.splice(i, 1);\n          }\n        }), this._onGamepadConnectedObserver = e.onGamepadConnectedObservable.add(function (e) {\n          if (e.type === a.Gamepad.POSE_ENABLED) {\n            var t = e;\n\n            if (n.webVROptions.trackPosition || (t._disableTrackPosition(new a.Vector3(\"left\" == t.hand ? -.15 : .15, -.5, .25)), n._updateCacheWhenTrackingDisabledObserver || (n._updateCacheWhenTrackingDisabledObserver = n._scene.onBeforeRenderObservable.add(function () {\n              n._updateCache();\n            }))), t.deviceScaleFactor = n.deviceScaleFactor, t._deviceToWorld.copyFrom(n._deviceToWorld), n._correctPositionIfNotTrackPosition(t._deviceToWorld), n.webVROptions.controllerMeshes && (t.defaultModel ? t.defaultModel.setEnabled(!0) : t.initControllerMesh(n.getScene(), function (e) {\n              if (e.scaling.scaleInPlace(n.deviceScaleFactor), n.onControllerMeshLoadedObservable.notifyObservers(t), n.webVROptions.defaultLightingOnControllers) {\n                n._lightOnControllers || (n._lightOnControllers = new a.HemisphericLight(\"vrControllersLight\", new a.Vector3(0, 1, 0), n.getScene()));\n\n                var r = function (e, t) {\n                  var i = e.getChildren();\n                  i && 0 !== i.length && i.forEach(function (e) {\n                    t.includedOnlyMeshes.push(e), r(e, t);\n                  });\n                };\n\n                n._lightOnControllers.includedOnlyMeshes.push(e), r(e, n._lightOnControllers);\n              }\n            })), t.attachToPoseControlledCamera(n), -1 === n.controllers.indexOf(t)) {\n              n.controllers.push(t);\n\n              for (var i = !1, r = 0; r < n.controllers.length; r++) n.controllers[r].controllerType === a.PoseEnabledControllerType.VIVE && (i ? n.controllers[r].hand = \"right\" : (i = !0, n.controllers[r].hand = \"left\"));\n\n              2 <= n.controllers.length && n.onControllersAttachedObservable.notifyObservers(n.controllers);\n            }\n          }\n        });\n      }, e;\n    }(a.FreeCamera);\n\n    a.WebVRFreeCamera = i;\n  }($a || ($a = {})), function (o) {\n    o.Node.AddNodeConstructor(\"DeviceOrientationCamera\", function (e, t) {\n      return function () {\n        return new i(e, o.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, t, i) || this;\n        return r._quaternionCache = new o.Quaternion(), r.inputs.addDeviceOrientation(), r;\n      }\n\n      return T(e, n), e.prototype.getClassName = function () {\n        return \"DeviceOrientationCamera\";\n      }, e.prototype._checkInputs = function () {\n        n.prototype._checkInputs.call(this), this._quaternionCache.copyFrom(this.rotationQuaternion), this._initialQuaternion && this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n      }, e.prototype.resetToCurrentRotation = function (t) {\n        var i = this;\n        void 0 === t && (t = o.Axis.Y), this.rotationQuaternion && (this._initialQuaternion || (this._initialQuaternion = new o.Quaternion()), this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion), [\"x\", \"y\", \"z\"].forEach(function (e) {\n          t[e] ? i._initialQuaternion[e] *= -1 : i._initialQuaternion[e] = 0;\n        }), this._initialQuaternion.normalize(), this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion));\n      }, e;\n    }(o.FreeCamera);\n\n    o.DeviceOrientationCamera = i;\n  }($a || ($a = {})), function (a) {\n    a.Node.AddNodeConstructor(\"VRDeviceOrientationFreeCamera\", function (e, t) {\n      return function () {\n        return new i(e, a.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (s) {\n      function e(e, t, i, r, n) {\n        void 0 === r && (r = !0), void 0 === n && (n = a.VRCameraMetrics.GetDefault());\n        var o = s.call(this, e, t, i) || this;\n        return n.compensateDistortion = r, o.setCameraRigMode(a.Camera.RIG_MODE_VR, {\n          vrCameraMetrics: n\n        }), o;\n      }\n\n      return T(e, s), e.prototype.getClassName = function () {\n        return \"VRDeviceOrientationFreeCamera\";\n      }, e;\n    }(a.DeviceOrientationCamera);\n\n    a.VRDeviceOrientationFreeCamera = i;\n  }($a || ($a = {})), function (h) {\n    h.Node.AddNodeConstructor(\"VRDeviceOrientationFreeCamera\", function (e, t) {\n      return function () {\n        return new i(e, 0, 0, 1, h.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (c) {\n      function e(e, t, i, r, n, o, s, a) {\n        void 0 === s && (s = !0), void 0 === a && (a = h.VRCameraMetrics.GetDefault());\n        var l = c.call(this, e, t, i, r, n, o) || this;\n        return a.compensateDistortion = s, l.setCameraRigMode(h.Camera.RIG_MODE_VR, {\n          vrCameraMetrics: a\n        }), l.inputs.addVRDeviceOrientation(), l;\n      }\n\n      return T(e, c), e.prototype.getClassName = function () {\n        return \"VRDeviceOrientationArcRotateCamera\";\n      }, e;\n    }(h.ArcRotateCamera);\n\n    h.VRDeviceOrientationArcRotateCamera = i;\n  }($a || ($a = {})), function (a) {\n    a.Node.AddNodeConstructor(\"VRDeviceOrientationGamepadCamera\", function (e, t) {\n      return function () {\n        return new i(e, a.Vector3.Zero(), t);\n      };\n    });\n\n    var i = function (s) {\n      function e(e, t, i, r, n) {\n        void 0 === r && (r = !0), void 0 === n && (n = a.VRCameraMetrics.GetDefault());\n        var o = s.call(this, e, t, i, r, n) || this;\n        return o.inputs.addGamepad(), o;\n      }\n\n      return T(e, s), e.prototype.getClassName = function () {\n        return \"VRDeviceOrientationGamepadCamera\";\n      }, e;\n    }(a.VRDeviceOrientationFreeCamera);\n\n    a.VRDeviceOrientationGamepadCamera = i;\n  }($a || ($a = {})), qs = $a || ($a = {}), Js = function () {\n    function r(e, t) {\n      if (void 0 === t && (t = null), this.scene = e, this._pointerDownOnMeshAsked = !1, this._isActionableMesh = !1, this._teleportationRequestInitiated = !1, this._teleportationBackRequestInitiated = !1, this._rotationRightAsked = !1, this._rotationLeftAsked = !1, this._dpadPressed = !0, this._activePointer = !1, this._id = r._idCounter++, t) this._gazeTracker = t.clone(\"gazeTracker\");else {\n        this._gazeTracker = qs.Mesh.CreateTorus(\"gazeTracker\", .0035, .0025, 20, e, !1), this._gazeTracker.bakeCurrentTransformIntoVertices(), this._gazeTracker.isPickable = !1, this._gazeTracker.isVisible = !1;\n        var i = new qs.StandardMaterial(\"targetMat\", e);\n        i.specularColor = qs.Color3.Black(), i.emissiveColor = new qs.Color3(.7, .7, .7), i.backFaceCulling = !1, this._gazeTracker.material = i;\n      }\n    }\n\n    return r.prototype._getForwardRay = function (e) {\n      return new qs.Ray(qs.Vector3.Zero(), new qs.Vector3(0, 0, e));\n    }, r.prototype._selectionPointerDown = function () {\n      this._pointerDownOnMeshAsked = !0, this._currentHit && this.scene.simulatePointerDown(this._currentHit, {\n        pointerId: this._id\n      });\n    }, r.prototype._selectionPointerUp = function () {\n      this._currentHit && this.scene.simulatePointerUp(this._currentHit, {\n        pointerId: this._id\n      }), this._pointerDownOnMeshAsked = !1;\n    }, r.prototype._activatePointer = function () {\n      this._activePointer = !0;\n    }, r.prototype._deactivatePointer = function () {\n      this._activePointer = !1;\n    }, r.prototype._updatePointerDistance = function (e) {\n      void 0 === e && (e = 100);\n    }, r.prototype.dispose = function () {\n      this._interactionsEnabled = !1, this._teleportationEnabled = !1, this._gazeTracker && this._gazeTracker.dispose();\n    }, r._idCounter = 0, r;\n  }(), $s = function (a) {\n    function e(e, t, i) {\n      var r = a.call(this, t, i) || this;\n      r.webVRController = e, r._laserPointer = qs.Mesh.CreateCylinder(\"laserPointer\", 1, .004, 2e-4, 20, 1, t, !1);\n      var n = new qs.StandardMaterial(\"laserPointerMat\", t);\n\n      if (n.emissiveColor = new qs.Color3(.7, .7, .7), n.alpha = .6, r._laserPointer.material = n, r._laserPointer.rotation.x = Math.PI / 2, r._laserPointer.position.z = -.5, r._laserPointer.isVisible = !1, r._laserPointer.isPickable = !1, !e.mesh) {\n        var o = new qs.Mesh(\"preloadControllerMesh\", t),\n            s = new qs.Mesh(qs.PoseEnabledController.POINTING_POSE, t);\n        s.rotation.x = -.7, o.addChild(s), e.attachToMesh(o);\n      }\n\n      return r._setLaserPointerParent(e.mesh), r._meshAttachedObserver = e._meshAttachedObservable.add(function (e) {\n        r._setLaserPointerParent(e);\n      }), r;\n    }\n\n    return T(e, a), e.prototype._getForwardRay = function (e) {\n      return this.webVRController.getForwardRay(e);\n    }, e.prototype._activatePointer = function () {\n      a.prototype._activatePointer.call(this), this._laserPointer.isVisible = !0;\n    }, e.prototype._deactivatePointer = function () {\n      a.prototype._deactivatePointer.call(this), this._laserPointer.isVisible = !1;\n    }, e.prototype._setLaserPointerColor = function (e) {\n      this._laserPointer.material.emissiveColor = e;\n    }, e.prototype._setLaserPointerParent = function (e) {\n      var t = function (e) {\n        e.isPickable = !1, e.getChildMeshes().forEach(function (e) {\n          t(e);\n        });\n      };\n\n      t(e);\n      var i = e.getChildMeshes();\n      this.webVRController._pointingPoseNode = null;\n\n      for (var r = 0; r < i.length; r++) if (i[r].name && 0 <= i[r].name.indexOf(qs.PoseEnabledController.POINTING_POSE)) {\n        e = i[r], this.webVRController._pointingPoseNode = e;\n        break;\n      }\n\n      this._laserPointer.parent = e;\n    }, e.prototype._updatePointerDistance = function (e) {\n      void 0 === e && (e = 100), this._laserPointer.scaling.y = e, this._laserPointer.position.z = -e / 2;\n    }, e.prototype.dispose = function () {\n      a.prototype.dispose.call(this), this._laserPointer.dispose(), this._meshAttachedObserver && this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);\n    }, e;\n  }(Js), ea = function (r) {\n    function e(e, t) {\n      var i = r.call(this, t) || this;\n      return i.getCamera = e, i;\n    }\n\n    return T(e, r), e.prototype._getForwardRay = function (e) {\n      var t = this.getCamera();\n      return t ? t.getForwardRay(e) : new qs.Ray(qs.Vector3.Zero(), qs.Vector3.Forward());\n    }, e;\n  }(Js), ta = function () {\n    function e(e, t) {\n      void 0 === t && (t = {});\n      var r = this;\n\n      if (this.webVROptions = t, this._webVRsupported = !1, this._webVRready = !1, this._webVRrequesting = !1, this._webVRpresenting = !1, this._fullscreenVRpresenting = !1, this.onEnteringVRObservable = new qs.Observable(), this.onExitingVRObservable = new qs.Observable(), this.onControllerMeshLoadedObservable = new qs.Observable(), this._useCustomVRButton = !1, this._teleportationRequested = !1, this._teleportActive = !1, this._floorMeshesCollection = [], this._rotationAllowed = !0, this._teleportBackwardsVector = new qs.Vector3(0, -1, -1), this._isDefaultTeleportationTarget = !0, this._teleportationFillColor = \"#444444\", this._teleportationBorderColor = \"#FFFFFF\", this._rotationAngle = 0, this._haloCenter = new qs.Vector3(0, 0, 0), this._padSensibilityUp = .65, this._padSensibilityDown = .35, this._leftController = null, this._rightController = null, this.onNewMeshSelected = new qs.Observable(), this.onNewMeshPicked = new qs.Observable(), this.onBeforeCameraTeleport = new qs.Observable(), this.onAfterCameraTeleport = new qs.Observable(), this.onSelectedMeshUnselected = new qs.Observable(), this.teleportationEnabled = !0, this._teleportationInitialized = !1, this._interactionsEnabled = !1, this._interactionsRequested = !1, this._displayGaze = !0, this._displayLaserPointer = !0, this.updateGazeTrackerScale = !0, this._onResize = function () {\n        r.moveButtonToBottomRight(), r._fullscreenVRpresenting && r._webVRready && r.exitVR();\n      }, this._onFullscreenChange = function () {\n        void 0 !== document.fullscreen ? r._fullscreenVRpresenting = document.fullscreen : void 0 !== document.mozFullScreen ? r._fullscreenVRpresenting = document.mozFullScreen : void 0 !== document.webkitIsFullScreen ? r._fullscreenVRpresenting = document.webkitIsFullScreen : void 0 !== document.msIsFullScreen ? r._fullscreenVRpresenting = document.msIsFullScreen : void 0 !== document.msFullscreenElement && (r._fullscreenVRpresenting = document.msFullscreenElement), !r._fullscreenVRpresenting && r._canvas && (r.exitVR(), r._useCustomVRButton || (r._btnVR.style.top = r._canvas.offsetTop + r._canvas.offsetHeight - 70 + \"px\", r._btnVR.style.left = r._canvas.offsetLeft + r._canvas.offsetWidth - 100 + \"px\"));\n      }, this.beforeRender = function () {\n        r._leftController && r._leftController._activePointer && r._castRayAndSelectObject(r._leftController), r._rightController && r._rightController._activePointer && r._castRayAndSelectObject(r._rightController), r._noControllerIsActive ? r._castRayAndSelectObject(r._cameraGazer) : r._cameraGazer._gazeTracker.isVisible = !1;\n      }, this._onNewGamepadConnected = function (e) {\n        if (e.type !== qs.Gamepad.POSE_ENABLED) e.leftStick && e.onleftstickchanged(function (e) {\n          r._teleportationInitialized && r.teleportationEnabled && (!r._leftController && !r._rightController || r._leftController && !r._leftController._activePointer && r._rightController && !r._rightController._activePointer) && (r._checkTeleportWithRay(e, r._cameraGazer), r._checkTeleportBackwards(e, r._cameraGazer));\n        }), e.rightStick && e.onrightstickchanged(function (e) {\n          r._teleportationInitialized && r._checkRotate(e, r._cameraGazer);\n        }), e.type === qs.Gamepad.XBOX && (e.onbuttondown(function (e) {\n          r._interactionsEnabled && e === qs.Xbox360Button.A && r._cameraGazer._selectionPointerDown();\n        }), e.onbuttonup(function (e) {\n          r._interactionsEnabled && e === qs.Xbox360Button.A && r._cameraGazer._selectionPointerUp();\n        }));else {\n          var t = e,\n              i = new $s(t, r._scene, r._cameraGazer._gazeTracker);\n          \"right\" === t.hand || r._leftController && r._leftController.webVRController != t ? r._rightController = i : r._leftController = i, r._tryEnableInteractionOnController(i);\n        }\n      }, this._tryEnableInteractionOnController = function (e) {\n        r._interactionsRequested && !e._interactionsEnabled && r._enableInteractionOnController(e), r._teleportationRequested && !e._teleportationEnabled && r._enableTeleportationOnController(e);\n      }, this._onNewGamepadDisconnected = function (e) {\n        e instanceof qs.WebVRController && (\"left\" === e.hand && null != r._leftController && (r._leftController.dispose(), r._leftController = null), \"right\" === e.hand && null != r._rightController && (r._rightController.dispose(), r._rightController = null));\n      }, this._workingVector = qs.Vector3.Zero(), this._workingQuaternion = qs.Quaternion.Identity(), this._workingMatrix = qs.Matrix.Identity(), this._scene = e, this._canvas = e.getEngine().getRenderingCanvas(), void 0 === t.createFallbackVRDeviceOrientationFreeCamera && (t.createFallbackVRDeviceOrientationFreeCamera = !0), void 0 === t.createDeviceOrientationCamera && (t.createDeviceOrientationCamera = !0), void 0 === t.laserToggle && (t.laserToggle = !0), void 0 === t.defaultHeight && (t.defaultHeight = 1.7), t.useCustomVRButton && (this._useCustomVRButton = !0, t.customVRButton && (this._btnVR = t.customVRButton)), t.rayLength && (this._rayLength = t.rayLength), this._defaultHeight = t.defaultHeight, t.positionScale && (this._rayLength *= t.positionScale, this._defaultHeight *= t.positionScale), this._hasEnteredVR = !1, this._scene.activeCamera ? this._position = this._scene.activeCamera.position.clone() : this._position = new qs.Vector3(0, this._defaultHeight, 0), t.createDeviceOrientationCamera || !this._scene.activeCamera) {\n        if (this._deviceOrientationCamera = new qs.DeviceOrientationCamera(\"deviceOrientationVRHelper\", this._position.clone(), e), this._scene.activeCamera && (this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ, this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ, this._scene.activeCamera instanceof qs.TargetCamera && this._scene.activeCamera.rotation)) {\n          var i = this._scene.activeCamera;\n          i.rotationQuaternion ? this._deviceOrientationCamera.rotationQuaternion.copyFrom(i.rotationQuaternion) : this._deviceOrientationCamera.rotationQuaternion.copyFrom(qs.Quaternion.RotationYawPitchRoll(i.rotation.y, i.rotation.x, i.rotation.z)), this._deviceOrientationCamera.rotation = i.rotation.clone();\n        }\n\n        this._scene.activeCamera = this._deviceOrientationCamera, this._canvas && this._scene.activeCamera.attachControl(this._canvas);\n      } else this._existingCamera = this._scene.activeCamera;\n\n      if (t.createFallbackVRDeviceOrientationFreeCamera && (this._vrDeviceOrientationCamera = new qs.VRDeviceOrientationFreeCamera(\"VRDeviceOrientationVRHelper\", this._position, this._scene)), this._webVRCamera = new qs.WebVRFreeCamera(\"WebVRHelper\", this._position, this._scene, t), this._webVRCamera.useStandingMatrix(), this._cameraGazer = new ea(function () {\n        return r.currentVRCamera;\n      }, e), !this._useCustomVRButton) {\n        this._btnVR = document.createElement(\"BUTTON\"), this._btnVR.className = \"babylonVRicon\", this._btnVR.id = \"babylonVRiconbtn\", this._btnVR.title = \"Click to switch to VR\";\n        \".babylonVRicon.vrdisplaypresenting { display: none; }\";\n        var n = document.createElement(\"style\");\n        n.appendChild(document.createTextNode(\".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }.babylonVRicon.vrdisplaypresenting { display: none; }\")), document.getElementsByTagName(\"head\")[0].appendChild(n), this.moveButtonToBottomRight();\n      }\n\n      this._btnVR && this._btnVR.addEventListener(\"click\", function () {\n        r.isInVRMode ? r.exitVR() : r.enterVR();\n      }), window.addEventListener(\"resize\", this._onResize), document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, !1), document.addEventListener(\"mozfullscreenchange\", this._onFullscreenChange, !1), document.addEventListener(\"webkitfullscreenchange\", this._onFullscreenChange, !1), document.addEventListener(\"msfullscreenchange\", this._onFullscreenChange, !1), document.onmsfullscreenchange = this._onFullscreenChange, t.createFallbackVRDeviceOrientationFreeCamera ? this.displayVRButton() : this._scene.getEngine().onVRDisplayChangedObservable.add(function (e) {\n        e.vrDisplay && r.displayVRButton();\n      }), this._onKeyDown = function (e) {\n        27 === e.keyCode && r.isInVRMode && r.exitVR();\n      }, document.addEventListener(\"keydown\", this._onKeyDown), this._scene.onPrePointerObservable.add(function (e, t) {\n        r.isInVRMode && (r.exitVR(), r._fullscreenVRpresenting && r._scene.getEngine().switchFullscreen(!0));\n      }, qs.PointerEventTypes.POINTERDOUBLETAP, !1), this._onVRDisplayChanged = function (e) {\n        return r.onVRDisplayChanged(e);\n      }, this._onVrDisplayPresentChange = function () {\n        return r.onVrDisplayPresentChange();\n      }, this._onVRRequestPresentStart = function () {\n        r._webVRrequesting = !0, r.updateButtonVisibility();\n      }, this._onVRRequestPresentComplete = function (e) {\n        r._webVRrequesting = !1, r.updateButtonVisibility();\n      }, e.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChanged), e.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart), e.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete), window.addEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChange), e.onDisposeObservable.add(function () {\n        r.dispose();\n      }), this._webVRCamera.onControllerMeshLoadedObservable.add(function (e) {\n        return r._onDefaultMeshLoaded(e);\n      }), this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected), this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected), this.updateButtonVisibility(), this._circleEase = new qs.CircleEase(), this._circleEase.setEasingMode(qs.EasingFunction.EASINGMODE_EASEINOUT), this.webVROptions.floorMeshes && this.enableTeleportation({\n        floorMeshes: this.webVROptions.floorMeshes\n      });\n    }\n\n    return Object.defineProperty(e.prototype, \"onEnteringVR\", {\n      get: function () {\n        return this.onEnteringVRObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onExitingVR\", {\n      get: function () {\n        return this.onExitingVRObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onControllerMeshLoaded\", {\n      get: function () {\n        return this.onControllerMeshLoadedObservable;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"teleportationTarget\", {\n      get: function () {\n        return this._teleportationTarget;\n      },\n      set: function (e) {\n        e && (e.name = \"teleportationTarget\", this._isDefaultTeleportationTarget = !1, this._teleportationTarget = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"gazeTrackerMesh\", {\n      get: function () {\n        return this._cameraGazer._gazeTracker;\n      },\n      set: function (e) {\n        e && (this._cameraGazer._gazeTracker && this._cameraGazer._gazeTracker.dispose(), this._leftController && this._leftController._gazeTracker && this._leftController._gazeTracker.dispose(), this._rightController && this._rightController._gazeTracker && this._rightController._gazeTracker.dispose(), this._cameraGazer._gazeTracker = e, this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices(), this._cameraGazer._gazeTracker.isPickable = !1, this._cameraGazer._gazeTracker.isVisible = !1, this._cameraGazer._gazeTracker.name = \"gazeTracker\", this._leftController && (this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\")), this._rightController && (this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\")));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"leftControllerGazeTrackerMesh\", {\n      get: function () {\n        return this._leftController ? this._leftController._gazeTracker : null;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"rightControllerGazeTrackerMesh\", {\n      get: function () {\n        return this._rightController ? this._rightController._gazeTracker : null;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"displayGaze\", {\n      get: function () {\n        return this._displayGaze;\n      },\n      set: function (e) {\n        (this._displayGaze = e) || (this._cameraGazer._gazeTracker.isVisible = !1, this._leftController && (this._leftController._gazeTracker.isVisible = !1), this._rightController && (this._rightController._gazeTracker.isVisible = !1));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"displayLaserPointer\", {\n      get: function () {\n        return this._displayLaserPointer;\n      },\n      set: function (e) {\n        (this._displayLaserPointer = e) ? (this._rightController && this._rightController._activatePointer(), this._leftController && this._leftController._activatePointer()) : (this._rightController && (this._rightController._deactivatePointer(), this._rightController._gazeTracker.isVisible = !1), this._leftController && (this._leftController._deactivatePointer(), this._leftController._gazeTracker.isVisible = !1));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"deviceOrientationCamera\", {\n      get: function () {\n        return this._deviceOrientationCamera;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"currentVRCamera\", {\n      get: function () {\n        return this._webVRready ? this._webVRCamera : this._scene.activeCamera;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"webVRCamera\", {\n      get: function () {\n        return this._webVRCamera;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"vrDeviceOrientationCamera\", {\n      get: function () {\n        return this._vrDeviceOrientationCamera;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"_teleportationRequestInitiated\", {\n      get: function () {\n        return this._cameraGazer._teleportationRequestInitiated || null !== this._leftController && this._leftController._teleportationRequestInitiated || null !== this._rightController && this._rightController._teleportationRequestInitiated;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._onDefaultMeshLoaded = function (e) {\n      this._leftController && this._leftController.webVRController == e && e.mesh && this._leftController._setLaserPointerParent(e.mesh), this._rightController && this._rightController.webVRController == e && e.mesh && this._rightController._setLaserPointerParent(e.mesh);\n\n      try {\n        this.onControllerMeshLoadedObservable.notifyObservers(e);\n      } catch (e) {\n        qs.Tools.Warn(\"Error in your custom logic onControllerMeshLoaded: \" + e);\n      }\n    }, Object.defineProperty(e.prototype, \"isInVRMode\", {\n      get: function () {\n        return this._webVRpresenting || this._fullscreenVRpresenting;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.onVrDisplayPresentChange = function () {\n      var e = this._scene.getEngine().getVRDevice();\n\n      if (e) {\n        var t = this._webVRpresenting;\n        this._webVRpresenting = e.isPresenting, t && !this._webVRpresenting && this.exitVR();\n      } else qs.Tools.Warn(\"Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?\");\n\n      this.updateButtonVisibility();\n    }, e.prototype.onVRDisplayChanged = function (e) {\n      this._webVRsupported = e.vrSupported, this._webVRready = !!e.vrDisplay, this._webVRpresenting = e.vrDisplay && e.vrDisplay.isPresenting, this.updateButtonVisibility();\n    }, e.prototype.moveButtonToBottomRight = function () {\n      this._canvas && !this._useCustomVRButton && (this._btnVR.style.top = this._canvas.offsetTop + this._canvas.offsetHeight - 70 + \"px\", this._btnVR.style.left = this._canvas.offsetLeft + this._canvas.offsetWidth - 100 + \"px\");\n    }, e.prototype.displayVRButton = function () {\n      this._useCustomVRButton || this._btnVRDisplayed || (document.body.appendChild(this._btnVR), this._btnVRDisplayed = !0);\n    }, e.prototype.updateButtonVisibility = function () {\n      this._btnVR && !this._useCustomVRButton && (this._btnVR.className = \"babylonVRicon\", this.isInVRMode ? this._btnVR.className += \" vrdisplaypresenting\" : (this._webVRready && (this._btnVR.className += \" vrdisplayready\"), this._webVRsupported && (this._btnVR.className += \" vrdisplaysupported\"), this._webVRrequesting && (this._btnVR.className += \" vrdisplayrequesting\")));\n    }, e.prototype.enterVR = function () {\n      if (this.onEnteringVRObservable) try {\n        this.onEnteringVRObservable.notifyObservers(this);\n      } catch (e) {\n        qs.Tools.Warn(\"Error in your custom logic onEnteringVR: \" + e);\n      }\n      this._scene.activeCamera && (this._position = this._scene.activeCamera.position.clone(), this._existingCamera = this._scene.activeCamera), this._webVRrequesting || (this._webVRready ? this._webVRpresenting || (this._webVRCamera.position = this._position, this._scene.activeCamera = this._webVRCamera) : this._vrDeviceOrientationCamera && (this._vrDeviceOrientationCamera.position = this._position, this._scene.activeCamera && (this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ), this._scene.activeCamera = this._vrDeviceOrientationCamera, this._scene.getEngine().switchFullscreen(!0), this.updateButtonVisibility()), this._scene.activeCamera && this._canvas && this._scene.activeCamera.attachControl(this._canvas), this._interactionsEnabled && this._scene.registerBeforeRender(this.beforeRender), this._hasEnteredVR = !0);\n    }, e.prototype.exitVR = function () {\n      if (this._hasEnteredVR) {\n        if (this.onExitingVRObservable) try {\n          this.onExitingVRObservable.notifyObservers(this);\n        } catch (e) {\n          qs.Tools.Warn(\"Error in your custom logic onExitingVR: \" + e);\n        }\n        this._webVRpresenting && this._scene.getEngine().disableVR(), this._scene.activeCamera && (this._position = this._scene.activeCamera.position.clone()), this._deviceOrientationCamera ? (this._deviceOrientationCamera.position = this._position, this._scene.activeCamera = this._deviceOrientationCamera, this._canvas && this._scene.activeCamera.attachControl(this._canvas)) : this._existingCamera && (this._existingCamera.position = this._position, this._scene.activeCamera = this._existingCamera), this.updateButtonVisibility(), this._interactionsEnabled && (this._scene.unregisterBeforeRender(this.beforeRender), this._cameraGazer._gazeTracker.isVisible = !1, this._leftController && (this._leftController._gazeTracker.isVisible = !1), this._rightController && (this._rightController._gazeTracker.isVisible = !1)), this._scene.getEngine().resize(), this._hasEnteredVR = !1;\n      }\n    }, Object.defineProperty(e.prototype, \"position\", {\n      get: function () {\n        return this._position;\n      },\n      set: function (e) {\n        this._position = e, this._scene.activeCamera && (this._scene.activeCamera.position = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.enableInteractions = function () {\n      var t = this;\n      this._interactionsEnabled || (this._interactionsRequested = !0, this._leftController && this._enableInteractionOnController(this._leftController), this._rightController && this._enableInteractionOnController(this._rightController), this.raySelectionPredicate = function (e) {\n        return e.isVisible && (e.isPickable || e.name === t._floorMeshName);\n      }, this.meshSelectionPredicate = function (e) {\n        return !0;\n      }, this._raySelectionPredicate = function (e) {\n        return !!(t._isTeleportationFloor(e) || -1 === e.name.indexOf(\"gazeTracker\") && -1 === e.name.indexOf(\"teleportationTarget\") && -1 === e.name.indexOf(\"torusTeleportation\")) && t.raySelectionPredicate(e);\n      }, this._interactionsEnabled = !0);\n    }, Object.defineProperty(e.prototype, \"_noControllerIsActive\", {\n      get: function () {\n        return !(this._leftController && this._leftController._activePointer || this._rightController && this._rightController._activePointer);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._isTeleportationFloor = function (e) {\n      for (var t = 0; t < this._floorMeshesCollection.length; t++) if (this._floorMeshesCollection[t].id === e.id) return !0;\n\n      return !(!this._floorMeshName || e.name !== this._floorMeshName);\n    }, e.prototype.addFloorMesh = function (e) {\n      this._floorMeshesCollection && (-1 < this._floorMeshesCollection.indexOf(e) || this._floorMeshesCollection.push(e));\n    }, e.prototype.removeFloorMesh = function (e) {\n      if (this._floorMeshesCollection) {\n        var t = this._floorMeshesCollection.indexOf(e);\n\n        -1 !== t && this._floorMeshesCollection.splice(t, 1);\n      }\n    }, e.prototype.enableTeleportation = function (e) {\n      if (void 0 === e && (e = {}), !this._teleportationInitialized) {\n        this._teleportationRequested = !0, this.enableInteractions(), e.floorMeshName && (this._floorMeshName = e.floorMeshName), e.floorMeshes && (this._floorMeshesCollection = e.floorMeshes), null != this._leftController && this._enableTeleportationOnController(this._leftController), null != this._rightController && this._enableTeleportationOnController(this._rightController);\n        var t = new qs.ImageProcessingConfiguration();\n        t.vignetteColor = new qs.Color4(0, 0, 0, 0), t.vignetteEnabled = !0, this._postProcessMove = new qs.ImageProcessingPostProcess(\"postProcessMove\", 1, this._webVRCamera, void 0, void 0, void 0, void 0, t), this._webVRCamera.detachPostProcess(this._postProcessMove), this._teleportationInitialized = !0, this._isDefaultTeleportationTarget && (this._createTeleportationCircles(), this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor));\n      }\n    }, e.prototype._enableInteractionOnController = function (i) {\n      var r = this;\n      i.webVRController.mesh && (i._interactionsEnabled = !0, i._activatePointer(), this.webVROptions.laserToggle && i.webVRController.onMainButtonStateChangedObservable.add(function (e) {\n        r._displayLaserPointer && 1 === e.value && (i._activePointer ? i._deactivatePointer() : i._activatePointer(), r.displayGaze && (i._gazeTracker.isVisible = i._activePointer));\n      }), i.webVRController.onTriggerStateChangedObservable.add(function (e) {\n        var t = i;\n        r._noControllerIsActive && (t = r._cameraGazer), t._pointerDownOnMeshAsked ? e.value < r._padSensibilityDown && t._selectionPointerUp() : e.value > r._padSensibilityUp && t._selectionPointerDown();\n      }));\n    }, e.prototype._checkTeleportWithRay = function (e, t) {\n      this._teleportationRequestInitiated && !t._teleportationRequestInitiated || (t._teleportationRequestInitiated ? Math.sqrt(e.y * e.y + e.x * e.x) < this._padSensibilityDown && (this._teleportActive && this.teleportCamera(this._haloCenter), t._teleportationRequestInitiated = !1) : e.y < -this._padSensibilityUp && t._dpadPressed && (t._activatePointer(), t._teleportationRequestInitiated = !0));\n    }, e.prototype._checkRotate = function (e, t) {\n      t._teleportationRequestInitiated || (t._rotationLeftAsked ? e.x > -this._padSensibilityDown && (t._rotationLeftAsked = !1) : e.x < -this._padSensibilityUp && t._dpadPressed && (t._rotationLeftAsked = !0, this._rotationAllowed && this._rotateCamera(!1)), t._rotationRightAsked ? e.x < this._padSensibilityDown && (t._rotationRightAsked = !1) : e.x > this._padSensibilityUp && t._dpadPressed && (t._rotationRightAsked = !0, this._rotationAllowed && this._rotateCamera(!0)));\n    }, e.prototype._checkTeleportBackwards = function (e, t) {\n      if (!t._teleportationRequestInitiated) if (e.y > this._padSensibilityUp && t._dpadPressed) {\n        if (!t._teleportationBackRequestInitiated) {\n          if (!this.currentVRCamera) return;\n          var i = qs.Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix()),\n              r = this.currentVRCamera.position;\n          this.currentVRCamera.devicePosition && this.currentVRCamera.deviceRotationQuaternion && (i = this.currentVRCamera.deviceRotationQuaternion, r = this.currentVRCamera.devicePosition), i.toEulerAnglesToRef(this._workingVector), this._workingVector.z = 0, this._workingVector.x = 0, qs.Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion), this._workingQuaternion.toRotationMatrix(this._workingMatrix), qs.Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);\n\n          var n = new qs.Ray(r, this._workingVector),\n              o = this._scene.pickWithRay(n, this._raySelectionPredicate);\n\n          o && o.pickedPoint && o.pickedMesh && this._isTeleportationFloor(o.pickedMesh) && o.distance < 5 && this.teleportCamera(o.pickedPoint), t._teleportationBackRequestInitiated = !0;\n        }\n      } else t._teleportationBackRequestInitiated = !1;\n    }, e.prototype._enableTeleportationOnController = function (t) {\n      var i = this;\n      t.webVRController.mesh && (t._interactionsEnabled || this._enableInteractionOnController(t), t._interactionsEnabled = !0, t._teleportationEnabled = !0, t.webVRController.controllerType === qs.PoseEnabledControllerType.VIVE && (t._dpadPressed = !1, t.webVRController.onPadStateChangedObservable.add(function (e) {\n        t._dpadPressed = e.pressed, t._dpadPressed || (t._rotationLeftAsked = !1, t._rotationRightAsked = !1, t._teleportationBackRequestInitiated = !1);\n      })), t.webVRController.onPadValuesChangedObservable.add(function (e) {\n        i.teleportationEnabled && (i._checkTeleportBackwards(e, t), i._checkTeleportWithRay(e, t)), i._checkRotate(e, t);\n      }));\n    }, e.prototype._createTeleportationCircles = function () {\n      this._teleportationTarget = qs.Mesh.CreateGround(\"teleportationTarget\", 2, 2, 2, this._scene), this._teleportationTarget.isPickable = !1;\n      var e = new qs.DynamicTexture(\"DynamicTexture\", 512, this._scene, !0);\n      e.hasAlpha = !0;\n      var t = e.getContext();\n      t.beginPath(), t.arc(256, 256, 200, 0, 2 * Math.PI, !1), t.fillStyle = this._teleportationFillColor, t.fill(), t.lineWidth = 10, t.strokeStyle = this._teleportationBorderColor, t.stroke(), t.closePath(), e.update();\n      var i = new qs.StandardMaterial(\"TextPlaneMaterial\", this._scene);\n      i.diffuseTexture = e, this._teleportationTarget.material = i;\n      var r = qs.Mesh.CreateTorus(\"torusTeleportation\", .75, .1, 25, this._scene, !1);\n      r.isPickable = !1, r.parent = this._teleportationTarget;\n      var n = new qs.Animation(\"animationInnerCircle\", \"position.y\", 30, qs.Animation.ANIMATIONTYPE_FLOAT, qs.Animation.ANIMATIONLOOPMODE_CYCLE),\n          o = [];\n      o.push({\n        frame: 0,\n        value: 0\n      }), o.push({\n        frame: 30,\n        value: .4\n      }), o.push({\n        frame: 60,\n        value: 0\n      }), n.setKeys(o);\n      var s = new qs.SineEase();\n      s.setEasingMode(qs.EasingFunction.EASINGMODE_EASEINOUT), n.setEasingFunction(s), r.animations = [], r.animations.push(n), this._scene.beginAnimation(r, 0, 60, !0), this._hideTeleportationTarget();\n    }, e.prototype._displayTeleportationTarget = function () {\n      this._teleportActive = !0, this._teleportationInitialized && (this._teleportationTarget.isVisible = !0, this._isDefaultTeleportationTarget && (this._teleportationTarget.getChildren()[0].isVisible = !0));\n    }, e.prototype._hideTeleportationTarget = function () {\n      this._teleportActive = !1, this._teleportationInitialized && (this._teleportationTarget.isVisible = !1, this._isDefaultTeleportationTarget && (this._teleportationTarget.getChildren()[0].isVisible = !1));\n    }, e.prototype._rotateCamera = function (e) {\n      var t = this;\n\n      if (this.currentVRCamera instanceof qs.FreeCamera) {\n        e ? this._rotationAngle++ : this._rotationAngle--, this.currentVRCamera.animations = [];\n        var i = qs.Quaternion.FromRotationMatrix(qs.Matrix.RotationY(Math.PI / 4 * this._rotationAngle)),\n            r = new qs.Animation(\"animationRotation\", \"rotationQuaternion\", 90, qs.Animation.ANIMATIONTYPE_QUATERNION, qs.Animation.ANIMATIONLOOPMODE_CONSTANT),\n            n = [];\n        n.push({\n          frame: 0,\n          value: this.currentVRCamera.rotationQuaternion\n        }), n.push({\n          frame: 6,\n          value: i\n        }), r.setKeys(n), r.setEasingFunction(this._circleEase), this.currentVRCamera.animations.push(r), this._postProcessMove.animations = [];\n        var o = new qs.Animation(\"animationPP\", \"vignetteWeight\", 90, qs.Animation.ANIMATIONTYPE_FLOAT, qs.Animation.ANIMATIONLOOPMODE_CONSTANT),\n            s = [];\n        s.push({\n          frame: 0,\n          value: 0\n        }), s.push({\n          frame: 3,\n          value: 4\n        }), s.push({\n          frame: 6,\n          value: 0\n        }), o.setKeys(s), o.setEasingFunction(this._circleEase), this._postProcessMove.animations.push(o);\n        var a = new qs.Animation(\"animationPP2\", \"vignetteStretch\", 90, qs.Animation.ANIMATIONTYPE_FLOAT, qs.Animation.ANIMATIONLOOPMODE_CONSTANT),\n            l = [];\n        l.push({\n          frame: 0,\n          value: 0\n        }), l.push({\n          frame: 3,\n          value: 10\n        }), l.push({\n          frame: 6,\n          value: 0\n        }), a.setKeys(l), a.setEasingFunction(this._circleEase), this._postProcessMove.animations.push(a), this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0, this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0, this._postProcessMove.samples = 4, this._webVRCamera.attachPostProcess(this._postProcessMove), this._scene.beginAnimation(this._postProcessMove, 0, 6, !1, 1, function () {\n          t._webVRCamera.detachPostProcess(t._postProcessMove);\n        }), this._scene.beginAnimation(this.currentVRCamera, 0, 6, !1, 1);\n      }\n    }, e.prototype._moveTeleportationSelectorTo = function (e, t, i) {\n      if (e.pickedPoint) {\n        t._teleportationRequestInitiated && (this._displayTeleportationTarget(), this._haloCenter.copyFrom(e.pickedPoint), this._teleportationTarget.position.copyFrom(e.pickedPoint));\n\n        var r = this._convertNormalToDirectionOfRay(e.getNormal(!0, !1), i);\n\n        if (r) {\n          var n = qs.Vector3.Cross(qs.Axis.Y, r),\n              o = qs.Vector3.Cross(r, n);\n          qs.Vector3.RotationFromAxisToRef(o, r, n, this._teleportationTarget.rotation);\n        }\n\n        this._teleportationTarget.position.y += .1;\n      }\n    }, e.prototype.teleportCamera = function (e) {\n      var t = this;\n\n      if (this.currentVRCamera instanceof qs.FreeCamera) {\n        this.webVRCamera.leftCamera ? (this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition), this._workingVector.subtractInPlace(this.webVRCamera.position), e.subtractToRef(this._workingVector, this._workingVector)) : this._workingVector.copyFrom(e), this.isInVRMode ? this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor : this._workingVector.y += this._defaultHeight, this.onBeforeCameraTeleport.notifyObservers(this._workingVector), this.currentVRCamera.animations = [];\n        var i = new qs.Animation(\"animationCameraTeleportation\", \"position\", 90, qs.Animation.ANIMATIONTYPE_VECTOR3, qs.Animation.ANIMATIONLOOPMODE_CONSTANT),\n            r = [{\n          frame: 0,\n          value: this.currentVRCamera.position\n        }, {\n          frame: 11,\n          value: this._workingVector\n        }];\n        i.setKeys(r), i.setEasingFunction(this._circleEase), this.currentVRCamera.animations.push(i), this._postProcessMove.animations = [];\n        var n = new qs.Animation(\"animationPP\", \"vignetteWeight\", 90, qs.Animation.ANIMATIONTYPE_FLOAT, qs.Animation.ANIMATIONLOOPMODE_CONSTANT),\n            o = [];\n        o.push({\n          frame: 0,\n          value: 0\n        }), o.push({\n          frame: 5,\n          value: 8\n        }), o.push({\n          frame: 11,\n          value: 0\n        }), n.setKeys(o), this._postProcessMove.animations.push(n);\n        var s = new qs.Animation(\"animationPP2\", \"vignetteStretch\", 90, qs.Animation.ANIMATIONTYPE_FLOAT, qs.Animation.ANIMATIONLOOPMODE_CONSTANT),\n            a = [];\n        a.push({\n          frame: 0,\n          value: 0\n        }), a.push({\n          frame: 5,\n          value: 10\n        }), a.push({\n          frame: 11,\n          value: 0\n        }), s.setKeys(a), this._postProcessMove.animations.push(s), this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0, this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0, this._webVRCamera.attachPostProcess(this._postProcessMove), this._scene.beginAnimation(this._postProcessMove, 0, 11, !1, 1, function () {\n          t._webVRCamera.detachPostProcess(t._postProcessMove);\n        }), this._scene.beginAnimation(this.currentVRCamera, 0, 11, !1, 1, function () {\n          t.onAfterCameraTeleport.notifyObservers(t._workingVector);\n        }), this._hideTeleportationTarget();\n      }\n    }, e.prototype._convertNormalToDirectionOfRay = function (e, t) {\n      e && Math.acos(qs.Vector3.Dot(e, t.direction)) < Math.PI / 2 && e.scaleInPlace(-1);\n      return e;\n    }, e.prototype._castRayAndSelectObject = function (e) {\n      if (this.currentVRCamera instanceof qs.FreeCamera) {\n        var t = e._getForwardRay(this._rayLength),\n            i = this._scene.pickWithRay(t, this._raySelectionPredicate);\n\n        if (i && (e._laserPointer && (i.originMesh = e._laserPointer.parent), this._scene.simulatePointerMove(i, {\n          pointerId: e._id\n        })), (e._currentHit = i) && i.pickedPoint) {\n          if (this._displayGaze) {\n            var r = 1;\n            e._gazeTracker.isVisible = !0, e._isActionableMesh && (r = 3), this.updateGazeTrackerScale && (e._gazeTracker.scaling.x = i.distance * r, e._gazeTracker.scaling.y = i.distance * r, e._gazeTracker.scaling.z = i.distance * r);\n\n            var n = this._convertNormalToDirectionOfRay(i.getNormal(), t);\n\n            if (n) {\n              var o = qs.Vector3.Cross(qs.Axis.Y, n),\n                  s = qs.Vector3.Cross(n, o);\n              qs.Vector3.RotationFromAxisToRef(s, n, o, e._gazeTracker.rotation);\n            }\n\n            e._gazeTracker.position.copyFrom(i.pickedPoint), e._gazeTracker.position.x < 0 ? e._gazeTracker.position.x += .002 : e._gazeTracker.position.x -= .002, e._gazeTracker.position.y < 0 ? e._gazeTracker.position.y += .002 : e._gazeTracker.position.y -= .002, e._gazeTracker.position.z < 0 ? e._gazeTracker.position.z += .002 : e._gazeTracker.position.z -= .002;\n          }\n\n          e._updatePointerDistance(i.distance);\n        } else e._updatePointerDistance(), e._gazeTracker.isVisible = !1;\n\n        if (i && i.pickedMesh) {\n          if (this._teleportationInitialized && this._isTeleportationFloor(i.pickedMesh) && i.pickedPoint) return e._currentMeshSelected && !this._isTeleportationFloor(e._currentMeshSelected) && this._notifySelectedMeshUnselected(e._currentMeshSelected), e._currentMeshSelected = null, void (e._teleportationRequestInitiated && this._moveTeleportationSelectorTo(i, e, t));\n          if (i.pickedMesh !== e._currentMeshSelected) if (this.meshSelectionPredicate(i.pickedMesh)) {\n            this.onNewMeshPicked.notifyObservers(i), e._currentMeshSelected = i.pickedMesh, i.pickedMesh.isPickable && i.pickedMesh.actionManager ? (this.changeGazeColor(new qs.Color3(0, 0, 1)), this.changeLaserColor(new qs.Color3(.2, .2, 1)), e._isActionableMesh = !0) : (this.changeGazeColor(new qs.Color3(.7, .7, .7)), this.changeLaserColor(new qs.Color3(.7, .7, .7)), e._isActionableMesh = !1);\n\n            try {\n              this.onNewMeshSelected.notifyObservers(i.pickedMesh);\n            } catch (e) {\n              qs.Tools.Warn(\"Error in your custom logic onNewMeshSelected: \" + e);\n            }\n          } else this._notifySelectedMeshUnselected(e._currentMeshSelected), e._currentMeshSelected = null, this.changeGazeColor(new qs.Color3(.7, .7, .7)), this.changeLaserColor(new qs.Color3(.7, .7, .7));\n        } else this._notifySelectedMeshUnselected(e._currentMeshSelected), e._currentMeshSelected = null, this.changeGazeColor(new qs.Color3(.7, .7, .7)), this.changeLaserColor(new qs.Color3(.7, .7, .7));\n      }\n    }, e.prototype._notifySelectedMeshUnselected = function (e) {\n      e && this.onSelectedMeshUnselected.notifyObservers(e);\n    }, e.prototype.changeLaserColor = function (e) {\n      this._leftController && this._leftController._setLaserPointerColor(e), this._rightController && this._rightController._setLaserPointerColor(e);\n    }, e.prototype.changeGazeColor = function (e) {\n      this._cameraGazer._gazeTracker.material && (this._cameraGazer._gazeTracker.material.emissiveColor = e, this._leftController && (this._leftController._gazeTracker.material.emissiveColor = e), this._rightController && (this._rightController._gazeTracker.material.emissiveColor = e));\n    }, e.prototype.dispose = function () {\n      this.isInVRMode && this.exitVR(), this._postProcessMove && this._postProcessMove.dispose(), this._webVRCamera && this._webVRCamera.dispose(), this._vrDeviceOrientationCamera && this._vrDeviceOrientationCamera.dispose(), !this._useCustomVRButton && this._btnVR.parentNode && document.body.removeChild(this._btnVR), this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera && this._deviceOrientationCamera.dispose(), this._cameraGazer && this._cameraGazer.dispose(), this._leftController && this._leftController.dispose(), this._rightController && this._rightController.dispose(), this._teleportationTarget && this._teleportationTarget.dispose(), this._floorMeshesCollection = [], document.removeEventListener(\"keydown\", this._onKeyDown), window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChange), window.removeEventListener(\"resize\", this._onResize), document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange), document.removeEventListener(\"mozfullscreenchange\", this._onFullscreenChange), document.removeEventListener(\"webkitfullscreenchange\", this._onFullscreenChange), document.removeEventListener(\"msfullscreenchange\", this._onFullscreenChange), document.onmsfullscreenchange = null, this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChanged), this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart), this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete), window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChange), this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected), this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected), this._scene.unregisterBeforeRender(this.beforeRender);\n    }, e.prototype.getClassName = function () {\n      return \"VRExperienceHelper\";\n    }, e;\n  }(), qs.VRExperienceHelper = ta, function (n) {\n    var o, e;\n    (e = o = n.JoystickAxis || (n.JoystickAxis = {}))[e.X = 0] = \"X\", e[e.Y = 1] = \"Y\", e[e.Z = 2] = \"Z\";\n\n    var t = function () {\n      function r(e) {\n        var t = this;\n\n        if (this._leftJoystick = !!e, r._globalJoystickIndex++, this._axisTargetedByLeftAndRight = o.X, this._axisTargetedByUpAndDown = o.Y, this.reverseLeftRight = !1, this.reverseUpDown = !1, this._touches = new n.StringDictionary(), this.deltaPosition = n.Vector3.Zero(), this._joystickSensibility = 25, this._inversedSensibility = 1 / (this._joystickSensibility / 1e3), this._onResize = function (e) {\n          r.vjCanvasWidth = window.innerWidth, r.vjCanvasHeight = window.innerHeight, r.vjCanvas && (r.vjCanvas.width = r.vjCanvasWidth, r.vjCanvas.height = r.vjCanvasHeight), r.halfWidth = r.vjCanvasWidth / 2;\n        }, !r.vjCanvas) {\n          window.addEventListener(\"resize\", this._onResize, !1), r.vjCanvas = document.createElement(\"canvas\"), r.vjCanvasWidth = window.innerWidth, r.vjCanvasHeight = window.innerHeight, r.vjCanvas.width = window.innerWidth, r.vjCanvas.height = window.innerHeight, r.vjCanvas.style.width = \"100%\", r.vjCanvas.style.height = \"100%\", r.vjCanvas.style.position = \"absolute\", r.vjCanvas.style.backgroundColor = \"transparent\", r.vjCanvas.style.top = \"0px\", r.vjCanvas.style.left = \"0px\", r.vjCanvas.style.zIndex = \"5\", r.vjCanvas.style.msTouchAction = \"none\", r.vjCanvas.setAttribute(\"touch-action\", \"none\");\n          var i = r.vjCanvas.getContext(\"2d\");\n          if (!i) throw new Error(\"Unable to create canvas for virtual joystick\");\n          (r.vjCanvasContext = i).strokeStyle = \"#ffffff\", r.vjCanvasContext.lineWidth = 2, document.body.appendChild(r.vjCanvas);\n        }\n\n        r.halfWidth = r.vjCanvas.width / 2, this.pressed = !1, this._joystickColor = \"cyan\", this._joystickPointerID = -1, this._joystickPointerPos = new n.Vector2(0, 0), this._joystickPreviousPointerPos = new n.Vector2(0, 0), this._joystickPointerStartPos = new n.Vector2(0, 0), this._deltaJoystickVector = new n.Vector2(0, 0), this._onPointerDownHandlerRef = function (e) {\n          t._onPointerDown(e);\n        }, this._onPointerMoveHandlerRef = function (e) {\n          t._onPointerMove(e);\n        }, this._onPointerUpHandlerRef = function (e) {\n          t._onPointerUp(e);\n        }, r.vjCanvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, !1), r.vjCanvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, !1), r.vjCanvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, !1), r.vjCanvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, !1), r.vjCanvas.addEventListener(\"contextmenu\", function (e) {\n          e.preventDefault();\n        }, !1), requestAnimationFrame(function () {\n          t._drawVirtualJoystick();\n        });\n      }\n\n      return r.prototype.setJoystickSensibility = function (e) {\n        this._joystickSensibility = e, this._inversedSensibility = 1 / (this._joystickSensibility / 1e3);\n      }, r.prototype._onPointerDown = function (e) {\n        e.preventDefault(), (!0 === this._leftJoystick ? e.clientX < r.halfWidth : e.clientX > r.halfWidth) && this._joystickPointerID < 0 ? (this._joystickPointerID = e.pointerId, this._joystickPointerStartPos.x = e.clientX, this._joystickPointerStartPos.y = e.clientY, this._joystickPointerPos = this._joystickPointerStartPos.clone(), this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone(), this._deltaJoystickVector.x = 0, this._deltaJoystickVector.y = 0, this.pressed = !0, this._touches.add(e.pointerId.toString(), e)) : r._globalJoystickIndex < 2 && this._action && (this._action(), this._touches.add(e.pointerId.toString(), {\n          x: e.clientX,\n          y: e.clientY,\n          prevX: e.clientX,\n          prevY: e.clientY\n        }));\n      }, r.prototype._onPointerMove = function (e) {\n        if (this._joystickPointerID == e.pointerId) {\n          this._joystickPointerPos.x = e.clientX, this._joystickPointerPos.y = e.clientY, this._deltaJoystickVector = this._joystickPointerPos.clone(), this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\n          var t = (this.reverseLeftRight ? -1 : 1) * this._deltaJoystickVector.x / this._inversedSensibility;\n\n          switch (this._axisTargetedByLeftAndRight) {\n            case o.X:\n              this.deltaPosition.x = Math.min(1, Math.max(-1, t));\n              break;\n\n            case o.Y:\n              this.deltaPosition.y = Math.min(1, Math.max(-1, t));\n              break;\n\n            case o.Z:\n              this.deltaPosition.z = Math.min(1, Math.max(-1, t));\n          }\n\n          var i = (this.reverseUpDown ? 1 : -1) * this._deltaJoystickVector.y / this._inversedSensibility;\n\n          switch (this._axisTargetedByUpAndDown) {\n            case o.X:\n              this.deltaPosition.x = Math.min(1, Math.max(-1, i));\n              break;\n\n            case o.Y:\n              this.deltaPosition.y = Math.min(1, Math.max(-1, i));\n              break;\n\n            case o.Z:\n              this.deltaPosition.z = Math.min(1, Math.max(-1, i));\n          }\n        } else {\n          var r = this._touches.get(e.pointerId.toString());\n\n          r && (r.x = e.clientX, r.y = e.clientY);\n        }\n      }, r.prototype._onPointerUp = function (e) {\n        if (this._joystickPointerID == e.pointerId) r.vjCanvasContext.clearRect(this._joystickPointerStartPos.x - 64, this._joystickPointerStartPos.y - 64, 128, 128), r.vjCanvasContext.clearRect(this._joystickPreviousPointerPos.x - 42, this._joystickPreviousPointerPos.y - 42, 84, 84), this._joystickPointerID = -1, this.pressed = !1;else {\n          var t = this._touches.get(e.pointerId.toString());\n\n          t && r.vjCanvasContext.clearRect(t.prevX - 44, t.prevY - 44, 88, 88);\n        }\n        this._deltaJoystickVector.x = 0, this._deltaJoystickVector.y = 0, this._touches.remove(e.pointerId.toString());\n      }, r.prototype.setJoystickColor = function (e) {\n        this._joystickColor = e;\n      }, r.prototype.setActionOnTouch = function (e) {\n        this._action = e;\n      }, r.prototype.setAxisForLeftRight = function (e) {\n        switch (e) {\n          case o.X:\n          case o.Y:\n          case o.Z:\n            this._axisTargetedByLeftAndRight = e;\n            break;\n\n          default:\n            this._axisTargetedByLeftAndRight = o.X;\n        }\n      }, r.prototype.setAxisForUpDown = function (e) {\n        switch (e) {\n          case o.X:\n          case o.Y:\n          case o.Z:\n            this._axisTargetedByUpAndDown = e;\n            break;\n\n          default:\n            this._axisTargetedByUpAndDown = o.Y;\n        }\n      }, r.prototype._drawVirtualJoystick = function () {\n        var i = this;\n        this.pressed && this._touches.forEach(function (e, t) {\n          t.pointerId === i._joystickPointerID ? (r.vjCanvasContext.clearRect(i._joystickPointerStartPos.x - 64, i._joystickPointerStartPos.y - 64, 128, 128), r.vjCanvasContext.clearRect(i._joystickPreviousPointerPos.x - 42, i._joystickPreviousPointerPos.y - 42, 84, 84), r.vjCanvasContext.beginPath(), r.vjCanvasContext.lineWidth = 6, r.vjCanvasContext.strokeStyle = i._joystickColor, r.vjCanvasContext.arc(i._joystickPointerStartPos.x, i._joystickPointerStartPos.y, 40, 0, 2 * Math.PI, !0), r.vjCanvasContext.stroke(), r.vjCanvasContext.closePath(), r.vjCanvasContext.beginPath(), r.vjCanvasContext.strokeStyle = i._joystickColor, r.vjCanvasContext.lineWidth = 2, r.vjCanvasContext.arc(i._joystickPointerStartPos.x, i._joystickPointerStartPos.y, 60, 0, 2 * Math.PI, !0), r.vjCanvasContext.stroke(), r.vjCanvasContext.closePath(), r.vjCanvasContext.beginPath(), r.vjCanvasContext.strokeStyle = i._joystickColor, r.vjCanvasContext.arc(i._joystickPointerPos.x, i._joystickPointerPos.y, 40, 0, 2 * Math.PI, !0), r.vjCanvasContext.stroke(), r.vjCanvasContext.closePath(), i._joystickPreviousPointerPos = i._joystickPointerPos.clone()) : (r.vjCanvasContext.clearRect(t.prevX - 44, t.prevY - 44, 88, 88), r.vjCanvasContext.beginPath(), r.vjCanvasContext.fillStyle = \"white\", r.vjCanvasContext.beginPath(), r.vjCanvasContext.strokeStyle = \"red\", r.vjCanvasContext.lineWidth = 6, r.vjCanvasContext.arc(t.x, t.y, 40, 0, 2 * Math.PI, !0), r.vjCanvasContext.stroke(), r.vjCanvasContext.closePath(), t.prevX = t.x, t.prevY = t.y);\n        }), requestAnimationFrame(function () {\n          i._drawVirtualJoystick();\n        });\n      }, r.prototype.releaseCanvas = function () {\n        r.vjCanvas && (r.vjCanvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef), r.vjCanvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef), r.vjCanvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef), r.vjCanvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef), window.removeEventListener(\"resize\", this._onResize), document.body.removeChild(r.vjCanvas), r.vjCanvas = null);\n      }, r._globalJoystickIndex = 0, r;\n    }();\n\n    n.VirtualJoystick = t;\n  }($a || ($a = {})), function (i) {\n    i.Node.AddNodeConstructor(\"VirtualJoysticksCamera\", function (e, t) {\n      return function () {\n        return new r(e, i.Vector3.Zero(), t);\n      };\n    });\n\n    var r = function (n) {\n      function e(e, t, i) {\n        var r = n.call(this, e, t, i) || this;\n        return r.inputs.addVirtualJoystick(), r;\n      }\n\n      return T(e, n), e.prototype.getClassName = function () {\n        return \"VirtualJoysticksCamera\";\n      }, e;\n    }(i.FreeCamera);\n\n    i.VirtualJoysticksCamera = r;\n  }($a || ($a = {})), ia = $a || ($a = {}), ra = function () {\n    function e() {}\n\n    return e.prototype.getLeftJoystick = function () {\n      return this._leftjoystick;\n    }, e.prototype.getRightJoystick = function () {\n      return this._rightjoystick;\n    }, e.prototype.checkInputs = function () {\n      if (this._leftjoystick) {\n        var e = this.camera,\n            t = 50 * e._computeLocalCameraSpeed(),\n            i = ia.Matrix.RotationYawPitchRoll(e.rotation.y, e.rotation.x, 0),\n            r = ia.Vector3.TransformCoordinates(new ia.Vector3(this._leftjoystick.deltaPosition.x * t, this._leftjoystick.deltaPosition.y * t, this._leftjoystick.deltaPosition.z * t), i);\n\n        e.cameraDirection = e.cameraDirection.add(r), e.cameraRotation = e.cameraRotation.addVector3(this._rightjoystick.deltaPosition), this._leftjoystick.pressed || (this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(.9)), this._rightjoystick.pressed || (this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(.9));\n      }\n    }, e.prototype.attachControl = function (e, t) {\n      this._leftjoystick = new ia.VirtualJoystick(!0), this._leftjoystick.setAxisForUpDown(ia.JoystickAxis.Z), this._leftjoystick.setAxisForLeftRight(ia.JoystickAxis.X), this._leftjoystick.setJoystickSensibility(.15), this._rightjoystick = new ia.VirtualJoystick(!1), this._rightjoystick.setAxisForUpDown(ia.JoystickAxis.X), this._rightjoystick.setAxisForLeftRight(ia.JoystickAxis.Y), this._rightjoystick.reverseUpDown = !0, this._rightjoystick.setJoystickSensibility(.05), this._rightjoystick.setJoystickColor(\"yellow\");\n    }, e.prototype.detachControl = function (e) {\n      this._leftjoystick.releaseCanvas(), this._rightjoystick.releaseCanvas();\n    }, e.prototype.getClassName = function () {\n      return \"FreeCameraVirtualJoystickInput\";\n    }, e.prototype.getSimpleName = function () {\n      return \"virtualJoystick\";\n    }, e;\n  }(), ia.FreeCameraVirtualJoystickInput = ra, ia.CameraInputTypes.FreeCameraVirtualJoystickInput = ra, function (b) {\n    var e = function (e, t, i) {\n      this.quality = e, this.distance = t, this.optimizeMesh = i;\n    };\n\n    b.SimplificationSettings = e;\n\n    var t,\n        i,\n        r = function () {\n      function e() {\n        this.running = !1, this._simplificationArray = [];\n      }\n\n      return e.prototype.addTask = function (e) {\n        this._simplificationArray.push(e);\n      }, e.prototype.executeNext = function () {\n        var e = this._simplificationArray.pop();\n\n        e ? (this.running = !0, this.runSimplification(e)) : this.running = !1;\n      }, e.prototype.runSimplification = function (r) {\n        var i = this;\n        if (r.parallelProcessing) r.settings.forEach(function (t) {\n          i.getSimplifier(r).simplify(t, function (e) {\n            r.mesh.addLODLevel(t.distance, e), e.isVisible = !0, t.quality === r.settings[r.settings.length - 1].quality && r.successCallback && r.successCallback(), i.executeNext();\n          });\n        });else {\n          var n = this.getSimplifier(r);\n          b.AsyncLoop.Run(r.settings.length, function (e) {\n            var t, i;\n            t = r.settings[e.index], i = function () {\n              e.executeNext();\n            }, n.simplify(t, function (e) {\n              r.mesh.addLODLevel(t.distance, e), e.isVisible = !0, i();\n            });\n          }, function () {\n            r.successCallback && r.successCallback(), i.executeNext();\n          });\n        }\n      }, e.prototype.getSimplifier = function (e) {\n        switch (e.simplificationType) {\n          case t.QUADRATIC:\n          default:\n            return new o(e.mesh);\n        }\n      }, e;\n    }();\n\n    b.SimplificationQueue = r, (i = t = b.SimplificationType || (b.SimplificationType = {}))[i.QUADRATIC = 0] = \"QUADRATIC\";\n\n    var f = function (e) {\n      this.vertices = e, this.error = new Array(4), this.deleted = !1, this.isDirty = !1, this.deletePending = !1, this.borderFactor = 0;\n    },\n        s = function () {\n      function e(e, t) {\n        this.position = e, this.id = t, this.isBorder = !0, this.q = new n(), this.triangleCount = 0, this.triangleStart = 0, this.originalOffsets = [];\n      }\n\n      return e.prototype.updatePosition = function (e) {\n        this.position.copyFrom(e);\n      }, e;\n    }(),\n        n = function () {\n      function n(e) {\n        this.data = new Array(10);\n\n        for (var t = 0; t < 10; ++t) e && e[t] ? this.data[t] = e[t] : this.data[t] = 0;\n      }\n\n      return n.prototype.det = function (e, t, i, r, n, o, s, a, l) {\n        return this.data[e] * this.data[n] * this.data[l] + this.data[i] * this.data[r] * this.data[a] + this.data[t] * this.data[o] * this.data[s] - this.data[i] * this.data[n] * this.data[s] - this.data[e] * this.data[o] * this.data[a] - this.data[t] * this.data[r] * this.data[l];\n      }, n.prototype.addInPlace = function (e) {\n        for (var t = 0; t < 10; ++t) this.data[t] += e.data[t];\n      }, n.prototype.addArrayInPlace = function (e) {\n        for (var t = 0; t < 10; ++t) this.data[t] += e[t];\n      }, n.prototype.add = function (e) {\n        for (var t = new n(), i = 0; i < 10; ++i) t.data[i] = this.data[i] + e.data[i];\n\n        return t;\n      }, n.FromData = function (e, t, i, r) {\n        return new n(n.DataFromNumbers(e, t, i, r));\n      }, n.DataFromNumbers = function (e, t, i, r) {\n        return [e * e, e * t, e * i, e * r, t * t, t * i, t * r, i * i, i * r, r * r];\n      }, n;\n    }(),\n        l = function (e, t) {\n      this.vertexId = e, this.triangleId = t;\n    },\n        o = function () {\n      function e(e) {\n        this._mesh = e, this.syncIterations = 5e3, this.aggressiveness = 7, this.decimationIterations = 100, this.boundingBoxEpsilon = b.Epsilon;\n      }\n\n      return e.prototype.simplify = function (t, e) {\n        var i = this;\n        this.initDecimatedMesh(), b.AsyncLoop.Run(this._mesh.subMeshes.length, function (e) {\n          i.initWithMesh(e.index, function () {\n            i.runDecimation(t, e.index, function () {\n              e.executeNext();\n            });\n          }, t.optimizeMesh);\n        }, function () {\n          setTimeout(function () {\n            e(i._reconstructedMesh);\n          }, 0);\n        });\n      }, e.prototype.runDecimation = function (e, t, i) {\n        var v = this,\n            r = ~~(this.triangles.length * e.quality),\n            y = 0,\n            n = this.triangles.length;\n        b.AsyncLoop.Run(this.decimationIterations, function (e) {\n          var t, i;\n          n - y <= r ? e.breakLoop() : (t = e.index, i = function () {\n            e.executeNext();\n          }, setTimeout(function () {\n            t % 5 == 0 && v.updateMesh(0 === t);\n\n            for (var e = 0; e < v.triangles.length; ++e) v.triangles[e].isDirty = !1;\n\n            var g = 1e-9 * Math.pow(t + 3, v.aggressiveness);\n            b.AsyncLoop.SyncAsyncForLoop(v.triangles.length, v.syncIterations, function (e) {\n              var t = ~~((v.triangles.length / 2 + e) % v.triangles.length),\n                  i = v.triangles[t];\n              if (i && !(i.error[3] > g || i.deleted || i.isDirty)) for (var r = 0; r < 3; ++r) if (i.error[r] < g) {\n                var n = [],\n                    o = [],\n                    s = i.vertices[r],\n                    a = i.vertices[(r + 1) % 3];\n                if (s.isBorder || a.isBorder) continue;\n                var l = b.Vector3.Zero(),\n                    c = b.Vector3.Zero(),\n                    h = b.Vector2.Zero(),\n                    u = new b.Color4(0, 0, 0, 1);\n                v.calculateError(s, a, l, c, h, u);\n                var d = new Array();\n                if (v.isFlipped(s, a, l, n, i.borderFactor, d)) continue;\n                if (v.isFlipped(a, s, l, o, i.borderFactor, d)) continue;\n                if (n.indexOf(!0) < 0 || o.indexOf(!0) < 0) continue;\n                var f = new Array();\n                if (d.forEach(function (e) {\n                  -1 === f.indexOf(e) && (e.deletePending = !0, f.push(e));\n                }), f.length % 2 != 0) continue;\n                s.q = a.q.add(s.q), s.updatePosition(l);\n                var p = v.references.length;\n                y = v.updateTriangles(s, s, n, y), y = v.updateTriangles(s, a, o, y);\n\n                var _ = v.references.length - p;\n\n                if (_ <= s.triangleCount) {\n                  if (_) for (var m = 0; m < _; m++) v.references[s.triangleStart + m] = v.references[p + m];\n                } else s.triangleStart = p;\n\n                s.triangleCount = _;\n                break;\n              }\n            }, i, function () {\n              return n - y <= r;\n            });\n          }, 0));\n        }, function () {\n          setTimeout(function () {\n            v.reconstructMesh(t), i();\n          }, 0);\n        });\n      }, e.prototype.initWithMesh = function (e, t, n) {\n        var c = this;\n        this.vertices = [], this.triangles = [];\n\n        var o = this._mesh.getVerticesData(b.VertexBuffer.PositionKind),\n            h = this._mesh.getIndices(),\n            u = this._mesh.subMeshes[e],\n            d = [],\n            i = u.verticesCount;\n\n        b.AsyncLoop.SyncAsyncForLoop(i, this.syncIterations / 4 >> 0, function (e) {\n          if (o) {\n            var t = e + u.verticesStart,\n                i = b.Vector3.FromArray(o, 3 * t),\n                r = function (e) {\n              if (n) for (var t = 0; t < c.vertices.length; ++t) if (c.vertices[t].position.equals(e)) return c.vertices[t];\n              return null;\n            }(i) || new s(i, c.vertices.length);\n\n            r.originalOffsets.push(t), r.id === c.vertices.length && c.vertices.push(r), d.push(r.id);\n          }\n        }, function () {\n          b.AsyncLoop.SyncAsyncForLoop(u.indexCount / 3, c.syncIterations, function (e) {\n            if (h) {\n              var t = 3 * (u.indexStart / 3 + e),\n                  i = h[t + 0],\n                  r = h[t + 1],\n                  n = h[t + 2],\n                  o = c.vertices[d[i - u.verticesStart]],\n                  s = c.vertices[d[r - u.verticesStart]],\n                  a = c.vertices[d[n - u.verticesStart]],\n                  l = new f([o, s, a]);\n              l.originalOffset = t, c.triangles.push(l);\n            }\n          }, function () {\n            c.init(t);\n          });\n        });\n      }, e.prototype.init = function (e) {\n        var r = this;\n        b.AsyncLoop.SyncAsyncForLoop(this.triangles.length, this.syncIterations, function (e) {\n          var t = r.triangles[e];\n          t.normal = b.Vector3.Cross(t.vertices[1].position.subtract(t.vertices[0].position), t.vertices[2].position.subtract(t.vertices[0].position)).normalize();\n\n          for (var i = 0; i < 3; i++) t.vertices[i].q.addArrayInPlace(n.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -b.Vector3.Dot(t.normal, t.vertices[0].position)));\n        }, function () {\n          b.AsyncLoop.SyncAsyncForLoop(r.triangles.length, r.syncIterations, function (e) {\n            for (var t = r.triangles[e], i = 0; i < 3; ++i) t.error[i] = r.calculateError(t.vertices[i], t.vertices[(i + 1) % 3]);\n\n            t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n          }, function () {\n            e();\n          });\n        });\n      }, e.prototype.reconstructMesh = function (e) {\n        var t,\n            r,\n            i,\n            n = [];\n\n        for (t = 0; t < this.vertices.length; ++t) this.vertices[t].triangleCount = 0;\n\n        for (t = 0; t < this.triangles.length; ++t) if (!this.triangles[t].deleted) {\n          for (r = this.triangles[t], i = 0; i < 3; ++i) r.vertices[i].triangleCount = 1;\n\n          n.push(r);\n        }\n\n        var o = this._reconstructedMesh.getVerticesData(b.VertexBuffer.PositionKind) || [],\n            s = this._reconstructedMesh.getVerticesData(b.VertexBuffer.NormalKind) || [],\n            a = this._reconstructedMesh.getVerticesData(b.VertexBuffer.UVKind) || [],\n            l = this._reconstructedMesh.getVerticesData(b.VertexBuffer.ColorKind) || [],\n            c = this._mesh.getVerticesData(b.VertexBuffer.NormalKind),\n            h = this._mesh.getVerticesData(b.VertexBuffer.UVKind),\n            u = this._mesh.getVerticesData(b.VertexBuffer.ColorKind),\n            d = 0;\n\n        for (t = 0; t < this.vertices.length; ++t) {\n          var f = this.vertices[t];\n          f.id = d, f.triangleCount && f.originalOffsets.forEach(function (e) {\n            c && (o.push(f.position.x), o.push(f.position.y), o.push(f.position.z), s.push(c[3 * e]), s.push(c[3 * e + 1]), s.push(c[3 * e + 2]), h && h.length ? (a.push(h[2 * e]), a.push(h[2 * e + 1])) : u && u.length && (l.push(u[4 * e]), l.push(u[4 * e + 1]), l.push(u[4 * e + 2]), l.push(u[4 * e + 3])), ++d);\n          });\n        }\n\n        var p = this._reconstructedMesh.getTotalIndices(),\n            _ = this._reconstructedMesh.getTotalVertices(),\n            m = this._reconstructedMesh.subMeshes;\n\n        this._reconstructedMesh.subMeshes = [];\n\n        var g = this._reconstructedMesh.getIndices(),\n            v = this._mesh.getIndices();\n\n        for (t = 0; t < n.length; ++t) r = n[t], [0, 1, 2].forEach(function (e) {\n          var t = v[r.originalOffset + e],\n              i = r.vertices[e].originalOffsets.indexOf(t);\n          i < 0 && (i = 0), g.push(r.vertices[e].id + i + _);\n        });\n\n        this._reconstructedMesh.setIndices(g), this._reconstructedMesh.setVerticesData(b.VertexBuffer.PositionKind, o), this._reconstructedMesh.setVerticesData(b.VertexBuffer.NormalKind, s), 0 < a.length && this._reconstructedMesh.setVerticesData(b.VertexBuffer.UVKind, a), 0 < l.length && this._reconstructedMesh.setVerticesData(b.VertexBuffer.ColorKind, l);\n        var y = this._mesh.subMeshes[e];\n        0 < e && (this._reconstructedMesh.subMeshes = [], m.forEach(function (e) {\n          b.SubMesh.AddToMesh(e.materialIndex, e.verticesStart, e.verticesCount, e.indexStart, e.indexCount, e.getMesh());\n        }), b.SubMesh.AddToMesh(y.materialIndex, _, d, p, 3 * n.length, this._reconstructedMesh));\n      }, e.prototype.initDecimatedMesh = function () {\n        this._reconstructedMesh = new b.Mesh(this._mesh.name + \"Decimated\", this._mesh.getScene()), this._reconstructedMesh.material = this._mesh.material, this._reconstructedMesh.parent = this._mesh.parent, this._reconstructedMesh.isVisible = !1, this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;\n      }, e.prototype.isFlipped = function (e, t, i, r, n, o) {\n        for (var s = 0; s < e.triangleCount; ++s) {\n          var a = this.triangles[this.references[e.triangleStart + s].triangleId];\n\n          if (!a.deleted) {\n            var l = this.references[e.triangleStart + s].vertexId,\n                c = a.vertices[(l + 1) % 3],\n                h = a.vertices[(l + 2) % 3];\n\n            if (c !== t && h !== t) {\n              var u = c.position.subtract(i);\n              u = u.normalize();\n              var d = h.position.subtract(i);\n              if (d = d.normalize(), .999 < Math.abs(b.Vector3.Dot(u, d))) return !0;\n              var f = b.Vector3.Cross(u, d).normalize();\n              if (r[s] = !1, b.Vector3.Dot(f, a.normal) < .2) return !0;\n            } else r[s] = !0, o.push(a);\n          }\n        }\n\n        return !1;\n      }, e.prototype.updateTriangles = function (e, t, i, r) {\n        for (var n = r, o = 0; o < t.triangleCount; ++o) {\n          var s = this.references[t.triangleStart + o],\n              a = this.triangles[s.triangleId];\n          a.deleted || (i[o] && a.deletePending ? (a.deleted = !0, n++) : (a.vertices[s.vertexId] = e, a.isDirty = !0, a.error[0] = this.calculateError(a.vertices[0], a.vertices[1]) + a.borderFactor / 2, a.error[1] = this.calculateError(a.vertices[1], a.vertices[2]) + a.borderFactor / 2, a.error[2] = this.calculateError(a.vertices[2], a.vertices[0]) + a.borderFactor / 2, a.error[3] = Math.min(a.error[0], a.error[1], a.error[2]), this.references.push(s)));\n        }\n\n        return n;\n      }, e.prototype.identifyBorder = function () {\n        for (var e = 0; e < this.vertices.length; ++e) {\n          var t,\n              i = [],\n              r = [],\n              n = this.vertices[e];\n\n          for (t = 0; t < n.triangleCount; ++t) for (var o = this.triangles[this.references[n.triangleStart + t].triangleId], s = 0; s < 3; s++) {\n            for (var a = 0, l = o.vertices[s]; a < i.length && r[a] !== l.id;) ++a;\n\n            a === i.length ? (i.push(1), r.push(l.id)) : i[a]++;\n          }\n\n          for (t = 0; t < i.length; ++t) 1 === i[t] ? this.vertices[r[t]].isBorder = !0 : this.vertices[r[t]].isBorder = !1;\n        }\n      }, e.prototype.updateMesh = function (e) {\n        var t, i, r, n;\n\n        if (void 0 === e && (e = !1), !e) {\n          var o = [];\n\n          for (t = 0; t < this.triangles.length; ++t) this.triangles[t].deleted || o.push(this.triangles[t]);\n\n          this.triangles = o;\n        }\n\n        for (t = 0; t < this.vertices.length; ++t) this.vertices[t].triangleCount = 0, this.vertices[t].triangleStart = 0;\n\n        for (t = 0; t < this.triangles.length; ++t) for (i = this.triangles[t], r = 0; r < 3; ++r) (n = i.vertices[r]).triangleCount++;\n\n        var s = 0;\n\n        for (t = 0; t < this.vertices.length; ++t) this.vertices[t].triangleStart = s, s += this.vertices[t].triangleCount, this.vertices[t].triangleCount = 0;\n\n        var a = new Array(3 * this.triangles.length);\n\n        for (t = 0; t < this.triangles.length; ++t) for (i = this.triangles[t], r = 0; r < 3; ++r) a[(n = i.vertices[r]).triangleStart + n.triangleCount] = new l(r, t), n.triangleCount++;\n\n        this.references = a, e && this.identifyBorder();\n      }, e.prototype.vertexError = function (e, t) {\n        var i = t.x,\n            r = t.y,\n            n = t.z;\n        return e.data[0] * i * i + 2 * e.data[1] * i * r + 2 * e.data[2] * i * n + 2 * e.data[3] * i + e.data[4] * r * r + 2 * e.data[5] * r * n + 2 * e.data[6] * r + e.data[7] * n * n + 2 * e.data[8] * n + e.data[9];\n      }, e.prototype.calculateError = function (e, t, i, r, n, o) {\n        var s = e.q.add(t.q),\n            a = e.isBorder && t.isBorder,\n            l = 0,\n            c = s.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\n\n        if (0 === c || a) {\n          var h = e.position.add(t.position).divide(new b.Vector3(2, 2, 2)),\n              u = this.vertexError(s, e.position),\n              d = this.vertexError(s, t.position),\n              f = this.vertexError(s, h);\n          (l = Math.min(u, d, f)) === u ? i && i.copyFrom(e.position) : l === d ? i && i.copyFrom(t.position) : i && i.copyFrom(h);\n        } else i || (i = b.Vector3.Zero()), i.x = -1 / c * s.det(1, 2, 3, 4, 5, 6, 5, 7, 8), i.y = 1 / c * s.det(0, 2, 3, 1, 5, 6, 2, 7, 8), i.z = -1 / c * s.det(0, 1, 3, 1, 4, 6, 2, 5, 8), l = this.vertexError(s, i);\n\n        return l;\n      }, e;\n    }();\n  }($a || ($a = {})), function (n) {\n    Object.defineProperty(n.Scene.prototype, \"simplificationQueue\", {\n      get: function () {\n        if (!this._simplificationQueue) {\n          this._simplificationQueue = new n.SimplificationQueue();\n\n          var e = this._getComponent(n.SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE);\n\n          e || (e = new t(this), this._addComponent(e));\n        }\n\n        return this._simplificationQueue;\n      },\n      set: function (e) {\n        this._simplificationQueue = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.Mesh.prototype.simplify = function (e, t, i, r) {\n      return void 0 === t && (t = !0), void 0 === i && (i = n.SimplificationType.QUADRATIC), this.getScene().simplificationQueue.addTask({\n        settings: e,\n        parallelProcessing: t,\n        mesh: this,\n        simplificationType: i,\n        successCallback: r\n      }), this;\n    };\n\n    var t = function () {\n      function e(e) {\n        this.name = n.SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE, this.scene = e;\n      }\n\n      return e.prototype.register = function () {\n        this.scene._beforeCameraUpdateStage.registerStep(n.SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE, this, this._beforeCameraUpdate);\n      }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {}, e.prototype._beforeCameraUpdate = function () {\n        this.scene._simplificationQueue && !this.scene._simplificationQueue.running && this.scene._simplificationQueue.executeNext();\n      }, e;\n    }();\n\n    n.SimplicationQueueSceneComponent = t;\n  }($a || ($a = {})), na = function (e, t) {\n    this.distance = e, this.mesh = t;\n  }, ($a || ($a = {})).MeshLODLevel = na, function (d) {\n    var e = function () {\n      function e(e) {\n        void 0 === e && (e = 0), this.priority = e;\n      }\n\n      return e.prototype.getDescription = function () {\n        return \"\";\n      }, e.prototype.apply = function (e, t) {\n        return !0;\n      }, e;\n    }(),\n        n = function (n) {\n      function e(e, t, i) {\n        void 0 === e && (e = 0), void 0 === t && (t = 1024), void 0 === i && (i = .5);\n        var r = n.call(this, e) || this;\n        return r.priority = e, r.maximumSize = t, r.step = i, r;\n      }\n\n      return T(e, n), e.prototype.getDescription = function () {\n        return \"Reducing render target texture size to \" + this.maximumSize;\n      }, e.prototype.apply = function (e, t) {\n        for (var i = !0, r = 0; r < e.textures.length; r++) {\n          var n = e.textures[r];\n\n          if (n.canRescale && !n.getContext) {\n            var o = n.getSize();\n            Math.max(o.width, o.height) > this.maximumSize && (n.scale(this.step), i = !1);\n          }\n        }\n\n        return i;\n      }, e;\n    }(d.SceneOptimization = e);\n\n    d.TextureOptimization = n;\n\n    var o = function (n) {\n      function e(e, t, i) {\n        void 0 === e && (e = 0), void 0 === t && (t = 2), void 0 === i && (i = .25);\n        var r = n.call(this, e) || this;\n        return r.priority = e, r.maximumScale = t, r.step = i, r._currentScale = -1, r._directionOffset = 1, r;\n      }\n\n      return T(e, n), e.prototype.getDescription = function () {\n        return \"Setting hardware scaling level to \" + this._currentScale;\n      }, e.prototype.apply = function (e, t) {\n        return -1 === this._currentScale && (this._currentScale = e.getEngine().getHardwareScalingLevel(), this._currentScale > this.maximumScale && (this._directionOffset = -1)), this._currentScale += this._directionOffset * this.step, e.getEngine().setHardwareScalingLevel(this._currentScale), 1 === this._directionOffset ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n      }, e;\n    }(e);\n\n    d.HardwareScalingOptimization = o;\n\n    var s = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.getDescription = function () {\n        return \"Turning shadows on/off\";\n      }, t.prototype.apply = function (e, t) {\n        return e.shadowsEnabled = t.isInImprovementMode, !0;\n      }, t;\n    }(e);\n\n    d.ShadowsOptimization = s;\n\n    var a = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.getDescription = function () {\n        return \"Turning post-processes on/off\";\n      }, t.prototype.apply = function (e, t) {\n        return e.postProcessesEnabled = t.isInImprovementMode, !0;\n      }, t;\n    }(e);\n\n    d.PostProcessesOptimization = a;\n\n    var l = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.getDescription = function () {\n        return \"Turning lens flares on/off\";\n      }, t.prototype.apply = function (e, t) {\n        return e.lensFlaresEnabled = t.isInImprovementMode, !0;\n      }, t;\n    }(e);\n\n    d.LensFlaresOptimization = l;\n\n    var c = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.getDescription = function () {\n        return this.onGetDescription ? this.onGetDescription() : \"Running user defined callback\";\n      }, t.prototype.apply = function (e, t) {\n        return !this.onApply || this.onApply(e, t);\n      }, t;\n    }(e);\n\n    d.CustomOptimization = c;\n\n    var h = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.getDescription = function () {\n        return \"Turning particles on/off\";\n      }, t.prototype.apply = function (e, t) {\n        return e.particlesEnabled = t.isInImprovementMode, !0;\n      }, t;\n    }(e);\n\n    d.ParticlesOptimization = h;\n\n    var u = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      return T(t, e), t.prototype.getDescription = function () {\n        return \"Turning render targets off\";\n      }, t.prototype.apply = function (e, t) {\n        return e.renderTargetsEnabled = t.isInImprovementMode, !0;\n      }, t;\n    }(e);\n\n    d.RenderTargetsOptimization = u;\n\n    var f = function (t) {\n      function u() {\n        var e = null !== t && t.apply(this, arguments) || this;\n        return e._canBeMerged = function (e) {\n          if (!(e instanceof d.Mesh)) return !1;\n          var t = e;\n          return !t.isDisposed() && !(!t.isVisible || !t.isEnabled()) && !(0 < t.instances.length) && !t.skeleton && !t.hasLODLevels;\n        }, e;\n      }\n\n      return T(u, t), Object.defineProperty(u, \"UpdateSelectionTree\", {\n        get: function () {\n          return u._UpdateSelectionTree;\n        },\n        set: function (e) {\n          u._UpdateSelectionTree = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), u.prototype.getDescription = function () {\n        return \"Merging similar meshes together\";\n      }, u.prototype.apply = function (e, t, i) {\n        for (var r = e.meshes.slice(0), n = r.length, o = 0; o < n; o++) {\n          var s = new Array(),\n              a = r[o];\n\n          if (this._canBeMerged(a)) {\n            s.push(a);\n\n            for (var l = o + 1; l < n; l++) {\n              var c = r[l];\n              this._canBeMerged(c) && c.material === a.material && c.checkCollisions === a.checkCollisions && (s.push(c), n--, r.splice(l, 1), l--);\n            }\n\n            s.length < 2 || d.Mesh.MergeMeshes(s, void 0, !0);\n          }\n        }\n\n        var h = e;\n        return h.createOrUpdateSelectionOctree && (null != i ? i && h.createOrUpdateSelectionOctree() : u.UpdateSelectionTree && h.createOrUpdateSelectionOctree()), !0;\n      }, u._UpdateSelectionTree = !1, u;\n    }(e);\n\n    d.MergeMeshesOptimization = f;\n\n    var p = function () {\n      function r(e, t) {\n        void 0 === e && (e = 60), void 0 === t && (t = 2e3), this.targetFrameRate = e, this.trackerDuration = t, this.optimizations = new Array();\n      }\n\n      return r.prototype.addOptimization = function (e) {\n        return this.optimizations.push(e), this;\n      }, r.prototype.addCustomOptimization = function (e, t, i) {\n        void 0 === i && (i = 0);\n        var r = new c(i);\n        return r.onApply = e, r.onGetDescription = t, this.optimizations.push(r), this;\n      }, r.LowDegradationAllowed = function (e) {\n        var t = new r(e),\n            i = 0;\n        return t.addOptimization(new f(i)), t.addOptimization(new s(i)), t.addOptimization(new l(i)), i++, t.addOptimization(new a(i)), t.addOptimization(new h(i)), i++, t.addOptimization(new n(i, 1024)), t;\n      }, r.ModerateDegradationAllowed = function (e) {\n        var t = new r(e),\n            i = 0;\n        return t.addOptimization(new f(i)), t.addOptimization(new s(i)), t.addOptimization(new l(i)), i++, t.addOptimization(new a(i)), t.addOptimization(new h(i)), i++, t.addOptimization(new n(i, 512)), i++, t.addOptimization(new u(i)), i++, t.addOptimization(new o(i, 2)), t;\n      }, r.HighDegradationAllowed = function (e) {\n        var t = new r(e),\n            i = 0;\n        return t.addOptimization(new f(i)), t.addOptimization(new s(i)), t.addOptimization(new l(i)), i++, t.addOptimization(new a(i)), t.addOptimization(new h(i)), i++, t.addOptimization(new n(i, 256)), i++, t.addOptimization(new u(i)), i++, t.addOptimization(new o(i, 4)), t;\n      }, r;\n    }();\n\n    d.SceneOptimizerOptions = p;\n\n    var t = function () {\n      function o(e, t, i, r) {\n        void 0 === i && (i = !0), void 0 === r && (r = !1);\n        var n = this;\n        if (this._isRunning = !1, this._currentPriorityLevel = 0, this._targetFrameRate = 60, this._trackerDuration = 2e3, this._currentFrameRate = 0, this._improvementMode = !1, this.onSuccessObservable = new d.Observable(), this.onNewOptimizationAppliedObservable = new d.Observable(), this.onFailureObservable = new d.Observable(), this._options = t || new p(), this._options.targetFrameRate && (this._targetFrameRate = this._options.targetFrameRate), this._options.trackerDuration && (this._trackerDuration = this._options.trackerDuration), i) for (var o = 0, s = 0, a = this._options.optimizations; s < a.length; s++) {\n          a[s].priority = o++;\n        }\n        this._improvementMode = r, this._scene = e || d.Engine.LastCreatedScene, this._sceneDisposeObserver = this._scene.onDisposeObservable.add(function () {\n          n._sceneDisposeObserver = null, n.dispose();\n        });\n      }\n\n      return Object.defineProperty(o.prototype, \"isInImprovementMode\", {\n        get: function () {\n          return this._improvementMode;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(o.prototype, \"currentPriorityLevel\", {\n        get: function () {\n          return this._currentPriorityLevel;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(o.prototype, \"currentFrameRate\", {\n        get: function () {\n          return this._currentFrameRate;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(o.prototype, \"targetFrameRate\", {\n        get: function () {\n          return this._targetFrameRate;\n        },\n        set: function (e) {\n          this._targetFrameRate = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(o.prototype, \"trackerDuration\", {\n        get: function () {\n          return this._trackerDuration;\n        },\n        set: function (e) {\n          this._trackerDuration = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(o.prototype, \"optimizations\", {\n        get: function () {\n          return this._options.optimizations;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), o.prototype.stop = function () {\n        this._isRunning = !1;\n      }, o.prototype.reset = function () {\n        this._currentPriorityLevel = 0;\n      }, o.prototype.start = function () {\n        var e = this;\n        this._isRunning || (this._isRunning = !0, this._scene.executeWhenReady(function () {\n          setTimeout(function () {\n            e._checkCurrentState();\n          }, e._trackerDuration);\n        }));\n      }, o.prototype._checkCurrentState = function () {\n        var e = this;\n\n        if (this._isRunning) {\n          var t = this._scene,\n              i = this._options;\n          if (this._currentFrameRate = Math.round(t.getEngine().getFps()), this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) return this._isRunning = !1, void this.onSuccessObservable.notifyObservers(this);\n\n          for (var r = !0, n = !0, o = 0; o < i.optimizations.length; o++) {\n            var s = i.optimizations[o];\n            s.priority === this._currentPriorityLevel && (n = !1, r = r && s.apply(t, this), this.onNewOptimizationAppliedObservable.notifyObservers(s));\n          }\n\n          if (n) return this._isRunning = !1, void this.onFailureObservable.notifyObservers(this);\n          r && this._currentPriorityLevel++, t.executeWhenReady(function () {\n            setTimeout(function () {\n              e._checkCurrentState();\n            }, e._trackerDuration);\n          });\n        }\n      }, o.prototype.dispose = function () {\n        this.stop(), this.onSuccessObservable.clear(), this.onFailureObservable.clear(), this.onNewOptimizationAppliedObservable.clear(), this._sceneDisposeObserver && this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n      }, o.OptimizeAsync = function (e, t, i, r) {\n        var n = new o(e, t || p.ModerateDegradationAllowed(), !1);\n        return i && n.onSuccessObservable.add(function () {\n          i();\n        }), r && n.onFailureObservable.add(function () {\n          r();\n        }), n.start(), n;\n      }, o;\n    }();\n\n    d.SceneOptimizer = t;\n  }($a || ($a = {})), function (h) {\n    h.Scene.prototype.getOutlineRenderer = function () {\n      return this._outlineRenderer || (this._outlineRenderer = new e(this)), this._outlineRenderer;\n    }, Object.defineProperty(h.AbstractMesh.prototype, \"renderOutline\", {\n      get: function () {\n        return this._renderOutline;\n      },\n      set: function (e) {\n        e && this.getScene().getOutlineRenderer(), this._renderOutline = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(h.AbstractMesh.prototype, \"renderOverlay\", {\n      get: function () {\n        return this._renderOverlay;\n      },\n      set: function (e) {\n        e && this.getScene().getOutlineRenderer(), this._renderOverlay = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n\n    var e = function () {\n      function e(e) {\n        this.name = h.SceneComponentConstants.NAME_OUTLINERENDERER, this.zOffset = 1, this.scene = e, this._engine = e.getEngine(), this.scene._addComponent(this);\n      }\n\n      return e.prototype.register = function () {\n        this.scene._beforeRenderingMeshStage.registerStep(h.SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh), this.scene._afterRenderingMeshStage.registerStep(h.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n      }, e.prototype.rebuild = function () {}, e.prototype.dispose = function () {}, e.prototype.render = function (e, t, i) {\n        var r = this;\n        void 0 === i && (i = !1);\n\n        var n = this.scene,\n            o = n.getEngine(),\n            s = o.getCaps().instancedArrays && null !== t.visibleInstances[e._id] && void 0 !== t.visibleInstances[e._id];\n\n        if (this.isReady(e, s)) {\n          var a = e.getRenderingMesh(),\n              l = e.getMaterial();\n\n          if (l && n.activeCamera) {\n            if (o.enableEffect(this._effect), l.useLogarithmicDepth && this._effect.setFloat(\"logarithmicDepthConstant\", 2 / (Math.log(n.activeCamera.maxZ + 1) / Math.LN2)), this._effect.setFloat(\"offset\", i ? 0 : a.outlineWidth), this._effect.setColor4(\"color\", i ? a.overlayColor : a.outlineColor, i ? a.overlayAlpha : l.alpha), this._effect.setMatrix(\"viewProjection\", n.getTransformMatrix()), a.useBones && a.computeBonesUsingShaders && a.skeleton && this._effect.setMatrices(\"mBones\", a.skeleton.getTransformMatrices(a)), a._bind(e, this._effect, h.Material.TriangleFillMode), l && l.needAlphaTesting()) {\n              var c = l.getAlphaTestTexture();\n              c && (this._effect.setTexture(\"diffuseSampler\", c), this._effect.setMatrix(\"diffuseMatrix\", c.getTextureMatrix()));\n            }\n\n            o.setZOffset(-this.zOffset), a._processRendering(e, this._effect, h.Material.TriangleFillMode, t, s, function (e, t) {\n              r._effect.setMatrix(\"world\", t);\n            }), o.setZOffset(0);\n          }\n        }\n      }, e.prototype.isReady = function (e, t) {\n        var i = [],\n            r = [h.VertexBuffer.PositionKind, h.VertexBuffer.NormalKind],\n            n = e.getMesh(),\n            o = e.getMaterial();\n        o && (o.needAlphaTesting() && (i.push(\"#define ALPHATEST\"), n.isVerticesDataPresent(h.VertexBuffer.UVKind) && (r.push(h.VertexBuffer.UVKind), i.push(\"#define UV1\")), n.isVerticesDataPresent(h.VertexBuffer.UV2Kind) && (r.push(h.VertexBuffer.UV2Kind), i.push(\"#define UV2\"))), o.useLogarithmicDepth && i.push(\"#define LOGARITHMICDEPTH\")), n.useBones && n.computeBonesUsingShaders ? (r.push(h.VertexBuffer.MatricesIndicesKind), r.push(h.VertexBuffer.MatricesWeightsKind), 4 < n.numBoneInfluencers && (r.push(h.VertexBuffer.MatricesIndicesExtraKind), r.push(h.VertexBuffer.MatricesWeightsExtraKind)), i.push(\"#define NUM_BONE_INFLUENCERS \" + n.numBoneInfluencers), i.push(\"#define BonesPerMesh \" + (n.skeleton ? n.skeleton.bones.length + 1 : 0))) : i.push(\"#define NUM_BONE_INFLUENCERS 0\"), t && (i.push(\"#define INSTANCES\"), r.push(\"world0\"), r.push(\"world1\"), r.push(\"world2\"), r.push(\"world3\"));\n        var s = i.join(\"\\n\");\n        return this._cachedDefines !== s && (this._cachedDefines = s, this._effect = this.scene.getEngine().createEffect(\"outline\", r, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\"], [\"diffuseSampler\"], s)), this._effect.isReady();\n      }, e.prototype._beforeRenderingMesh = function (e, t, i) {\n        this._savedDepthWrite = this._engine.getDepthWrite(), e.renderOutline && (this._engine.setDepthWrite(!1), this.render(t, i), this._engine.setDepthWrite(this._savedDepthWrite));\n      }, e.prototype._afterRenderingMesh = function (e, t, i) {\n        if (e.renderOutline && this._savedDepthWrite && (this._engine.setDepthWrite(!0), this._engine.setColorWrite(!1), this.render(t, i), this._engine.setColorWrite(!0)), e.renderOverlay) {\n          var r = this._engine.getAlphaMode();\n\n          this._engine.setAlphaMode(h.Engine.ALPHA_COMBINE), this.render(t, i, !0), this._engine.setAlphaMode(r);\n        }\n      }, e;\n    }();\n\n    h.OutlineRenderer = e;\n  }($a || ($a = {})), function (y) {\n    y.AbstractMesh.prototype.disableEdgesRendering = function () {\n      return this._edgesRenderer && (this._edgesRenderer.dispose(), this._edgesRenderer = null), this;\n    }, y.AbstractMesh.prototype.enableEdgesRendering = function (e, t) {\n      return void 0 === e && (e = .95), void 0 === t && (t = !1), this.disableEdgesRendering(), this._edgesRenderer = new i(this, e, t), this;\n    }, Object.defineProperty(y.AbstractMesh.prototype, \"edgesRenderer\", {\n      get: function () {\n        return this._edgesRenderer;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), y.LinesMesh.prototype.enableEdgesRendering = function (e, t) {\n      return void 0 === e && (e = .95), void 0 === t && (t = !1), this.disableEdgesRendering(), this._edgesRenderer = new y.LineEdgesRenderer(this, e, t), this;\n    };\n\n    var b = function () {\n      this.edges = new Array(), this.edgesConnectedCount = 0;\n    },\n        i = function () {\n      function e(e, t, i, r) {\n        void 0 === t && (t = .95), void 0 === i && (i = !1), void 0 === r && (r = !0);\n        var n = this;\n        this.edgesWidthScalerForOrthographic = 1e3, this.edgesWidthScalerForPerspective = 50, this._linesPositions = new Array(), this._linesNormals = new Array(), this._linesIndices = new Array(), this._buffers = {}, this._checkVerticesInsteadOfIndices = !1, this.isEnabled = !0, this._source = e, this._checkVerticesInsteadOfIndices = i, this._epsilon = t, this._prepareRessources(), r && this._generateEdgesLines(), this._meshRebuildObserver = this._source.onRebuildObservable.add(function () {\n          n._rebuild();\n        }), this._meshDisposeObserver = this._source.onDisposeObservable.add(function () {\n          n.dispose();\n        });\n      }\n\n      return e.prototype._prepareRessources = function () {\n        this._lineShader || (this._lineShader = new y.ShaderMaterial(\"lineShader\", this._source.getScene(), \"line\", {\n          attributes: [\"position\", \"normal\"],\n          uniforms: [\"worldViewProjection\", \"color\", \"width\", \"aspectRatio\"]\n        }), this._lineShader.disableDepthWrite = !0, this._lineShader.backFaceCulling = !1);\n      }, e.prototype._rebuild = function () {\n        var e = this._buffers[y.VertexBuffer.PositionKind];\n        e && e._rebuild(), (e = this._buffers[y.VertexBuffer.NormalKind]) && e._rebuild();\n\n        var t = this._source.getScene().getEngine();\n\n        this._ib = t.createIndexBuffer(this._linesIndices);\n      }, e.prototype.dispose = function () {\n        this._source.onRebuildObservable.remove(this._meshRebuildObserver), this._source.onDisposeObservable.remove(this._meshDisposeObserver);\n        var e = this._buffers[y.VertexBuffer.PositionKind];\n        e && (e.dispose(), this._buffers[y.VertexBuffer.PositionKind] = null), (e = this._buffers[y.VertexBuffer.NormalKind]) && (e.dispose(), this._buffers[y.VertexBuffer.NormalKind] = null), this._source.getScene().getEngine()._releaseBuffer(this._ib), this._lineShader.dispose();\n      }, e.prototype._processEdgeForAdjacencies = function (e, t, i, r, n) {\n        return e === i && t === r || e === r && t === i ? 0 : e === r && t === n || e === n && t === r ? 1 : e === n && t === i || e === i && t === n ? 2 : -1;\n      }, e.prototype._processEdgeForAdjacenciesWithVertices = function (e, t, i, r, n) {\n        return e.equalsWithEpsilon(i) && t.equalsWithEpsilon(r) || e.equalsWithEpsilon(r) && t.equalsWithEpsilon(i) ? 0 : e.equalsWithEpsilon(r) && t.equalsWithEpsilon(n) || e.equalsWithEpsilon(n) && t.equalsWithEpsilon(r) ? 1 : e.equalsWithEpsilon(n) && t.equalsWithEpsilon(i) || e.equalsWithEpsilon(i) && t.equalsWithEpsilon(n) ? 2 : -1;\n      }, e.prototype._checkEdge = function (e, t, i, r, n) {\n        var o;\n        void 0 === t ? o = !0 : o = y.Vector3.Dot(i[e], i[t]) < this._epsilon;\n\n        if (o) {\n          var s = this._linesPositions.length / 3;\n          r.subtract(n).normalize(), this._linesPositions.push(r.x), this._linesPositions.push(r.y), this._linesPositions.push(r.z), this._linesPositions.push(r.x), this._linesPositions.push(r.y), this._linesPositions.push(r.z), this._linesPositions.push(n.x), this._linesPositions.push(n.y), this._linesPositions.push(n.z), this._linesPositions.push(n.x), this._linesPositions.push(n.y), this._linesPositions.push(n.z), this._linesNormals.push(n.x), this._linesNormals.push(n.y), this._linesNormals.push(n.z), this._linesNormals.push(-1), this._linesNormals.push(n.x), this._linesNormals.push(n.y), this._linesNormals.push(n.z), this._linesNormals.push(1), this._linesNormals.push(r.x), this._linesNormals.push(r.y), this._linesNormals.push(r.z), this._linesNormals.push(-1), this._linesNormals.push(r.x), this._linesNormals.push(r.y), this._linesNormals.push(r.z), this._linesNormals.push(1), this._linesIndices.push(s), this._linesIndices.push(s + 1), this._linesIndices.push(s + 2), this._linesIndices.push(s), this._linesIndices.push(s + 2), this._linesIndices.push(s + 3);\n        }\n      }, e.prototype._generateEdgesLines = function () {\n        var e = this._source.getVerticesData(y.VertexBuffer.PositionKind),\n            t = this._source.getIndices();\n\n        if (t && e) {\n          var i,\n              r,\n              n = new Array(),\n              o = new Array();\n\n          for (i = 0; i < t.length; i += 3) {\n            r = new b();\n            var s = t[i],\n                a = t[i + 1],\n                l = t[i + 2];\n            r.p0 = new y.Vector3(e[3 * s], e[3 * s + 1], e[3 * s + 2]), r.p1 = new y.Vector3(e[3 * a], e[3 * a + 1], e[3 * a + 2]), r.p2 = new y.Vector3(e[3 * l], e[3 * l + 1], e[3 * l + 2]);\n            var c = y.Vector3.Cross(r.p1.subtract(r.p0), r.p2.subtract(r.p1));\n            c.normalize(), o.push(c), n.push(r);\n          }\n\n          for (i = 0; i < n.length; i++) {\n            r = n[i];\n\n            for (var h = i + 1; h < n.length; h++) {\n              var u = n[h];\n              if (3 === r.edgesConnectedCount) break;\n              if (3 !== u.edgesConnectedCount) for (var d = t[3 * h], f = t[3 * h + 1], p = t[3 * h + 2], _ = 0; _ < 3; _++) {\n                var m = 0;\n\n                if (void 0 === r.edges[_]) {\n                  switch (_) {\n                    case 0:\n                      m = this._checkVerticesInsteadOfIndices ? this._processEdgeForAdjacenciesWithVertices(r.p0, r.p1, u.p0, u.p1, u.p2) : this._processEdgeForAdjacencies(t[3 * i], t[3 * i + 1], d, f, p);\n                      break;\n\n                    case 1:\n                      m = this._checkVerticesInsteadOfIndices ? this._processEdgeForAdjacenciesWithVertices(r.p1, r.p2, u.p0, u.p1, u.p2) : this._processEdgeForAdjacencies(t[3 * i + 1], t[3 * i + 2], d, f, p);\n                      break;\n\n                    case 2:\n                      m = this._checkVerticesInsteadOfIndices ? this._processEdgeForAdjacenciesWithVertices(r.p2, r.p0, u.p0, u.p1, u.p2) : this._processEdgeForAdjacencies(t[3 * i + 2], t[3 * i], d, f, p);\n                  }\n\n                  if (-1 !== m && (r.edges[_] = h, u.edges[m] = i, r.edgesConnectedCount++, u.edgesConnectedCount++, 3 === r.edgesConnectedCount)) break;\n                }\n              }\n            }\n          }\n\n          for (i = 0; i < n.length; i++) {\n            var g = n[i];\n            this._checkEdge(i, g.edges[0], o, g.p0, g.p1), this._checkEdge(i, g.edges[1], o, g.p1, g.p2), this._checkEdge(i, g.edges[2], o, g.p2, g.p0);\n          }\n\n          var v = this._source.getScene().getEngine();\n\n          this._buffers[y.VertexBuffer.PositionKind] = new y.VertexBuffer(v, this._linesPositions, y.VertexBuffer.PositionKind, !1), this._buffers[y.VertexBuffer.NormalKind] = new y.VertexBuffer(v, this._linesNormals, y.VertexBuffer.NormalKind, !1, !1, 4), this._ib = v.createIndexBuffer(this._linesIndices), this._indicesCount = this._linesIndices.length;\n        }\n      }, e.prototype.isReady = function () {\n        return this._lineShader.isReady();\n      }, e.prototype.render = function () {\n        var e = this._source.getScene();\n\n        if (this.isReady() && e.activeCamera) {\n          var t = e.getEngine();\n          this._lineShader._preBind(), 1 !== this._source.edgesColor.a ? t.setAlphaMode(y.Engine.ALPHA_COMBINE) : t.setAlphaMode(y.Engine.ALPHA_DISABLE), t.bindBuffers(this._buffers, this._ib, this._lineShader.getEffect()), e.resetCachedMaterial(), this._lineShader.setColor4(\"color\", this._source.edgesColor), e.activeCamera.mode === y.Camera.ORTHOGRAPHIC_CAMERA ? this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForOrthographic) : this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForPerspective), this._lineShader.setFloat(\"aspectRatio\", t.getAspectRatio(e.activeCamera)), this._lineShader.bind(this._source.getWorldMatrix()), t.drawElementsType(y.Material.TriangleFillMode, 0, this._indicesCount), this._lineShader.unbind();\n        }\n      }, e;\n    }();\n\n    y.EdgesRenderer = i;\n  }($a || ($a = {})), oa = $a || ($a = {}), sa = function () {\n    this.edges = new Array(), this.edgesConnectedCount = 0;\n  }, aa = function (n) {\n    function e(e, t, i) {\n      void 0 === t && (t = .95), void 0 === i && (i = !1);\n      var r = n.call(this, e, t, i, !1) || this;\n      return r._generateEdgesLines(), r;\n    }\n\n    return T(e, n), e.prototype._checkEdge = function (e, t, i, r, n) {\n      var o = this._linesPositions.length / 3;\n      r.subtract(n).normalize(), this._linesPositions.push(r.x), this._linesPositions.push(r.y), this._linesPositions.push(r.z), this._linesPositions.push(r.x), this._linesPositions.push(r.y), this._linesPositions.push(r.z), this._linesPositions.push(n.x), this._linesPositions.push(n.y), this._linesPositions.push(n.z), this._linesPositions.push(n.x), this._linesPositions.push(n.y), this._linesPositions.push(n.z), this._linesNormals.push(n.x), this._linesNormals.push(n.y), this._linesNormals.push(n.z), this._linesNormals.push(-1), this._linesNormals.push(n.x), this._linesNormals.push(n.y), this._linesNormals.push(n.z), this._linesNormals.push(1), this._linesNormals.push(r.x), this._linesNormals.push(r.y), this._linesNormals.push(r.z), this._linesNormals.push(-1), this._linesNormals.push(r.x), this._linesNormals.push(r.y), this._linesNormals.push(r.z), this._linesNormals.push(1), this._linesIndices.push(o), this._linesIndices.push(o + 1), this._linesIndices.push(o + 2), this._linesIndices.push(o), this._linesIndices.push(o + 2), this._linesIndices.push(o + 3);\n    }, e.prototype._generateEdgesLines = function () {\n      var e = this._source.getVerticesData(oa.VertexBuffer.PositionKind);\n\n      if (this._source.getIndices() && e) {\n        for (var t, i = new Array(), r = new Array(), n = 0; n < e.length / 3 - 1; n++) {\n          var o = new sa();\n          o.p0 = new oa.Vector3(e[3 * n], e[3 * n + 1], e[3 * n + 2]), o.p1 = new oa.Vector3(e[3 * (n + 1)], e[3 * (n + 1) + 1], e[3 * (n + 1) + 2]), i.push(o);\n        }\n\n        for (t = 0; t < i.length; t++) {\n          var s = i[t];\n\n          this._checkEdge(t, s.edges[0], r, s.p0, s.p1);\n        }\n\n        var a = this._source.getScene().getEngine();\n\n        this._buffers[oa.VertexBuffer.PositionKind] = new oa.VertexBuffer(a, this._linesPositions, oa.VertexBuffer.PositionKind, !1), this._buffers[oa.VertexBuffer.NormalKind] = new oa.VertexBuffer(a, this._linesNormals, oa.VertexBuffer.NormalKind, !1, !1, 4), this._ib = a.createIndexBuffer(this._linesIndices), this._indicesCount = this._linesIndices.length;\n      }\n    }, e;\n  }(oa.EdgesRenderer), oa.LineEdgesRenderer = aa, function (s) {\n    s.AbstractScene.AddParser(s.SceneComponentConstants.NAME_EFFECTLAYER, function (e, t, i, r) {\n      if (e.effectLayers) {\n        i.effectLayers || (i.effectLayers = new Array());\n\n        for (var n = 0; n < e.effectLayers.length; n++) {\n          var o = s.EffectLayer.Parse(e.effectLayers[n], t, r);\n          i.effectLayers.push(o);\n        }\n      }\n    }), s.AbstractScene.prototype.removeEffectLayer = function (e) {\n      var t = this.effectLayers.indexOf(e);\n      return -1 !== t && this.effectLayers.splice(t, 1), t;\n    }, s.AbstractScene.prototype.addEffectLayer = function (e) {\n      this.effectLayers.push(e);\n    };\n\n    var e = function () {\n      function e(e) {\n        this.name = s.SceneComponentConstants.NAME_EFFECTLAYER, this._renderEffects = !1, this._needStencil = !1, this._previousStencilState = !1, this.scene = e, this._engine = e.getEngine(), e.effectLayers = new Array();\n      }\n\n      return e.prototype.register = function () {\n        this.scene._isReadyForMeshStage.registerStep(s.SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh), this.scene._cameraDrawRenderTargetStage.registerStep(s.SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture), this.scene._beforeCameraDrawStage.registerStep(s.SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil), this.scene._afterRenderingGroupDrawStage.registerStep(s.SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup), this.scene._afterCameraDrawStage.registerStep(s.SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack), this.scene._afterCameraDrawStage.registerStep(s.SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\n      }, e.prototype.rebuild = function () {\n        for (var e = 0, t = this.scene.effectLayers; e < t.length; e++) {\n          t[e]._rebuild();\n        }\n      }, e.prototype.serialize = function (e) {\n        e.effectLayers = [];\n\n        for (var t = 0, i = this.scene.effectLayers; t < i.length; t++) {\n          var r = i[t];\n          r.serialize && e.effectLayers.push(r.serialize());\n        }\n      }, e.prototype.addFromContainer = function (e) {\n        var t = this;\n        e.effectLayers && e.effectLayers.forEach(function (e) {\n          t.scene.addEffectLayer(e);\n        });\n      }, e.prototype.removeFromContainer = function (e) {\n        var t = this;\n        e.effectLayers && e.effectLayers.forEach(function (e) {\n          t.scene.removeEffectLayer(e);\n        });\n      }, e.prototype.dispose = function () {\n        for (var e = this.scene.effectLayers; e.length;) e[0].dispose();\n      }, e.prototype._isReadyForMesh = function (e, t) {\n        for (var i = 0, r = this.scene.effectLayers; i < r.length; i++) {\n          var n = r[i];\n          if (n.hasMesh(e)) for (var o = 0, s = e.subMeshes; o < s.length; o++) {\n            var a = s[o];\n            if (!n.isReady(a, t)) return !1;\n          }\n        }\n\n        return !0;\n      }, e.prototype._renderMainTexture = function (e) {\n        this._renderEffects = !1, this._needStencil = !1;\n        var t = this.scene.effectLayers;\n\n        if (t && 0 < t.length) {\n          this._previousStencilState = this._engine.getStencilBuffer();\n\n          for (var i = 0, r = t; i < r.length; i++) {\n            var n = r[i];\n\n            if (n.shouldRender() && (!n.camera || n.camera.cameraRigMode === s.Camera.RIG_MODE_NONE && e === n.camera || n.camera.cameraRigMode !== s.Camera.RIG_MODE_NONE && -1 < n.camera._rigCameras.indexOf(e))) {\n              this._renderEffects = !0, this._needStencil = this._needStencil || n.needStencil();\n              var o = n._mainTexture;\n              o._shouldRender() && (this.scene.incrementRenderId(), o.render(!1, !1));\n            }\n          }\n\n          this.scene.incrementRenderId();\n        }\n      }, e.prototype._setStencil = function (e) {\n        this._needStencil && this._engine.setStencilBuffer(!0);\n      }, e.prototype._setStencilBack = function (e) {\n        this._needStencil && this._engine.setStencilBuffer(this._previousStencilState);\n      }, e.prototype._draw = function (e) {\n        if (this._renderEffects) {\n          this._engine.setDepthBuffer(!1);\n\n          for (var t = this.scene.effectLayers, i = 0; i < t.length; i++) {\n            var r = t[i];\n            r.renderingGroupId === e && r.shouldRender() && r.render();\n          }\n\n          this._engine.setDepthBuffer(!0);\n        }\n      }, e.prototype._drawCamera = function (e) {\n        this._renderEffects && this._draw(-1);\n      }, e.prototype._drawRenderingGroup = function (e) {\n        !this.scene._isInIntermediateRendering() && this._renderEffects && this._draw(e);\n      }, e;\n    }();\n\n    s.EffectLayerSceneComponent = e;\n  }($a || ($a = {}));\n\n  var la, ca, ha, ua, da, fa, pa, _a, ma, ga, va, ya, ba, Ta, Ea, xa, Pa, Aa, Sa, Ma, Ra, Ca, Oa, Da, Ia, wa, La, Fa, Ba;\n\n  ae = this && this.__assign || function () {\n    return (ae = Object.assign || function (e) {\n      for (var t, i = 1, r = arguments.length; i < r; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n      return e;\n    }).apply(this, arguments);\n  };\n\n  la = $a || ($a = {}), ca = function () {\n    function e(e, t) {\n      this._vertexBuffers = {}, this._maxSize = 0, this._mainTextureDesiredSize = {\n        width: 0,\n        height: 0\n      }, this._shouldRender = !0, this._postProcesses = [], this._textures = [], this._emissiveTextureAndColor = {\n        texture: null,\n        color: new la.Color4()\n      }, this.neutralColor = new la.Color4(), this.isEnabled = !0, this.onDisposeObservable = new la.Observable(), this.onBeforeRenderMainTextureObservable = new la.Observable(), this.onBeforeComposeObservable = new la.Observable(), this.onAfterComposeObservable = new la.Observable(), this.onSizeChangedObservable = new la.Observable(), this.name = e, this._scene = t || la.Engine.LastCreatedScene;\n\n      var i = this._scene._getComponent(la.SceneComponentConstants.NAME_EFFECTLAYER);\n\n      i || (i = new la.EffectLayerSceneComponent(this._scene), this._scene._addComponent(i)), this._engine = this._scene.getEngine(), this._maxSize = this._engine.getCaps().maxTextureSize, this._scene.effectLayers.push(this), this._generateIndexBuffer(), this._genrateVertexBuffer();\n    }\n\n    return Object.defineProperty(e.prototype, \"camera\", {\n      get: function () {\n        return this._effectLayerOptions.camera;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"renderingGroupId\", {\n      get: function () {\n        return this._effectLayerOptions.renderingGroupId;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._init = function (e) {\n      this._effectLayerOptions = ae({\n        mainTextureRatio: .5,\n        alphaBlendingMode: la.Engine.ALPHA_COMBINE,\n        camera: null,\n        renderingGroupId: -1\n      }, e), this._setMainTextureSize(), this._createMainTexture(), this._createTextureAndPostProcesses(), this._mergeEffect = this._createMergeEffect();\n    }, e.prototype._generateIndexBuffer = function () {\n      var e = [];\n      e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = this._engine.createIndexBuffer(e);\n    }, e.prototype._genrateVertexBuffer = function () {\n      var e = [];\n      e.push(1, 1), e.push(-1, 1), e.push(-1, -1), e.push(1, -1);\n      var t = new la.VertexBuffer(this._engine, e, la.VertexBuffer.PositionKind, !1, !1, 2);\n      this._vertexBuffers[la.VertexBuffer.PositionKind] = t;\n    }, e.prototype._setMainTextureSize = function () {\n      this._effectLayerOptions.mainTextureFixedSize ? (this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize, this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize) : (this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio, this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio, this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? la.Tools.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width, this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? la.Tools.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height), this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width), this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\n    }, e.prototype._createMainTexture = function () {\n      var s = this;\n      this._mainTexture = new la.RenderTargetTexture(\"HighlightLayerMainRTT\", {\n        width: this._mainTextureDesiredSize.width,\n        height: this._mainTextureDesiredSize.height\n      }, this._scene, !1, !0, la.Engine.TEXTURETYPE_UNSIGNED_INT), this._mainTexture.activeCamera = this._effectLayerOptions.camera, this._mainTexture.wrapU = la.Texture.CLAMP_ADDRESSMODE, this._mainTexture.wrapV = la.Texture.CLAMP_ADDRESSMODE, this._mainTexture.anisotropicFilteringLevel = 1, this._mainTexture.updateSamplingMode(la.Texture.BILINEAR_SAMPLINGMODE), this._mainTexture.renderParticles = !1, this._mainTexture.renderList = null, this._mainTexture.ignoreCameraViewport = !0, this._mainTexture.customRenderFunction = function (e, t, i, r) {\n        var n;\n        s.onBeforeRenderMainTextureObservable.notifyObservers(s);\n\n        var o = s._scene.getEngine();\n\n        if (r.length) {\n          for (o.setColorWrite(!1), n = 0; n < r.length; n++) s._renderSubMesh(r.data[n]);\n\n          o.setColorWrite(!0);\n        }\n\n        for (n = 0; n < e.length; n++) s._renderSubMesh(e.data[n]);\n\n        for (n = 0; n < t.length; n++) s._renderSubMesh(t.data[n]);\n\n        for (n = 0; n < i.length; n++) s._renderSubMesh(i.data[n]);\n      }, this._mainTexture.onClearObservable.add(function (e) {\n        e.clear(s.neutralColor, !0, !0, !0);\n      });\n    }, e.prototype._isReady = function (e, t, i) {\n      var r = e.getMaterial();\n      if (!r) return !1;\n      if (!r.isReady(e.getMesh(), t)) return !1;\n      var n = [],\n          o = [la.VertexBuffer.PositionKind],\n          s = e.getMesh(),\n          a = !1,\n          l = !1;\n\n      if (r && r.needAlphaTesting()) {\n        var c = r.getAlphaTestTexture();\n        c && (n.push(\"#define ALPHATEST\"), s.isVerticesDataPresent(la.VertexBuffer.UV2Kind) && 1 === c.coordinatesIndex ? (n.push(\"#define DIFFUSEUV2\"), l = !0) : s.isVerticesDataPresent(la.VertexBuffer.UVKind) && (n.push(\"#define DIFFUSEUV1\"), a = !0));\n      }\n\n      i && (n.push(\"#define EMISSIVE\"), s.isVerticesDataPresent(la.VertexBuffer.UV2Kind) && 1 === i.coordinatesIndex ? (n.push(\"#define EMISSIVEUV2\"), l = !0) : s.isVerticesDataPresent(la.VertexBuffer.UVKind) && (n.push(\"#define EMISSIVEUV1\"), a = !0)), a && (o.push(la.VertexBuffer.UVKind), n.push(\"#define UV1\")), l && (o.push(la.VertexBuffer.UV2Kind), n.push(\"#define UV2\")), s.useBones && s.computeBonesUsingShaders ? (o.push(la.VertexBuffer.MatricesIndicesKind), o.push(la.VertexBuffer.MatricesWeightsKind), 4 < s.numBoneInfluencers && (o.push(la.VertexBuffer.MatricesIndicesExtraKind), o.push(la.VertexBuffer.MatricesWeightsExtraKind)), n.push(\"#define NUM_BONE_INFLUENCERS \" + s.numBoneInfluencers), n.push(\"#define BonesPerMesh \" + (s.skeleton ? s.skeleton.bones.length + 1 : 0))) : n.push(\"#define NUM_BONE_INFLUENCERS 0\");\n      var h = s.morphTargetManager,\n          u = 0;\n      h && 0 < h.numInfluencers && (n.push(\"#define MORPHTARGETS\"), u = h.numInfluencers, n.push(\"#define NUM_MORPH_INFLUENCERS \" + u), la.MaterialHelper.PrepareAttributesForMorphTargets(o, s, {\n        NUM_MORPH_INFLUENCERS: u\n      })), t && (n.push(\"#define INSTANCES\"), o.push(\"world0\"), o.push(\"world1\"), o.push(\"world2\"), o.push(\"world3\"));\n      var d = n.join(\"\\n\");\n      return this._cachedDefines !== d && (this._cachedDefines = d, this._effectLayerMapGenerationEffect = this._scene.getEngine().createEffect(\"glowMapGeneration\", o, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"color\", \"emissiveMatrix\", \"morphTargetInfluences\"], [\"diffuseSampler\", \"emissiveSampler\"], d, void 0, void 0, void 0, {\n        maxSimultaneousMorphTargets: u\n      })), this._effectLayerMapGenerationEffect.isReady();\n    }, e.prototype.render = function () {\n      var e = this._mergeEffect;\n\n      if (e.isReady()) {\n        for (var t = 0; t < this._postProcesses.length; t++) if (!this._postProcesses[t].isReady()) return;\n\n        var i = this._scene.getEngine();\n\n        this.onBeforeComposeObservable.notifyObservers(this), i.enableEffect(e), i.setState(!1), i.bindBuffers(this._vertexBuffers, this._indexBuffer, e);\n        var r = i.getAlphaMode();\n        i.setAlphaMode(this._effectLayerOptions.alphaBlendingMode), this._internalRender(e), i.setAlphaMode(r), this.onAfterComposeObservable.notifyObservers(this);\n\n        var n = this._mainTexture.getSize();\n\n        this._setMainTextureSize(), n.width === this._mainTextureDesiredSize.width && n.height === this._mainTextureDesiredSize.height || (this.onSizeChangedObservable.notifyObservers(this), this._disposeTextureAndPostProcesses(), this._createMainTexture(), this._createTextureAndPostProcesses());\n      }\n    }, e.prototype.hasMesh = function (e) {\n      return -1 === this.renderingGroupId || e.renderingGroupId === this.renderingGroupId;\n    }, e.prototype.shouldRender = function () {\n      return this.isEnabled && this._shouldRender;\n    }, e.prototype._shouldRenderMesh = function (e) {\n      return !0;\n    }, e.prototype._shouldRenderEmissiveTextureForMesh = function (e) {\n      return !0;\n    }, e.prototype._renderSubMesh = function (e) {\n      var i = this;\n\n      if (this.shouldRender()) {\n        var t = e.getMaterial(),\n            r = e.getRenderingMesh(),\n            n = this._scene,\n            o = n.getEngine();\n\n        if (t && !t.needAlphaBlendingForMesh(r)) {\n          o.setState(t.backFaceCulling);\n\n          var s = r._getInstancesRenderList(e._id);\n\n          if (!s.mustReturn && this._shouldRenderMesh(r)) {\n            var a = o.getCaps().instancedArrays && null !== s.visibleInstances[e._id] && void 0 !== s.visibleInstances[e._id];\n\n            if (this._setEmissiveTextureAndColor(r, e, t), this._isReady(e, a, this._emissiveTextureAndColor.texture)) {\n              if (o.enableEffect(this._effectLayerMapGenerationEffect), r._bind(e, this._effectLayerMapGenerationEffect, la.Material.TriangleFillMode), this._effectLayerMapGenerationEffect.setMatrix(\"viewProjection\", n.getTransformMatrix()), this._effectLayerMapGenerationEffect.setFloat4(\"color\", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a), t && t.needAlphaTesting()) {\n                var l = t.getAlphaTestTexture();\n\n                if (l) {\n                  this._effectLayerMapGenerationEffect.setTexture(\"diffuseSampler\", l);\n\n                  var c = l.getTextureMatrix();\n                  c && this._effectLayerMapGenerationEffect.setMatrix(\"diffuseMatrix\", c);\n                }\n              }\n\n              this._emissiveTextureAndColor.texture && (this._effectLayerMapGenerationEffect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture), this._effectLayerMapGenerationEffect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix())), r.useBones && r.computeBonesUsingShaders && r.skeleton && this._effectLayerMapGenerationEffect.setMatrices(\"mBones\", r.skeleton.getTransformMatrices(r)), la.MaterialHelper.BindMorphTargetParameters(r, this._effectLayerMapGenerationEffect), r._processRendering(e, this._effectLayerMapGenerationEffect, la.Material.TriangleFillMode, s, a, function (e, t) {\n                return i._effectLayerMapGenerationEffect.setMatrix(\"world\", t);\n              });\n            } else this._mainTexture.resetRefreshCounter();\n          }\n        }\n      }\n    }, e.prototype._rebuild = function () {\n      var e = this._vertexBuffers[la.VertexBuffer.PositionKind];\n      e && e._rebuild(), this._generateIndexBuffer();\n    }, e.prototype._disposeTextureAndPostProcesses = function () {\n      this._mainTexture.dispose();\n\n      for (var e = 0; e < this._postProcesses.length; e++) this._postProcesses[e] && this._postProcesses[e].dispose();\n\n      this._postProcesses = [];\n\n      for (e = 0; e < this._textures.length; e++) this._textures[e] && this._textures[e].dispose();\n\n      this._textures = [];\n    }, e.prototype.dispose = function () {\n      var e = this._vertexBuffers[la.VertexBuffer.PositionKind];\n      e && (e.dispose(), this._vertexBuffers[la.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this._disposeTextureAndPostProcesses();\n\n      var t = this._scene.effectLayers.indexOf(this, 0);\n\n      -1 < t && this._scene.effectLayers.splice(t, 1), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onBeforeRenderMainTextureObservable.clear(), this.onBeforeComposeObservable.clear(), this.onAfterComposeObservable.clear(), this.onSizeChangedObservable.clear();\n    }, e.prototype.getClassName = function () {\n      return \"EffectLayer\";\n    }, e.Parse = function (e, t, i) {\n      return la.Tools.Instantiate(e.customType).Parse(e, t, i);\n    }, b([la.serialize()], e.prototype, \"name\", void 0), b([la.serializeAsColor4()], e.prototype, \"neutralColor\", void 0), b([la.serialize()], e.prototype, \"isEnabled\", void 0), b([la.serializeAsCameraReference()], e.prototype, \"camera\", null), b([la.serialize()], e.prototype, \"renderingGroupId\", null), e;\n  }(), la.EffectLayer = ca, function (h) {\n    h.AbstractScene.prototype.getHighlightLayerByName = function (e) {\n      for (var t = 0; t < this.effectLayers.length; t++) if (this.effectLayers[t].name === e && this.effectLayers[t].getEffectName() === i.EffectName) return this.effectLayers[t];\n\n      return null;\n    };\n\n    var n = function (c) {\n      function e(e, t, i, r, n, o, s, a) {\n        void 0 === o && (o = h.Texture.BILINEAR_SAMPLINGMODE);\n        var l = c.call(this, e, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, r, n, o, s, a) || this;\n        return l.direction = t, l.kernel = i, l.onApplyObservable.add(function (e) {\n          e.setFloat2(\"screenSize\", l.width, l.height), e.setVector2(\"direction\", l.direction), e.setFloat(\"blurWidth\", l.kernel);\n        }), l;\n      }\n\n      return T(e, c), e;\n    }(h.PostProcess),\n        i = function (s) {\n      function a(e, t, i) {\n        var r = s.call(this, e, t) || this;\n        return r.name = e, r.innerGlow = !0, r.outerGlow = !0, r.onBeforeBlurObservable = new h.Observable(), r.onAfterBlurObservable = new h.Observable(), r._instanceGlowingMeshStencilReference = a.GlowingMeshStencilReference++, r._meshes = {}, r._excludedMeshes = {}, r.neutralColor = a.NeutralColor, r._engine.isStencilEnable || h.Tools.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new BABYLON.Engine(canvas, antialias, { stencil: true }\"), r._options = ae({\n          mainTextureRatio: .5,\n          blurTextureSizeRatio: .5,\n          blurHorizontalSize: 1,\n          blurVerticalSize: 1,\n          alphaBlendingMode: h.Engine.ALPHA_COMBINE,\n          camera: null,\n          renderingGroupId: -1\n        }, i), r._init({\n          alphaBlendingMode: r._options.alphaBlendingMode,\n          camera: r._options.camera,\n          mainTextureFixedSize: r._options.mainTextureFixedSize,\n          mainTextureRatio: r._options.mainTextureRatio,\n          renderingGroupId: r._options.renderingGroupId\n        }), r._shouldRender = !1, r;\n      }\n\n      return T(a, s), Object.defineProperty(a.prototype, \"blurHorizontalSize\", {\n        get: function () {\n          return this._horizontalBlurPostprocess.kernel;\n        },\n        set: function (e) {\n          this._horizontalBlurPostprocess.kernel = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(a.prototype, \"blurVerticalSize\", {\n        get: function () {\n          return this._verticalBlurPostprocess.kernel;\n        },\n        set: function (e) {\n          this._verticalBlurPostprocess.kernel = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), a.prototype.getEffectName = function () {\n        return a.EffectName;\n      }, a.prototype._createMergeEffect = function () {\n        return this._engine.createEffect(\"glowMapMerge\", [h.VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : void 0);\n      }, a.prototype._createTextureAndPostProcesses = function () {\n        var t = this,\n            i = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio,\n            r = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\n        i = this._engine.needPOTTextures ? h.Tools.GetExponentOfTwo(i, this._maxSize) : i, r = this._engine.needPOTTextures ? h.Tools.GetExponentOfTwo(r, this._maxSize) : r;\n        var e = 0;\n        e = this._engine.getCaps().textureHalfFloatRender ? h.Engine.TEXTURETYPE_HALF_FLOAT : h.Engine.TEXTURETYPE_UNSIGNED_INT, this._blurTexture = new h.RenderTargetTexture(\"HighlightLayerBlurRTT\", {\n          width: i,\n          height: r\n        }, this._scene, !1, !0, e), this._blurTexture.wrapU = h.Texture.CLAMP_ADDRESSMODE, this._blurTexture.wrapV = h.Texture.CLAMP_ADDRESSMODE, this._blurTexture.anisotropicFilteringLevel = 16, this._blurTexture.updateSamplingMode(h.Texture.TRILINEAR_SAMPLINGMODE), this._blurTexture.renderParticles = !1, this._blurTexture.ignoreCameraViewport = !0, this._textures = [this._blurTexture], this._options.alphaBlendingMode === h.Engine.ALPHA_COMBINE ? (this._downSamplePostprocess = new h.PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio, null, h.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._downSamplePostprocess.onApplyObservable.add(function (e) {\n          e.setTexture(\"textureSampler\", t._mainTexture);\n        }), this._horizontalBlurPostprocess = new n(\"HighlightLayerHBP\", new h.Vector2(1, 0), this._options.blurHorizontalSize, 1, null, h.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._horizontalBlurPostprocess.onApplyObservable.add(function (e) {\n          e.setFloat2(\"screenSize\", i, r);\n        }), this._verticalBlurPostprocess = new n(\"HighlightLayerVBP\", new h.Vector2(0, 1), this._options.blurVerticalSize, 1, null, h.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine()), this._verticalBlurPostprocess.onApplyObservable.add(function (e) {\n          e.setFloat2(\"screenSize\", i, r);\n        }), this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess]) : (this._horizontalBlurPostprocess = new h.BlurPostProcess(\"HighlightLayerHBP\", new h.Vector2(1, 0), this._options.blurHorizontalSize / 2, {\n          width: i,\n          height: r\n        }, null, h.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, e), this._horizontalBlurPostprocess.width = i, this._horizontalBlurPostprocess.height = r, this._horizontalBlurPostprocess.onApplyObservable.add(function (e) {\n          e.setTexture(\"textureSampler\", t._mainTexture);\n        }), this._verticalBlurPostprocess = new h.BlurPostProcess(\"HighlightLayerVBP\", new h.Vector2(0, 1), this._options.blurVerticalSize / 2, {\n          width: i,\n          height: r\n        }, null, h.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, e), this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess]), this._mainTexture.onAfterUnbindObservable.add(function () {\n          t.onBeforeBlurObservable.notifyObservers(t);\n\n          var e = t._blurTexture.getInternalTexture();\n\n          e && t._scene.postProcessManager.directRender(t._postProcesses, e, !0), t.onAfterBlurObservable.notifyObservers(t);\n        }), this._postProcesses.map(function (e) {\n          e.autoClear = !1;\n        });\n      }, a.prototype.needStencil = function () {\n        return !0;\n      }, a.prototype.isReady = function (e, t) {\n        var i = e.getMaterial(),\n            r = e.getRenderingMesh();\n        if (!i || !r || !this._meshes) return !1;\n        var n = null,\n            o = this._meshes[r.uniqueId];\n        return o && o.glowEmissiveOnly && i && (n = i.emissiveTexture), s.prototype._isReady.call(this, e, t, n);\n      }, a.prototype._internalRender = function (e) {\n        e.setTexture(\"textureSampler\", this._blurTexture);\n        var t = this._engine,\n            i = t.getStencilBuffer(),\n            r = t.getStencilFunction(),\n            n = t.getStencilMask(),\n            o = t.getStencilOperationPass(),\n            s = t.getStencilOperationFail(),\n            a = t.getStencilOperationDepthFail(),\n            l = t.getStencilFunctionReference();\n        t.setStencilOperationPass(h.Engine.REPLACE), t.setStencilOperationFail(h.Engine.KEEP), t.setStencilOperationDepthFail(h.Engine.KEEP), t.setStencilMask(0), t.setStencilBuffer(!0), t.setStencilFunctionReference(this._instanceGlowingMeshStencilReference), this.outerGlow && (e.setFloat(\"offset\", 0), t.setStencilFunction(h.Engine.NOTEQUAL), t.drawElementsType(h.Material.TriangleFillMode, 0, 6)), this.innerGlow && (e.setFloat(\"offset\", 1), t.setStencilFunction(h.Engine.EQUAL), t.drawElementsType(h.Material.TriangleFillMode, 0, 6)), t.setStencilFunction(r), t.setStencilMask(n), t.setStencilBuffer(i), t.setStencilOperationPass(o), t.setStencilOperationFail(s), t.setStencilOperationDepthFail(a), t.setStencilFunctionReference(l);\n      }, a.prototype.shouldRender = function () {\n        return !!s.prototype.shouldRender.call(this) && !!this._meshes;\n      }, a.prototype._shouldRenderMesh = function (e) {\n        return (!this._excludedMeshes || !this._excludedMeshes[e.uniqueId]) && !!s.prototype.hasMesh.call(this, e);\n      }, a.prototype._setEmissiveTextureAndColor = function (e, t, i) {\n        var r = this._meshes[e.uniqueId];\n        r ? this._emissiveTextureAndColor.color.set(r.color.r, r.color.g, r.color.b, 1) : this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a), r && r.glowEmissiveOnly && i ? (this._emissiveTextureAndColor.texture = i.emissiveTexture, this._emissiveTextureAndColor.color.set(1, 1, 1, 1)) : this._emissiveTextureAndColor.texture = null;\n      }, a.prototype.addExcludedMesh = function (e) {\n        this._excludedMeshes && (this._excludedMeshes[e.uniqueId] || (this._excludedMeshes[e.uniqueId] = {\n          mesh: e,\n          beforeRender: e.onBeforeRenderObservable.add(function (e) {\n            e.getEngine().setStencilBuffer(!1);\n          }),\n          afterRender: e.onAfterRenderObservable.add(function (e) {\n            e.getEngine().setStencilBuffer(!0);\n          })\n        }));\n      }, a.prototype.removeExcludedMesh = function (e) {\n        if (this._excludedMeshes) {\n          var t = this._excludedMeshes[e.uniqueId];\n          t && (t.beforeRender && e.onBeforeRenderObservable.remove(t.beforeRender), t.afterRender && e.onAfterRenderObservable.remove(t.afterRender)), this._excludedMeshes[e.uniqueId] = null;\n        }\n      }, a.prototype.hasMesh = function (e) {\n        return !!this._meshes && !!s.prototype.hasMesh.call(this, e) && void 0 !== this._meshes[e.uniqueId] && null !== this._meshes[e.uniqueId];\n      }, a.prototype.addMesh = function (e, t, i) {\n        var r = this;\n\n        if (void 0 === i && (i = !1), this._meshes) {\n          var n = this._meshes[e.uniqueId];\n          n ? n.color = t : (this._meshes[e.uniqueId] = {\n            mesh: e,\n            color: t,\n            observerHighlight: e.onBeforeRenderObservable.add(function (e) {\n              r._excludedMeshes && r._excludedMeshes[e.uniqueId] ? r._defaultStencilReference(e) : e.getScene().getEngine().setStencilFunctionReference(r._instanceGlowingMeshStencilReference);\n            }),\n            observerDefault: e.onAfterRenderObservable.add(this._defaultStencilReference),\n            glowEmissiveOnly: i\n          }, e.onDisposeObservable.add(function () {\n            r._disposeMesh(e);\n          })), this._shouldRender = !0;\n        }\n      }, a.prototype.removeMesh = function (e) {\n        if (this._meshes) {\n          var t = this._meshes[e.uniqueId];\n\n          for (var i in t && (t.observerHighlight && e.onBeforeRenderObservable.remove(t.observerHighlight), t.observerDefault && e.onAfterRenderObservable.remove(t.observerDefault), delete this._meshes[e.uniqueId]), this._shouldRender = !1, this._meshes) if (this._meshes[i]) {\n            this._shouldRender = !0;\n            break;\n          }\n        }\n      }, a.prototype._defaultStencilReference = function (e) {\n        e.getScene().getEngine().setStencilFunctionReference(a.NormalMeshStencilReference);\n      }, a.prototype._disposeMesh = function (e) {\n        this.removeMesh(e), this.removeExcludedMesh(e);\n      }, a.prototype.dispose = function () {\n        if (this._meshes) {\n          for (var e in this._meshes) {\n            (t = this._meshes[e]) && t.mesh && (t.observerHighlight && t.mesh.onBeforeRenderObservable.remove(t.observerHighlight), t.observerDefault && t.mesh.onAfterRenderObservable.remove(t.observerDefault));\n          }\n\n          this._meshes = null;\n        }\n\n        if (this._excludedMeshes) {\n          for (var e in this._excludedMeshes) {\n            var t;\n            (t = this._excludedMeshes[e]) && (t.beforeRender && t.mesh.onBeforeRenderObservable.remove(t.beforeRender), t.afterRender && t.mesh.onAfterRenderObservable.remove(t.afterRender));\n          }\n\n          this._excludedMeshes = null;\n        }\n\n        s.prototype.dispose.call(this);\n      }, a.prototype.getClassName = function () {\n        return \"HighlightLayer\";\n      }, a.prototype.serialize = function () {\n        var e = h.SerializationHelper.Serialize(this);\n        if (e.customType = \"BABYLON.HighlightLayer\", e.meshes = [], this._meshes) for (var t in this._meshes) {\n          var i = this._meshes[t];\n          i && e.meshes.push({\n            glowEmissiveOnly: i.glowEmissiveOnly,\n            color: i.color.asArray(),\n            meshId: i.mesh.id\n          });\n        }\n        if (e.excludedMeshes = [], this._excludedMeshes) for (var r in this._excludedMeshes) {\n          var n = this._excludedMeshes[r];\n          n && e.excludedMeshes.push(n.mesh.id);\n        }\n        return e;\n      }, a.Parse = function (e, t, i) {\n        var r,\n            n = h.SerializationHelper.Parse(function () {\n          return new a(e.name, t, e.options);\n        }, e, t, i);\n\n        for (r = 0; r < e.excludedMeshes.length; r++) {\n          (o = t.getMeshByID(e.excludedMeshes[r])) && n.addExcludedMesh(o);\n        }\n\n        for (r = 0; r < e.meshes.length; r++) {\n          var o,\n              s = e.meshes[r];\n          (o = t.getMeshByID(s.meshId)) && n.addMesh(o, h.Color3.FromArray(s.color), s.glowEmissiveOnly);\n        }\n\n        return n;\n      }, a.EffectName = \"HighlightLayer\", a.NeutralColor = new h.Color4(0, 0, 0, 0), a.GlowingMeshStencilReference = 2, a.NormalMeshStencilReference = 1, b([h.serialize()], a.prototype, \"innerGlow\", void 0), b([h.serialize()], a.prototype, \"outerGlow\", void 0), b([h.serialize()], a.prototype, \"blurHorizontalSize\", null), b([h.serialize()], a.prototype, \"blurVerticalSize\", null), b([h.serialize(\"options\")], a.prototype, \"_options\", void 0), a;\n    }(h.EffectLayer);\n\n    h.HighlightLayer = i;\n  }($a || ($a = {})), function (a) {\n    a.AbstractScene.prototype.getGlowLayerByName = function (e) {\n      for (var t = 0; t < this.effectLayers.length; t++) if (this.effectLayers[t].name === e && this.effectLayers[t].getEffectName() === i.EffectName) return this.effectLayers[t];\n\n      return null;\n    };\n\n    var i = function (o) {\n      function s(e, t, i) {\n        var r = o.call(this, e, t) || this;\n        return r._intensity = 1, r._includedOnlyMeshes = [], r._excludedMeshes = [], r.neutralColor = new a.Color4(0, 0, 0, 1), r._options = ae({\n          mainTextureRatio: s.DefaultTextureRatio,\n          blurKernelSize: 32,\n          mainTextureFixedSize: void 0,\n          camera: null,\n          mainTextureSamples: 1,\n          renderingGroupId: -1\n        }, i), r._init({\n          alphaBlendingMode: a.Engine.ALPHA_ADD,\n          camera: r._options.camera,\n          mainTextureFixedSize: r._options.mainTextureFixedSize,\n          mainTextureRatio: r._options.mainTextureRatio,\n          renderingGroupId: r._options.renderingGroupId\n        }), r;\n      }\n\n      return T(s, o), Object.defineProperty(s.prototype, \"blurKernelSize\", {\n        get: function () {\n          return this._horizontalBlurPostprocess1.kernel;\n        },\n        set: function (e) {\n          this._horizontalBlurPostprocess1.kernel = e, this._verticalBlurPostprocess1.kernel = e, this._horizontalBlurPostprocess2.kernel = e, this._verticalBlurPostprocess2.kernel = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(s.prototype, \"intensity\", {\n        get: function () {\n          return this._intensity;\n        },\n        set: function (e) {\n          this._intensity = e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), s.prototype.getEffectName = function () {\n        return s.EffectName;\n      }, s.prototype._createMergeEffect = function () {\n        return this._engine.createEffect(\"glowMapMerge\", [a.VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], \"#define EMISSIVE \\n\");\n      }, s.prototype._createTextureAndPostProcesses = function () {\n        var t = this,\n            e = this._mainTextureDesiredSize.width,\n            i = this._mainTextureDesiredSize.height;\n        e = this._engine.needPOTTextures ? a.Tools.GetExponentOfTwo(e, this._maxSize) : e, i = this._engine.needPOTTextures ? a.Tools.GetExponentOfTwo(i, this._maxSize) : i;\n        var r = 0;\n        r = this._engine.getCaps().textureHalfFloatRender ? a.Engine.TEXTURETYPE_HALF_FLOAT : a.Engine.TEXTURETYPE_UNSIGNED_INT, this._blurTexture1 = new a.RenderTargetTexture(\"GlowLayerBlurRTT\", {\n          width: e,\n          height: i\n        }, this._scene, !1, !0, r), this._blurTexture1.wrapU = a.Texture.CLAMP_ADDRESSMODE, this._blurTexture1.wrapV = a.Texture.CLAMP_ADDRESSMODE, this._blurTexture1.updateSamplingMode(a.Texture.BILINEAR_SAMPLINGMODE), this._blurTexture1.renderParticles = !1, this._blurTexture1.ignoreCameraViewport = !0;\n        var n = Math.floor(e / 2),\n            o = Math.floor(i / 2);\n        this._blurTexture2 = new a.RenderTargetTexture(\"GlowLayerBlurRTT2\", {\n          width: n,\n          height: o\n        }, this._scene, !1, !0, r), this._blurTexture2.wrapU = a.Texture.CLAMP_ADDRESSMODE, this._blurTexture2.wrapV = a.Texture.CLAMP_ADDRESSMODE, this._blurTexture2.updateSamplingMode(a.Texture.BILINEAR_SAMPLINGMODE), this._blurTexture2.renderParticles = !1, this._blurTexture2.ignoreCameraViewport = !0, this._textures = [this._blurTexture1, this._blurTexture2], this._horizontalBlurPostprocess1 = new a.BlurPostProcess(\"GlowLayerHBP1\", new a.Vector2(1, 0), this._options.blurKernelSize / 2, {\n          width: e,\n          height: i\n        }, null, a.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, r), this._horizontalBlurPostprocess1.width = e, this._horizontalBlurPostprocess1.height = i, this._horizontalBlurPostprocess1.onApplyObservable.add(function (e) {\n          e.setTexture(\"textureSampler\", t._mainTexture);\n        }), this._verticalBlurPostprocess1 = new a.BlurPostProcess(\"GlowLayerVBP1\", new a.Vector2(0, 1), this._options.blurKernelSize / 2, {\n          width: e,\n          height: i\n        }, null, a.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, r), this._horizontalBlurPostprocess2 = new a.BlurPostProcess(\"GlowLayerHBP2\", new a.Vector2(1, 0), this._options.blurKernelSize / 2, {\n          width: n,\n          height: o\n        }, null, a.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, r), this._horizontalBlurPostprocess2.width = n, this._horizontalBlurPostprocess2.height = o, this._horizontalBlurPostprocess2.onApplyObservable.add(function (e) {\n          e.setTexture(\"textureSampler\", t._blurTexture1);\n        }), this._verticalBlurPostprocess2 = new a.BlurPostProcess(\"GlowLayerVBP2\", new a.Vector2(0, 1), this._options.blurKernelSize / 2, {\n          width: n,\n          height: o\n        }, null, a.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), !1, r), this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2], this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1], this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2], this._mainTexture.samples = this._options.mainTextureSamples, this._mainTexture.onAfterUnbindObservable.add(function () {\n          var e = t._blurTexture1.getInternalTexture();\n\n          e && (t._scene.postProcessManager.directRender(t._postProcesses1, e, !0), (e = t._blurTexture2.getInternalTexture()) && t._scene.postProcessManager.directRender(t._postProcesses2, e, !0));\n        }), this._postProcesses.map(function (e) {\n          e.autoClear = !1;\n        });\n      }, s.prototype.isReady = function (e, t) {\n        var i = e.getMaterial(),\n            r = e.getRenderingMesh();\n        if (!i || !r) return !1;\n        var n = i.emissiveTexture;\n        return o.prototype._isReady.call(this, e, t, n);\n      }, s.prototype.needStencil = function () {\n        return !1;\n      }, s.prototype._internalRender = function (e) {\n        e.setTexture(\"textureSampler\", this._blurTexture1), e.setTexture(\"textureSampler2\", this._blurTexture2), e.setFloat(\"offset\", this._intensity);\n        var t = this._engine,\n            i = t.getStencilBuffer();\n        t.setStencilBuffer(!1), t.drawElementsType(a.Material.TriangleFillMode, 0, 6), t.setStencilBuffer(i);\n      }, s.prototype._setEmissiveTextureAndColor = function (e, t, i) {\n        var r = 1;\n        this.customEmissiveTextureSelector ? this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(e, t, i) : i ? (this._emissiveTextureAndColor.texture = i.emissiveTexture, this._emissiveTextureAndColor.texture && (r = this._emissiveTextureAndColor.texture.level)) : this._emissiveTextureAndColor.texture = null, this.customEmissiveColorSelector ? this.customEmissiveColorSelector(e, t, i, this._emissiveTextureAndColor.color) : i.emissiveColor ? this._emissiveTextureAndColor.color.set(i.emissiveColor.r * r, i.emissiveColor.g * r, i.emissiveColor.b * r, 1) : this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n      }, s.prototype._shouldRenderMesh = function (e) {\n        return this.hasMesh(e);\n      }, s.prototype.addExcludedMesh = function (e) {\n        -1 === this._excludedMeshes.indexOf(e.uniqueId) && this._excludedMeshes.push(e.uniqueId);\n      }, s.prototype.removeExcludedMesh = function (e) {\n        var t = this._excludedMeshes.indexOf(e.uniqueId);\n\n        -1 !== t && this._excludedMeshes.splice(t, 1);\n      }, s.prototype.addIncludedOnlyMesh = function (e) {\n        -1 === this._includedOnlyMeshes.indexOf(e.uniqueId) && this._includedOnlyMeshes.push(e.uniqueId);\n      }, s.prototype.removeIncludedOnlyMesh = function (e) {\n        var t = this._includedOnlyMeshes.indexOf(e.uniqueId);\n\n        -1 !== t && this._includedOnlyMeshes.splice(t, 1);\n      }, s.prototype.hasMesh = function (e) {\n        return !!o.prototype.hasMesh.call(this, e) && (this._includedOnlyMeshes.length ? -1 !== this._includedOnlyMeshes.indexOf(e.uniqueId) : !this._excludedMeshes.length || -1 === this._excludedMeshes.indexOf(e.uniqueId));\n      }, s.prototype._disposeMesh = function (e) {\n        this.removeIncludedOnlyMesh(e), this.removeExcludedMesh(e);\n      }, s.prototype.getClassName = function () {\n        return \"GlowLayer\";\n      }, s.prototype.serialize = function () {\n        var e,\n            t = a.SerializationHelper.Serialize(this);\n        if (t.customType = \"BABYLON.GlowLayer\", t.includedMeshes = [], this._includedOnlyMeshes.length) for (e = 0; e < this._includedOnlyMeshes.length; e++) {\n          (i = this._scene.getMeshByUniqueID(this._includedOnlyMeshes[e])) && t.includedMeshes.push(i.id);\n        }\n        if (t.excludedMeshes = [], this._excludedMeshes.length) for (e = 0; e < this._excludedMeshes.length; e++) {\n          var i;\n          (i = this._scene.getMeshByUniqueID(this._excludedMeshes[e])) && t.excludedMeshes.push(i.id);\n        }\n        return t;\n      }, s.Parse = function (e, t, i) {\n        var r,\n            n = a.SerializationHelper.Parse(function () {\n          return new s(e.name, t, e.options);\n        }, e, t, i);\n\n        for (r = 0; r < e.excludedMeshes.length; r++) {\n          (o = t.getMeshByID(e.excludedMeshes[r])) && n.addExcludedMesh(o);\n        }\n\n        for (r = 0; r < e.includedMeshes.length; r++) {\n          var o;\n          (o = t.getMeshByID(e.includedMeshes[r])) && n.addIncludedOnlyMesh(o);\n        }\n\n        return n;\n      }, s.EffectName = \"GlowLayer\", s.DefaultBlurKernelSize = 32, s.DefaultTextureRatio = .5, b([a.serialize()], s.prototype, \"blurKernelSize\", null), b([a.serialize()], s.prototype, \"intensity\", null), b([a.serialize(\"options\")], s.prototype, \"_options\", void 0), s;\n    }(a.EffectLayer);\n\n    a.GlowLayer = i;\n  }($a || ($a = {})), function (a) {\n    var o, e;\n    (e = o = a.AssetTaskState || (a.AssetTaskState = {}))[e.INIT = 0] = \"INIT\", e[e.RUNNING = 1] = \"RUNNING\", e[e.DONE = 2] = \"DONE\", e[e.ERROR = 3] = \"ERROR\";\n\n    var t = function () {\n      function e(e) {\n        this.name = e, this._isCompleted = !1, this._taskState = o.INIT;\n      }\n\n      return Object.defineProperty(e.prototype, \"isCompleted\", {\n        get: function () {\n          return this._isCompleted;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"taskState\", {\n        get: function () {\n          return this._taskState;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(e.prototype, \"errorObject\", {\n        get: function () {\n          return this._errorObject;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), e.prototype._setErrorObject = function (e, t) {\n        this._errorObject || (this._errorObject = {\n          message: e,\n          exception: t\n        });\n      }, e.prototype.run = function (e, t, i) {\n        var r = this;\n        this._taskState = o.RUNNING, this.runTask(e, function () {\n          r.onDoneCallback(t, i);\n        }, function (e, t) {\n          r.onErrorCallback(i, e, t);\n        });\n      }, e.prototype.runTask = function (e, t, i) {\n        throw new Error(\"runTask is not implemented\");\n      }, e.prototype.reset = function () {\n        this._taskState = o.INIT;\n      }, e.prototype.onErrorCallback = function (e, t, i) {\n        this._taskState = o.ERROR, this._errorObject = {\n          message: t,\n          exception: i\n        }, this.onError && this.onError(this, t, i), e();\n      }, e.prototype.onDoneCallback = function (e, t) {\n        try {\n          this._taskState = o.DONE, this._isCompleted = !0, this.onSuccess && this.onSuccess(this), e();\n        } catch (e) {\n          this.onErrorCallback(t, \"Task is done, error executing success callback(s)\", e);\n        }\n      }, e;\n    }();\n\n    a.AbstractAssetTask = t;\n\n    var s = function (e, t, i) {\n      this.remainingCount = e, this.totalCount = t, this.task = i;\n    };\n\n    a.AssetsProgressEvent = s;\n\n    var l = function (o) {\n      function e(e, t, i, r) {\n        var n = o.call(this, e) || this;\n        return n.name = e, n.meshesNames = t, n.rootUrl = i, n.sceneFilename = r, n;\n      }\n\n      return T(e, o), e.prototype.runTask = function (e, r, n) {\n        var o = this;\n        a.SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, e, function (e, t, i) {\n          o.loadedMeshes = e, o.loadedParticleSystems = t, o.loadedSkeletons = i, r();\n        }, null, function (e, t, i) {\n          n(t, i);\n        });\n      }, e;\n    }(t);\n\n    a.MeshAssetTask = l;\n\n    var r = function (r) {\n      function e(e, t) {\n        var i = r.call(this, e) || this;\n        return i.name = e, i.url = t, i;\n      }\n\n      return T(e, r), e.prototype.runTask = function (e, t, i) {\n        var r = this;\n\n        e._loadFile(this.url, function (e) {\n          r.text = e, t();\n        }, void 0, !1, !1, function (e, t) {\n          e && i(e.status + \" \" + e.statusText, t);\n        });\n      }, e;\n    }(t);\n\n    a.TextFileAssetTask = r;\n\n    var n = function (r) {\n      function e(e, t) {\n        var i = r.call(this, e) || this;\n        return i.name = e, i.url = t, i;\n      }\n\n      return T(e, r), e.prototype.runTask = function (e, t, i) {\n        var r = this;\n\n        e._loadFile(this.url, function (e) {\n          r.data = e, t();\n        }, void 0, !0, !0, function (e, t) {\n          e && i(e.status + \" \" + e.statusText, t);\n        });\n      }, e;\n    }(t);\n\n    a.BinaryFileAssetTask = n;\n\n    var c = function (r) {\n      function e(e, t) {\n        var i = r.call(this, e) || this;\n        return i.name = e, i.url = t, i;\n      }\n\n      return T(e, r), e.prototype.runTask = function (e, t, i) {\n        var r = this,\n            n = new Image();\n        a.Tools.SetCorsBehavior(this.url, n), n.onload = function () {\n          r.image = n, t();\n        }, n.onerror = function (e) {\n          i(\"Error loading image\", e);\n        }, n.src = this.url;\n      }, e;\n    }(t);\n\n    a.ImageAssetTask = c;\n\n    var h = function (s) {\n      function e(e, t, i, r, n) {\n        void 0 === n && (n = a.Texture.TRILINEAR_SAMPLINGMODE);\n        var o = s.call(this, e) || this;\n        return o.name = e, o.url = t, o.noMipmap = i, o.invertY = r, o.samplingMode = n, o;\n      }\n\n      return T(e, s), e.prototype.runTask = function (e, t, i) {\n        this.texture = new a.Texture(this.url, e, this.noMipmap, this.invertY, this.samplingMode, function () {\n          t();\n        }, function (e, t) {\n          i(e, t);\n        });\n      }, e;\n    }(t);\n\n    a.TextureAssetTask = h;\n\n    var u = function (s) {\n      function e(e, t, i, r, n) {\n        var o = s.call(this, e) || this;\n        return o.name = e, o.url = t, o.extensions = i, o.noMipmap = r, o.files = n, o;\n      }\n\n      return T(e, s), e.prototype.runTask = function (e, t, i) {\n        this.texture = new a.CubeTexture(this.url, e, this.extensions, this.noMipmap, this.files, function () {\n          t();\n        }, function (e, t) {\n          i(e, t);\n        });\n      }, e;\n    }(t);\n\n    a.CubeTextureAssetTask = u;\n\n    var d = function (l) {\n      function e(e, t, i, r, n, o, s) {\n        void 0 === r && (r = !1), void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = !1);\n        var a = l.call(this, e) || this;\n        return a.name = e, a.url = t, a.size = i, a.noMipmap = r, a.generateHarmonics = n, a.gammaSpace = o, a.reserved = s, a;\n      }\n\n      return T(e, l), e.prototype.run = function (e, t, i) {\n        this.texture = new a.HDRCubeTexture(this.url, e, this.size, this.noMipmap, this.generateHarmonics, this.gammaSpace, this.reserved, function () {\n          t();\n        }, function (e, t) {\n          i(e, t);\n        });\n      }, e;\n    }(t);\n\n    a.HDRCubeTextureAssetTask = d;\n\n    var i = function () {\n      function e(e) {\n        this._isLoading = !1, this._tasks = new Array(), this._waitingTasksCount = 0, this._totalTasksCount = 0, this.onTaskSuccessObservable = new a.Observable(), this.onTaskErrorObservable = new a.Observable(), this.onTasksDoneObservable = new a.Observable(), this.onProgressObservable = new a.Observable(), this.useDefaultLoadingScreen = !0, this._scene = e;\n      }\n\n      return e.prototype.addMeshTask = function (e, t, i, r) {\n        var n = new l(e, t, i, r);\n        return this._tasks.push(n), n;\n      }, e.prototype.addTextFileTask = function (e, t) {\n        var i = new r(e, t);\n        return this._tasks.push(i), i;\n      }, e.prototype.addBinaryFileTask = function (e, t) {\n        var i = new n(e, t);\n        return this._tasks.push(i), i;\n      }, e.prototype.addImageTask = function (e, t) {\n        var i = new c(e, t);\n        return this._tasks.push(i), i;\n      }, e.prototype.addTextureTask = function (e, t, i, r, n) {\n        void 0 === n && (n = a.Texture.TRILINEAR_SAMPLINGMODE);\n        var o = new h(e, t, i, r, n);\n        return this._tasks.push(o), o;\n      }, e.prototype.addCubeTextureTask = function (e, t, i, r, n) {\n        var o = new u(e, t, i, r, n);\n        return this._tasks.push(o), o;\n      }, e.prototype.addHDRCubeTextureTask = function (e, t, i, r, n, o, s) {\n        void 0 === r && (r = !1), void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === s && (s = !1);\n        var a = new d(e, t, i, r, n, o, s);\n        return this._tasks.push(a), a;\n      }, e.prototype.removeTask = function (e) {\n        var t = this._tasks.indexOf(e);\n\n        -1 < t && this._tasks.splice(t, 1);\n      }, e.prototype._decreaseWaitingTasksCount = function (e) {\n        this._waitingTasksCount--;\n\n        try {\n          this.onProgress && this.onProgress(this._waitingTasksCount, this._totalTasksCount, e), this.onProgressObservable.notifyObservers(new s(this._waitingTasksCount, this._totalTasksCount, e));\n        } catch (e) {\n          a.Tools.Error(\"Error running progress callbacks.\"), console.log(e);\n        }\n\n        if (0 === this._waitingTasksCount) {\n          try {\n            this.onFinish && this.onFinish(this._tasks);\n\n            for (var t = this._tasks.slice(), i = 0, r = t; i < r.length; i++) {\n              if ((e = r[i]).taskState === o.DONE) {\n                var n = this._tasks.indexOf(e);\n\n                -1 < n && this._tasks.splice(n, 1);\n              }\n            }\n\n            this.onTasksDoneObservable.notifyObservers(this._tasks);\n          } catch (e) {\n            a.Tools.Error(\"Error running tasks-done callbacks.\"), console.log(e);\n          }\n\n          this._isLoading = !1, this._scene.getEngine().hideLoadingUI();\n        }\n      }, e.prototype._runTask = function (i) {\n        var r = this,\n            t = function (e, t) {\n          i._setErrorObject(e, t), r.onTaskError && r.onTaskError(i), r.onTaskErrorObservable.notifyObservers(i), r._decreaseWaitingTasksCount(i);\n        };\n\n        i.run(this._scene, function () {\n          try {\n            r.onTaskSuccess && r.onTaskSuccess(i), r.onTaskSuccessObservable.notifyObservers(i), r._decreaseWaitingTasksCount(i);\n          } catch (e) {\n            t(\"Error executing task success callbacks\", e);\n          }\n        }, t);\n      }, e.prototype.reset = function () {\n        return this._isLoading = !1, this._tasks = new Array(), this;\n      }, e.prototype.load = function () {\n        if (this._isLoading) return this;\n        if (this._isLoading = !0, this._waitingTasksCount = this._tasks.length, this._totalTasksCount = this._tasks.length, 0 === this._waitingTasksCount) return this._isLoading = !1, this.onFinish && this.onFinish(this._tasks), this.onTasksDoneObservable.notifyObservers(this._tasks), this;\n        this.useDefaultLoadingScreen && this._scene.getEngine().displayLoadingUI();\n\n        for (var e = 0; e < this._tasks.length; e++) {\n          var t = this._tasks[e];\n          t.taskState === o.INIT && this._runTask(t);\n        }\n\n        return this;\n      }, e;\n    }();\n\n    a.AssetsManager = i;\n  }($a || ($a = {})), ha = $a || ($a = {}), ua = [], da = function (e, t) {\n    if (!ua[e.id] && !e.doNotSerialize) {\n      if (e instanceof ha.BoxGeometry) t.boxes.push(e.serialize());else if (e instanceof ha.SphereGeometry) t.spheres.push(e.serialize());else if (e instanceof ha.CylinderGeometry) t.cylinders.push(e.serialize());else if (e instanceof ha.TorusGeometry) t.toruses.push(e.serialize());else if (e instanceof ha.GroundGeometry) t.grounds.push(e.serialize());else if (e instanceof ha.Plane) t.planes.push(e.serialize());else if (e instanceof ha.TorusKnotGeometry) t.torusKnots.push(e.serialize());else {\n        if (e instanceof ha._PrimitiveGeometry) throw new Error(\"Unknown primitive type\");\n        t.vertexData.push(e.serializeVerticeData());\n      }\n      ua[e.id] = !0;\n    }\n  }, fa = function (e, t) {\n    var i = {},\n        r = e._geometry;\n    return r && (e.getScene().getGeometryByID(r.id) || da(r, t.geometries)), e.serialize && e.serialize(i), i;\n  }, pa = function () {\n    function v() {}\n\n    return v.ClearCache = function () {\n      ua = [];\n    }, v.Serialize = function (e) {\n      var t,\n          i,\n          r,\n          n = {};\n\n      if (v.ClearCache(), n.useDelayedTextureLoading = e.useDelayedTextureLoading, n.autoClear = e.autoClear, n.clearColor = e.clearColor.asArray(), n.ambientColor = e.ambientColor.asArray(), n.gravity = e.gravity.asArray(), n.collisionsEnabled = e.collisionsEnabled, n.workerCollisions = e.workerCollisions, e.fogMode && 0 !== e.fogMode && (n.fogMode = e.fogMode, n.fogColor = e.fogColor.asArray(), n.fogStart = e.fogStart, n.fogEnd = e.fogEnd, n.fogDensity = e.fogDensity), e.isPhysicsEnabled()) {\n        var o = e.getPhysicsEngine();\n        o && (n.physicsEnabled = !0, n.physicsGravity = o.gravity.asArray(), n.physicsEngine = o.getPhysicsPluginName());\n      }\n\n      e.metadata && (n.metadata = e.metadata), n.morphTargetManagers = [];\n\n      for (var s = 0, a = e.meshes; s < a.length; s++) {\n        var l = (p = a[s]).morphTargetManager;\n        l && n.morphTargetManagers.push(l.serialize());\n      }\n\n      for (n.lights = [], t = 0; t < e.lights.length; t++) (i = e.lights[t]).doNotSerialize || n.lights.push(i.serialize());\n\n      for (n.cameras = [], t = 0; t < e.cameras.length; t++) {\n        var c = e.cameras[t];\n        c.doNotSerialize || n.cameras.push(c.serialize());\n      }\n\n      for (e.activeCamera && (n.activeCameraID = e.activeCamera.id), ha.Animation.AppendSerializedAnimations(e, n), n.materials = [], n.multiMaterials = [], t = 0; t < e.materials.length; t++) (r = e.materials[t]).doNotSerialize || n.materials.push(r.serialize());\n\n      for (n.multiMaterials = [], t = 0; t < e.multiMaterials.length; t++) {\n        var h = e.multiMaterials[t];\n        n.multiMaterials.push(h.serialize());\n      }\n\n      for (e.environmentTexture && (n.environmentTexture = e.environmentTexture.name), n.skeletons = [], t = 0; t < e.skeletons.length; t++) {\n        var u = e.skeletons[t];\n        u.doNotSerialize || n.skeletons.push(u.serialize());\n      }\n\n      for (n.transformNodes = [], t = 0; t < e.transformNodes.length; t++) n.transformNodes.push(e.transformNodes[t].serialize());\n\n      n.geometries = {}, n.geometries.boxes = [], n.geometries.spheres = [], n.geometries.cylinders = [], n.geometries.toruses = [], n.geometries.grounds = [], n.geometries.planes = [], n.geometries.torusKnots = [], n.geometries.vertexData = [], ua = [];\n      var d = e.getGeometries();\n\n      for (t = 0; t < d.length; t++) {\n        var f = d[t];\n        f.isReady() && da(f, n.geometries);\n      }\n\n      for (n.meshes = [], t = 0; t < e.meshes.length; t++) {\n        var p;\n\n        if ((p = e.meshes[t]) instanceof ha.Mesh) {\n          var _ = p;\n          _.doNotSerialize || _.delayLoadState !== ha.Engine.DELAYLOADSTATE_LOADED && _.delayLoadState !== ha.Engine.DELAYLOADSTATE_NONE || n.meshes.push(fa(_, n));\n        }\n      }\n\n      for (n.particleSystems = [], t = 0; t < e.particleSystems.length; t++) n.particleSystems.push(e.particleSystems[t].serialize());\n\n      e.actionManager && (n.actions = e.actionManager.serialize(\"scene\"));\n\n      for (var m = 0, g = e._serializableComponents; m < g.length; m++) {\n        g[m].serialize(n);\n      }\n\n      return n;\n    }, v.SerializeMesh = function (t, e, i) {\n      void 0 === e && (e = !1), void 0 === i && (i = !1);\n      var r = {};\n      if (v.ClearCache(), t = t instanceof Array ? t : [t], e || i) for (var n = 0; n < t.length; ++n) i && t[n].getDescendants().forEach(function (e) {\n        e instanceof ha.Mesh && t.indexOf(e) < 0 && t.push(e);\n      }), e && t[n].parent && t.indexOf(t[n].parent) < 0 && t.push(t[n].parent);\n      return t.forEach(function (e) {\n        !function (t, e) {\n          if (t.delayLoadState === ha.Engine.DELAYLOADSTATE_LOADED || t.delayLoadState === ha.Engine.DELAYLOADSTATE_NONE) {\n            if (t.material) if (t.material instanceof ha.MultiMaterial) {\n              if (e.multiMaterials = e.multiMaterials || [], e.materials = e.materials || [], !e.multiMaterials.some(function (e) {\n                return e.id === t.material.id;\n              })) {\n                e.multiMaterials.push(t.material.serialize());\n\n                for (var i = function (t) {\n                  t && (e.materials.some(function (e) {\n                    return e.id === t.id;\n                  }) || e.materials.push(t.serialize()));\n                }, r = 0, n = t.material.subMaterials; r < n.length; r++) i(n[r]);\n              }\n            } else e.materials = e.materials || [], e.materials.some(function (e) {\n              return e.id === t.material.id;\n            }) || e.materials.push(t.material.serialize());\n            var o = t._geometry;\n            o && (e.geometries || (e.geometries = {}, e.geometries.boxes = [], e.geometries.spheres = [], e.geometries.cylinders = [], e.geometries.toruses = [], e.geometries.grounds = [], e.geometries.planes = [], e.geometries.torusKnots = [], e.geometries.vertexData = []), da(o, e.geometries)), t.skeleton && (e.skeletons = e.skeletons || [], e.skeletons.push(t.skeleton.serialize())), e.meshes = e.meshes || [], e.meshes.push(fa(t, e));\n          }\n        }(e, r);\n      }), r;\n    }, v;\n  }(), ha.SceneSerializer = pa, _a = $a || ($a = {}), ma = function () {\n    function e(e, t, i, r, n) {\n      void 0 === r && (r = !0), void 0 === n && (n = !1);\n      var o = this;\n      this.name = e, this._viewMatrix = _a.Matrix.Identity(), this._target = _a.Vector3.Zero(), this._add = _a.Vector3.Zero(), this._invertYAxis = !1, this.position = _a.Vector3.Zero(), this._scene = i, this._scene.reflectionProbes || (this._scene.reflectionProbes = new Array()), this._scene.reflectionProbes.push(this), this._renderTargetTexture = new _a.RenderTargetTexture(e, t, i, r, !0, n ? _a.Engine.TEXTURETYPE_FLOAT : _a.Engine.TEXTURETYPE_UNSIGNED_INT, !0), this._renderTargetTexture.onBeforeRenderObservable.add(function (e) {\n        switch (e) {\n          case 0:\n            o._add.copyFromFloats(1, 0, 0);\n\n            break;\n\n          case 1:\n            o._add.copyFromFloats(-1, 0, 0);\n\n            break;\n\n          case 2:\n            o._add.copyFromFloats(0, o._invertYAxis ? 1 : -1, 0);\n\n            break;\n\n          case 3:\n            o._add.copyFromFloats(0, o._invertYAxis ? -1 : 1, 0);\n\n            break;\n\n          case 4:\n            o._add.copyFromFloats(0, 0, 1);\n\n            break;\n\n          case 5:\n            o._add.copyFromFloats(0, 0, -1);\n\n        }\n\n        o._attachedMesh && o.position.copyFrom(o._attachedMesh.getAbsolutePosition()), o.position.addToRef(o._add, o._target), _a.Matrix.LookAtLHToRef(o.position, o._target, _a.Vector3.Up(), o._viewMatrix), i.setTransformMatrix(o._viewMatrix, o._projectionMatrix), i._forcedViewPosition = o.position;\n      }), this._renderTargetTexture.onAfterUnbindObservable.add(function () {\n        i._forcedViewPosition = null, i.updateTransformMatrix(!0);\n      }), i.activeCamera && (this._projectionMatrix = _a.Matrix.PerspectiveFovLH(Math.PI / 2, 1, i.activeCamera.minZ, i.activeCamera.maxZ));\n    }\n\n    return Object.defineProperty(e.prototype, \"samples\", {\n      get: function () {\n        return this._renderTargetTexture.samples;\n      },\n      set: function (e) {\n        this._renderTargetTexture.samples = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"refreshRate\", {\n      get: function () {\n        return this._renderTargetTexture.refreshRate;\n      },\n      set: function (e) {\n        this._renderTargetTexture.refreshRate = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.getScene = function () {\n      return this._scene;\n    }, Object.defineProperty(e.prototype, \"cubeTexture\", {\n      get: function () {\n        return this._renderTargetTexture;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"renderList\", {\n      get: function () {\n        return this._renderTargetTexture.renderList;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.attachToMesh = function (e) {\n      this._attachedMesh = e;\n    }, e.prototype.setRenderingAutoClearDepthStencil = function (e, t) {\n      this._renderTargetTexture.setRenderingAutoClearDepthStencil(e, t);\n    }, e.prototype.dispose = function () {\n      var e = this._scene.reflectionProbes.indexOf(this);\n\n      -1 !== e && this._scene.reflectionProbes.splice(e, 1), this._renderTargetTexture && (this._renderTargetTexture.dispose(), this._renderTargetTexture = null);\n    }, e;\n  }(), _a.ReflectionProbe = ma, ga = $a || ($a = {}), va = function () {\n    function e(e) {\n      this.name = ga.SceneComponentConstants.NAME_LAYER, this.scene = e, this._engine = e.getEngine(), e.layers = new Array();\n    }\n\n    return e.prototype.register = function () {\n      this.scene._beforeCameraDrawStage.registerStep(ga.SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawBackground), this.scene._afterCameraDrawStage.registerStep(ga.SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawForeground);\n    }, e.prototype.rebuild = function () {\n      for (var e = 0, t = this.scene.layers; e < t.length; e++) {\n        t[e]._rebuild();\n      }\n    }, e.prototype.dispose = function () {\n      for (var e = this.scene.layers; e.length;) e[0].dispose();\n    }, e.prototype._draw = function (e, t) {\n      var i = this.scene.layers;\n\n      if (i.length) {\n        this._engine.setDepthBuffer(!1);\n\n        for (var r = e.layerMask, n = 0, o = i; n < o.length; n++) {\n          var s = o[n];\n          s.isBackground === t && 0 != (s.layerMask & r) && s.render();\n        }\n\n        this._engine.setDepthBuffer(!0);\n      }\n    }, e.prototype._drawBackground = function (e) {\n      this._draw(e, !0);\n    }, e.prototype._drawForeground = function (e) {\n      this._draw(e, !1);\n    }, e;\n  }(), ga.LayerSceneComponent = va, ya = $a || ($a = {}), ba = function () {\n    function e(e, t, i, r, n) {\n      this.name = e, this.scale = new ya.Vector2(1, 1), this.offset = new ya.Vector2(0, 0), this.alphaBlendingMode = ya.Engine.ALPHA_COMBINE, this.layerMask = 268435455, this._vertexBuffers = {}, this.onDisposeObservable = new ya.Observable(), this.onBeforeRenderObservable = new ya.Observable(), this.onAfterRenderObservable = new ya.Observable(), this.texture = t ? new ya.Texture(t, i, !0) : null, this.isBackground = void 0 === r || r, this.color = void 0 === n ? new ya.Color4(1, 1, 1, 1) : n, this._scene = i || ya.Engine.LastCreatedScene;\n\n      var o = this._scene._getComponent(ya.SceneComponentConstants.NAME_LAYER);\n\n      o || (o = new ya.LayerSceneComponent(this._scene), this._scene._addComponent(o)), this._scene.layers.push(this);\n\n      var s = this._scene.getEngine(),\n          a = [];\n\n      a.push(1, 1), a.push(-1, 1), a.push(-1, -1), a.push(1, -1);\n      var l = new ya.VertexBuffer(s, a, ya.VertexBuffer.PositionKind, !1, !1, 2);\n      this._vertexBuffers[ya.VertexBuffer.PositionKind] = l, this._createIndexBuffer(), this._effect = s.createEffect(\"layer\", [ya.VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], \"\"), this._alphaTestEffect = s.createEffect(\"layer\", [ya.VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], \"#define ALPHATEST\");\n    }\n\n    return Object.defineProperty(e.prototype, \"onDispose\", {\n      set: function (e) {\n        this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onBeforeRender\", {\n      set: function (e) {\n        this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"onAfterRender\", {\n      set: function (e) {\n        this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype._createIndexBuffer = function () {\n      var e = this._scene.getEngine(),\n          t = [];\n\n      t.push(0), t.push(1), t.push(2), t.push(0), t.push(2), t.push(3), this._indexBuffer = e.createIndexBuffer(t);\n    }, e.prototype._rebuild = function () {\n      var e = this._vertexBuffers[ya.VertexBuffer.PositionKind];\n      e && e._rebuild(), this._createIndexBuffer();\n    }, e.prototype.render = function () {\n      var e = this.alphaTest ? this._alphaTestEffect : this._effect;\n\n      if (e.isReady() && this.texture && this.texture.isReady()) {\n        var t = this._scene.getEngine();\n\n        this.onBeforeRenderObservable.notifyObservers(this), t.enableEffect(e), t.setState(!1), e.setTexture(\"textureSampler\", this.texture), e.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix()), e.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a), e.setVector2(\"offset\", this.offset), e.setVector2(\"scale\", this.scale), t.bindBuffers(this._vertexBuffers, this._indexBuffer, e), this.alphaTest ? t.drawElementsType(ya.Material.TriangleFillMode, 0, 6) : (t.setAlphaMode(this.alphaBlendingMode), t.drawElementsType(ya.Material.TriangleFillMode, 0, 6), t.setAlphaMode(ya.Engine.ALPHA_DISABLE)), this.onAfterRenderObservable.notifyObservers(this);\n      }\n    }, e.prototype.dispose = function () {\n      var e = this._vertexBuffers[ya.VertexBuffer.PositionKind];\n      e && (e.dispose(), this._vertexBuffers[ya.VertexBuffer.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null), this.texture && (this.texture.dispose(), this.texture = null);\n\n      var t = this._scene.layers.indexOf(this);\n\n      this._scene.layers.splice(t, 1), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderObservable.clear();\n    }, e;\n  }(), ya.Layer = ba, Ta = $a || ($a = {}), Ea = function () {\n    function e() {}\n\n    return e.CreateResizedCopy = function (t, e, i, r) {\n      void 0 === r && (r = !0);\n      var n = t.getScene(),\n          o = n.getEngine(),\n          s = new Ta.RenderTargetTexture(\"resized\" + t.name, {\n        width: e,\n        height: i\n      }, n, !t.noMipmap, !0, t._texture.type, !1, t._samplingMode, !1);\n      s.wrapU = t.wrapU, s.wrapV = t.wrapV, s.uOffset = t.uOffset, s.vOffset = t.vOffset, s.uScale = t.uScale, s.vScale = t.vScale, s.uAng = t.uAng, s.vAng = t.vAng, s.wAng = t.wAng, s.coordinatesIndex = t.coordinatesIndex, s.level = t.level, s.anisotropicFilteringLevel = t.anisotropicFilteringLevel, s._texture.isReady = !1, t.wrapU = Ta.Texture.CLAMP_ADDRESSMODE, t.wrapV = Ta.Texture.CLAMP_ADDRESSMODE;\n      var a = new Ta.PassPostProcess(\"pass\", 1, null, r ? Ta.Texture.BILINEAR_SAMPLINGMODE : Ta.Texture.NEAREST_SAMPLINGMODE, o, !1, Ta.Engine.TEXTURETYPE_UNSIGNED_INT);\n      return a.getEffect().executeWhenCompiled(function () {\n        a.onApply = function (e) {\n          e.setTexture(\"textureSampler\", t);\n        };\n\n        var e = s.getInternalTexture();\n        e && (n.postProcessManager.directRender([a], e), o.unBindFramebuffer(e), s.disposeFramebufferObjects(), a.dispose(), e.isReady = !0);\n      }), s;\n    }, e.GetEnvironmentBRDFTexture = function (e) {\n      if (!e._environmentBRDFTexture) {\n        var t = Ta.Texture.CreateFromBase64String(this._environmentBRDFBase64Texture, \"EnvironmentBRDFTexture\", e, !0, !1, Ta.Texture.BILINEAR_SAMPLINGMODE);\n        t.wrapU = Ta.Texture.CLAMP_ADDRESSMODE, t.wrapV = Ta.Texture.CLAMP_ADDRESSMODE, e._environmentBRDFTexture = t;\n      }\n\n      return e._environmentBRDFTexture;\n    }, e._environmentBRDFBase64Texture = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR4Xu19Z7PtTHbW1g3jMMbGmGDAZAMm5xxMLDAU0WSKWOQcCoqccw6eGdtgk4yNbZxnvvAL+Af8Af6AsQl+06ako9X36dXPSi3pnPu+cz/cOntL3S1pq5+w1mrpLs/eud9fvn27rf9evPPwFz+v22S7fGZ/n7/70G79J5/Xv/qzbLP+Pnvvoc/6Tz7jX/15/c62LfeH7fofbpfP3l/ct36Wf+u4+D37+XYb++G26LPsr/zFttnPuh37bm1bt0f7MvtlnOx4uv0H4fty8UUsz77rfn/57u32cgXvDv72eQf0tl0+G38b0Nf9K4Dl704MEfA16KsE8Gw9JgD+DQE8EA0DT2b7GwK4GHnF4a8iguXZt9/vL5/dbisJbEq/uwD5vIK/fbbAv4N9U/8nJIDNCazKvBLBGwdwu62OhajxmQSAx6gqNp5HCg9wPan2nwSNjhLD8ux/3u8vP3y7vbwDAYjtR8AzFyDqLu1Q+YEINnew23rPCYiKb+q/K7o4AVT4tg0t/h4ydJZfkQASQ/d5b9fZ/Z1ENmuPn/cwYCYEELBguKC3nRkCnE0AFOwOKCOAR/sH/L4hgFMpbSWP5dn/uN9ffs7t9mJ5cAHoBLTyszBAFJ/F/xIKdASw5wgaEWDMLySxAk4svf6L+4QAGPiJCziNAPb4f3UZ2dh/m+z7BK4SAPYrxf5FB6ABPgCUAfANAZwKyscc7IEA/vv9/uLzbreXzx9cQCMACAl00m8jAlF7ov6SCMQ8gJsMFFBnCECSg5H6TxJAU3vPAbwhgFfz9AABeOEDBcIbB3AqPzwQwH+731/8sNvt5Ydut5e3B2C/fG9P+jESgGz/RgxG9r9VAwTUUh0goQDafUz+DYnAnSha5l99Z1l/yQVswAZSGIAugNd/9xBgCw9E8aECkHUB22QPHIAVDlQdQAMWAibhBgZAasAVHUAI8Cqg96Tm0bj3VBS9jwd7IIBvuN9ffMHt9vLTbreXy+32QlwAhgMIeuNzKwOqCoB2Aa00KHE+EsIeDuj4H2N+Hf/TfAC6A4nhgQCQDDwiaKDXiq9KgBEJNPArAtCk0AEd2mpAizW3/lYIoANpBPg3BPA+hjs/9eXZV+0E8Bm32wsJA9aEoBCAuAABPiEAC/yDC4gSgRgKRHkAlgsI6v7iEFqJEMgBwb4BGkEfEEDnDlReoAP/SQRgOYIB+IYDMEE/SQBbXoLNr0jhq4qOZc0PHBSf5oKW519xvz//kbfby8+83V68ABfwniIBgwgQ/HoRUMv8w5qAoQqgk4DWQiCw+63eD8k/XAPQgK5s/5a5xzAAqgR6wY9k+ZEMtCOoJABb230hEHMFWQdgAl0Ap/+uc6tKBrrP/n0AuwfiNwTwNKguHHV5/qX3+/M1B/Ddb7cXax7g2e324vaQB3hhkMAW92tHoFb96cVAbimwkgQ0Vv7R+D8iACfuxzKfLvnNlAAjAsBwwP2MwLQAD9sbYJME0AFcg5uBPSAA0x0AobhtcDKDA0j3KYDhk7Hp8uKj9/vzH3C7vfget9uLT9nDgDUZuOYCLBJA8MNKPyGGIftPrL+4gy3eh5p/lwRUYYAs9Fn7tM/E9lvJwCH2DxJ/mPTr4nyyLiDtBgTAGCrgNuPzNuETgN+suEEAFhng9lkCoICMLH7V0isCeEMCxylrefkl9/uzz90J4NNUGLDmAnYXINUBrf5dCCAuQCcCvYVAYPk3G++VAveVfkIAFRLolgbr2F9ifP33pAqAV/fHRF4HcAS7AKlAAEIYFNwITOszs/wMsB6II4BXFZ0QwBsSOEYCDwTw2TsBfPrt9uLlqzCgcwFABI0EVCiANl8Uvq0JWNsi2JPZ/0YKsOiHxftsW4v51ZqAaBWgZf91PsBL/jFHwEqBR1cCiuJ3gAfCmCEA3cf8rmz8AMZHIoA3JDBPAsuHVgL4jNvt+UoCH34ggK0asIYBGArsAB7AD+reQgCl+GwZ8LaNlP3MEEDaSg4ACMGr/+ulwV4JsAEfLH42/vdKgWElAJ4QpBl+LAlKErHwt+oGMgTA2ngE4IUIOH3dGr/hAKT/m/UBdSJYPuVL7vflU26352sScCWAD+0EsCcDVxewKjfmAzAsENVn4EfgdySgnYB81yEAgL4RA8T8mTUASAAYBgylQAkL8K/+zL6rsl8qF6ArAeS7WRGoAB8Sf7isN/VZqTs6jQ5wXlweWfyqpQ8I4I0TmCCAT/3I/b48u92ef9bt9nwNAdZE4FoOFALYXcAGegkDMByAzzQEgJh+cAIs/legH0IA5QTCPADE+7ISkD0TgA/8sBIgLQfOgF/F9kPcr+J8fIYguyCILQRKgV4DNviOzoKqeJS0u4AA3pBAjQSWT//I/b5OmC0MWB3ASgBrGLA+IryvDNxCgRXo+wKhjgwk8bcTwUACsJ09ANRVAALwCxmEoFcrAUsuAJ4M1E8BDuHABAHomJ8RgACrZfQLyT9dBWi2OOEG9NJd/TDQ8HAQuBE97ZhjGKy6o+imnU+4gDckkCeB5cMfud/v6zr9Dz84gOdCAM/3JwQhF9CAD25gBWWz/8wNgMpj3K9Lfy0foMMBVffXyT4r+cceC9bvCcDFP0311QrATPkvWgosYQFLAuoqQEcQuw3v2si25F+M1RkZXLUU+CgBmCBOEsCbvECOBJbP+Oj9fv+u2+3Zp91uz9cy4Kfebs/3ROD6iPD2b10YJCXB+0PyrgsHdtBuRACfBeTN+uM+suJPSEDbfh3/oxPoHgwiC3/06j8Eutj69sAQqj++I0CUfvIpwCEvYCT90O4Pn1XsT5Ve1/+dcp9FBh3woqXBSEJkvjHHEOUPqJPAjUUCeOMGfCJYPvOj9/t7//d2e7YmAlcS2B3A8xcPYcBm/7ULEDIQew+5gS0EIEA31R8Uf6gAoBsgKwBd9ddvBBJAs6XARgLQXQ2o7T8+IETe+9eRACg7rhCMVgCiE8D4O9wOCb2ubOht1/vYd2ubzLlgKbBHEDSnAMfL6durVm8qBPwXWz7rY/f7/X/fbsvL2+3Zqv4QAjzfw4COAMAJbEC3wC8koBJ9lAhgxZ+4hi3Oh/f8dU8EqtV/JhHgWn9cC4CJQZXZp6GAk/1nawMkrrcqAiwPIIA2FwOB2oaAF5UkcX+GADBs0I5gsNbBQqCorJcFJjqWKvhNMjky0Aek7/LZH7vf3/vO2215vruAD91uz/dSYCOAPQzYkoD7vw34sFIQw4LNymNSUKk8Wv0hCYhkoJ74Q6BboO9eDKoWAHXvBiCvAdPZf4nt3QqA924AbfXV8t8uN4Bt2We029WkoErWpSoCSm11TM8AOYA5uRS4RAITIQDDavaYHxCcm5exfM7H7vd3v2N9McDt9uxDD//WKsAG/ue32/M1DEACuO3g1jkBsf57fqCL/7UbIISAio85AAG0VQEYiIC9DJTYfy/+Dx8HlpeDRK8G90IBHQbgWgD2WT8LoOJ7NyeA5JEkAwwxmuqzur5X6y+sBEwDMggrqoBNH7c68Puk/fI9Vwfwvx4e6H724oEA1iSg5AAaAewlweeyLmAnAHQCTfU1CTAH4GyTMt+QDMRFQFEYQB71lXUAOjHYlvTqh4N2xe5yASoh2PpaJUGDBDrLr9cGIDlY1l+vDlQOAQHckYMiA68KMFsGtOy65RCGsMIDT+QqJoD3yUwCy/f+6P3+7koAt50AXrwigM0FrIuEoBrwHMMAUhmQUKAlAwHo7VmAPURo9h/r//ozLv1V7/5v6wGMV4B3rwYPXEBqIZAQwp4TYDE+LQlqtQfw6my/LgsyZaeLg7wVgmDnWQ5AA5ZWCDRx7ECzyn3udgFptFCIgTlyFRMEUCKgA+O/jl2Xz/3o/f7Otz88QvpszQOsLmAPARoBSDVgud02AthdwPZ5BSxUBVr8L3kAVHrvs076KSLQi3/M9QCJ7H/G/rf4n8X41XIgcwHecuBMDgAe+BHA6uQgqnvbF5DB5hwUQM3vQgIWkKOVftH+gAC6cz0RXZ9MjmD5fh/ZCWCd1CsB7CSwhgArAUgIIC5AQoDOCewJwab+CH79WR4C0mQAZT4hEQS9DgfEztNkoEECDfi6FAhZflb6Q1XXqwHDEECpvZX4a0qP1l7bfAS98cQfzQUo9a4mASMC0CsIm6JGK/2i/QkCuFK9PxmIYPm8nQDu795uy3K7LTvwVyJAB7ARwJoAVLkA7QIkJ9A5AQS95Ad2YmgvAJWwQFcBpB38pUuB9wVKbAWgCXwV86Mz2ICKTwUWFgOxMEBicr0eoBwCGBUADfxsDsAiA+zflNay31ZcfnAdAAXgDGkcdAcfZCJYfuCX3O9vf/vtthHAmgcQF7ATwOoAtn9IACsRSDkQ/wqIIUGoXYEQQ/sL5IDJP539776DwodVAGlr5QBgP8sDdApP3gSUXQa8/rZsRaBeHmy+HwDyCI1MUNlZzX9iJSBO9igJGJYCo4RdIqMfJQ4Ztq8C7FXjHuSnQ92XH/yvdwJ4Z68ErOXAlQRW0O9/JRG42v9GBHsuAImAqv+uzDo30C3yAfVHoHeg9xyAp/7wlp+WFCSWv1sOTBb+0EoAZP5DImBrApAUMFHolQG19c+EAkbpjyUEdQ6gm/QEsCzZFxKDlWNwprJVWfBm/1WAvWrcQ0ie7Lz80H91v7/9v263+9sPI2zrAZAEdvXvXMBKBJIIFDcgyUAEvHICg/o7wA/Bvyt35wCc2F9Cg03RvRyAA34N8hD0xsIfXP7bQgDMFSgyYO8GsF4N/hQ5ALak1yUGRQDZZJ5VWXgKEsie8yQuH63b8vn/8oEA3lsJYJ2EQgD73xX4z9bs/74gaHMBQgA7+DsXAJWBBniHCLTtNx2AUnkG/LYNiUCpvX7wp6sIOHF/lwgkNf8UGagwYMgLMBdgLQCyVgOyciCGCs5nz/Jr8EXOQOcQZEbrfjjTU8qaCBseMyx4vxPB8iP+RU8A24Kg9R8Qgaj/av8lDBgcwApQ+QdVgW0bKr3+jsk//AztzBKgtv4K+Kj08rl7JFgt9BnCAIsQcD2AsQAolQj0CAGAqhOFCK5u3cA+84dyIJLCPm6buAgoBa5qDoDF6wzUkZ13iSDKKwTamSKZSf29cuzJUwq7LV/wz18RwH2Nl9dKABLArv6bC5B/+9OBGxmsIIR1AQ3w2gk4RECTfwBulgC0rP96/FYJUOv9SzkAB/xuKTBY/qsTgZ0LILF/s/RW9v81ywEwhbeAwUIH6hRwGp+wEOhqoF49fojqQoPlR/+z+/3t77jd3n3rdru999CzEYAQAYJfXACEAqL8W5lQgA5uoJUK9zxBB3ii9ALiYT2AjvuN72wFILP+XdlP8gLKFeg6f5QM3AC+VlMMZ9ABGuN+VePHWL6tHVD23or3tQPo2iWfBRgShDp0ELcBjmIAbwTWqEzIJvLM6kEDEFcD9erxCzg3my4/9p/e7299x+323lu32+oAtjwAhgE7Cazqv7mAvRLQcgG7A9B5AAwHus87CWBYsIKFfe+eCSBgt2J+7QBQ+VsogOU/9fIPBvLhASEF8AHwlhPQ2wVYFhmo/Wby74QyYLcmQAEbbbue2FcnAb28QTmHQKBwNVCvHv8IESw//h/f7299pyIA7QIE/LsTeIbqL59hPUADvHIBG8jBIWgn0L4rsKMj2Noomz8QgZELsCoAAnh0Caj8lup7ib9tX+ZBoKgUmFkWTGJ8S/UHZa/kAHT+QGaeoeQmMUC/CoAzVYAjYDvSNwPCq8fPnINus/zEfwQE8O7tdt8dwGZjIQQQ9Y9cwAB+RQIC4I4MdvvdLL+O//E7LgLykn6q3Efjf6X8bOUfkoNYcQZ8z/KzBUBYCqT/YQgjBuOBHxPs7JHh7JoAy/IzWz+xEtBKBEYg8fIGw+SeQQQ+CzHZP+oWXWPU/8z9y0/+h/f729/5kAN4791X/6/cpl4SCsDfLRQwHEBLCmJFYH92vssNgBPo7D8qv4CekIHpAjKgx1iffGbKb5UAQwdguIAtz2KsEWj7vIQggNON91lYoIFN2mznYKj9UBmwQgXLLcDstRTdBchEFWAWcLP9MgC9cuzM8aXN8lP//v3+9v/uCUDyAM0FIBFADqAjAsgFiAvYwK3/MfAL8InSd/Yfy37Qpyv3OSTgxf8C5vZXPfF3aB2AA3hJGg5LghMOgCUBo8SgEAyC3Irvh5xAwhW0cT1iQBKYWds/QQLdeVUQcrEjeGoiWH7633sggHfWJOAaAkglYL/wLQyQf3tYsCp9CwmgFIgOgIJ/JwMdBuB3cQTDX4z9wR2whN+WE9idh67761p/F/8bpb8O/OotQCsJDhZfji0qT9p0LsCI83X9H8E9KH8iCSiTrQO29bwAAbvlCipPAw4T/oRKQAVElbaMJ472t7jnqnEjrlt+1t+539/6P4oAxLquawIkF7Bb/40M9hAAHcD2GVzABmBYKSgxfyMGAbROCipl1w6gs/8ZF0Cy/UIOOr7vHAIu9iHP/2v77yX9ROUt29+AHVUCnDJgtvSn8wXsnQGzIUAW3F27qFS4z2CrD07wCogqbR8LtGecUwR4vX/5OX/7FQFsOYC9FCiToBGAEAH83ZwA5AM06BspiPKrNQIt/kcg69iffBegNqVXb/wdQgIMC0DltUuQ+L+Bmz0OrNTdK/91+4JVf15SEPMCYRkwEfc3stBxurMS0AoTMKRocaV8cKw6jpcFsdUn2/8qRT8buGeP55HC8vP+5v3+1v99cADvvfNQBZB4dO24Kv5GAntSUOz/+n1wAis4wAnoMAC/N9svSUKsBABgmwPAbQTwWzsW/2vAI6j14h+1CEjnBYZFQWSxj+sEVFyPjgBBrhf+aOtPY39vRaBVJlQ2vyOGIATQsb6etBguDMSQyAF4IMhUAmZANNNnUNSqBDvtzzif6HSWL/wbuwN4eycA4gDEBQgRYPzfSGC3/BYBdOCHxKBHBAJoAbdWfIz1I9XXsf5g9y0yAJB7iUDPCaC6e2EA2ngMGyIHwAgBldncf4ID0EDXVp1NYmbnrclOtyfDhiPOoCO4CEXB/rOBfOZ4yy/8a7sDAALY1gKAfWMEgOovoNdk0IArKr+7gwH02gWQ2L4t/sEEoLL2IQnoFX96HYC4CIz/jcSgAJSVAtu2RPZ/SPRBHkC7AkYEqceC2fqBfdKaCcHAAeAkpKVBCANcElBVgBQRTC4HngHOTJ+rQo2jhEbP6xf/VU4AmBza7L+EAZgLgGSgxP8dGQDwmQOQbS2xp6oEWAnQn1seIEMCJO4fsv8Q2w/JQU0IJMvPiCCT/NPuQP/noJ0rAFBa23VSr1N/vQhIgxzzB9odMMIAkGvFZPF6JkyIlJeFFl6IcRYYX0ciOOOcll/6l+/3t/7fngPYy4BSCmyT0SGAlgvY4/+BAET10fZjUhAWCg2AV8nBEPQ6D6DJgSUAoQ/G+Dr+T9l/pfg0HxAs/e3WBUhbsihIgHKkHGiGCQHYO/UHomDgdd0BcRkZlYtyAFlgZNtlzqkSJcwc1xr/6FjLL/tLPQG8t+YA3tuXBKPiqISgAB//bjZdkoNE/Rs5EAIYXIAKCwYHYJADlvhalp8RgS4PogNwFN8jgo1A2LoALxRw1gA09TbCAjckQHBZlQEFwEoS0Iv1S3mAYFGPlwOIJn+0v+ocPohEsHzRX9gJYM0BvPvwTyoB2gGsP6iEAowANsBJWAAVgRYeAPCb/WdkAKEAttNJwRbzM+UPQI8K36k9Kf3RagBTe2vhj3o8uAFXLxUGxTdXBrK1AIltTZ2JzUe7Lp/Ralvxvrb5kcWP9nv2fwBzIRF4FRFkx/XcwRljHCGm5Vf++fv9re+63d4xCABVRhOAJoOtRCguQKoCmghwv7L/mBPQwB/KfMQhCEF0ym8RAUkIToUAxrP/gxOwSoDGmn9WCjTzASw3kHQA5poA7Q4g3n+MEMAChiadiopXwHZV26usvB43e/7Lr/pznADakmBdDcB8AFj+5ggcF4AhgAlwwyUM6m+pPgF8U3BS6jOdAAkJ3HUAO5C7ZKBT99/IVDsGhwyY3e8qNfhCERXDa5BrlW/ftaoqe265Ar0U+PIQQCUzqwqYBYfnSK4AcuW8sjmHaMzl1/zZnQDeud3eXRcCrfH/ngNYbyxzAKL8nQNAMiC5gI0gBNz42XIBAnAkBACwqDyWByPlp2BPWP7WD0Crs/5ewq+1JaBnWX8rEajbDiVAlbNpwHRyAJ4D6EqECQcQWfxo/0wI4E3wcPJnUbSLXqH5A26qHaD9kb7ssKaj+nV/ZiSALRG4rwhsJLBfUKt/k3yAJMGwEtCFBGD/PTIY4n6d8ANyaEk/Q/nPUv8h+WeRgXYCVgIwSwbK3osKi4PonEGUC2C2Pngc2LL73Xanlj9bBTg7BIgAFe2vuoxZS14B7wy/DCT8xX/qfn/rrYccwLtrElA7AJkgkrDSJUHJfO/Z/wZ4Kx8g4IXyYKfm0i9QfkoSJK5HghALr51Ce2Jwv0ad9BvAj1WCidKfZf1x3UDnvPQ90HYf7o1WfSQMGbOpU1D3H6oCynpjPE7VfSccpoalMEHNdAxFKkDLgDzTRo5ZaXukz1E34f1Gy2/8kzEB6MUlsjCoCwWMEAAdgOcGTECrnECn+JYTgPyABn0U82vwt7hfJft0rK9DAlHooTSolH94GxBUAnTSL/reAbz6UBADt344SDkIJBIT5E62HgnEAwgFmjq3ChFkAJUFd7Zd9fwsdZ89nnX85Tf/8Z0A1hwAOgDJAxBbuU1usboYCoiCKvWX+L/lAUDlNUG0bD8Bt7dviP9Vf0v9LbV3XQCz/3qbZf2d0h8D+JAPYDb/RAfArL1l92W7Z/OjEICpOZvkw7bES0EisET7M0RxRNkzx78qJGj37rf+MUUA+zoAnQjs1gTAhJNyFy4X7kBtkYHKB0ifDMgrLiADfJMESGa/Cwe0/a+CHsmA5QQ8N6ByAzJZh1IhEobOAegsvwaVDhEKDkCre0cielYbau4SQfIZggyIM0DMtMkc6ywnMHMsduzlt/+R+/2tt2+3d8QBiAtQSUBaEVDxPyYB22cEuiYDQgJtLUFk7539ke1vgAeAR05gC3ekbAclwuaEjEVA3XoAAnLpT6sBCuStrUrIpqsBHhkwcBOVTecFJAteCAFSyk/GzapwBOJofwV0mbEQkNX2p/X9HX9IEcB7eyLw3q8IlPgSbV/LBThEIMreQJkhAeYOIsDrsELV8VmIgHX9ITGo1L+BnxGB5wQY6IvKLzZZCKD7nsj8m+sADjoAVHk9ga19tF1CzSk5GO8T9MCUAdpZbSqEUW17lpNYfucfvN/fBgfwLlQBcEnwdkA9cdGiCjCgGrCpZhACDMSA6wL28dewgKl6GzuI963EXwtf1Nr/wQ0YMb+bCJwAPgKc5gPIPeiImeUC4B5J2zbZnGXBQjI4Mdk2HFNPYqv9MNlJCJByAzPPEezIiUAe7a8ANjPWGYpePc52Db/799/vb7/zKgQQAnhvDwH0cwFWLqBluwkRYJ7AqgoMTiHjApTqR9ZfbLxbCbCUX1wOKQGiO8ASn7XdKgMimL2SoG4nkxGVnqk+OoeBDHR4AN87EmCWnlULBGiBuiNJMFC5RJB8HsACRgYwZ7WpEEY2pNEuYOoYv/f37Q7g3dvtnT3+39YC6BBAv3IK1wVA9p8SAYC5gRDBqz53QDasvag/dQboGMCy0zBA7e/CgoTyszX/VeA35QeH1YGc2Hwr2YchGn5mJNGVd8FdoEOIHEBo9VkeQc3cqFJgEkPhxSBHwoIMCVTAlx1vlggq4y+/7/fe72+tDuDdV2XARgD7isDtd95BpZWjKRUov4Acwa6BT5OEsEjICg1aBUAl8DpwA2kgQeCYbHsjL0zygfKbll9XC5xk3zYGgM1yA0IKERGgI2PJQJ20M13CAQfgWv1kEjBj+Yc2zlqAGdWPgBPtrwI2O16FXMrn8Ad+z04AaxVgTwDiasAtBNgnrK4E6HBgSApichCBBHkBCnQNbmb1iTPoSEXlDXCfTv6x0EAA2OUDtCPA70bMT6sAXjVAlf4sIhieC8BYXy0CYk5gIPKCA8CJGzoAI5QYJqoRzx8NAZ6KCLLgzra7igSWP/i79hzA6gCAAMQFrBMNSUCrFypUm+x78k/cQRffY45AqatOGDJy0CDHkh5dDERielFhWvrTIYHO+icy/jK+qe6sCkCAH70erLsXylXMWv5GFowQrLyACISU6HZ0W+RALX0Qz2ug4NgYUWScRNQ+q6IZ8GbaVMCdHS99jX/4dwIBCAmsoNd5AHAB1sRDArByAV1YgLkBnfRDF6AtPbP4LNY32lkOgMX/tPynSKFzC466Y2JP+mT+mk8BOiVAVP2MA9COgH4nQGcgHxyCAe5uMicqARTcJ+QBIlB5+6O+V4E7c9wMCSx/9HfkCEDyAMPDJiQZ2AABqtZUVwG7s+ZWMlCDO/F9iPFZso9l/IkDaMRgxPqe4g8JQa30yg14pdaM7TddgWHxXcUPVgLqvnqyWw6AqrlT0jPV33AekYJb4IlAdfX+6LwR0BVi8Yhg+WO//X5/e68AyLMAawlwCAEwF2BkpTfgqwlu5QU6G45KrdYNsNi9qwAQMgjBnyEDI77XYGcxfjXut1wAhlfSptsGoNHJPab6XkLwTAeAk1MIidp+mJlRJYCqPxCABwizr0aUDl3I/ogEMsDMjJEZp0oYjECWP/HbSA4ACEDWAbA8gJ6MjADWbYP6i5LqvyRROBBABHgjXEAV14k963s7d0koOkm/s+J+FiaERADqbjkAHKNNrsRCoE7lmYsQ0HjlPm+dgMzKRLmQkkgyBJhR/SPWPwPyTJuriWD5U78FHMB7eyJQ5QDaYiBhXL0mgGWumRNQAO/KbieTASMOL8bvVgUSq2/lAvAaOvDiwiEjs6/BThdZ6bUBJNvfuQN0Z+pzVzI09nXqrT3UMRMAACAASURBVJcKg+J6xKAnLao7Tvruc6ZcyBS6EDpUXUIEvgyAz2oTnQuqe+aYzT386d98v69rALZ1AEIAazVgz/4zBzC8aorlAdS2rkIgC4e8v2TxkOsGMLeA45I6vgZ7ygFg4g8JQhOdl+FPZv+ZnRey0CQhE4PtH1TfCBmkXQd+S+1ZXkCTiQZq0gG4sb6qMHSAKFYQHpsIMoDMtKla/syYy5/9Tb0DWGP/7R8QgOUA2NtnzEw3LhRS6hjlA9CK6/gfS4XU5rOk427p9bg02cfATtS9CwGcSsB6/taTf9Zvx0ItvQ2JgH7WgEYyMMA+5AwmHMBMDsAjAhrPTz5M9H4mggy4M65g+XO/YSeAXf1lLYAsBca/24D7MwKdakBIYOUBxKYyJ0BDAeIOTOW2QI75AgVkXNVH7b+VBFTgDisAQda/gd5LrCrlZpa/WXJrEVBk+cGxNWAkqwDMQWiFNq2/zNKgDOi6A2NFICULRAV8rrSN7HgEzmh/NH4G2MZlDi8qXf78Fz8QgNj/thjIcADtvw9HNcgQwGxIwPIGLHTQVj8BfszWmzkAlZsQwFrlPbcCYOUCjBwKKwl6pUBRWyFhukxY7LmO7414X8f61BVY4YLY9iDBhy6BTX6LPJCoPHtcAXelbQRUD+gZEojGZyCvjrv8hV/fOwArBGBLgnFpcGdJYUJ0gNknxLDNCwm8xKEV6xtqPwt4DWpm92kIQICN7bSNF2Xv/pLfUgNd5wxoCEAA34GbqL0VAmhSuMIBuIqv8wGJRUQWmCzAfNIQwV/8tff7O+9BEhBKgEMiUIUAXjLQinMbAAAcCIruFWMVgBPFX28iLhW2Yvzu+JCo06A21wAQm69XRVJwk+RpaiEQCxeQKEDlaWhgtEWQWEqvt7vhwoQDKAFfjR+5hytdgjf20X1HLH/kIpa//GtUCLATgE4CogOQz628IwzslKx0gosuG1bWnuUGotJhyzUYYUIjBSsnoJKVXZnPCAeYo3EBH1UDDIA38CniiBR/CA1I1r5VEQBUg/1XVt8jjG7iWZUD5WEz5UIK8sRagIhYquQQgfqI/a/aeBYKZMOD5a/86r0MCGsApAqQcQDbgTQBMNuqJ70GE/nuOgMSGjDFj7ZZhNABnxBTIxon459Vfa9yYpUEEfRU5RXounEUkJEgGJlEYNb9O2IQ16hsO07y9nk2ETjzJKG4JIKUSlgQKqyDzgzQM22ic/AcxPLXflXSAew30no8eDsJvBGWyhmJsKojQOAOi3R0yRFtPcvuqxo/tf7qeryYv2T/mZqT0IARgfzmG9Eg6erP8Jvr+4Tk4Sk6IwnWfgA/IxsCPhmfKWuk3ugcqENIgLwC+hl1j4Ac7c+CPDNOd4/++q/ccwCRA1iFHkqAtBrA3ICh/J46Yp7AjM+DHIK27t1aA0YIbKGPIisrw59NAOqSH/0NEKyMCBS4qwnAtNpnk4JGnN8pfKYKoIgiA2R2DEYglW1XE8FZQI6AHu1vv8nf+BUPBNDKgFYOgDkAsHdmQhAnkhP74kNDg72OwgMP0CRuN90GW+CTdCwWoVluQKv3EAYQ1cZjuOpv9JXJNyT49KIgliMwlByVu7kJUFwvPBjcQuaxYSuUOBAGZMjGIxEP1BEQn3z/3/oi4gA0CQD4uxAACMBLCKLNjFSPJd3Q7rtJOWu1oZNcHMgmE+8H5T3P3Xj7OlCzCgEeN+sEVDs8Rpu4Ol9ggd1ScuYWkAQIsDv1lrYqB+BZ/2FfsBqQAe3sbZG6Xwn2aGzr3Ja//cuJA8CnAXfr314SajgBkwBwAs6EAwmwWWFChThY0s8iI297B3DDPYRtCLi3Psb2AdRAHrKvqb9BCEyNtaKXS4OkoqAnomXjKUEo9e/GSjqAs0HvAS8C5WzfaNwKES1/95cZDmAlAbIacPudIRcgi4H0oqBuUirgU6WDSVtJsHnJw8gtZNyGWeJLEJNn61vZzYjzo/3dQ0Ea1DgmUXMWAqTAbil9UOaLynttQj+iAzibCCLQRfstUM+ShJiqqP/y937p7gDuex5gBz5bByD23woDMA9ACeCAG8jkCLTis+8ZUhjCAisZOKvwySw/OoWONFWMrmv4ZsWAqX+wrXMGbLkwnMvgIowEIWuHTsV1CTKz978WeViA88IKDzRnA/Ts8TyCcUng7/+SngC2twFZJLBPljIB4IQ1wgA9waPM+rCfJApN9Tae1beOGZ1LO06CEKj7UbF9A7CVB7AShIa9R3Uf1gOwhF9V6S1iEEQFDqFN3my14IJEYNYRTANNERd+PZMMIsXXp7H8g198v68VgHf2uP9dBX5xAtvbgaUUqEqCg/1HKweAlx9vsLeGIlqxchWojCyqY1RCgXK5jxGHofIsD9B+V92nSAgIxCEkgLEGBU8mAaO4PgoVmEJbOQQG1CzIs+08Msg6kAwRzJBOlgiWf/SLRgewksCq8l0YAKBveQAgBGb/t4vDhJQmAwf4a9dQeZPWnJbiHMfgOYeNlAKlx3BFOxs3L6B+LySS8EUg6rzwuEgQ3luBGugDqx/lCzyCGPbtCBBi05M9Io2OFB4hEXgmGLMgzZDEjIvYruUf/0I7BGgkAJWAbY46SUArGThMyAIZVADH2ppEkiCBir2n5xmpu5ME1I5pUH+LYEnFICKEDpiFEADPSSu0JhQX/MphTBFBIYnI3MRjgLviLs48H9OR/JNf4IcAK9bxPwoV9TerAXgj4T0BOJk9MhAQDZOfACUCNgIy0zbTJpPZpyGAQwTiKug7AYkr0L+N991Vf00gpGyHINbK3yZVMQQwVT2xEMh1BEZ/Nvk1EKsKmgXyGeOeTQQdEf/TL3wggNX2b/H//jqwLRGo1gC0HMCeD9AlQPw+WDqZJEZIoCdaNY6OgOmFAVq5u7ae3Y9AHam7sd8kApUsZHaekclAvrv86eoBcwkZkFvrA1hf1wU4Cu4Btu1T/c8G/hWgrxDEmSFDc0D//OdDCEAqADoPIMnA7a8wrv6LpSEFfJlkoQtAdfKShEmAWlUDN7xgOYYE6DPuBY+Lv0W0HRXdK/cN2X6l0jqcsICubbx2AVeFAK7Sy+zV1YDiasAjgH6MvqZth+vXH6sksfyLn/eKAFaw6yoA5gEE9FYScDsZZfsR8CwhSJNb2Tq5UVLsQO0lE5Pk4bqRiBDU/oEcHFVn9X1T4dFZ6TKhYfWZcltqbm6HsZm6D07QKuGRcqQGgEUKSF5N2QySYPutbZkw4SmJwCIIJIXIYSz/8uf2BEDXAWAosN/w7gUhAHwhge7GY2wGBKFtf5oMGKgcl1Cx/wKwKKQY2hWB3oHbqver7ab6J8t/2L9VbaR6sM8auk4gArlRNbBchQnSaBw5RyV7lRCAgSYCerS/otRZwqiMmSECc7x/9XNUDkCvAyB5AAwDtrlBQgG8KegCOsvolQgrgPKcQKTQSReBhOCquBP3a8LTToXF/vpY8ls2J6AdBFH/rNJfov4YDoL6UzVP5gDc8MBJBFbBnwHrWW08EEcqrvhw+5oNBZZ//bMLBCDqb7kAcAJtUQeyOuQDcGIPnzFeJQClSbJqngBULW3xIzKpkBYe3wGxkISn/u5zASwccLbh5NHhht43ELsFcGeFXwfmA1UAdBsZ9YxU/ej+zDkwJ+RtO5Mkmhh9yc+637cKwJ79lxyAlP/kKcC1IqBzAJgL0K4AQwC0m7hgyAsBrAVEaL0HJU6SQKeiyT6dWictOwsTsqW+9ttosAax/pA3AKJBEqEhQLX+T+J2PG9GEIxEPPC6ag/SNzhOtm/fZo3JABYpfLT/KBFU+leUvxHNR37mSAAC/lYBUDkA76EgIYWOAHASKnXHm4/hwaB8pIxIV8oFFpxlziNws/0diSgF91bwuQQmE7QQ+2fUvwO+pf7KkXRA9db6W6QB1+KCHu1qMgTQE70DoTOG24/Y5qMuIEMOFYBXQ4FM++WjP2MnAFUClGTg5gCEAMhy4M4F7JNou/eZ0qBWELD7qO6D0uNkZXmEwKqb4HXI4wzAa8ejLTYSjb5mfXz8jgCvlP86YrhC/ZH4lfpSFU4SgAfMo88TZFxAlRgyY1aI4Iy2zQF87KfbBLCVAAP199YCaBJAV9AlnAxX0NqwnIBSrHSSziAPa/VeJt/ACMp0AY6l1+CNvofqb6h6NikoJMMUHN2apayZNt3YxRwAPa6Tb2iTXj4cVP2MwkdkUQFz5njsGt1tX/rTHghArwHY7P++DBhdwDanYCWgzgPIfh2TtfUB+6QcJhcBedfGUXoGwAaOyXhdKy4rC1rxPAtlymqfjP0x5h6ArVSdARJdiQa6BWC8t3h8RhQ616AnY+cEigRQdREWUZ1NDBnFz4I5Y+OroMf2y5f9VE4ACH50AS4B7OD28gDtxyEVgW6yOIQwWGlg/Uz8bQLXcBoa/AM56Dq8FcMbCTyx/o3ISF3fsvaMWPRv7JLEPht08nC4TyTDb5UNI1VnwO3coaHQFPBKxa0QwAO/G1LAucwA+2oHkDkny2Vs27/8pygCANUXF9D+h2CdC1CA334rcQf7Z7yxsp8qiFpBOKhPQAiW6jIlN9UdzllAKQBjdtxT9eF8HJLQ5xNae6Lska1nSu+pfyMjb3GOlxwEYrHANwA6sO/abdBxyRiPAf4ZoGf6WOA9y0Es/+YnAwHs4JfsP4v/JSEoTgD/is1veYFZEsB+xAp7gDEX0yRU2asQaHX2wD8QjEEsCDKt0pZqM2LpSqaiiNpteCW7mQSgukc4UTWxsH0Z8EaKT/erRGIW/E/pAo6AOdt35+Pxvwf/t0gA8BKQFfzZMiDmAYakoJ4oUB2gE4UtHDLiYQSa9bnsDEhJj4HfdBYHF/V4Vn8gvh3sh9Rfk60ot7c9Uf+Xc80AkDnCNGng+RrnzCa/RS6Z8zXBJDv0ORnf9bHY96Pbov7LV/ykMQfQrQMgVQABvP67//60BKgXA7UTU9Z/mDgk+TeAndjrBtpCBcEF9Wz23on7j1p9TW74mzaH4jgC/Vtri20uDdakzvIDbTL0y1I9Gx+V8CJHgNeTBfIMEXhjz5LDU5HB8pU/ccwByBOAXQ6AxP9sQVBL5EJGF8uByPYDCehJE1UGAuB7JKD3MadA22iFx9DCiPPpeZAFOZWyH46Jk2cDPiZFRX1IvI7XrMdg2fsOvCRsYGMM25QadgC8KAeQIg5BblAajOL26v5Z4DPrb6m95wKWf/cTxhwAPgJskQAu/aUhAIB5+22J9aelQa0uOuFFQoRBCY2Soc4PNBDBMQVAGJ50amqVI8kYOH4F3FTZsyU9EvuLMs4q/NBP3SNT1Y2FPQyQcs0RYYT7JxYTZQgiAmoE/Ki/8E80DgO+RQYe8Nvx/v2P3wng9updALgAyEoEYrY/ejS4katyBegG2OfOEqpSX7s4K0QohgVUpSft+5VgR7BFsb/nEkxScByD/s31pB2IIOMSIETRE9YLF0wiOGMtwcUu4EoyyIAe79uyEsDwIhAsBSrrT6sAuyJ0i4KU6p9CAkpl9boBNuHT7iCw9vThJBJfe8erKrt2IZZjoWSIcTkLCTwVt6oC6nojwLKYvuoWIsUf1DsZRljn7m3PAPcMBY/GqIK8YU/IHTYs/+HHKQLYAd+tBCQkMIQA7L0AQAxo8bbjI1MXPiOIqMJNOgIEly4HmvsUIaUA7oQ0tD/LuBsAzTqC7XosUnAy/MwBZADtKTl1fjhB2aT19j9RCHAGOWTGyII/Gyos//HHAgEo5c8kAbv4X6m+lRDEmy73EtViSEA5pcFOIVTSMHIEAgTLVuvVceXVeFWwO3F+ByIW5zuxv1ZRRqL6d2TK64E1Y/9dIiDWfVB3veqPEcEThAARcDNgPKtNdC6Dw/lPP+Z+fxcWAOHbgM2FQKDsQ/wP+7TSo+qzsiAqk1apLmGoVUor4kTpcCCDALzZen1EQpbNp+QEjgNdiZWxN8t4pCKQUXeLOChZOFacEoFxTmzsYRIjEZwQAnjjRwCL7Hu0PxofLnVc1IM7gzxGE96vWgkAHwUWF8AWAuGDQOyhIAQ/KwPu+9t5KmVvJwXtMHSgE9BQfU0g7oMy2g4byb9ZMFtkwUCMhNDtJ2VDDVoNLBoSEBLpQBYB18kPpElkv9HM1XRzwFB85gzw2BaArX4uoRRAFYG7up+RQYYgKm5i+aof/RACiPK39wAAEbB3ArSq3v4Bl//qpcAa8Nt3QhAM7N0FE7DTSWc4goEUAAwm8Ky1CNYCG69syWr/BJBWLkArvWflL1H/iDwE2I6dH0hKJkeyYtCRFYCThSdZYLuEwo6hCGwGlE9FBsNx//OP2gkAwwBJBBoVgK4SsE8KyQWwuJ8RAoIdCQJvpMXqVnlQA3z4TpRdjsHA1IEo6hss7JFzQQDQYwaE0AHAUmMrSWgAmJKomuRH7D8DmOVWGMAjgHb7T8oBeORR2XcFOcyMyfps2776C/ocwPr7df8rkEMC23xS/0uQLgVm3IBOAHYni1ldneHVcSMJKdbJEYYOQU7BDR+M8VMZeQZUY1tHVNYxlQJnQgJNKNbk9tzGAFovx0CWDXurDkPF1+MVcgBZhzDbbgaoVWdQsftNaIHcNwLQIYCQgCh9SwaC2jfgQ/lPg92qAnQnokIB6gCUcrlVAqNsZqqco+xMtTM2/FTwVxyBofAsvGGgNe25UxqskgxV+ETIkCaCAgFEzkLmqdXuqZ1ARBam6gMAl6/5kSoEUPYfwa/fBNSeBQBi2MZW7wRox8skBgnYTUfgKLeA11O4KDk3gJ0pWzI00BOYxuhOeU9fhwXWqdg/Io7MfuJKKNhBfRrAJisAFJgH1wF4oPYAF4HxyP6oLwN6xhls/f7Lj7jf5dHf9hdeBNoRgJH5L4UB+2TSpBDmBADsCG5U9izYq+Sg25uKqqsJhnJ64JdrcC13Mfan14tAdDL76MhM0qmOFdh2fRxGJBZQoycKI7BkQZ5tFx0v2h+BPw30BrhXH7bweCOA/eWf+kUgFvjxKcChGqAAbuYADCLQ4N5O14j9I/DjftcGe1UDpn7Ogh2LhCrHfyzw098Hwews/aVkkMzkD8qd7JciggNJQItUjoC0CuAjxMLOMzz3r/3h4ADgLcDM+ktOwKwC4HJg9ZmV/RoXWaGBUv1TiYABO8ofWLHwRDLPBd8JCn8quLMWPeMkiPozK5/dNpBCkAPIgnwWiLP9QqAqBc8of6rN1/3wh4VA8gRg9AxARwI7iFgJUCcAKwlBFg50lQIdDoCbMC1rpYKQrBygW+kUMcjkR+CsxvHus/sReCPQRvsR0A74rPCBnXtK6ZVTsdzgYwK+ovaVthE5zCi/8MnydZ+vQgC1AIiFARveINHnJQMbNlHlAbDbiTj7NBmUiYCoNqsiDBNUT+YjoHaSh3Lz3BDBcivedkaSjvqa8X2ypBe+QEQBVl9vBHrmCCi4H7EKcJban00GFcJYvv6H9UlA+i4AXAuAZT/1WWf/LdXv8G6VAQkxlMHPMsJFJ3CJylugstTaU2FPdT3wZpQ9UZ4LiYvU/TswJ1xDRsWZ88v0a0oIFjtDNt7YEQCPEEc0dnX/AwGQ2P9oDkDCAvld9XdP9dEV4I3tbpaenMZ3V2lIn0yCSlv0wyTh1Nkz9p6ppxVGoFU2VV/UOqn+6NKiMbtzdQgmcgRv1P/hJlXdw/C7/dcfajsAifeFDESU27MB+wa5jzoUaOB3LD4SA4v9NVF4LgAnd3ehgeozAHugHianEx6wCR+FG2YeA294whVQYtjvWQRUMw9BlDIkG7b6j4VmVrusOp9s/y0ncJX6R+POAD4kiI0A4L8BQ+Uf3gfg2H/2MBBTfdP+C7vAzdaPAFfIwLSERHVoIoqUBjNKm3EDGVIwx8kAOFLuaL86hkkkxcU/jDgrSh8CUhG9B6iMzc+0iUB7xO6H4EWszLqBb/ghJARgTwKytwI7OYAhBHBcQDYckOtlTmFYABIA3XILbCEJ3QaE1ampsRItHTbsF+mqqpUryCzZzYA/QzJJN+ICPLFqLwPCI/F/aXy5N4YjiRT6akB7BGmd2/INP/ghBGjJPwL+1QnIfGf2X8CuQ4GGEZXoO9UFEOdwhAxYDiCtXE79ngKh2t7LFWTAHwAbSTEKEby2kaqznEHUJ6XmCUJJjaPUdFbFK4CvtI2IprJ/+caVAHQSkD0ObL0MxCgJbnNNqb7+XlX+KATYLlwdky4NZVaRxY/ZcMGLZwNHkCaXCPwZ1bbOBZXNyS0wkJruSKmll1w9CsrHdACzZOBdYwWwYj7CcAhcijf+8o0/KHYAkgzs/u4Trqm+/g7gKYUDRNG7F4jKhTlAbz+SbgNjdz+g0S5yA0wFO5AQAnHVzwOoZ/vPAn8yMeclKSMlPwOspm1nhO2oeRZEM+0qgH8q9d/O8ZtWAig4AMGQuRDIWQ48JAUBkO3eRcDWuQSi+pETQOBSdpxQ/kjJI7IYljkrVXaBlajpZxbqeGrOQEDzGqA8OoywfvdqHP5+IICznEKFSDJOYhjvm35g0QEkFwIh2Bm4w3AgcAJ6MrV5R+y9BpcmCFQl+oOz8MByE0qNu/EK4UDkJBihWHF7Bvz4m5jAJct+I8Wn+6+I1a8YE0k4+OwBtaLwlbYZwIfjrQQwrP4jK/82+6+2y8q/IQmolR2SiNvvqFUc3x/A9jOwESfAgB6BnxGJFR6E9tWbhJ499ey9FUbIhDT6ejadAjwKMbSVtkgxY7kvAOuZjwFn1fvq0CACeAhucGPycejzzT9gdABYERheCLqDUQhh+0qeC2iYNcBvWf4wMWgQhE7+CdHoC04TAlFy0zkY6+41udAJkyANar8JKVIHEBFEspYfOZLIxofkmSEOr82B+H9WvWcIoALaStuILNj+bdtKAF4JUKu+uQpQx/5AFKj6NBwQeiLOYCCxKEegCELb++GHcCoCA2taYHXU0IrtXTJhjsd5kKcDpziDBEEgQZkkg+MBWVigiYjA/T3gZofjGI4kC+azwTszXgTaqwlgHX/5ls97tRRYVL2tADRCgUH1yYKgDofE4nc4VqDG/EGbE0ZiziMIF/yGYlCHYJEKKzviJLaOEWTbQ5CQpN9AAhcoP5JWGaBA8lmyKYHZI+FgldwMeLNhgncNlX0RWczufyAAWQqcjP2tCgACV+Z+t0RYAUmIpAOxEdtHTmDbTybBsHaAnIMmiuHmatcBk9m8iexcEgrqVgP2c6cxvFL+LMii2HkYJ5Er8H6TaeL4ANj/CKSPofiIowcH8P23COBGnwHQhOBVALxHg1l4kCED0mbIEVjqTIhk+4GT26dJIXAF0yGBQR4U6MR5ZNsNTkIRS0mVsa8ir+o4LnF4ZKvPYXKV3xWK/1o4gG/9/ioJKC8E9dyAAXaM75sDANDp+N8LA7p3CyjF1Y5B3xxKEsZ6AVo5SIDYZHMvGRUlqqLseLCSbzunpBVGMsy6hTA0icAWXf9sIjC45irZyPzKuJUjIH4KxR8cwLd+v50A1PMAmOzTnwXTYvkld7Bth5uM+9uBo3yAodKR8uP4HUEQ5dFtGYEM25QCDwQQqVAEzAgcQdx/JvipC4jICX50Cpxk/wzoorCkAsrM8WbHM0WCEGXU9qr9y0oAWwiglH8LCYz1/w3wqvznqr5BDhqsUwuEqg5BkUwHdgOI2yGsx02tHIHcaGd/pMQIbArMRF7hCGAwFMqAxWwTEdys+sO9zJzfjBuoKPVVba8lgGISsFsApElivyE45wdXADdNhwUdlkm8nnYCCeWXY+l439tecgvG5OxuZqSMjnPoJnwWYJETYUoenWOkaBP9M2C2yDML8my72fg/Am2FLKKxZvZvfb7t+77KAWxOwEj8NXUHp7DNb3QBCvwSAnSCq0MAQhiitugOcCzcbsX71qrAri9OXEY21nMGHUu9GnG4oQVncMg2Z8FPSDEFNMcVHemf6ssIidw3a6wsyM9oVwXhUQLwznkQMVIKbQRAV/45RKDJoAHcIQMhiwjUQwjQscer3hYh0BWBxhhCNCzej/ZZx9FuIsolHLbMFUWfAXIUviAY2ecKOUVjMTIoXH8EmAwhRSA/Cuoj/c255pHot33uQw6A5QFku5cLQGAjMSDmLCcw4BImixUaCDCZkntuwGtPCcABCx6nHBJkVDg7qSuvwEoAcQDIBPi9MTIAKyt59rcKyGWWHCr9IvJ4kv2NAII8gIC1Wwqs1wUAoi0yEABrx82UP+sGziCFDsgkHLDyBN1N80gjqCLg+CkQJOPqdn4BUOhEniENVJtE/2x8TduRa/IAmT1WBMSzxomO8yj7P/65r1YCotIPn0m8j28BFpVvwGdkoCRf2/gOd1k3MNgImIEEyBZZYEKJugVrHYEoi3EsTSzu5HEIZCCFyuQPnMIl4If7kgVMtt0hUkOCMj5XgVex7VM2XU3IlEAQxyPDdP0//n3GlYAh+FWs370OXBbbqWSfblNxAlbbsuUPyMLLBeA9YLafTZruB8+AO2vps+32650Flqem4b4T1d881oyreWICqJLL1e2XjQDkjUDkmX+d5WffEVeWE0CBNJU/qfq6f0eQBdVv/Qw1tdyCBWzGsDJGqBIZgiCAzjqK0kQ6A1hnjOGBNUEwIUmd5AAqxyndB0PFw7nkOAY9R5ePf+9XSUBGBAJudAVt234Ttn37xi4ESGyTE0rnAIBtBqwfAD/+Zl68r8nGdA3RykEsy2TtfJYkKsfWk+wM4GavJwnA2fj/CDCPgqzSPwoLov1HSOUVAeBKwGgtgJH80+AfbL8OC9A66Od0gFy0UiuCa+Sjt0cKboYQRGmHsR0w4vmGE0GRltk+AapuIlTbG9dcDh8mxpkCauL6wt/eUcojfY8AUiv0Wd+tc3ogAA/8xsKfDuykTVP2/YO1GlCLNnUCiii0Cpu7LUfgjUf2WTG/JgXLORwFtbkE2VLQRNKPTgiHjNKASBw7PZZ2J0Vnc+Q4ugsk6gAAG0BJREFUVVKKQH/muZxKCp/4Xv3DQGLn0fI3sEerAPVTghAaaFyllgcDi1Asq43t6yzwI2IIKgHiOFKWjZyjZ3XZBMuAOJqYbTJVwwuDfIb/l8FR2cy5VX6Ts0HmZdunz90i7eClJZnjZdoMv1EjAMcFbLiYAT+x8TpX0DCeAHPXxAA5XTug7YiW7on9NPYPwgLtEEKiSNjcTg2y4YSehCeBv+xUZid98ne5khCmwHaQDGeOGfVZVgKwqgAiiBH4U2XAfTCco1qxNcAZxiOAm+J/kSvwEoYU4Anl325ath0hr5BYNPDYq9Sr4LzY+reJfBZZVa/vhPYRGGf2Z/p4bZZPfM++CmCFAF4YIETR/upnApw3AqUJAQ4ShQPD/ovA3wjdANDwwxvKZbVjN45uSwI427eqnIywpsbIKOT7iAAy4Ix+p5kxMn2kzSsCCKoA+AiwJoOOAJTtF8vPSAK3NSFLhAJdPwLuTKiwHc8jhsx+1YaGBSRxJdeadQgWETBVTJNG0mVEE3TbXww9yg6lmPzL/gapawNSitpXgIdcF40783tlzmUd94EAEiVAuc8m+HWOoCH61fxAy19R/mplAElHicqrryeD3wM1fVkpm1gBkOgxHEV0gZA4VnpiFlQ5MzHNNoXjpM+9APBozKuI59BvpgAwJgE/B0KA6CWgrP7vZP4bWcBJZJYEI1FYQuzlAtw8gTFg2jXs12I+diz7gQA9tu/2GaRkOQvrfYapiZgNR6znyMn1zQCkpG7GOZfG0PenQAAZIM6cS2bcq9osnxAC0C6AgH14+Ie9EIQQwoY5FRo0HAbbKY5In3Yf2QtHEGVWiGEAVhHow1cHPHgeJnAZqAIll3GrSUdKBkdyBmQF41WTsxv3LMK6mAAe5bdwSKt6/AcCMEIAmevrbz88A7Dv1CofVQQ66w9ftAJrMdSuAHD46ucIiEGDeRDcKCwgB43KgZYa47l4biIav0QyybjfOufhWGcRiQHK7nivKQFUATcQ+Ylgnhl7+cT3sEOARgDO038dATjZ/w74AKTM9q05AScjBY8YEHRVy4/Kr4mEKZXbRnaSa/IAvR3HISk3CZkkr3AMOPeM3c2SiTtWAfyzgDyz3+xYZ/6e6XPoCMBZ9tuAboB8cALKIbT5x54H2CeVBrkGOHUFHjFQNlBJ6wnVZ+AWgogA3Fg6cVymuJ1zME/kYQdT0CwgXTUpEFdmUodtCgQQjrVf2NXtMuNn2lTu18x4rxyACgO8sp+n+ts+A+Rs+a+0Z1jFfXS/ASLLGQxjJEAYlgpn1FwdN0UazloDD6wR4aQVH4GTPP+ZCUkn/MmhxtWgsu7H7O9x5fkun/hsFQKw5B+AGsGfjfc9UrDIYjukmmjatlv4taoAFduvyccFWYJIvOSdFvIo7s8Avps0ScBaE606VoVUdFvL9byO4Inc2PvhnEcC2CfL+mf7p+P//ar1dgTsEA7AmJ1gFrZ36k36tXEjV8CshFwT3tEsqBPt2rDQNqX68GNl2kfEUQGmpcQR+VSOkQJIQf2vUMorxkxdd1R+hbl6aLzmAMhCnuEZAKPmrxW+EYAFcGtpsLM9dATgUrSiMvLQbSruYArQCaKIAJxyCjgxnGN6hGLuyy55npicFuEcJZSjAD7aPwvOK46TGfPBAej4nz3959T8B8VXYMR5aK4HIACOLD8DLZvzlp2nZiAB1G1+J9pVbD8jrdR6Awts5PymQL+Pf6j6EBCCNVHN/7iV/lgq6XkWCcn1k2NmwX2UxLLHyQBeLkPGXD7x3cccQGbdP1P9UPmt5CAAqiMLOVvD8re2XkjggHXASALUWfAzl4BzKLT0wblk+kdt0vuNc6lMbBPkhtU9tMpRgfUogGaApfmi8lsdPd9S/44ASLyPQEelZwlATQqIPU/56ctB1MtEGI61slP1NybvU4LfELBXmxMZfzZGxnGkQY8HgB9rxkVM9XkK0imqfYUYqgRYAnHBEelxXzkAJwcg4EOFz9p+5hSasBPlZuGCMgIPIkwmiN50RjWg+22zDsFxHRnwR21cEKtzjADvTUx0OzMgjsY2VbEI/iq4ps+L3JiKslfPszJ2pS2exwMBZHMA+8Re709HAGxxELTtnACgWZNIa5ew/APY9c0xngno+qlBXHxfDP7tBlaOwSZjsn+GFLZJciAMOUQYRQI4dKxHBvWVJDAz9vKJz4rXAYjidiHA/sPRtQDWE4LGOwIt1e+2KxvgEsD7DPyotNPqXwQNO84ApIkxI3IJwXryMcPjnUAAVeCd1f6MaxsJgNX9WXjgKbzlCIwyX7vn3jJhpZCUAGBjRBCKTzjukoraOlfbp04iooTk04mFic4I6QiwvQkvp+XlL44cewYkZwF0uDZ1D2Ztu76VR8ZZPv5ZDxpOwwDr+X9P4ZV9b66B2HodRmgXnHEGrc8Tgz98B4GF4wJp0Bud7B+BqDu9fcxMn6hNaT+5llL/IsnNkMNMn9eZUDYC0M/5I2jXzxqowzaw9l1bZzsCl1p9I1zQJCHkhffeVH+HJBgA9HwysZYE4TA/Z/sZziECi+clPAXOKg62y5xLFHJMjZFU2ciVnA30GRJ4jD7Lxz/zVQ5AwFVa/rt3osAv5gIQ3A+25OFuenbefV6AlBLZeBb4U/hMNSLQC8gonPyzx7Xq7gapyObwfKJx4SfIOJmzjveYQM78VlW7PktU2eseCSCI9wegW5Y/SQwakDpksPYLM1juofVTQHFxE71NKGkJQmyGDTyt9qsFGeCYo8N5ZcfJtnMnsvo9smNm2mWBUHU50bFnjvvYY67H6wiAvvLLyQPgk3xWqKCFRZSdAbdti5KBilws8YrcAd70cgxfJYtAYQPI97uPEog62DbxCmNGE7UKJjx2duwz2kVjXLl/hiAihzEz5isCCFYByhzRCj0A37H92xjE1neuwtmP/V1nQBYKWfMbQ40MCKvtD5EMO6ErgBqMGQGBnWa6z37sdPujoUYUipy4f9a+R0A/c9zl277bXgXYRQABjsDUIK0Anym7DiW0m2CCaS0ZHsggafuzYO6GSwCQNkn0CwnojDESYUwFjDjcTL9osVHZTTwigCMgvu77txCAEkCy7s9IAcHI3IIGNoJwIAV0ppmwYD+4xgn9HoCpAuIQl0aDsF9nH0J6KDWo2v5DKk86zxy/QjCZtq9Tm+hcrtq/EUCn9M4LQIYwYL+x5mpABUgK8H0jgmH47IC/U38Sl1fBnwV+GryzuYILwd+GTl5ENPmyzNONkzx2xg7PklP2ujLtHqtNdJxov3YljQBEibW1t7Y34CVW/Wngt3vv9MXxB4sPd5w5CBY+6PESTvihCUzU7JzF68uCwzrnSnKudCx1MZmJUxo/itWTP+bMeWX7PEW7s46ZGSdq00IA+uYfou4DkEG9vX2W7Weqz8gBccjcAQNPRfnNuUjcCQPB6a7BZIMqBI32SfBVjhZNtm6sxPFL48HglX5XtM2OeWa7zFhWm+VbP6NPAgrYXOX3VH8fwFT9qEqg+rvq76izRxQZfEVlQXcOJ4nDBdgZY6TZKoZ6ZpLFo4iq8JZHj1Htf1X7K8bNjDnTZiCAyPLPxvs4LnUEiaW/HaifCPyReEXEkSGfM22/nO82OaKTTyP4QMOLQo/M5NdnfXWf6viZ9pk263Vm2m0hwOoAUK3NxUCBsrvEkFH9YI1AN3+zFYHki0M6UBog8bCDYcth0SUHOgW3pwxyAPiJ9wvMjp6Z7Gzsx+pXPU62/RntGgFYyt/IQVnS9au3DwHL6vc6RIjWASDIBntvOMvsSkAPwBZuuu0HQBuNUwUFPd+LwZ+diFc4kPSxyQ/52H2rx6u0z7bV7ZZvkRyAEddr694BP3IFmXyAE/NHlt8iAv2fjXju1wJ/Cvhq4AzOzDZO58y4mXxClUxObX/4IvqzyU547xqOjnGkf7VvpX2p7bd8eCIJKIpLXAFTfq322jl0feCOee00qC2HYIHfUt408GFgb26n5v0JawVmiOVUgHuDpX6E+GwqEzseLRcnXz3OzDVV+3jtl5UAEKAIOhO40WO+mZifOA5KBEG7DuCJhUADIcDkZPPUJIQDil21/dP4KXYsNs9g46HNgYGrkz1/UucRwHrMo+c527/abwwBdgLoSIAou1bjSNU98jD/81Ct/t7/IyAuRPocAH9F9be2pEM0x+l+tTEag03u11H55Zy2yTZzURUUH2xbBVDmcEfGfOy+yzfrEMBaCrzfTAbsiBwyYcGg/oSEAOu9sKi2oe2fUP3WJQnacN4XbH84lp6VB9xJZoKn25RPPD3yaQ2PAC5zEkfHP9I/03cjAAbgAegHFv9YBMEsPyqsPgcNbNaWgb+bh4QsNLHgjWV9Q4IxZoZFIubxghmWcRWZSVrgj/xwb8Df/VYZMEY/7hVjPBAAgIIqvKHGkfJ3Y0UEsl99+L4AaQcoxLmm593Z4Gfz2pvrw76kg5giBXIiV+EwHDdsEE336/efAaiZszzzuEfHWr7508k7ARXIEMjMGZhKnnkpKGnDxhu2ESWfAX8K0Jn/ZwBmgjn3E7Y/i5uIWDITM3uszFgdYV01cPVEgvZHwXP0dK46fmXc5Zs+nZcBN8BFqn10v7H8V5NMZ7kTVYHBoicBTMkgqaqhC3AaRHiJ9m8TccJZeBM4dUw2wIHrjABVmdjkJ2nDV8eJzuus/VeelzX2RgCDwnuLghxV74CbedQ3Uy5MvBQkUn53P7odreIJUFnzvdueGKdq+b3xLwF2NqE/zRxnweiDNc6VpLD+Uo0AGnjBWg92f6dVur2yNFhA59h4nEfb5+T6fw2MCPxU9ZV8mG3UXKNzn1yjnqIRZtz9RXIpinaIplkiCgd+08D9Bc4ihuUbMQRQkzXrDBAv4UNBcllR+IDK/Ejgb5MZZnVEIJ7V9J4M9EAdEUI7ZqZhVrkzZJawFslTegPvR/gFMiSxEYBW2PX7oPIROWTe+JsIHzoygS/6fDTwjiq/Bv8s8BmJAOfR2x6BxnMW1dDBIyxrTkbnt/VzGqX6PwIgjhxCX0MGXEeO9xh912t4IIAo5nfAj2o0kAaqeDLb341hHNcDf/QEoAvsI8lCA4nW5D/iAE5558ABxR/O/SDCD3a/DCuZ83q/E8HyDZ/mVAF2pCEoKcizdj5DJEIaVfAnlgJXwT/lApxS3wzoM2DLTNSK8mfHE+UvtS/A9apxM6fwlMeW81vJ5WrnsREAA/W2LQHsVMyfGKez/gr8Q1ignEXm8V8PzFXXYIHJUmY2mWbIwPq/EvWEzkzeTJuQNMgg2XEzIJwJb6rjHgp7zjrYI43D3MryX8EBWHZ+VvUtEmGAbseAGUSPWwT/2apvglntOAv0bRwDWRnAXdYmM/BkEvKpgZm8tEeC7nWH6QhgRvVdkColt9rKcT1ioC4gsP0V8LttjUnMwFkBvjXJhu2EFGcBEk3saL8cN5uHmD3PaMpnzzMax9v/GMc4cn5n9N0IANXXBWnmPQCi0Enwb8AO2mbAXwFw1fJXiKQBxLg7FYJAR8aGiyboZfvVwNFxMhN1ZoyZPplzie5hZYzXve3y9RICEBAOZJAEdQnQxpiuG3DWBWA//RnJhu5TdyskFTIDKwBPtU2qfwQGb3/Ut/utEo0TTUxczPSd6ZMF5pVjZ88hanfkHDcCiAC7HSAqFQJthi4icAlU8YMyImPtAcAOmLBtCHzCHikwR6GEvtMnVxQY6ZFD2vMt8TDTjFN5yj5Xgisa29t/BNSV4y5f/6nj04ADABNZfI8kqJor5XcVPwF+D7RybimSgF/PHDNQ5YhAPCC2vkl3EYF6VvlpP7VxZpJW+lTasntbAYLVduYcKse9evzoXJav+9RX6wBkMnUKfgH4U+VFDcTkcmANCAR/SBIF8M+CPOUUCDnijZwB9UyfDlSJmZpo0s3HTPtMm7McRMkNRcgK9s9e18HDDt03AugArx7qMfftQ0XKP+MmvD4U4HguhDi8PpV9mfUGTJFToJdrMGaGNWHO2u46iYCQjgAwC4RsuyxRZoA0c8xo3CvGjI7p3dvla4kD2Dqom06JIOsOEs8A4A9jOZCzwV9yBKpxBtSZNt01JY5h3cwzicA7p84VZGZech1AFhjZdjPneYTIop+iet7ReGed60YAFuBc9T8R/IPiF2N+Rh6RWtM+xEmIw/EmlEckacA6KnsGuL0JaO5LJv2ykztqF+2fBXV23LNApcc5cnyPCM4Yd/kv6ACyoM62q7wSTD+BaDiQlAuYLBNSIBeAGRGBSQbkTlZAf0bb4dySbqQ62TOTNtPGDVkIarJjnkkCR45Z/V1nHMPa5xUBwEQ/TfnhF3DHJC8TYa7gKPhLqg8Hi4Bd3W9ZbDZhzgB3ZYx2bs7szUzsqM3R/Y/pBqJzPZM0HgP4eD0bAaTi/WxeoBDvD6SQIAzG/K1bslJgEUF3o48+XUhi32EiFev8WYKYAjzOPBCDSFkicHj7o75Zlc+MQy4vurS2vzp+9ryvtveZ81i+5lPGMiBT3zRJ7J3Tig9UHvVxHYC6SxmQm22csVwC2q8lcgTbGGRWHQF4tq83KbYxjNkegWAW6NG4mUk84wYyx50Zt3K+FgFUzu2o+9gIIALeVeBHuxmdQxb8VeAP48IAEZCn9zvHsCZQFuDZdvQ4CeWPJudTE0F0fjNOoDLmEQKoHmfmWjRhLF8dOQA1KVygFpKDrwP4B7IwgDkNdOYIDJBlgXt2O7wPenJEE3IG7DN9qhM9Ou8rx5slgMo5zzoT5hY2AjBBfTL48cfZhs6+OhzOvANtArBpR5AA5mEiIHc5GjPrCLLEcIXyW5O3uj07sTNgybTJgjU7Vna8KtEebe/1X/6z5QAmwT+AnL1g9CD4hTzcsMAiDba9mPCLQEv3G2RlTfoMoDNtvEnZ+quBZlR6Buwzx7lCvTMAz7SZIYDsuFlyZCrvnddGAIMDCMDfgbxCFIkKgUcg2q6m1X3/VWj7yTUD7Ec1iSHhLrJEcAT0dLIVKxHRRKwSQQSAq/dH15PdX2030z76LRj4oz7LV2kHQJRqIAgB1GOD31DRChF0bR3lM8GcKO91fYvuwmJr73y8yeQSRlL5zwL1rOJHk/jo/oxyR8e4GtDZ41fPoyeAQhKvVBk4Q/kD8FdIYLvhCTLxQozIAWzDBwCLQB3tj87BnQwTyl8hgkrbzKSNAHD1/gxJZNtkrhfVPLo2rfyV9hsBlMH8RMpfBjn8MpbyZ8asEEEbT/1GFZWOgB/tD13EBcpfBfwVbiCa+FfvrwA7OpfKWLNksZ7D8p8+lFwI9AS2H1U0A1Rp47YlwLTaTwF/7xSB9Oj+I+pfeX15SCYGyWYm5etGAhlQPmabqxwFjrsRgAaO+f0k5ccTcI+dBGuaHJLjReByCSNQ16PAj/qHgIUBKqrN2h7tH6ncFQQRgSoCeLQ/Gj+65gxxasufPSZrt/zHrAN4jcCfBjyG4RPPCZQdgAOuCLgeqUSEFIIeZt0VQD46pjeBryCBCMRX788CNjqPCplYx9wIIHQAB8GfVvwT3gNAgTQBflflme0l7qJCIDMgzwCvtQmcSZpECi82rTiECBTVsWbHi/pl9kdtzgT20bGW/xA5gNcc/K4bOAh8D8DdD3/kPygplhVLoL9Q+TPnESlUFdTV9rPOIgLw0f1HQRv9rjpE8I63EYDpAF5D8LuAP2j5o7GpSkMn/UNXvlfaZtxCa3Oh8lcAWWk7C9yzjpEFmAes2X3ZY2dIKNNm+feWA3hC8FeASNuS9QxZNbeOTfur38i6edkxI2BnVFc7kyPWPnO8yvhntI0m9WOSwBGQRy7g6P4skWwEMDiASfDjzTFdxX5m3f4CYCNyyCzwicZIkQUBv6fiFYWvtDVB9cjKnyWLqrqfBehZsM4CcbZfFrjR+BFRynGWf6cdwCT4GahSJBCAPwJrtx++6GOnQK3icVO5T3p+oAL0qG13fYScvImVAW/p+CoIzYxfPb8qkUSAuIIgZseMzjWzP9NmPb+NABpYXgPwlwAPE02vZjwT8BHJsMn7ZG6AzLoMAM9qU7H5Z6j7GWNkVLd6nCwAFVe2r5HCn7V/+crVAVSeAUALbyjhrPJ7LsIC9NaHKN4lDsBQVtMpOI7CIyg2ebxjzKr/DOgzfSok8NhtI2CeCfQjID3SN7pG3L985cvEOgAE/ZFXfSceCio7AMO1uIShriflFhySqQL2DMKgx0yofwbAnnupALYCpsx5PUaY8H4ILSoAjxzG8hUvi88C7Ee3VB5PjrZJuA02BgVp4EBSwM7E/cn1BBVV90A2tQ86RQCOCCuz/ygRZAF/lETOBLSnypXz9Igssy8igIp7WP7tTgAhcCfVuyOBE8DfLq4A/shVuERhAGsKpBeFBNH/gmRNqogoov2PRQJHj/MYJDBDDkeAPHs8fcxGAJaiVwHMwLZtS4Df7Kst+8HKgQX44fj7hizYz24XKbH8rmjzItAe3R+dU9WmZ53AB5UEZoE8228ggH+TdQAFADMgpQhGAZ0SAlHkSOGj/VZ4MRNCZPvMtuv6JQgqA9gqKWTBmAV3tl32uGcpvgWy6vZZpT8L5CgQlAA85a2qtwZ6RflDB5AEfwT4aL+21Fb7LIhn+kfAzfzHIhVgR22j8zmq/BVQZc61SgKV41fH9n6bWXI4q9/y5SoJiAMfBb9Xm7ccwXB8cQVE7QayIW8groI0s5KwOmYEHm9Cm/suUP+MEp/V5oiaV8B6VdsZEphR9Jk+FXLYCMAE0oTtb2OpCZoBq+kAjLFMsgDP4x33TOsfugohMnJuEUEM56lmRaSIV+/PnP8RwGfHrxzjyrZnksPlBPBlRhlwxrpnwW8CnWXJC0RymBCS5b4zwV5Wf+hwBNhH+lqW9rHdwVF1P9r/dQZ6ljiWlQC0SjIbPLRRilYFv0cC7Yc9WOrLAFWf94y9n+ljnZurdie8YnzquMS9PAUJHAVshqCs63oMsFeuzzvPaB8eZ/lS7QCU4jJVNckgUGurH1XuiVJfilSYFTdUtUIgR0nA67/tU7OjouBll2GEKVnQZ4EWXUPFps8es3KM15EEskoPt3T7KP02AojUO0UCk+CnoCWAzII7Au2w3yG8o6COzoUBioKCnKPrFBjJqRlQcQLVY2WJIjNuBaCvIwlUVX0G0NVjdATwMXEAAYBdEnhC8Ecgc/efGPNH5xFNdhOQRdt/ptpHCh3tj675CFE8JTFUjv2UriFz7GUlgOp/DNKRwUHwdxPfUeMjDoCCq5BfOOoEZvpr2x+BLavolXEyAM6obnTMzHEqoMuc09HxKv2rbTPAVYZO/ydUbXfkKP4/BnecprBuissAAAAASUVORK5CYII=\", e;\n  }(), Ta.TextureTools = Ea, xa = $a || ($a = {}), Pa = function () {\n    function p() {\n      this._mode = p.FitFrustumSidesMode, this._radiusScale = 1, this._positionScale = .5, this._defaultElevation = .3, this._elevationReturnTime = 1500, this._elevationReturnWaitTime = 1e3, this._zoomStopsAnimation = !1, this._framingTime = 1500, this.autoCorrectCameraLimitsAndSensibility = !0, this._isPointerDown = !1, this._lastInteractionTime = -1 / 0, this._animatables = new Array(), this._betaIsAnimating = !1;\n    }\n\n    return Object.defineProperty(p.prototype, \"name\", {\n      get: function () {\n        return \"Framing\";\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"mode\", {\n      get: function () {\n        return this._mode;\n      },\n      set: function (e) {\n        this._mode = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"radiusScale\", {\n      get: function () {\n        return this._radiusScale;\n      },\n      set: function (e) {\n        this._radiusScale = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"positionScale\", {\n      get: function () {\n        return this._positionScale;\n      },\n      set: function (e) {\n        this._positionScale = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"defaultElevation\", {\n      get: function () {\n        return this._defaultElevation;\n      },\n      set: function (e) {\n        this._defaultElevation = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"elevationReturnTime\", {\n      get: function () {\n        return this._elevationReturnTime;\n      },\n      set: function (e) {\n        this._elevationReturnTime = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"elevationReturnWaitTime\", {\n      get: function () {\n        return this._elevationReturnWaitTime;\n      },\n      set: function (e) {\n        this._elevationReturnWaitTime = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"zoomStopsAnimation\", {\n      get: function () {\n        return this._zoomStopsAnimation;\n      },\n      set: function (e) {\n        this._zoomStopsAnimation = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(p.prototype, \"framingTime\", {\n      get: function () {\n        return this._framingTime;\n      },\n      set: function (e) {\n        this._framingTime = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), p.prototype.init = function () {}, p.prototype.attach = function (e) {\n      var t = this;\n      this._attachedCamera = e;\n\n      var i = this._attachedCamera.getScene();\n\n      p.EasingFunction.setEasingMode(p.EasingMode), this._onPrePointerObservableObserver = i.onPrePointerObservable.add(function (e) {\n        e.type !== xa.PointerEventTypes.POINTERDOWN ? e.type === xa.PointerEventTypes.POINTERUP && (t._isPointerDown = !1) : t._isPointerDown = !0;\n      }), this._onMeshTargetChangedObserver = e.onMeshTargetChangedObservable.add(function (e) {\n        e && t.zoomOnMesh(e);\n      }), this._onAfterCheckInputsObserver = e.onAfterCheckInputsObservable.add(function () {\n        t._applyUserInteraction(), t._maintainCameraAboveGround();\n      });\n    }, p.prototype.detach = function () {\n      if (this._attachedCamera) {\n        var e = this._attachedCamera.getScene();\n\n        this._onPrePointerObservableObserver && e.onPrePointerObservable.remove(this._onPrePointerObservableObserver), this._onAfterCheckInputsObserver && this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver), this._onMeshTargetChangedObserver && this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver), this._attachedCamera = null;\n      }\n    }, p.prototype.zoomOnMesh = function (e, t, i) {\n      void 0 === t && (t = !1), void 0 === i && (i = null), e.computeWorldMatrix(!0);\n      var r = e.getBoundingInfo().boundingBox;\n      this.zoomOnBoundingInfo(r.minimumWorld, r.maximumWorld, t, i);\n    }, p.prototype.zoomOnMeshHierarchy = function (e, t, i) {\n      void 0 === t && (t = !1), void 0 === i && (i = null), e.computeWorldMatrix(!0);\n      var r = e.getHierarchyBoundingVectors(!0);\n      this.zoomOnBoundingInfo(r.min, r.max, t, i);\n    }, p.prototype.zoomOnMeshesHierarchy = function (e, t, i) {\n      void 0 === t && (t = !1), void 0 === i && (i = null);\n\n      for (var r = new xa.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new xa.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), o = 0; o < e.length; o++) {\n        var s = e[o].getHierarchyBoundingVectors(!0);\n        xa.Tools.CheckExtends(s.min, r, n), xa.Tools.CheckExtends(s.max, r, n);\n      }\n\n      this.zoomOnBoundingInfo(r, n, t, i);\n    }, p.prototype.zoomOnBoundingInfo = function (e, t, i, r) {\n      var n,\n          o = this;\n\n      if (void 0 === i && (i = !1), void 0 === r && (r = null), this._attachedCamera) {\n        var s = e.y,\n            a = s + (t.y - s) * this._positionScale,\n            l = t.subtract(e).scale(.5);\n        if (i) n = new xa.Vector3(0, a, 0);else {\n          var c = e.add(l);\n          n = new xa.Vector3(c.x, a, c.z);\n        }\n        this._vectorTransition || (this._vectorTransition = xa.Animation.CreateAnimation(\"target\", xa.Animation.ANIMATIONTYPE_VECTOR3, 60, p.EasingFunction)), this._betaIsAnimating = !0;\n        var h = xa.Animation.TransitionTo(\"target\", n, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\n        h && this._animatables.push(h);\n        var u = 0;\n\n        if (this._mode === p.FitFrustumSidesMode) {\n          var d = this._calculateLowerRadiusFromModelBoundingSphere(e, t);\n\n          this.autoCorrectCameraLimitsAndSensibility && (this._attachedCamera.lowerRadiusLimit = l.length() + this._attachedCamera.minZ), u = d;\n        } else this._mode === p.IgnoreBoundsSizeMode && (u = this._calculateLowerRadiusFromModelBoundingSphere(e, t), this.autoCorrectCameraLimitsAndSensibility && null === this._attachedCamera.lowerRadiusLimit && (this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ));\n\n        if (this.autoCorrectCameraLimitsAndSensibility) {\n          var f = t.subtract(e).length();\n          this._attachedCamera.panningSensibility = 5e3 / f, this._attachedCamera.wheelPrecision = 100 / u;\n        }\n\n        this._radiusTransition || (this._radiusTransition = xa.Animation.CreateAnimation(\"radius\", xa.Animation.ANIMATIONTYPE_FLOAT, 60, p.EasingFunction)), (h = xa.Animation.TransitionTo(\"radius\", u, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, function () {\n          o.stopAllAnimations(), r && r(), o._attachedCamera && o._attachedCamera.useInputToRestoreState && o._attachedCamera.storeState();\n        })) && this._animatables.push(h);\n      }\n    }, p.prototype._calculateLowerRadiusFromModelBoundingSphere = function (e, t) {\n      var i = t.subtract(e).length(),\n          r = this._getFrustumSlope(),\n          n = .5 * i * this._radiusScale,\n          o = n * Math.sqrt(1 + 1 / (r.x * r.x)),\n          s = n * Math.sqrt(1 + 1 / (r.y * r.y)),\n          a = Math.max(o, s),\n          l = this._attachedCamera;\n\n      return l ? (l.lowerRadiusLimit && this._mode === p.IgnoreBoundsSizeMode && (a = a < l.lowerRadiusLimit ? l.lowerRadiusLimit : a), l.upperRadiusLimit && (a = a > l.upperRadiusLimit ? l.upperRadiusLimit : a), a) : 0;\n    }, p.prototype._maintainCameraAboveGround = function () {\n      var e = this;\n\n      if (!(this._elevationReturnTime < 0)) {\n        var t = xa.Tools.Now - this._lastInteractionTime,\n            i = .5 * Math.PI - this._defaultElevation,\n            r = .5 * Math.PI;\n\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > r && t >= this._elevationReturnWaitTime) {\n          this._betaIsAnimating = !0, this.stopAllAnimations(), this._betaTransition || (this._betaTransition = xa.Animation.CreateAnimation(\"beta\", xa.Animation.ANIMATIONTYPE_FLOAT, 60, p.EasingFunction));\n          var n = xa.Animation.TransitionTo(\"beta\", i, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, function () {\n            e._clearAnimationLocks(), e.stopAllAnimations();\n          });\n          n && this._animatables.push(n);\n        }\n      }\n    }, p.prototype._getFrustumSlope = function () {\n      var e = this._attachedCamera;\n      if (!e) return xa.Vector2.Zero();\n      var t = e.getScene().getEngine().getAspectRatio(e),\n          i = Math.tan(e.fov / 2),\n          r = i * t;\n      return new xa.Vector2(r, i);\n    }, p.prototype._clearAnimationLocks = function () {\n      this._betaIsAnimating = !1;\n    }, p.prototype._applyUserInteraction = function () {\n      this.isUserIsMoving && (this._lastInteractionTime = xa.Tools.Now, this.stopAllAnimations(), this._clearAnimationLocks());\n    }, p.prototype.stopAllAnimations = function () {\n      for (this._attachedCamera && (this._attachedCamera.animations = []); this._animatables.length;) this._animatables[0] && (this._animatables[0].onAnimationEnd = null, this._animatables[0].stop()), this._animatables.shift();\n    }, Object.defineProperty(p.prototype, \"isUserIsMoving\", {\n      get: function () {\n        return !!this._attachedCamera && (0 !== this._attachedCamera.inertialAlphaOffset || 0 !== this._attachedCamera.inertialBetaOffset || 0 !== this._attachedCamera.inertialRadiusOffset || 0 !== this._attachedCamera.inertialPanningX || 0 !== this._attachedCamera.inertialPanningY || this._isPointerDown);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), p.EasingFunction = new xa.ExponentialEase(), p.EasingMode = xa.EasingFunction.EASINGMODE_EASEINOUT, p.IgnoreBoundsSizeMode = 0, p.FitFrustumSidesMode = 1, p;\n  }(), xa.FramingBehavior = Pa, Aa = $a || ($a = {}), Sa = function () {\n    function r() {\n      this.transitionDuration = 450, this.lowerRadiusTransitionRange = 2, this.upperRadiusTransitionRange = -2, this._autoTransitionRange = !1, this._radiusIsAnimating = !1, this._radiusBounceTransition = null, this._animatables = new Array();\n    }\n\n    return Object.defineProperty(r.prototype, \"name\", {\n      get: function () {\n        return \"Bouncing\";\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"autoTransitionRange\", {\n      get: function () {\n        return this._autoTransitionRange;\n      },\n      set: function (e) {\n        var i = this;\n\n        if (this._autoTransitionRange !== e) {\n          this._autoTransitionRange = e;\n          var t = this._attachedCamera;\n          t && (e ? this._onMeshTargetChangedObserver = t.onMeshTargetChangedObservable.add(function (e) {\n            if (e) {\n              e.computeWorldMatrix(!0);\n              var t = e.getBoundingInfo().diagonalLength;\n              i.lowerRadiusTransitionRange = .05 * t, i.upperRadiusTransitionRange = .05 * t;\n            }\n          }) : this._onMeshTargetChangedObserver && t.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver));\n        }\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype.init = function () {}, r.prototype.attach = function (e) {\n      var t = this;\n      this._attachedCamera = e, this._onAfterCheckInputsObserver = e.onAfterCheckInputsObservable.add(function () {\n        t._attachedCamera && (t._isRadiusAtLimit(t._attachedCamera.lowerRadiusLimit) && t._applyBoundRadiusAnimation(t.lowerRadiusTransitionRange), t._isRadiusAtLimit(t._attachedCamera.upperRadiusLimit) && t._applyBoundRadiusAnimation(t.upperRadiusTransitionRange));\n      });\n    }, r.prototype.detach = function () {\n      this._attachedCamera && (this._onAfterCheckInputsObserver && this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver), this._onMeshTargetChangedObserver && this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver), this._attachedCamera = null);\n    }, r.prototype._isRadiusAtLimit = function (e) {\n      return !!this._attachedCamera && this._attachedCamera.radius === e && !this._radiusIsAnimating;\n    }, r.prototype._applyBoundRadiusAnimation = function (e) {\n      var t = this;\n\n      if (this._attachedCamera) {\n        this._radiusBounceTransition || (r.EasingFunction.setEasingMode(r.EasingMode), this._radiusBounceTransition = Aa.Animation.CreateAnimation(\"radius\", Aa.Animation.ANIMATIONTYPE_FLOAT, 60, r.EasingFunction)), this._cachedWheelPrecision = this._attachedCamera.wheelPrecision, this._attachedCamera.wheelPrecision = 1 / 0, this._attachedCamera.inertialRadiusOffset = 0, this.stopAllAnimations(), this._radiusIsAnimating = !0;\n        var i = Aa.Animation.TransitionTo(\"radius\", this._attachedCamera.radius + e, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, function () {\n          return t._clearAnimationLocks();\n        });\n        i && this._animatables.push(i);\n      }\n    }, r.prototype._clearAnimationLocks = function () {\n      this._radiusIsAnimating = !1, this._attachedCamera && (this._attachedCamera.wheelPrecision = this._cachedWheelPrecision);\n    }, r.prototype.stopAllAnimations = function () {\n      for (this._attachedCamera && (this._attachedCamera.animations = []); this._animatables.length;) this._animatables[0].onAnimationEnd = null, this._animatables[0].stop(), this._animatables.shift();\n    }, r.EasingFunction = new Aa.BackEase(.3), r.EasingMode = Aa.EasingFunction.EASINGMODE_EASEOUT, r;\n  }(), Aa.BouncingBehavior = Sa, Ma = $a || ($a = {}), Ra = function () {\n    function e() {\n      this._zoomStopsAnimation = !1, this._idleRotationSpeed = .05, this._idleRotationWaitTime = 2e3, this._idleRotationSpinupTime = 2e3, this._isPointerDown = !1, this._lastFrameTime = null, this._lastInteractionTime = -1 / 0, this._cameraRotationSpeed = 0, this._lastFrameRadius = 0;\n    }\n\n    return Object.defineProperty(e.prototype, \"name\", {\n      get: function () {\n        return \"AutoRotation\";\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"zoomStopsAnimation\", {\n      get: function () {\n        return this._zoomStopsAnimation;\n      },\n      set: function (e) {\n        this._zoomStopsAnimation = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"idleRotationSpeed\", {\n      get: function () {\n        return this._idleRotationSpeed;\n      },\n      set: function (e) {\n        this._idleRotationSpeed = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"idleRotationWaitTime\", {\n      get: function () {\n        return this._idleRotationWaitTime;\n      },\n      set: function (e) {\n        this._idleRotationWaitTime = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"idleRotationSpinupTime\", {\n      get: function () {\n        return this._idleRotationSpinupTime;\n      },\n      set: function (e) {\n        this._idleRotationSpinupTime = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"rotationInProgress\", {\n      get: function () {\n        return 0 < Math.abs(this._cameraRotationSpeed);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.init = function () {}, e.prototype.attach = function (e) {\n      var n = this;\n      this._attachedCamera = e;\n\n      var t = this._attachedCamera.getScene();\n\n      this._onPrePointerObservableObserver = t.onPrePointerObservable.add(function (e) {\n        e.type !== Ma.PointerEventTypes.POINTERDOWN ? e.type === Ma.PointerEventTypes.POINTERUP && (n._isPointerDown = !1) : n._isPointerDown = !0;\n      }), this._onAfterCheckInputsObserver = e.onAfterCheckInputsObservable.add(function () {\n        var e = Ma.Tools.Now,\n            t = 0;\n        null != n._lastFrameTime && (t = e - n._lastFrameTime), n._lastFrameTime = e, n._applyUserInteraction();\n        var i = e - n._lastInteractionTime - n._idleRotationWaitTime,\n            r = Math.max(Math.min(i / n._idleRotationSpinupTime, 1), 0);\n        n._cameraRotationSpeed = n._idleRotationSpeed * r, n._attachedCamera && (n._attachedCamera.alpha -= n._cameraRotationSpeed * (t / 1e3));\n      });\n    }, e.prototype.detach = function () {\n      if (this._attachedCamera) {\n        var e = this._attachedCamera.getScene();\n\n        this._onPrePointerObservableObserver && e.onPrePointerObservable.remove(this._onPrePointerObservableObserver), this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver), this._attachedCamera = null;\n      }\n    }, e.prototype._userIsZooming = function () {\n      return !!this._attachedCamera && 0 !== this._attachedCamera.inertialRadiusOffset;\n    }, e.prototype._shouldAnimationStopForInteraction = function () {\n      if (!this._attachedCamera) return !1;\n      var e = !1;\n      return this._lastFrameRadius === this._attachedCamera.radius && 0 !== this._attachedCamera.inertialRadiusOffset && (e = !0), this._lastFrameRadius = this._attachedCamera.radius, this._zoomStopsAnimation ? e : this._userIsZooming();\n    }, e.prototype._applyUserInteraction = function () {\n      this._userIsMoving() && !this._shouldAnimationStopForInteraction() && (this._lastInteractionTime = Ma.Tools.Now);\n    }, e.prototype._userIsMoving = function () {\n      return !!this._attachedCamera && (0 !== this._attachedCamera.inertialAlphaOffset || 0 !== this._attachedCamera.inertialBetaOffset || 0 !== this._attachedCamera.inertialRadiusOffset || 0 !== this._attachedCamera.inertialPanningX || 0 !== this._attachedCamera.inertialPanningY || this._isPointerDown);\n    }, e;\n  }(), Ma.AutoRotationBehavior = Ra, function (d) {\n    var r = function () {\n      this.renderWidth = 512, this.renderHeight = 256, this.textureSize = 512, this.deterministicLockstep = !1, this.lockstepMaxSteps = 4;\n    };\n\n    d.NullEngineOptions = r;\n\n    var e = function (i) {\n      function e(e) {\n        void 0 === e && (e = new r());\n        var t = i.call(this, null) || this;\n        return void 0 === e.deterministicLockstep && (e.deterministicLockstep = !1), void 0 === e.lockstepMaxSteps && (e.lockstepMaxSteps = 4), t._options = e, t._caps = new d.EngineCapabilities(), t._caps.maxTexturesImageUnits = 16, t._caps.maxVertexTextureImageUnits = 16, t._caps.maxTextureSize = 512, t._caps.maxCubemapTextureSize = 512, t._caps.maxRenderTextureSize = 512, t._caps.maxVertexAttribs = 16, t._caps.maxVaryingVectors = 16, t._caps.maxFragmentUniformVectors = 16, t._caps.maxVertexUniformVectors = 16, t._caps.standardDerivatives = !1, t._caps.astc = null, t._caps.s3tc = null, t._caps.pvrtc = null, t._caps.etc1 = null, t._caps.etc2 = null, t._caps.textureAnisotropicFilterExtension = null, t._caps.maxAnisotropy = 0, t._caps.uintIndices = !1, t._caps.fragmentDepthSupported = !1, t._caps.highPrecisionShaderSupported = !0, t._caps.colorBufferFloat = !1, t._caps.textureFloat = !1, t._caps.textureFloatLinearFiltering = !1, t._caps.textureFloatRender = !1, t._caps.textureHalfFloat = !1, t._caps.textureHalfFloatLinearFiltering = !1, t._caps.textureHalfFloatRender = !1, t._caps.textureLOD = !1, t._caps.drawBuffersExtension = !1, t._caps.depthTextureExtension = !1, t._caps.vertexArrayObject = !1, t._caps.instancedArrays = !1, d.Tools.Log(\"Babylon.js null engine (v\" + d.Engine.Version + \") launched\"), \"undefined\" == typeof URL && (URL = {\n          createObjectURL: function () {},\n          revokeObjectURL: function () {}\n        }), \"undefined\" == typeof Blob && (Blob = function () {}), t;\n      }\n\n      return T(e, i), e.prototype.isDeterministicLockStep = function () {\n        return this._options.deterministicLockstep;\n      }, e.prototype.getLockstepMaxSteps = function () {\n        return this._options.lockstepMaxSteps;\n      }, e.prototype.getHardwareScalingLevel = function () {\n        return 1;\n      }, e.prototype.createVertexBuffer = function (e) {\n        return {\n          capacity: 0,\n          references: 1,\n          is32Bits: !1\n        };\n      }, e.prototype.createIndexBuffer = function (e) {\n        return {\n          capacity: 0,\n          references: 1,\n          is32Bits: !1\n        };\n      }, e.prototype.clear = function (e, t, i, r) {\n        void 0 === r && (r = !1);\n      }, e.prototype.getRenderWidth = function (e) {\n        return void 0 === e && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._options.renderWidth;\n      }, e.prototype.getRenderHeight = function (e) {\n        return void 0 === e && (e = !1), !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._options.renderHeight;\n      }, e.prototype.setViewport = function (e, t, i) {\n        this._cachedViewport = e;\n      }, e.prototype.createShaderProgram = function (e, t, i, r) {\n        return {\n          transformFeedback: null,\n          __SPECTOR_rebuildProgram: null\n        };\n      }, e.prototype.getUniforms = function (e, t) {\n        return [];\n      }, e.prototype.getAttributes = function (e, t) {\n        return [];\n      }, e.prototype.bindSamplers = function (e) {\n        this._currentEffect = null;\n      }, e.prototype.enableEffect = function (e) {\n        (this._currentEffect = e).onBind && e.onBind(e), e._onBindObservable && e._onBindObservable.notifyObservers(e);\n      }, e.prototype.setState = function (e, t, i, r) {\n        void 0 === t && (t = 0), void 0 === r && (r = !1);\n      }, e.prototype.setIntArray = function (e, t) {}, e.prototype.setIntArray2 = function (e, t) {}, e.prototype.setIntArray3 = function (e, t) {}, e.prototype.setIntArray4 = function (e, t) {}, e.prototype.setFloatArray = function (e, t) {}, e.prototype.setFloatArray2 = function (e, t) {}, e.prototype.setFloatArray3 = function (e, t) {}, e.prototype.setFloatArray4 = function (e, t) {}, e.prototype.setArray = function (e, t) {}, e.prototype.setArray2 = function (e, t) {}, e.prototype.setArray3 = function (e, t) {}, e.prototype.setArray4 = function (e, t) {}, e.prototype.setMatrices = function (e, t) {}, e.prototype.setMatrix = function (e, t) {}, e.prototype.setMatrix3x3 = function (e, t) {}, e.prototype.setMatrix2x2 = function (e, t) {}, e.prototype.setFloat = function (e, t) {}, e.prototype.setFloat2 = function (e, t, i) {}, e.prototype.setFloat3 = function (e, t, i, r) {}, e.prototype.setBool = function (e, t) {}, e.prototype.setFloat4 = function (e, t, i, r, n) {}, e.prototype.setColor3 = function (e, t) {}, e.prototype.setColor4 = function (e, t, i) {}, e.prototype.setAlphaMode = function (e, t) {\n        void 0 === t && (t = !1), this._alphaMode !== e && (this._alphaState.alphaBlend = e !== d.Engine.ALPHA_DISABLE, t || this.setDepthWrite(e === d.Engine.ALPHA_DISABLE), this._alphaMode = e);\n      }, e.prototype.bindBuffers = function (e, t, i) {}, e.prototype.wipeCaches = function (e) {\n        this.preventCacheWipeBetweenFrames || (this.resetTextureCache(), this._currentEffect = null, e && (this._currentProgram = null, this._stencilState.reset(), this._depthCullingState.reset(), this._alphaState.reset()), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null);\n      }, e.prototype.draw = function (e, t, i, r) {}, e.prototype.drawElementsType = function (e, t, i, r) {}, e.prototype.drawArraysType = function (e, t, i, r) {}, e.prototype._createTexture = function () {\n        return {};\n      }, e.prototype._releaseTexture = function (e) {}, e.prototype.createTexture = function (e, t, i, r, n, o, s, a, l, c) {\n        void 0 === n && (n = d.Texture.TRILINEAR_SAMPLINGMODE), void 0 === o && (o = null), void 0 === s && (s = null), void 0 === a && (a = null);\n        var h = new d.InternalTexture(this, d.InternalTexture.DATASOURCE_URL),\n            u = String(e);\n        return h.url = u, h.generateMipMaps = !t, h.samplingMode = n, h.invertY = i, h.baseWidth = this._options.textureSize, h.baseHeight = this._options.textureSize, h.width = this._options.textureSize, h.height = this._options.textureSize, c && (h.format = c), h.isReady = !0, o && o(), this._internalTexturesCache.push(h), h;\n      }, e.prototype.createRenderTargetTexture = function (e, t) {\n        var i = new d.RenderTargetCreationOptions();\n        void 0 !== t && \"object\" == typeof t ? (i.generateMipMaps = t.generateMipMaps, i.generateDepthBuffer = void 0 === t.generateDepthBuffer || t.generateDepthBuffer, i.generateStencilBuffer = i.generateDepthBuffer && t.generateStencilBuffer, i.type = void 0 === t.type ? d.Engine.TEXTURETYPE_UNSIGNED_INT : t.type, i.samplingMode = void 0 === t.samplingMode ? d.Texture.TRILINEAR_SAMPLINGMODE : t.samplingMode) : (i.generateMipMaps = t, i.generateDepthBuffer = !0, i.generateStencilBuffer = !1, i.type = d.Engine.TEXTURETYPE_UNSIGNED_INT, i.samplingMode = d.Texture.TRILINEAR_SAMPLINGMODE);\n        var r = new d.InternalTexture(this, d.InternalTexture.DATASOURCE_RENDERTARGET),\n            n = e.width || e,\n            o = e.height || e;\n        return r._depthStencilBuffer = {}, r._framebuffer = {}, r.baseWidth = n, r.baseHeight = o, r.width = n, r.height = o, r.isReady = !0, r.samples = 1, r.generateMipMaps = !!i.generateMipMaps, r.samplingMode = i.samplingMode, r.type = i.type, r._generateDepthBuffer = i.generateDepthBuffer, r._generateStencilBuffer = !!i.generateStencilBuffer, this._internalTexturesCache.push(r), r;\n      }, e.prototype.updateTextureSamplingMode = function (e, t) {\n        t.samplingMode = e;\n      }, e.prototype.bindFramebuffer = function (e, t, i, r, n) {\n        this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget), this._currentRenderTarget = e, this._currentFramebuffer = e._MSAAFramebuffer ? e._MSAAFramebuffer : e._framebuffer, this._cachedViewport && !n && this.setViewport(this._cachedViewport, i, r);\n      }, e.prototype.unBindFramebuffer = function (e, t, i) {\n        void 0 === t && (t = !1), this._currentRenderTarget = null, i && (e._MSAAFramebuffer && (this._currentFramebuffer = e._framebuffer), i()), this._currentFramebuffer = null;\n      }, e.prototype.createDynamicVertexBuffer = function (e) {\n        return {\n          capacity: 1,\n          references: 1,\n          is32Bits: !1\n        };\n      }, e.prototype.updateDynamicTexture = function (e, t, i, r, n) {\n        void 0 === r && (r = !1);\n      }, e.prototype.getError = function () {\n        return 0;\n      }, e.prototype._getUnpackAlignement = function () {\n        return 1;\n      }, e.prototype._unpackFlipY = function (e) {}, e.prototype.updateDynamicIndexBuffer = function (e, t, i) {\n        void 0 === i && (i = 0);\n      }, e.prototype.updateDynamicVertexBuffer = function (e, t, i, r) {}, e.prototype._bindTextureDirectly = function (e, t) {\n        return this._boundTexturesCache[this._activeChannel] !== t && (this._boundTexturesCache[this._activeChannel] = t, !0);\n      }, e.prototype._bindTexture = function (e, t) {\n        e < 0 || this._bindTextureDirectly(0, t);\n      }, e.prototype._releaseBuffer = function (e) {\n        return e.references--, 0 === e.references;\n      }, e.prototype.releaseEffects = function () {}, e.prototype.displayLoadingUI = function () {}, e.prototype.hideLoadingUI = function () {}, e.prototype._uploadCompressedDataToTextureDirectly = function (e, t, i, r, n, o, s) {\n        void 0 === o && (o = 0), void 0 === s && (s = 0);\n      }, e.prototype._uploadDataToTextureDirectly = function (e, t, i, r) {\n        void 0 === i && (i = 0), void 0 === r && (r = 0);\n      }, e.prototype._uploadArrayBufferViewToTexture = function (e, t, i, r) {\n        void 0 === i && (i = 0), void 0 === r && (r = 0);\n      }, e.prototype._uploadImageToTexture = function (e, t, i, r) {\n        void 0 === i && (i = 0), void 0 === r && (r = 0);\n      }, e;\n    }(d.Engine);\n\n    d.NullEngine = e;\n  }($a || ($a = {})), Ca = $a || ($a = {}), Oa = function () {\n    function e(e) {\n      this.engine = e, this._captureGPUFrameTime = !1, this._gpuFrameTime = new Ca.PerfCounter(), this._captureShaderCompilationTime = !1, this._shaderCompilationTime = new Ca.PerfCounter(), this._onBeginFrameObserver = null, this._onEndFrameObserver = null, this._onBeforeShaderCompilationObserver = null, this._onAfterShaderCompilationObserver = null;\n    }\n\n    return Object.defineProperty(e.prototype, \"gpuFrameTimeCounter\", {\n      get: function () {\n        return this._gpuFrameTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureGPUFrameTime\", {\n      get: function () {\n        return this._captureGPUFrameTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureGPUFrameTime && ((this._captureGPUFrameTime = e) ? (this._onBeginFrameObserver = this.engine.onBeginFrameObservable.add(function () {\n          t._gpuFrameTimeToken || (t._gpuFrameTimeToken = t.engine.startTimeQuery());\n        }), this._onEndFrameObserver = this.engine.onEndFrameObservable.add(function () {\n          if (t._gpuFrameTimeToken) {\n            var e = t.engine.endTimeQuery(t._gpuFrameTimeToken);\n            -1 < e && (t._gpuFrameTimeToken = null, t._gpuFrameTime.fetchNewFrame(), t._gpuFrameTime.addCount(e, !0));\n          }\n        })) : (this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver), this._onBeginFrameObserver = null, this.engine.onEndFrameObservable.remove(this._onEndFrameObserver), this._onEndFrameObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"shaderCompilationTimeCounter\", {\n      get: function () {\n        return this._shaderCompilationTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureShaderCompilationTime\", {\n      get: function () {\n        return this._captureShaderCompilationTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureShaderCompilationTime && ((this._captureShaderCompilationTime = e) ? (this._onBeforeShaderCompilationObserver = this.engine.onBeforeShaderCompilationObservable.add(function () {\n          t._shaderCompilationTime.fetchNewFrame(), t._shaderCompilationTime.beginMonitoring();\n        }), this._onAfterShaderCompilationObserver = this.engine.onAfterShaderCompilationObservable.add(function () {\n          t._shaderCompilationTime.endMonitoring();\n        })) : (this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver), this._onBeforeShaderCompilationObserver = null, this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver), this._onAfterShaderCompilationObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function () {\n      this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver), this._onBeginFrameObserver = null, this.engine.onEndFrameObservable.remove(this._onEndFrameObserver), this._onEndFrameObserver = null, this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver), this._onBeforeShaderCompilationObserver = null, this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver), this._onAfterShaderCompilationObserver = null, this.engine = null;\n    }, e;\n  }(), Ca.EngineInstrumentation = Oa, Da = $a || ($a = {}), Ia = function () {\n    function e(e) {\n      var t = this;\n      this.scene = e, this._captureActiveMeshesEvaluationTime = !1, this._activeMeshesEvaluationTime = new Da.PerfCounter(), this._captureRenderTargetsRenderTime = !1, this._renderTargetsRenderTime = new Da.PerfCounter(), this._captureFrameTime = !1, this._frameTime = new Da.PerfCounter(), this._captureRenderTime = !1, this._renderTime = new Da.PerfCounter(), this._captureInterFrameTime = !1, this._interFrameTime = new Da.PerfCounter(), this._captureParticlesRenderTime = !1, this._particlesRenderTime = new Da.PerfCounter(), this._captureSpritesRenderTime = !1, this._spritesRenderTime = new Da.PerfCounter(), this._capturePhysicsTime = !1, this._physicsTime = new Da.PerfCounter(), this._captureAnimationsTime = !1, this._animationsTime = new Da.PerfCounter(), this._captureCameraRenderTime = !1, this._cameraRenderTime = new Da.PerfCounter(), this._onBeforeActiveMeshesEvaluationObserver = null, this._onAfterActiveMeshesEvaluationObserver = null, this._onBeforeRenderTargetsRenderObserver = null, this._onAfterRenderTargetsRenderObserver = null, this._onAfterRenderObserver = null, this._onBeforeDrawPhaseObserver = null, this._onAfterDrawPhaseObserver = null, this._onBeforeAnimationsObserver = null, this._onBeforeParticlesRenderingObserver = null, this._onAfterParticlesRenderingObserver = null, this._onBeforeSpritesRenderingObserver = null, this._onAfterSpritesRenderingObserver = null, this._onBeforePhysicsObserver = null, this._onAfterPhysicsObserver = null, this._onAfterAnimationsObserver = null, this._onBeforeCameraRenderObserver = null, this._onAfterCameraRenderObserver = null, this._onBeforeAnimationsObserver = e.onBeforeAnimationsObservable.add(function () {\n        t._captureActiveMeshesEvaluationTime && t._activeMeshesEvaluationTime.fetchNewFrame(), t._captureRenderTargetsRenderTime && t._renderTargetsRenderTime.fetchNewFrame(), t._captureFrameTime && (Da.Tools.StartPerformanceCounter(\"Scene rendering\"), t._frameTime.beginMonitoring()), t._captureInterFrameTime && t._interFrameTime.endMonitoring(), t._captureParticlesRenderTime && t._particlesRenderTime.fetchNewFrame(), t._captureSpritesRenderTime && t._spritesRenderTime.fetchNewFrame(), t._captureAnimationsTime && t._animationsTime.beginMonitoring(), t.scene.getEngine()._drawCalls.fetchNewFrame(), t.scene.getEngine()._textureCollisions.fetchNewFrame();\n      }), this._onAfterRenderObserver = e.onAfterRenderObservable.add(function () {\n        t._captureFrameTime && (Da.Tools.EndPerformanceCounter(\"Scene rendering\"), t._frameTime.endMonitoring()), t._captureRenderTime && t._renderTime.endMonitoring(!1), t._captureInterFrameTime && t._interFrameTime.beginMonitoring();\n      });\n    }\n\n    return Object.defineProperty(e.prototype, \"activeMeshesEvaluationTimeCounter\", {\n      get: function () {\n        return this._activeMeshesEvaluationTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureActiveMeshesEvaluationTime\", {\n      get: function () {\n        return this._captureActiveMeshesEvaluationTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureActiveMeshesEvaluationTime && ((this._captureActiveMeshesEvaluationTime = e) ? (this._onBeforeActiveMeshesEvaluationObserver = this.scene.onBeforeActiveMeshesEvaluationObservable.add(function () {\n          Da.Tools.StartPerformanceCounter(\"Active meshes evaluation\"), t._activeMeshesEvaluationTime.beginMonitoring();\n        }), this._onAfterActiveMeshesEvaluationObserver = this.scene.onAfterActiveMeshesEvaluationObservable.add(function () {\n          Da.Tools.EndPerformanceCounter(\"Active meshes evaluation\"), t._activeMeshesEvaluationTime.endMonitoring();\n        })) : (this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver), this._onBeforeActiveMeshesEvaluationObserver = null, this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver), this._onAfterActiveMeshesEvaluationObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"renderTargetsRenderTimeCounter\", {\n      get: function () {\n        return this._renderTargetsRenderTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureRenderTargetsRenderTime\", {\n      get: function () {\n        return this._captureRenderTargetsRenderTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureRenderTargetsRenderTime && ((this._captureRenderTargetsRenderTime = e) ? (this._onBeforeRenderTargetsRenderObserver = this.scene.onBeforeRenderTargetsRenderObservable.add(function () {\n          Da.Tools.StartPerformanceCounter(\"Render targets rendering\"), t._renderTargetsRenderTime.beginMonitoring();\n        }), this._onAfterRenderTargetsRenderObserver = this.scene.onAfterRenderTargetsRenderObservable.add(function () {\n          Da.Tools.EndPerformanceCounter(\"Render targets rendering\"), t._renderTargetsRenderTime.endMonitoring(!1);\n        })) : (this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver), this._onBeforeRenderTargetsRenderObserver = null, this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver), this._onAfterRenderTargetsRenderObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"particlesRenderTimeCounter\", {\n      get: function () {\n        return this._particlesRenderTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureParticlesRenderTime\", {\n      get: function () {\n        return this._captureParticlesRenderTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureParticlesRenderTime && ((this._captureParticlesRenderTime = e) ? (this._onBeforeParticlesRenderingObserver = this.scene.onBeforeParticlesRenderingObservable.add(function () {\n          Da.Tools.StartPerformanceCounter(\"Particles\"), t._particlesRenderTime.beginMonitoring();\n        }), this._onAfterParticlesRenderingObserver = this.scene.onAfterParticlesRenderingObservable.add(function () {\n          Da.Tools.EndPerformanceCounter(\"Particles\"), t._particlesRenderTime.endMonitoring(!1);\n        })) : (this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver), this._onBeforeParticlesRenderingObserver = null, this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver), this._onAfterParticlesRenderingObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"spritesRenderTimeCounter\", {\n      get: function () {\n        return this._spritesRenderTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureSpritesRenderTime\", {\n      get: function () {\n        return this._captureSpritesRenderTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureSpritesRenderTime && (this._captureSpritesRenderTime = e, this.scene.spriteManagers && (e ? (this._onBeforeSpritesRenderingObserver = this.scene.onBeforeSpritesRenderingObservable.add(function () {\n          Da.Tools.StartPerformanceCounter(\"Sprites\"), t._spritesRenderTime.beginMonitoring();\n        }), this._onAfterSpritesRenderingObserver = this.scene.onAfterSpritesRenderingObservable.add(function () {\n          Da.Tools.EndPerformanceCounter(\"Sprites\"), t._spritesRenderTime.endMonitoring(!1);\n        })) : (this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver), this._onBeforeSpritesRenderingObserver = null, this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver), this._onAfterSpritesRenderingObserver = null)));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"physicsTimeCounter\", {\n      get: function () {\n        return this._physicsTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"capturePhysicsTime\", {\n      get: function () {\n        return this._capturePhysicsTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._capturePhysicsTime && this.scene.onBeforePhysicsObservable && ((this._capturePhysicsTime = e) ? (this._onBeforePhysicsObserver = this.scene.onBeforePhysicsObservable.add(function () {\n          Da.Tools.StartPerformanceCounter(\"Physics\"), t._physicsTime.beginMonitoring();\n        }), this._onAfterPhysicsObserver = this.scene.onAfterPhysicsObservable.add(function () {\n          Da.Tools.EndPerformanceCounter(\"Physics\"), t._physicsTime.endMonitoring();\n        })) : (this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver), this._onBeforePhysicsObserver = null, this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver), this._onAfterPhysicsObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"animationsTimeCounter\", {\n      get: function () {\n        return this._animationsTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureAnimationsTime\", {\n      get: function () {\n        return this._captureAnimationsTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureAnimationsTime && ((this._captureAnimationsTime = e) ? this._onAfterAnimationsObserver = this.scene.onAfterAnimationsObservable.add(function () {\n          t._animationsTime.endMonitoring();\n        }) : (this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver), this._onAfterAnimationsObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"frameTimeCounter\", {\n      get: function () {\n        return this._frameTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureFrameTime\", {\n      get: function () {\n        return this._captureFrameTime;\n      },\n      set: function (e) {\n        this._captureFrameTime = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"interFrameTimeCounter\", {\n      get: function () {\n        return this._interFrameTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureInterFrameTime\", {\n      get: function () {\n        return this._captureInterFrameTime;\n      },\n      set: function (e) {\n        this._captureInterFrameTime = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"renderTimeCounter\", {\n      get: function () {\n        return this._renderTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureRenderTime\", {\n      get: function () {\n        return this._captureRenderTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureRenderTime && ((this._captureRenderTime = e) ? (this._onBeforeDrawPhaseObserver = this.scene.onBeforeDrawPhaseObservable.add(function () {\n          t._renderTime.beginMonitoring(), Da.Tools.StartPerformanceCounter(\"Main render\");\n        }), this._onAfterDrawPhaseObserver = this.scene.onAfterDrawPhaseObservable.add(function () {\n          t._renderTime.endMonitoring(!1), Da.Tools.EndPerformanceCounter(\"Main render\");\n        })) : (this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver), this._onBeforeDrawPhaseObserver = null, this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver), this._onAfterDrawPhaseObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"cameraRenderTimeCounter\", {\n      get: function () {\n        return this._cameraRenderTime;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"captureCameraRenderTime\", {\n      get: function () {\n        return this._captureCameraRenderTime;\n      },\n      set: function (e) {\n        var t = this;\n        e !== this._captureCameraRenderTime && ((this._captureCameraRenderTime = e) ? (this._onBeforeCameraRenderObserver = this.scene.onBeforeCameraRenderObservable.add(function (e) {\n          t._cameraRenderTime.beginMonitoring(), Da.Tools.StartPerformanceCounter(\"Rendering camera \" + e.name);\n        }), this._onAfterCameraRenderObserver = this.scene.onAfterCameraRenderObservable.add(function (e) {\n          t._cameraRenderTime.endMonitoring(!1), Da.Tools.EndPerformanceCounter(\"Rendering camera \" + e.name);\n        })) : (this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = null, this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = null));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"drawCallsCounter\", {\n      get: function () {\n        return this.scene.getEngine()._drawCalls;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"textureCollisionsCounter\", {\n      get: function () {\n        return this.scene.getEngine()._textureCollisions;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function () {\n      this.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = null, this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver), this._onBeforeActiveMeshesEvaluationObserver = null, this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver), this._onAfterActiveMeshesEvaluationObserver = null, this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver), this._onBeforeRenderTargetsRenderObserver = null, this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver), this._onAfterRenderTargetsRenderObserver = null, this.scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver), this._onBeforeAnimationsObserver = null, this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver), this._onBeforeParticlesRenderingObserver = null, this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver), this._onAfterParticlesRenderingObserver = null, this._onBeforeSpritesRenderingObserver && (this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver), this._onBeforeSpritesRenderingObserver = null), this._onAfterSpritesRenderingObserver && (this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver), this._onAfterSpritesRenderingObserver = null), this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver), this._onBeforeDrawPhaseObserver = null, this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver), this._onAfterDrawPhaseObserver = null, this._onBeforePhysicsObserver && (this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver), this._onBeforePhysicsObserver = null), this._onAfterPhysicsObserver && (this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver), this._onAfterPhysicsObserver = null), this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver), this._onAfterAnimationsObserver = null, this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = null, this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = null, this.scene = null;\n    }, e;\n  }(), Da.SceneInstrumentation = Ia, wa = function () {\n    this._timeElapsedQueryEnded = !1;\n  }, ($a || ($a = {}))._TimeToken = wa, La = $a || ($a = {}), Fa = function (t) {\n    function e() {\n      var e = t.call(this) || this;\n      return e.DIFFUSE = !1, e.DIFFUSEDIRECTUV = 0, e.GAMMADIFFUSE = !1, e.DIFFUSEHASALPHA = !1, e.OPACITYFRESNEL = !1, e.REFLECTIONBLUR = !1, e.REFLECTIONFRESNEL = !1, e.REFLECTIONFALLOFF = !1, e.TEXTURELODSUPPORT = !1, e.PREMULTIPLYALPHA = !1, e.USERGBCOLOR = !1, e.USEHIGHLIGHTANDSHADOWCOLORS = !1, e.NOISE = !1, e.REFLECTIONBGR = !1, e.IMAGEPROCESSING = !1, e.VIGNETTE = !1, e.VIGNETTEBLENDMODEMULTIPLY = !1, e.VIGNETTEBLENDMODEOPAQUE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = !1, e.SAMPLER3DBGRMAP = !1, e.IMAGEPROCESSINGPOSTPROCESS = !1, e.EXPOSURE = !1, e.REFLECTION = !1, e.REFLECTIONMAP_3D = !1, e.REFLECTIONMAP_SPHERICAL = !1, e.REFLECTIONMAP_PLANAR = !1, e.REFLECTIONMAP_CUBIC = !1, e.REFLECTIONMAP_PROJECTION = !1, e.REFLECTIONMAP_SKYBOX = !1, e.REFLECTIONMAP_SKYBOX_TRANSFORMED = !1, e.REFLECTIONMAP_EXPLICIT = !1, e.REFLECTIONMAP_EQUIRECTANGULAR = !1, e.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, e.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, e.INVERTCUBICMAP = !1, e.REFLECTIONMAP_OPPOSITEZ = !1, e.LODINREFLECTIONALPHA = !1, e.GAMMAREFLECTION = !1, e.RGBDREFLECTION = !1, e.EQUIRECTANGULAR_RELFECTION_FOV = !1, e.MAINUV1 = !1, e.MAINUV2 = !1, e.UV1 = !1, e.UV2 = !1, e.CLIPPLANE = !1, e.CLIPPLANE2 = !1, e.CLIPPLANE3 = !1, e.CLIPPLANE4 = !1, e.POINTSIZE = !1, e.FOG = !1, e.NORMAL = !1, e.NUM_BONE_INFLUENCERS = 0, e.BonesPerMesh = 0, e.INSTANCES = !1, e.SHADOWFLOAT = !1, e.rebuild(), e;\n    }\n\n    return T(e, t), e;\n  }(La.MaterialDefines), Ba = function (r) {\n    function n(e, t) {\n      var i = r.call(this, e, t) || this;\n      return i.primaryColor = La.Color3.White(), i._primaryColorShadowLevel = 0, i._primaryColorHighlightLevel = 0, i.reflectionTexture = null, i.reflectionBlur = 0, i.diffuseTexture = null, i._shadowLights = null, i.shadowLights = null, i.shadowLevel = 0, i.sceneCenter = La.Vector3.Zero(), i.opacityFresnel = !0, i.reflectionFresnel = !1, i.reflectionFalloffDistance = 0, i.reflectionAmount = 1, i.reflectionReflectance0 = .05, i.reflectionReflectance90 = .5, i.useRGBColor = !0, i.enableNoise = !1, i._fovMultiplier = 1, i.useEquirectangularFOV = !1, i._maxSimultaneousLights = 4, i.maxSimultaneousLights = 4, i._imageProcessingObserver = null, i.switchToBGR = !1, i._renderTargets = new La.SmartArray(16), i._reflectionControls = La.Vector4.Zero(), i._white = La.Color3.White(), i._primaryShadowColor = La.Color3.Black(), i._primaryHighlightColor = La.Color3.Black(), i._attachImageProcessingConfiguration(null), i.getRenderTargetTextures = function () {\n        return i._renderTargets.reset(), i._diffuseTexture && i._diffuseTexture.isRenderTarget && i._renderTargets.push(i._diffuseTexture), i._reflectionTexture && i._reflectionTexture.isRenderTarget && i._renderTargets.push(i._reflectionTexture), i._renderTargets;\n      }, i;\n    }\n\n    return T(n, r), Object.defineProperty(n.prototype, \"_perceptualColor\", {\n      get: function () {\n        return this.__perceptualColor;\n      },\n      set: function (e) {\n        this.__perceptualColor = e, this._computePrimaryColorFromPerceptualColor(), this._markAllSubMeshesAsLightsDirty();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"primaryColorShadowLevel\", {\n      get: function () {\n        return this._primaryColorShadowLevel;\n      },\n      set: function (e) {\n        this._primaryColorShadowLevel = e, this._computePrimaryColors(), this._markAllSubMeshesAsLightsDirty();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"primaryColorHighlightLevel\", {\n      get: function () {\n        return this._primaryColorHighlightLevel;\n      },\n      set: function (e) {\n        this._primaryColorHighlightLevel = e, this._computePrimaryColors(), this._markAllSubMeshesAsLightsDirty();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"reflectionStandardFresnelWeight\", {\n      set: function (e) {\n        var t = e;\n        t < .5 ? (t *= 2, this.reflectionReflectance0 = n.StandardReflectance0 * t, this.reflectionReflectance90 = n.StandardReflectance90 * t) : (t = 2 * t - 1, this.reflectionReflectance0 = n.StandardReflectance0 + (1 - n.StandardReflectance0) * t, this.reflectionReflectance90 = n.StandardReflectance90 + (1 - n.StandardReflectance90) * t);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"fovMultiplier\", {\n      get: function () {\n        return this._fovMultiplier;\n      },\n      set: function (e) {\n        isNaN(e) && (e = 1), this._fovMultiplier = Math.max(0, Math.min(2, e));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.prototype._attachImageProcessingConfiguration = function (e) {\n      var t = this;\n      e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), this._imageProcessingConfiguration = e || this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function (e) {\n        t._computePrimaryColorFromPerceptualColor(), t._markAllSubMeshesAsImageProcessingDirty();\n      })));\n    }, Object.defineProperty(n.prototype, \"imageProcessingConfiguration\", {\n      get: function () {\n        return this._imageProcessingConfiguration;\n      },\n      set: function (e) {\n        this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty();\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorCurvesEnabled\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorGradingEnabled\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorGradingEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraToneMappingEnabled\", {\n      get: function () {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.toneMappingEnabled = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraExposure\", {\n      get: function () {\n        return this._imageProcessingConfiguration.exposure;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.exposure = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraContrast\", {\n      get: function () {\n        return this._imageProcessingConfiguration.contrast;\n      },\n      set: function (e) {\n        this._imageProcessingConfiguration.contrast = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorGradingTexture\", {\n      get: function () {\n        return this._imageProcessingConfiguration.colorGradingTexture;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorGradingTexture = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"cameraColorCurves\", {\n      get: function () {\n        return this.imageProcessingConfiguration.colorCurves;\n      },\n      set: function (e) {\n        this.imageProcessingConfiguration.colorCurves = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(n.prototype, \"hasRenderTargetTextures\", {\n      get: function () {\n        return !(!this._diffuseTexture || !this._diffuseTexture.isRenderTarget) || !(!this._reflectionTexture || !this._reflectionTexture.isRenderTarget);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.prototype.needAlphaTesting = function () {\n      return !0;\n    }, n.prototype.needAlphaBlending = function () {\n      return this.alpha < 0 || null != this._diffuseTexture && this._diffuseTexture.hasAlpha;\n    }, n.prototype.isReadyForSubMesh = function (e, t, i) {\n      var r = this;\n      if (void 0 === i && (i = !1), t.effect && this.isFrozen && this._wasPreviouslyReady) return !0;\n      t._materialDefines || (t._materialDefines = new Fa());\n      var n = this.getScene(),\n          o = t._materialDefines;\n      if (!this.checkReadyOnEveryCall && t.effect && o._renderId === n.getRenderId()) return !0;\n      var s = n.getEngine();\n\n      if (La.MaterialHelper.PrepareDefinesForLights(n, e, o, !1, this._maxSimultaneousLights), o._needNormals = !0, o._areTexturesDirty) {\n        if (o._needUVs = !1, n.texturesEnabled) {\n          if (n.getEngine().getCaps().textureLOD && (o.TEXTURELODSUPPORT = !0), this._diffuseTexture && La.StandardMaterial.DiffuseTextureEnabled) {\n            if (!this._diffuseTexture.isReadyOrNotBlocking()) return !1;\n            La.MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, o, \"DIFFUSE\"), o.DIFFUSEHASALPHA = this._diffuseTexture.hasAlpha, o.GAMMADIFFUSE = this._diffuseTexture.gammaSpace, o.OPACITYFRESNEL = this._opacityFresnel;\n          } else o.DIFFUSE = !1, o.DIFFUSEHASALPHA = !1, o.GAMMADIFFUSE = !1, o.OPACITYFRESNEL = !1;\n\n          var a = this._reflectionTexture;\n\n          if (a && La.StandardMaterial.ReflectionTextureEnabled) {\n            if (!a.isReadyOrNotBlocking()) return !1;\n\n            switch (o.REFLECTION = !0, o.GAMMAREFLECTION = a.gammaSpace, o.RGBDREFLECTION = a.isRGBD, o.REFLECTIONBLUR = 0 < this._reflectionBlur, o.REFLECTIONMAP_OPPOSITEZ = this.getScene().useRightHandedSystem ? !a.invertZ : a.invertZ, o.LODINREFLECTIONALPHA = a.lodLevelInAlpha, o.EQUIRECTANGULAR_RELFECTION_FOV = this.useEquirectangularFOV, o.REFLECTIONBGR = this.switchToBGR, a.coordinatesMode === La.Texture.INVCUBIC_MODE && (o.INVERTCUBICMAP = !0), o.REFLECTIONMAP_3D = a.isCube, a.coordinatesMode) {\n              case La.Texture.EXPLICIT_MODE:\n                o.REFLECTIONMAP_EXPLICIT = !0;\n                break;\n\n              case La.Texture.PLANAR_MODE:\n                o.REFLECTIONMAP_PLANAR = !0;\n                break;\n\n              case La.Texture.PROJECTION_MODE:\n                o.REFLECTIONMAP_PROJECTION = !0;\n                break;\n\n              case La.Texture.SKYBOX_MODE:\n                o.REFLECTIONMAP_SKYBOX = !0, o.REFLECTIONMAP_SKYBOX_TRANSFORMED = !a.getReflectionTextureMatrix().isIdentity();\n                break;\n\n              case La.Texture.SPHERICAL_MODE:\n                o.REFLECTIONMAP_SPHERICAL = !0;\n                break;\n\n              case La.Texture.EQUIRECTANGULAR_MODE:\n                o.REFLECTIONMAP_EQUIRECTANGULAR = !0;\n                break;\n\n              case La.Texture.FIXED_EQUIRECTANGULAR_MODE:\n                o.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !0;\n                break;\n\n              case La.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                o.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !0;\n                break;\n\n              case La.Texture.CUBIC_MODE:\n              case La.Texture.INVCUBIC_MODE:\n              default:\n                o.REFLECTIONMAP_CUBIC = !0;\n            }\n\n            this.reflectionFresnel ? (o.REFLECTIONFRESNEL = !0, o.REFLECTIONFALLOFF = 0 < this.reflectionFalloffDistance, this._reflectionControls.x = this.reflectionAmount, this._reflectionControls.y = this.reflectionReflectance0, this._reflectionControls.z = this.reflectionReflectance90, this._reflectionControls.w = 1 / this.reflectionFalloffDistance) : (o.REFLECTIONFRESNEL = !1, o.REFLECTIONFALLOFF = !1);\n          } else o.REFLECTION = !1, o.REFLECTIONFRESNEL = !1, o.REFLECTIONFALLOFF = !1, o.REFLECTIONBLUR = !1, o.REFLECTIONMAP_3D = !1, o.REFLECTIONMAP_SPHERICAL = !1, o.REFLECTIONMAP_PLANAR = !1, o.REFLECTIONMAP_CUBIC = !1, o.REFLECTIONMAP_PROJECTION = !1, o.REFLECTIONMAP_SKYBOX = !1, o.REFLECTIONMAP_SKYBOX_TRANSFORMED = !1, o.REFLECTIONMAP_EXPLICIT = !1, o.REFLECTIONMAP_EQUIRECTANGULAR = !1, o.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, o.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, o.INVERTCUBICMAP = !1, o.REFLECTIONMAP_OPPOSITEZ = !1, o.LODINREFLECTIONALPHA = !1, o.GAMMAREFLECTION = !1, o.RGBDREFLECTION = !1;\n        }\n\n        o.PREMULTIPLYALPHA = this.alphaMode === La.Engine.ALPHA_PREMULTIPLIED || this.alphaMode === La.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF, o.USERGBCOLOR = this._useRGBColor, o.NOISE = this._enableNoise;\n      }\n\n      if (o._areLightsDirty && (o.USEHIGHLIGHTANDSHADOWCOLORS = !this._useRGBColor && (0 !== this._primaryColorShadowLevel || 0 !== this._primaryColorHighlightLevel)), o._areImageProcessingDirty && this._imageProcessingConfiguration) {\n        if (!this._imageProcessingConfiguration.isReady()) return !1;\n\n        this._imageProcessingConfiguration.prepareDefines(o);\n      }\n\n      if (La.MaterialHelper.PrepareDefinesForMisc(e, n, !1, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e), o), La.MaterialHelper.PrepareDefinesForFrameBoundValues(n, s, o, i), La.MaterialHelper.PrepareDefinesForAttributes(e, o, !1, !0, !1) && e && (n.getEngine().getCaps().standardDerivatives || e.isVerticesDataPresent(La.VertexBuffer.NormalKind) || (e.createNormals(!0), La.Tools.Warn(\"BackgroundMaterial: Normals have been created for the mesh: \" + e.name))), o.isDirty) {\n        o.markAsProcessed(), n.resetCachedMaterial();\n        var l = new La.EffectFallbacks();\n        o.FOG && l.addFallback(0, \"FOG\"), o.POINTSIZE && l.addFallback(1, \"POINTSIZE\"), La.MaterialHelper.HandleFallbacksForShadows(o, l, this._maxSimultaneousLights), 0 < o.NUM_BONE_INFLUENCERS && l.addCPUSkinningFallback(0, e);\n        var c = [La.VertexBuffer.PositionKind];\n        o.NORMAL && c.push(La.VertexBuffer.NormalKind), o.UV1 && c.push(La.VertexBuffer.UVKind), o.UV2 && c.push(La.VertexBuffer.UV2Kind), La.MaterialHelper.PrepareAttributesForBones(c, e, o, l), La.MaterialHelper.PrepareAttributesForInstances(c, o);\n        var h = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"mBones\", \"vPrimaryColor\", \"vPrimaryColorShadow\", \"vReflectionInfos\", \"reflectionMatrix\", \"vReflectionMicrosurfaceInfos\", \"fFovMultiplier\", \"shadowLevel\", \"alpha\", \"vBackgroundCenter\", \"vReflectionControl\", \"vDiffuseInfos\", \"diffuseMatrix\"],\n            u = [\"diffuseSampler\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\"],\n            d = [\"Material\", \"Scene\"];\n        La.ImageProcessingConfiguration && (La.ImageProcessingConfiguration.PrepareUniforms(h, o), La.ImageProcessingConfiguration.PrepareSamplers(u, o)), La.MaterialHelper.PrepareUniformsAndSamplersList({\n          uniformsNames: h,\n          uniformBuffersNames: d,\n          samplers: u,\n          defines: o,\n          maxSimultaneousLights: this._maxSimultaneousLights\n        });\n        var f = o.toString();\n        t.setEffect(n.getEngine().createEffect(\"background\", {\n          attributes: c,\n          uniformsNames: h,\n          uniformBuffersNames: d,\n          samplers: u,\n          defines: f,\n          fallbacks: l,\n          onCompiled: function (e) {\n            r.onCompiled && r.onCompiled(e), r.bindSceneUniformBuffer(e, n.getSceneUniformBuffer());\n          },\n          onError: this.onError,\n          indexParameters: {\n            maxSimultaneousLights: this._maxSimultaneousLights\n          }\n        }, s), o), this.buildUniformLayout();\n      }\n\n      return !(!t.effect || !t.effect.isReady()) && (o._renderId = n.getRenderId(), this._wasPreviouslyReady = !0);\n    }, n.prototype._computePrimaryColorFromPerceptualColor = function () {\n      this.__perceptualColor && (this._primaryColor.copyFrom(this.__perceptualColor), this._primaryColor.toLinearSpaceToRef(this._primaryColor), this._imageProcessingConfiguration && this._primaryColor.scaleToRef(1 / this._imageProcessingConfiguration.exposure, this._primaryColor), this._computePrimaryColors());\n    }, n.prototype._computePrimaryColors = function () {\n      0 === this._primaryColorShadowLevel && 0 === this._primaryColorHighlightLevel || (this._primaryColor.scaleToRef(this._primaryColorShadowLevel, this._primaryShadowColor), this._primaryColor.subtractToRef(this._primaryShadowColor, this._primaryShadowColor), this._white.subtractToRef(this._primaryColor, this._primaryHighlightColor), this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel, this._primaryHighlightColor), this._primaryColor.addToRef(this._primaryHighlightColor, this._primaryHighlightColor));\n    }, n.prototype.buildUniformLayout = function () {\n      this._uniformBuffer.addUniform(\"vPrimaryColor\", 4), this._uniformBuffer.addUniform(\"vPrimaryColorShadow\", 4), this._uniformBuffer.addUniform(\"vDiffuseInfos\", 2), this._uniformBuffer.addUniform(\"vReflectionInfos\", 2), this._uniformBuffer.addUniform(\"diffuseMatrix\", 16), this._uniformBuffer.addUniform(\"reflectionMatrix\", 16), this._uniformBuffer.addUniform(\"vReflectionMicrosurfaceInfos\", 3), this._uniformBuffer.addUniform(\"fFovMultiplier\", 1), this._uniformBuffer.addUniform(\"pointSize\", 1), this._uniformBuffer.addUniform(\"shadowLevel\", 1), this._uniformBuffer.addUniform(\"alpha\", 1), this._uniformBuffer.addUniform(\"vBackgroundCenter\", 3), this._uniformBuffer.addUniform(\"vReflectionControl\", 4), this._uniformBuffer.create();\n    }, n.prototype.unbind = function () {\n      this._diffuseTexture && this._diffuseTexture.isRenderTarget && this._uniformBuffer.setTexture(\"diffuseSampler\", null), this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._uniformBuffer.setTexture(\"reflectionSampler\", null), r.prototype.unbind.call(this);\n    }, n.prototype.bindOnlyWorldMatrix = function (e) {\n      this._activeEffect.setMatrix(\"world\", e);\n    }, n.prototype.bindForSubMesh = function (e, t, i) {\n      var r = this.getScene(),\n          n = i._materialDefines;\n\n      if (n) {\n        var o = i.effect;\n\n        if (o) {\n          this._activeEffect = o, this.bindOnlyWorldMatrix(e), La.MaterialHelper.BindBonesParameters(t, this._activeEffect);\n\n          var s = this._mustRebind(r, o, t.visibility);\n\n          if (s) {\n            this._uniformBuffer.bindToEffect(o, \"Material\"), this.bindViewProjection(o);\n            var a = this._reflectionTexture;\n            this._uniformBuffer.useUbo && this.isFrozen && this._uniformBuffer.isSync || (r.texturesEnabled && (this._diffuseTexture && La.StandardMaterial.DiffuseTextureEnabled && (this._uniformBuffer.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level), La.MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, \"diffuse\")), a && La.StandardMaterial.ReflectionTextureEnabled && (this._uniformBuffer.updateMatrix(\"reflectionMatrix\", a.getReflectionTextureMatrix()), this._uniformBuffer.updateFloat2(\"vReflectionInfos\", a.level, this._reflectionBlur), this._uniformBuffer.updateFloat3(\"vReflectionMicrosurfaceInfos\", a.getSize().width, a.lodGenerationScale, a.lodGenerationOffset))), 0 < this.shadowLevel && this._uniformBuffer.updateFloat(\"shadowLevel\", this.shadowLevel), this._uniformBuffer.updateFloat(\"alpha\", this.alpha), this.pointsCloud && this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize), n.USEHIGHLIGHTANDSHADOWCOLORS ? (this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryHighlightColor, 1), this._uniformBuffer.updateColor4(\"vPrimaryColorShadow\", this._primaryShadowColor, 1)) : this._uniformBuffer.updateColor4(\"vPrimaryColor\", this._primaryColor, 1)), this._uniformBuffer.updateFloat(\"fFovMultiplier\", this._fovMultiplier), r.texturesEnabled && (this._diffuseTexture && La.StandardMaterial.DiffuseTextureEnabled && this._uniformBuffer.setTexture(\"diffuseSampler\", this._diffuseTexture), a && La.StandardMaterial.ReflectionTextureEnabled && (n.REFLECTIONBLUR && n.TEXTURELODSUPPORT ? this._uniformBuffer.setTexture(\"reflectionSampler\", a) : n.REFLECTIONBLUR ? (this._uniformBuffer.setTexture(\"reflectionSampler\", a._lodTextureMid || a), this._uniformBuffer.setTexture(\"reflectionSamplerLow\", a._lodTextureLow || a), this._uniformBuffer.setTexture(\"reflectionSamplerHigh\", a._lodTextureHigh || a)) : this._uniformBuffer.setTexture(\"reflectionSampler\", a), n.REFLECTIONFRESNEL && (this._uniformBuffer.updateFloat3(\"vBackgroundCenter\", this.sceneCenter.x, this.sceneCenter.y, this.sceneCenter.z), this._uniformBuffer.updateFloat4(\"vReflectionControl\", this._reflectionControls.x, this._reflectionControls.y, this._reflectionControls.z, this._reflectionControls.w)))), La.MaterialHelper.BindClipPlane(this._activeEffect, r), La.MaterialHelper.BindEyePosition(o, r);\n          }\n\n          !s && this.isFrozen || (r.lightsEnabled && La.MaterialHelper.BindLights(r, t, this._activeEffect, n, this._maxSimultaneousLights, !1), this.bindView(o), La.MaterialHelper.BindFogParameters(r, t, this._activeEffect, !0), this._imageProcessingConfiguration && this._imageProcessingConfiguration.bind(this._activeEffect)), this._uniformBuffer.update(), this._afterBind(t, this._activeEffect);\n        }\n      }\n    }, n.prototype.dispose = function (e, t) {\n      void 0 === e && (e = !1), void 0 === t && (t = !1), t && (this.diffuseTexture && this.diffuseTexture.dispose(), this.reflectionTexture && this.reflectionTexture.dispose()), this._renderTargets.dispose(), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), r.prototype.dispose.call(this, e);\n    }, n.prototype.clone = function (e) {\n      var t = this;\n      return La.SerializationHelper.Clone(function () {\n        return new n(e, t.getScene());\n      }, this);\n    }, n.prototype.serialize = function () {\n      var e = La.SerializationHelper.Serialize(this);\n      return e.customType = \"BABYLON.BackgroundMaterial\", e;\n    }, n.prototype.getClassName = function () {\n      return \"BackgroundMaterial\";\n    }, n.Parse = function (e, t, i) {\n      return La.SerializationHelper.Parse(function () {\n        return new n(e.name, t);\n      }, e, t, i);\n    }, n.StandardReflectance0 = .05, n.StandardReflectance90 = .5, b([La.serializeAsColor3()], n.prototype, \"_primaryColor\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], n.prototype, \"primaryColor\", void 0), b([La.serializeAsColor3()], n.prototype, \"__perceptualColor\", void 0), b([La.serialize()], n.prototype, \"_primaryColorShadowLevel\", void 0), b([La.serialize()], n.prototype, \"_primaryColorHighlightLevel\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")], n.prototype, \"primaryColorHighlightLevel\", null), b([La.serializeAsTexture()], n.prototype, \"_reflectionTexture\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionTexture\", void 0), b([La.serialize()], n.prototype, \"_reflectionBlur\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionBlur\", void 0), b([La.serializeAsTexture()], n.prototype, \"_diffuseTexture\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"diffuseTexture\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"shadowLights\", void 0), b([La.serialize()], n.prototype, \"_shadowLevel\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"shadowLevel\", void 0), b([La.serializeAsVector3()], n.prototype, \"_sceneCenter\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"sceneCenter\", void 0), b([La.serialize()], n.prototype, \"_opacityFresnel\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"opacityFresnel\", void 0), b([La.serialize()], n.prototype, \"_reflectionFresnel\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionFresnel\", void 0), b([La.serialize()], n.prototype, \"_reflectionFalloffDistance\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionFalloffDistance\", void 0), b([La.serialize()], n.prototype, \"_reflectionAmount\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionAmount\", void 0), b([La.serialize()], n.prototype, \"_reflectionReflectance0\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionReflectance0\", void 0), b([La.serialize()], n.prototype, \"_reflectionReflectance90\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"reflectionReflectance90\", void 0), b([La.serialize()], n.prototype, \"_useRGBColor\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"useRGBColor\", void 0), b([La.serialize()], n.prototype, \"_enableNoise\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"enableNoise\", void 0), b([La.serialize()], n.prototype, \"_maxSimultaneousLights\", void 0), b([La.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], n.prototype, \"maxSimultaneousLights\", void 0), b([La.serializeAsImageProcessingConfiguration()], n.prototype, \"_imageProcessingConfiguration\", void 0), n;\n  }(La.PushMaterial), La.BackgroundMaterial = Ba;\n  var Na, Va, Ua, za, Ga, ka, Wa, Ha, Xa, ja, Ya, Ka, Qa, Za;\n\n  ae = this && this.__assign || function () {\n    return (ae = Object.assign || function (e) {\n      for (var t, i = 1, r = arguments.length; i < r; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n      return e;\n    }).apply(this, arguments);\n  };\n\n  Na = $a || ($a = {}), Va = function () {\n    function r(e, t) {\n      var i = this;\n      this._errorHandler = function (e, t) {\n        i.onErrorObservable.notifyObservers({\n          message: e,\n          exception: t\n        });\n      }, this._options = ae({}, r._getDefaultOptions(), e), this._scene = t, this.onErrorObservable = new Na.Observable(), this._setupBackground(), this._setupImageProcessing();\n    }\n\n    return r._getDefaultOptions = function () {\n      return {\n        createGround: !0,\n        groundSize: 15,\n        groundTexture: this._groundTextureCDNUrl,\n        groundColor: new Na.Color3(.2, .2, .3).toLinearSpace().scale(3),\n        groundOpacity: .9,\n        enableGroundShadow: !0,\n        groundShadowLevel: .5,\n        enableGroundMirror: !1,\n        groundMirrorSizeRatio: .3,\n        groundMirrorBlurKernel: 64,\n        groundMirrorAmount: 1,\n        groundMirrorFresnelWeight: 1,\n        groundMirrorFallOffDistance: 0,\n        groundMirrorTextureType: Na.Engine.TEXTURETYPE_UNSIGNED_INT,\n        groundYBias: 1e-5,\n        createSkybox: !0,\n        skyboxSize: 20,\n        skyboxTexture: this._skyboxTextureCDNUrl,\n        skyboxColor: new Na.Color3(.2, .2, .3).toLinearSpace().scale(3),\n        backgroundYRotation: 0,\n        sizeAuto: !0,\n        rootPosition: Na.Vector3.Zero(),\n        setupImageProcessing: !0,\n        environmentTexture: this._environmentTextureCDNUrl,\n        cameraExposure: .8,\n        cameraContrast: 1.2,\n        toneMappingEnabled: !0\n      };\n    }, Object.defineProperty(r.prototype, \"rootMesh\", {\n      get: function () {\n        return this._rootMesh;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"skybox\", {\n      get: function () {\n        return this._skybox;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"skyboxTexture\", {\n      get: function () {\n        return this._skyboxTexture;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"skyboxMaterial\", {\n      get: function () {\n        return this._skyboxMaterial;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"ground\", {\n      get: function () {\n        return this._ground;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"groundTexture\", {\n      get: function () {\n        return this._groundTexture;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"groundMirror\", {\n      get: function () {\n        return this._groundMirror;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"groundMirrorRenderList\", {\n      get: function () {\n        return this._groundMirror ? this._groundMirror.renderList : null;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(r.prototype, \"groundMaterial\", {\n      get: function () {\n        return this._groundMaterial;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), r.prototype.updateOptions = function (e) {\n      var t = ae({}, this._options, e);\n      this._ground && !t.createGround && (this._ground.dispose(), this._ground = null), this._groundMaterial && !t.createGround && (this._groundMaterial.dispose(), this._groundMaterial = null), this._groundTexture && this._options.groundTexture != t.groundTexture && (this._groundTexture.dispose(), this._groundTexture = null), this._skybox && !t.createSkybox && (this._skybox.dispose(), this._skybox = null), this._skyboxMaterial && !t.createSkybox && (this._skyboxMaterial.dispose(), this._skyboxMaterial = null), this._skyboxTexture && this._options.skyboxTexture != t.skyboxTexture && (this._skyboxTexture.dispose(), this._skyboxTexture = null), this._groundMirror && !t.enableGroundMirror && (this._groundMirror.dispose(), this._groundMirror = null), this._scene.environmentTexture && this._options.environmentTexture != t.environmentTexture && this._scene.environmentTexture.dispose(), this._options = t, this._setupBackground(), this._setupImageProcessing();\n    }, r.prototype.setMainColor = function (e) {\n      this.groundMaterial && (this.groundMaterial.primaryColor = e), this.skyboxMaterial && (this.skyboxMaterial.primaryColor = e), this.groundMirror && (this.groundMirror.clearColor = new Na.Color4(e.r, e.g, e.b, 1));\n    }, r.prototype._setupImageProcessing = function () {\n      this._options.setupImageProcessing && (this._scene.imageProcessingConfiguration.contrast = this._options.cameraContrast, this._scene.imageProcessingConfiguration.exposure = this._options.cameraExposure, this._scene.imageProcessingConfiguration.toneMappingEnabled = this._options.toneMappingEnabled, this._setupEnvironmentTexture());\n    }, r.prototype._setupEnvironmentTexture = function () {\n      if (!this._scene.environmentTexture) if (this._options.environmentTexture instanceof Na.BaseTexture) this._scene.environmentTexture = this._options.environmentTexture;else {\n        var e = Na.CubeTexture.CreateFromPrefilteredData(this._options.environmentTexture, this._scene);\n        this._scene.environmentTexture = e;\n      }\n    }, r.prototype._setupBackground = function () {\n      this._rootMesh || (this._rootMesh = new Na.Mesh(\"BackgroundHelper\", this._scene)), this._rootMesh.rotation.y = this._options.backgroundYRotation;\n\n      var e = this._getSceneSize();\n\n      this._options.createGround && (this._setupGround(e), this._setupGroundMaterial(), this._setupGroundDiffuseTexture(), this._options.enableGroundMirror && this._setupGroundMirrorTexture(e), this._setupMirrorInGroundMaterial()), this._options.createSkybox && (this._setupSkybox(e), this._setupSkyboxMaterial(), this._setupSkyboxReflectionTexture()), this._rootMesh.position.x = e.rootPosition.x, this._rootMesh.position.z = e.rootPosition.z, this._rootMesh.position.y = e.rootPosition.y;\n    }, r.prototype._getSceneSize = function () {\n      var t = this,\n          e = this._options.groundSize,\n          i = this._options.skyboxSize,\n          r = this._options.rootPosition;\n      if (!this._scene.meshes || 1 === this._scene.meshes.length) return {\n        groundSize: e,\n        skyboxSize: i,\n        rootPosition: r\n      };\n\n      var n = this._scene.getWorldExtends(function (e) {\n        return e !== t._ground && e !== t._rootMesh && e !== t._skybox;\n      }),\n          o = n.max.subtract(n.min);\n\n      if (this._options.sizeAuto) {\n        this._scene.activeCamera instanceof Na.ArcRotateCamera && this._scene.activeCamera.upperRadiusLimit && (i = e = 2 * this._scene.activeCamera.upperRadiusLimit);\n        var s = o.length();\n        e < s && (i = e = 2 * s), e *= 1.1, i *= 1.5, (r = n.min.add(o.scale(.5))).y = n.min.y - this._options.groundYBias;\n      }\n\n      return {\n        groundSize: e,\n        skyboxSize: i,\n        rootPosition: r\n      };\n    }, r.prototype._setupGround = function (e) {\n      var t = this;\n      this._ground && !this._ground.isDisposed() || (this._ground = Na.Mesh.CreatePlane(\"BackgroundPlane\", e.groundSize, this._scene), this._ground.rotation.x = Math.PI / 2, this._ground.parent = this._rootMesh, this._ground.onDisposeObservable.add(function () {\n        t._ground = null;\n      })), this._ground.receiveShadows = this._options.enableGroundShadow;\n    }, r.prototype._setupGroundMaterial = function () {\n      this._groundMaterial || (this._groundMaterial = new Na.BackgroundMaterial(\"BackgroundPlaneMaterial\", this._scene)), this._groundMaterial.alpha = this._options.groundOpacity, this._groundMaterial.alphaMode = Na.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF, this._groundMaterial.shadowLevel = this._options.groundShadowLevel, this._groundMaterial.primaryColor = this._options.groundColor, this._groundMaterial.useRGBColor = !1, this._groundMaterial.enableNoise = !0, this._ground && (this._ground.material = this._groundMaterial);\n    }, r.prototype._setupGroundDiffuseTexture = function () {\n      if (this._groundMaterial && !this._groundTexture) if (this._options.groundTexture instanceof Na.BaseTexture) this._groundMaterial.diffuseTexture = this._options.groundTexture;else {\n        var e = new Na.Texture(this._options.groundTexture, this._scene, void 0, void 0, void 0, void 0, this._errorHandler);\n        e.gammaSpace = !1, e.hasAlpha = !0, this._groundMaterial.diffuseTexture = e;\n      }\n    }, r.prototype._setupGroundMirrorTexture = function (e) {\n      var t = Na.Texture.CLAMP_ADDRESSMODE;\n      if (!this._groundMirror && (this._groundMirror = new Na.MirrorTexture(\"BackgroundPlaneMirrorTexture\", {\n        ratio: this._options.groundMirrorSizeRatio\n      }, this._scene, !1, this._options.groundMirrorTextureType, Na.Texture.BILINEAR_SAMPLINGMODE, !0), this._groundMirror.mirrorPlane = new Na.Plane(0, -1, 0, e.rootPosition.y), this._groundMirror.anisotropicFilteringLevel = 1, this._groundMirror.wrapU = t, this._groundMirror.wrapV = t, this._groundMirror.gammaSpace = !1, this._groundMirror.renderList)) for (var i = 0; i < this._scene.meshes.length; i++) {\n        var r = this._scene.meshes[i];\n        r !== this._ground && r !== this._skybox && r !== this._rootMesh && this._groundMirror.renderList.push(r);\n      }\n      this._groundMirror.clearColor = new Na.Color4(this._options.groundColor.r, this._options.groundColor.g, this._options.groundColor.b, 1), this._groundMirror.adaptiveBlurKernel = this._options.groundMirrorBlurKernel;\n    }, r.prototype._setupMirrorInGroundMaterial = function () {\n      this._groundMaterial && (this._groundMaterial.reflectionTexture = this._groundMirror, this._groundMaterial.reflectionFresnel = !0, this._groundMaterial.reflectionAmount = this._options.groundMirrorAmount, this._groundMaterial.reflectionStandardFresnelWeight = this._options.groundMirrorFresnelWeight, this._groundMaterial.reflectionFalloffDistance = this._options.groundMirrorFallOffDistance);\n    }, r.prototype._setupSkybox = function (e) {\n      var t = this;\n      this._skybox && !this._skybox.isDisposed() || (this._skybox = Na.Mesh.CreateBox(\"BackgroundSkybox\", e.skyboxSize, this._scene, void 0, Na.Mesh.BACKSIDE), this._skybox.onDisposeObservable.add(function () {\n        t._skybox = null;\n      })), this._skybox.parent = this._rootMesh;\n    }, r.prototype._setupSkyboxMaterial = function () {\n      this._skybox && (this._skyboxMaterial || (this._skyboxMaterial = new Na.BackgroundMaterial(\"BackgroundSkyboxMaterial\", this._scene)), this._skyboxMaterial.useRGBColor = !1, this._skyboxMaterial.primaryColor = this._options.skyboxColor, this._skyboxMaterial.enableNoise = !0, this._skybox.material = this._skyboxMaterial);\n    }, r.prototype._setupSkyboxReflectionTexture = function () {\n      this._skyboxMaterial && (this._skyboxTexture || (this._options.skyboxTexture instanceof Na.BaseTexture ? this._skyboxMaterial.reflectionTexture = this._options.skyboxTexture : (this._skyboxTexture = new Na.CubeTexture(this._options.skyboxTexture, this._scene, void 0, void 0, void 0, void 0, this._errorHandler), this._skyboxTexture.coordinatesMode = Na.Texture.SKYBOX_MODE, this._skyboxTexture.gammaSpace = !1, this._skyboxMaterial.reflectionTexture = this._skyboxTexture)));\n    }, r.prototype.dispose = function () {\n      this._groundMaterial && this._groundMaterial.dispose(!0, !0), this._skyboxMaterial && this._skyboxMaterial.dispose(!0, !0), this._rootMesh.dispose(!1);\n    }, r._groundTextureCDNUrl = \"https://assets.babylonjs.com/environments/backgroundGround.png\", r._skyboxTextureCDNUrl = \"https://assets.babylonjs.com/environments/backgroundSkybox.dds\", r._environmentTextureCDNUrl = \"https://assets.babylonjs.com/environments/environmentSpecular.env\", r;\n  }(), Na.EnvironmentHelper = Va, Ua = $a || ($a = {}), za = function () {\n    function c() {\n      this.systems = new Array();\n    }\n\n    return Object.defineProperty(c.prototype, \"emitterNode\", {\n      get: function () {\n        return this._emitterNode;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), c.prototype.setEmitterAsSphere = function (e, t, i) {\n      this._emitterNode && this._emitterNode.dispose(), this._emitterCreationOptions = {\n        kind: \"Sphere\",\n        options: e,\n        renderingGroupId: t\n      };\n      var r = Ua.MeshBuilder.CreateSphere(\"emitterSphere\", {\n        diameter: e.diameter,\n        segments: e.segments\n      }, i);\n      r.renderingGroupId = t;\n      var n = new Ua.StandardMaterial(\"emitterSphereMaterial\", i);\n      n.emissiveColor = e.color, r.material = n;\n\n      for (var o = 0, s = this.systems; o < s.length; o++) {\n        s[o].emitter = r;\n      }\n\n      this._emitterNode = r;\n    }, c.prototype.start = function (e) {\n      for (var t = 0, i = this.systems; t < i.length; t++) {\n        var r = i[t];\n        e && (r.emitter = e), r.start();\n      }\n    }, c.prototype.dispose = function () {\n      for (var e = 0, t = this.systems; e < t.length; e++) {\n        t[e].dispose();\n      }\n\n      this.systems = [], this._emitterNode && (this._emitterNode.dispose(), this._emitterNode = null);\n    }, c.prototype.serialize = function () {\n      for (var e = {\n        systems: []\n      }, t = 0, i = this.systems; t < i.length; t++) {\n        var r = i[t];\n        e.systems.push(r.serialize());\n      }\n\n      return this._emitterNode && (e.emitter = this._emitterCreationOptions), e;\n    }, c.Parse = function (e, t, i) {\n      void 0 === i && (i = !1);\n      var r = new c(),\n          n = Ua.ParticleHelper.BaseAssetsUrl + \"/textures/\";\n      t = t || Ua.Engine.LastCreatedScene;\n\n      for (var o = 0, s = e.systems; o < s.length; o++) {\n        var a = s[o];\n        r.systems.push(i ? Ua.GPUParticleSystem.Parse(a, t, n, !0) : Ua.ParticleSystem.Parse(a, t, n, !0));\n      }\n\n      if (e.emitter) {\n        var l = e.emitter.options;\n\n        switch (e.emitter.kind) {\n          case \"Sphere\":\n            r.setEmitterAsSphere({\n              diameter: l.diameter,\n              segments: l.segments,\n              color: Ua.Color3.FromArray(l.color)\n            }, e.emitter.renderingGroupId, t);\n        }\n      }\n\n      return r;\n    }, c;\n  }(), Ua.ParticleSystemSet = za, Ga = $a || ($a = {}), ka = function () {\n    function e() {}\n\n    return e.CreateDefault = function (e, t, i, r) {\n      var n;\n      return void 0 === t && (t = 500), void 0 === r && (r = !1), (n = r ? new Ga.GPUParticleSystem(\"default system\", {\n        capacity: t\n      }, i) : new Ga.ParticleSystem(\"default system\", t, i)).emitter = e, n.particleTexture = new Ga.Texture(\"https://www.babylonjs.com/assets/Flare.png\", n.getScene()), n.createConeEmitter(.1, Math.PI / 4), n.color1 = new Ga.Color4(1, 1, 1, 1), n.color2 = new Ga.Color4(1, 1, 1, 1), n.colorDead = new Ga.Color4(1, 1, 1, 0), n.minSize = .1, n.maxSize = .1, n.minEmitPower = 2, n.maxEmitPower = 2, n.updateSpeed = 1 / 60, n.emitRate = 30, n;\n    }, e.CreateAsync = function (n, o, s) {\n      void 0 === s && (s = !1), o || (o = Ga.Engine.LastCreatedScene);\n      var a = {};\n      return o._addPendingData(a), new Promise(function (r, i) {\n        if (s && !Ga.GPUParticleSystem.IsSupported) return o._removePendingData(a), i(\"Particle system with GPU is not supported.\");\n        Ga.Tools.LoadFile(e.BaseAssetsUrl + \"/systems/\" + n + \".json\", function (e, t) {\n          o._removePendingData(a);\n\n          var i = JSON.parse(e.toString());\n          return r(Ga.ParticleSystemSet.Parse(i, o, s));\n        }, void 0, void 0, void 0, function (e, t) {\n          return o._removePendingData(a), i(\"An error occured while the creation of your particle system. Check if your type '\" + n + \"' exists.\");\n        });\n      });\n    }, e.ExportSet = function (e) {\n      for (var t = new Ga.ParticleSystemSet(), i = 0, r = e; i < r.length; i++) {\n        var n = r[i];\n        t.systems.push(n);\n      }\n\n      return t;\n    }, e.BaseAssetsUrl = \"https://assets.babylonjs.com/particles\", e;\n  }(), Ga.ParticleHelper = ka, Wa = $a || ($a = {}), Ha = function (l) {\n    function e(e, t, i, r) {\n      var n = l.call(this, e, r) || this;\n      n._useDirectMapping = !1, e = e || \"videoDome\", i.resolution = 0 | Math.abs(i.resolution) || 32, i.clickToPlay = Boolean(i.clickToPlay), i.autoPlay = void 0 === i.autoPlay || Boolean(i.autoPlay), i.loop = void 0 === i.loop || Boolean(i.loop), i.size = Math.abs(i.size) || (r.activeCamera ? .48 * r.activeCamera.maxZ : 1e3), void 0 === i.useDirectMapping ? n._useDirectMapping = !0 : n._useDirectMapping = i.useDirectMapping, n._setReady(!1);\n      var o = {\n        loop: i.loop,\n        autoPlay: i.autoPlay,\n        autoUpdateTexture: !0,\n        poster: i.poster\n      },\n          s = n._material = new Wa.BackgroundMaterial(e + \"_material\", r),\n          a = n._videoTexture = new Wa.VideoTexture(e + \"_texture\", t, r, !1, n._useDirectMapping, Wa.Texture.TRILINEAR_SAMPLINGMODE, o);\n      return n._mesh = Wa.Mesh.CreateSphere(e + \"_mesh\", i.resolution, i.size, r, !1, Wa.Mesh.BACKSIDE), a.onLoadObservable.addOnce(function () {\n        n._setReady(!0);\n      }), s.useEquirectangularFOV = !0, s.fovMultiplier = 1, s.opacityFresnel = !1, n._useDirectMapping ? (a.wrapU = Wa.Texture.CLAMP_ADDRESSMODE, a.wrapV = Wa.Texture.CLAMP_ADDRESSMODE, s.diffuseTexture = a) : (a.coordinatesMode = Wa.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE, a.wrapV = Wa.Texture.CLAMP_ADDRESSMODE, s.reflectionTexture = a), n._mesh.material = s, n._mesh.parent = n, i.clickToPlay && (r.onPointerUp = function () {\n        n._videoTexture.video.play();\n      }), n;\n    }\n\n    return T(e, l), Object.defineProperty(e.prototype, \"videoTexture\", {\n      get: function () {\n        return this._videoTexture;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"fovMultiplier\", {\n      get: function () {\n        return this._material.fovMultiplier;\n      },\n      set: function (e) {\n        this._material.fovMultiplier = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function (e, t) {\n      void 0 === t && (t = !1), this._videoTexture.dispose(), this._mesh.dispose(), this._material.dispose(), l.prototype.dispose.call(this, e, t);\n    }, e;\n  }(Wa.TransformNode), Wa.VideoDome = Ha, Xa = $a || ($a = {}), ja = function (a) {\n    function e(e, t, i, r, n) {\n      void 0 === n && (n = null);\n      var o = a.call(this, e, r) || this;\n      o._useDirectMapping = !1, o.onLoadErrorObservable = new Xa.Observable(), e = e || \"photoDome\", i.resolution = 0 | Math.abs(i.resolution) || 32, i.size = Math.abs(i.size) || (r.activeCamera ? .48 * r.activeCamera.maxZ : 1e3), void 0 === i.useDirectMapping ? o._useDirectMapping = !0 : o._useDirectMapping = i.useDirectMapping, o._setReady(!1);\n      var s = o._material = new Xa.BackgroundMaterial(e + \"_material\", r);\n      return o._mesh = Xa.Mesh.CreateSphere(e + \"_mesh\", i.resolution, i.size, r, !1, Xa.Mesh.BACKSIDE), s.opacityFresnel = !1, s.useEquirectangularFOV = !0, s.fovMultiplier = 1, o.photoTexture = new Xa.Texture(t, r, !0, !o._useDirectMapping, void 0, void 0, function (e, t) {\n        o.onLoadErrorObservable.notifyObservers(e || \"Unknown error occured\"), n && n(e, t);\n      }), o.photoTexture.onLoadObservable.addOnce(function () {\n        o._setReady(!0);\n      }), o._mesh.material = s, o._mesh.parent = o;\n    }\n\n    return T(e, a), Object.defineProperty(e.prototype, \"photoTexture\", {\n      get: function () {\n        return this._photoTexture;\n      },\n      set: function (e) {\n        this._photoTexture !== e && (this._photoTexture = e, this._useDirectMapping ? (this._photoTexture.wrapU = Xa.Texture.CLAMP_ADDRESSMODE, this._photoTexture.wrapV = Xa.Texture.CLAMP_ADDRESSMODE, this._material.diffuseTexture = this._photoTexture) : (this._photoTexture.coordinatesMode = Xa.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE, this._photoTexture.wrapV = Xa.Texture.CLAMP_ADDRESSMODE, this._material.reflectionTexture = this._photoTexture));\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(e.prototype, \"fovMultiplier\", {\n      get: function () {\n        return this._material.fovMultiplier;\n      },\n      set: function (e) {\n        this._material.fovMultiplier = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), e.prototype.dispose = function (e, t) {\n      void 0 === t && (t = !1), this._photoTexture.dispose(), this._mesh.dispose(), this._material.dispose(), this.onLoadErrorObservable.clear(), a.prototype.dispose.call(this, e, t);\n    }, e;\n  }(Xa.TransformNode), Xa.PhotoDome = ja, Ya = $a || ($a = {}), Ka = function () {\n    this.occlusionInternalRetryCounter = 0, this.isOcclusionQueryInProgress = !1, this.isOccluded = !1, this.occlusionRetryCount = -1, this.occlusionType = Ya.AbstractMesh.OCCLUSION_TYPE_NONE, this.occlusionQueryAlgorithmType = Ya.AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;\n  }, Ya.Engine.prototype.createQuery = function () {\n    return this._gl.createQuery();\n  }, Ya.Engine.prototype.deleteQuery = function (e) {\n    return this._gl.deleteQuery(e), this;\n  }, Ya.Engine.prototype.isQueryResultAvailable = function (e) {\n    return this._gl.getQueryParameter(e, this._gl.QUERY_RESULT_AVAILABLE);\n  }, Ya.Engine.prototype.getQueryResult = function (e) {\n    return this._gl.getQueryParameter(e, this._gl.QUERY_RESULT);\n  }, Ya.Engine.prototype.beginOcclusionQuery = function (e, t) {\n    var i = this._getGlAlgorithmType(e);\n\n    return this._gl.beginQuery(i, t), this;\n  }, Ya.Engine.prototype.endOcclusionQuery = function (e) {\n    var t = this._getGlAlgorithmType(e);\n\n    return this._gl.endQuery(t), this;\n  }, Ya.Engine.prototype._createTimeQuery = function () {\n    var e = this.getCaps().timerQuery;\n    return e.createQueryEXT ? e.createQueryEXT() : this.createQuery();\n  }, Ya.Engine.prototype._deleteTimeQuery = function (e) {\n    var t = this.getCaps().timerQuery;\n    t.deleteQueryEXT ? t.deleteQueryEXT(e) : this.deleteQuery(e);\n  }, Ya.Engine.prototype._getTimeQueryResult = function (e) {\n    var t = this.getCaps().timerQuery;\n    return t.getQueryObjectEXT ? t.getQueryObjectEXT(e, t.QUERY_RESULT_EXT) : this.getQueryResult(e);\n  }, Ya.Engine.prototype._getTimeQueryAvailability = function (e) {\n    var t = this.getCaps().timerQuery;\n    return t.getQueryObjectEXT ? t.getQueryObjectEXT(e, t.QUERY_RESULT_AVAILABLE_EXT) : this.isQueryResultAvailable(e);\n  }, Ya.Engine.prototype.startTimeQuery = function () {\n    var e = this.getCaps(),\n        t = e.timerQuery;\n    if (!t) return null;\n    var i = new Ya._TimeToken();\n    if (this._gl.getParameter(t.GPU_DISJOINT_EXT), e.canUseTimestampForTimerQuery) i._startTimeQuery = this._createTimeQuery(), t.queryCounterEXT(i._startTimeQuery, t.TIMESTAMP_EXT);else {\n      if (this._currentNonTimestampToken) return this._currentNonTimestampToken;\n      i._timeElapsedQuery = this._createTimeQuery(), t.beginQueryEXT ? t.beginQueryEXT(t.TIME_ELAPSED_EXT, i._timeElapsedQuery) : this._gl.beginQuery(t.TIME_ELAPSED_EXT, i._timeElapsedQuery), this._currentNonTimestampToken = i;\n    }\n    return i;\n  }, Ya.Engine.prototype.endTimeQuery = function (e) {\n    var t = this.getCaps(),\n        i = t.timerQuery;\n    if (!i || !e) return -1;\n\n    if (t.canUseTimestampForTimerQuery) {\n      if (!e._startTimeQuery) return -1;\n      e._endTimeQuery || (e._endTimeQuery = this._createTimeQuery(), i.queryCounterEXT(e._endTimeQuery, i.TIMESTAMP_EXT));\n    } else if (!e._timeElapsedQueryEnded) {\n      if (!e._timeElapsedQuery) return -1;\n      i.endQueryEXT ? i.endQueryEXT(i.TIME_ELAPSED_EXT) : this._gl.endQuery(i.TIME_ELAPSED_EXT), e._timeElapsedQueryEnded = !0;\n    }\n\n    var r = this._gl.getParameter(i.GPU_DISJOINT_EXT),\n        n = !1;\n\n    if (e._endTimeQuery ? n = this._getTimeQueryAvailability(e._endTimeQuery) : e._timeElapsedQuery && (n = this._getTimeQueryAvailability(e._timeElapsedQuery)), n && !r) {\n      var o = 0;\n\n      if (t.canUseTimestampForTimerQuery) {\n        if (!e._startTimeQuery || !e._endTimeQuery) return -1;\n\n        var s = this._getTimeQueryResult(e._startTimeQuery);\n\n        o = this._getTimeQueryResult(e._endTimeQuery) - s, this._deleteTimeQuery(e._startTimeQuery), this._deleteTimeQuery(e._endTimeQuery), e._startTimeQuery = null, e._endTimeQuery = null;\n      } else {\n        if (!e._timeElapsedQuery) return -1;\n        o = this._getTimeQueryResult(e._timeElapsedQuery), this._deleteTimeQuery(e._timeElapsedQuery), e._timeElapsedQuery = null, e._timeElapsedQueryEnded = !1, this._currentNonTimestampToken = null;\n      }\n\n      return o;\n    }\n\n    return -1;\n  }, Ya.Engine.prototype._getGlAlgorithmType = function (e) {\n    return e === Ya.AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE ? this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this._gl.ANY_SAMPLES_PASSED;\n  }, Object.defineProperty(Ya.AbstractMesh.prototype, \"isOcclusionQueryInProgress\", {\n    get: function () {\n      return this._occlusionDataStorage.isOcclusionQueryInProgress;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(Ya.AbstractMesh.prototype, \"_occlusionDataStorage\", {\n    get: function () {\n      return this.__occlusionDataStorage || (this.__occlusionDataStorage = new Ka()), this.__occlusionDataStorage;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(Ya.AbstractMesh.prototype, \"isOccluded\", {\n    get: function () {\n      return this._occlusionDataStorage.isOccluded;\n    },\n    set: function (e) {\n      this._occlusionDataStorage.isOccluded = e;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(Ya.AbstractMesh.prototype, \"occlusionQueryAlgorithmType\", {\n    get: function () {\n      return this._occlusionDataStorage.occlusionQueryAlgorithmType;\n    },\n    set: function (e) {\n      this._occlusionDataStorage.occlusionQueryAlgorithmType = e;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(Ya.AbstractMesh.prototype, \"occlusionType\", {\n    get: function () {\n      return this._occlusionDataStorage.occlusionType;\n    },\n    set: function (e) {\n      this._occlusionDataStorage.occlusionType = e;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(Ya.AbstractMesh.prototype, \"occlusionRetryCount\", {\n    get: function () {\n      return this._occlusionDataStorage.occlusionRetryCount;\n    },\n    set: function (e) {\n      this._occlusionDataStorage.occlusionRetryCount = e;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Ya.AbstractMesh.prototype._checkOcclusionQuery = function () {\n    var e = this._occlusionDataStorage;\n    if (e.occlusionType === Ya.AbstractMesh.OCCLUSION_TYPE_NONE) return e.isOccluded = !1;\n    var t = this.getEngine();\n    if (t.webGLVersion < 2) return e.isOccluded = !1;\n    if (!t.isQueryResultAvailable) return e.isOccluded = !1;\n    if (this.isOcclusionQueryInProgress && this._occlusionQuery) if (t.isQueryResultAvailable(this._occlusionQuery)) {\n      var i = t.getQueryResult(this._occlusionQuery);\n      e.isOcclusionQueryInProgress = !1, e.occlusionInternalRetryCounter = 0, e.isOccluded = 1 !== i;\n    } else {\n      if (e.occlusionInternalRetryCounter++, !(-1 !== e.occlusionRetryCount && e.occlusionInternalRetryCounter > e.occlusionRetryCount)) return !1;\n      e.isOcclusionQueryInProgress = !1, e.occlusionInternalRetryCounter = 0, e.isOccluded = e.occlusionType !== Ya.AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC && e.isOccluded;\n    }\n    var r = this.getScene();\n\n    if (r.getBoundingBoxRenderer) {\n      var n = r.getBoundingBoxRenderer();\n      this._occlusionQuery || (this._occlusionQuery = t.createQuery()), t.beginOcclusionQuery(e.occlusionQueryAlgorithmType, this._occlusionQuery), n.renderOcclusionBoundingBox(this), t.endOcclusionQuery(e.occlusionQueryAlgorithmType), this._occlusionDataStorage.isOcclusionQueryInProgress = !0;\n    }\n\n    return e.isOccluded;\n  }, Qa = $a || ($a = {}), Za = function (s) {\n    function n(e, t, i, r, n) {\n      void 0 === t && (t = 256), void 0 === i && (i = Qa.Engine.LastCreatedScene);\n      var o = s.call(this, e, t, \"noise\", i, r, n) || this;\n      return o._time = 0, o.brightness = .2, o.octaves = 3, o.persistence = .8, o.animationSpeedFactor = 1, o.autoClear = !1, o._updateShaderUniforms(), o;\n    }\n\n    return T(n, s), n.prototype._updateShaderUniforms = function () {\n      var e = this.getScene();\n      e && (this._time += e.getAnimationRatio() * this.animationSpeedFactor * .01, this.setFloat(\"brightness\", this.brightness), this.setFloat(\"persistence\", this.persistence), this.setFloat(\"timeScale\", this._time));\n    }, n.prototype._getDefines = function () {\n      return \"#define OCTAVES \" + (0 | this.octaves);\n    }, n.prototype.render = function (e) {\n      this._updateShaderUniforms(), s.prototype.render.call(this, e);\n    }, n.prototype.serialize = function () {\n      var e = {\n        customType: \"BABYLON.NoiseProceduralTexture\"\n      };\n      return e.brightness = this.brightness, e.octaves = this.octaves, e.persistence = this.persistence, e.animationSpeedFactor = this.animationSpeedFactor, e.size = this.getSize().width, e.generateMipMaps = this._generateMipMaps, e;\n    }, n.Parse = function (e, t, i) {\n      var r = new n(e.name, e.size, t, void 0, e.generateMipMaps);\n      return r.brightness = e.brightness, r.octaves = e.octaves, r.persistence = e.persistence, r.animationSpeedFactor = e.animationSpeedFactor, r;\n    }, n;\n  }(Qa.ProceduralTexture), Qa.NoiseProceduralTexture = Za;\n  var qa, Ja, $a, el;\n\n  ae = this && this.__assign || function () {\n    return (ae = Object.assign || function (e) {\n      for (var t, i = 1, r = arguments.length; i < r; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n      return e;\n    }).apply(this, arguments);\n  };\n\n  qa = $a || ($a = {}), Ja = function () {\n    function n(e, t) {\n      if (void 0 === t && (t = null), !n.IsSupported(e)) throw \"Your browser does not support recording so far.\";\n      var i = e.getRenderingCanvas();\n      if (!i) throw \"The babylon engine must have a canvas to be recorded\";\n      this._canvas = i, this._canvas.isRecording = !1, this._options = ae({}, n._defaultOptions, t);\n\n      var r = this._canvas.captureStream(this._options.fps);\n\n      this._mediaRecorder = new MediaRecorder(r, {\n        mimeType: this._options.mimeType\n      }), this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this), this._mediaRecorder.onerror = this._handleError.bind(this), this._mediaRecorder.onstop = this._handleStop.bind(this);\n    }\n\n    return n.IsSupported = function (e) {\n      var t = e.getRenderingCanvas();\n      return !!t && \"function\" == typeof t.captureStream;\n    }, Object.defineProperty(n.prototype, \"isRecording\", {\n      get: function () {\n        return !!this._canvas && this._canvas.isRecording;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), n.prototype.stopRecording = function () {\n      this._canvas && this._mediaRecorder && this.isRecording && (this._canvas.isRecording = !1, this._mediaRecorder.stop());\n    }, n.prototype.startRecording = function (e, t) {\n      var i = this;\n      if (void 0 === e && (e = \"babylonjs.webm\"), void 0 === t && (t = 7), !this._canvas || !this._mediaRecorder) throw \"Recorder has already been disposed\";\n      if (this.isRecording) throw \"Recording already in progress\";\n      return 0 < t && setTimeout(function () {\n        i.stopRecording();\n      }, 1e3 * t), this._fileName = e, this._recordedChunks = [], this._resolve = null, this._reject = null, this._canvas.isRecording = !0, this._mediaRecorder.start(this._options.recordChunckSize), new Promise(function (e, t) {\n        i._resolve = e, i._reject = t;\n      });\n    }, n.prototype.dispose = function () {\n      this._canvas = null, this._mediaRecorder = null, this._recordedChunks = [], this._fileName = null, this._resolve = null, this._reject = null;\n    }, n.prototype._handleDataAvailable = function (e) {\n      0 < e.data.size && this._recordedChunks.push(e.data);\n    }, n.prototype._handleError = function (e) {\n      if (this.stopRecording(), !this._reject) throw new e.error();\n\n      this._reject(e.error);\n    }, n.prototype._handleStop = function () {\n      this.stopRecording();\n      var e = new Blob(this._recordedChunks);\n      this._resolve && this._resolve(e), window.URL.createObjectURL(e), this._fileName && qa.Tools.Download(e, this._fileName);\n    }, n._defaultOptions = {\n      mimeType: \"video/webm\",\n      fps: 25,\n      recordChunckSize: 3e3\n    }, n;\n  }(), qa.VideoRecorder = Ja, (el = $a || ($a = {})).Scene.prototype.createDefaultLight = function (e) {\n    if (void 0 === e && (e = !1), e && this.lights) for (var t = 0; t < this.lights.length; t++) this.lights[t].dispose();\n    0 === this.lights.length && new el.HemisphericLight(\"default light\", el.Vector3.Up(), this);\n  }, el.Scene.prototype.createDefaultCamera = function (e, t, i) {\n    if (void 0 === e && (e = !1), void 0 === t && (t = !1), void 0 === i && (i = !1), t && this.activeCamera && (this.activeCamera.dispose(), this.activeCamera = null), !this.activeCamera) {\n      var r,\n          n = this.getWorldExtends(),\n          o = n.max.subtract(n.min),\n          s = n.min.add(o.scale(.5)),\n          a = 1.5 * o.length();\n\n      if (isFinite(a) || (a = 1, s.copyFromFloats(0, 0, 0)), e) {\n        var l = new el.ArcRotateCamera(\"default camera\", -Math.PI / 2, Math.PI / 2, a, s, this);\n        l.lowerRadiusLimit = .01 * a, l.wheelPrecision = 100 / a, r = l;\n      } else {\n        var c = new el.FreeCamera(\"default camera\", new el.Vector3(s.x, s.y, -a), this);\n        c.setTarget(s), r = c;\n      }\n\n      r.minZ = .01 * a, r.maxZ = 1e3 * a, r.speed = .2 * a, this.activeCamera = r;\n      var h = this.getEngine().getRenderingCanvas();\n      i && h && r.attachControl(h);\n    }\n  }, el.Scene.prototype.createDefaultCameraOrLight = function (e, t, i) {\n    void 0 === e && (e = !1), void 0 === t && (t = !1), void 0 === i && (i = !1), this.createDefaultLight(t), this.createDefaultCamera(e, t, i);\n  }, el.Scene.prototype.createDefaultSkybox = function (e, t, i, r, n) {\n    if (void 0 === t && (t = !1), void 0 === i && (i = 1e3), void 0 === r && (r = 0), void 0 === n && (n = !0), !e) return el.Tools.Warn(\"Can not create default skybox without environment texture.\"), null;\n    n && e && (this.environmentTexture = e);\n    var o = el.Mesh.CreateBox(\"hdrSkyBox\", i, this);\n\n    if (t) {\n      var s = new el.PBRMaterial(\"skyBox\", this);\n      s.backFaceCulling = !1, s.reflectionTexture = e.clone(), s.reflectionTexture && (s.reflectionTexture.coordinatesMode = el.Texture.SKYBOX_MODE), s.microSurface = 1 - r, s.disableLighting = !0, s.twoSidedLighting = !0, o.infiniteDistance = !0, o.material = s;\n    } else {\n      var a = new el.StandardMaterial(\"skyBox\", this);\n      a.backFaceCulling = !1, a.reflectionTexture = e.clone(), a.reflectionTexture && (a.reflectionTexture.coordinatesMode = el.Texture.SKYBOX_MODE), a.disableLighting = !0, o.infiniteDistance = !0, o.material = a;\n    }\n\n    return o;\n  }, el.Scene.prototype.createDefaultEnvironment = function (e) {\n    return el.EnvironmentHelper ? new el.EnvironmentHelper(e, this) : null;\n  }, el.Scene.prototype.createDefaultVRExperience = function (e) {\n    return void 0 === e && (e = {}), new el.VRExperienceHelper(this, e);\n  }, $a.Effect.ShadersStore = {\n    defaultVertexShader: \"#include<__decl__defaultVertex>\\n\\n#define CUSTOM_VERTEX_BEGIN\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<helperFunctions>\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nvarying vec2 vDiffuseUV;\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nvarying vec2 vAmbientUV;\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nvarying vec2 vOpacityUV;\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nvarying vec2 vEmissiveUV;\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nvarying vec2 vLightmapUV;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nvarying vec2 vSpecularUV;\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nvarying vec2 vBumpUV;\\n#endif\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\n#define CUSTOM_VERTEX_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\nvec3 positionUpdated=position;\\n#ifdef NORMAL \\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\n#ifdef REFLECTIONMAP_SKYBOX_TRANSFORMED\\nvPositionUVW=(reflectionMatrix*vec4(position,1.0)).xyz;\\n#else\\nvPositionUVW=position;\\n#endif\\n#endif \\n#define CUSTOM_VERTEX_UPDATE_POSITION\\n#define CUSTOM_VERTEX_UPDATE_NORMAL\\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\nvPositionW=vec3(worldPos);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normalUpdated);\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uv;\\n#endif\\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nif (vDiffuseInfos.x == 0.)\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nif (vAmbientInfos.x == 0.)\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nif (vOpacityInfos.x == 0.)\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nif (vEmissiveInfos.x == 0.)\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nif (vLightmapInfos.x == 0.)\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nif (vSpecularInfos.x == 0.)\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nif (vBumpInfos.x == 0.)\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#include<bumpVertex>\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#ifdef VERTEXCOLOR\\n\\nvColor=color;\\n#endif\\n#include<pointCloudVertex>\\n#include<logDepthVertex>\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\",\n    defaultPixelShader: \"#include<__decl__defaultFragment>\\n#if defined(BUMP) || !defined(NORMAL)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#define CUSTOM_FRAGMENT_BEGIN\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\n\\n#define RECIPROCAL_PI2 0.15915494\\nuniform vec3 vEyePosition;\\nuniform vec3 vAmbientColor;\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n\\n#include<helperFunctions>\\n\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<lightsFragmentFunctions>\\n#include<shadowsFragmentFunctions>\\n\\n#ifdef DIFFUSE\\n#if DIFFUSEDIRECTUV == 1\\n#define vDiffuseUV vMainUV1\\n#elif DIFFUSEDIRECTUV == 2\\n#define vDiffuseUV vMainUV2\\n#else\\nvarying vec2 vDiffuseUV;\\n#endif\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef AMBIENT\\n#if AMBIENTDIRECTUV == 1\\n#define vAmbientUV vMainUV1\\n#elif AMBIENTDIRECTUV == 2\\n#define vAmbientUV vMainUV2\\n#else\\nvarying vec2 vAmbientUV;\\n#endif\\nuniform sampler2D ambientSampler;\\n#endif\\n#ifdef OPACITY \\n#if OPACITYDIRECTUV == 1\\n#define vOpacityUV vMainUV1\\n#elif OPACITYDIRECTUV == 2\\n#define vOpacityUV vMainUV2\\n#else\\nvarying vec2 vOpacityUV;\\n#endif\\nuniform sampler2D opacitySampler;\\n#endif\\n#ifdef EMISSIVE\\n#if EMISSIVEDIRECTUV == 1\\n#define vEmissiveUV vMainUV1\\n#elif EMISSIVEDIRECTUV == 2\\n#define vEmissiveUV vMainUV2\\n#else\\nvarying vec2 vEmissiveUV;\\n#endif\\nuniform sampler2D emissiveSampler;\\n#endif\\n#ifdef LIGHTMAP\\n#if LIGHTMAPDIRECTUV == 1\\n#define vLightmapUV vMainUV1\\n#elif LIGHTMAPDIRECTUV == 2\\n#define vLightmapUV vMainUV2\\n#else\\nvarying vec2 vLightmapUV;\\n#endif\\nuniform sampler2D lightmapSampler;\\n#endif\\n#ifdef REFRACTION\\n#ifdef REFRACTIONMAP_3D\\nuniform samplerCube refractionCubeSampler;\\n#else\\nuniform sampler2D refraction2DSampler;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\n#if SPECULARDIRECTUV == 1\\n#define vSpecularUV vMainUV1\\n#elif SPECULARDIRECTUV == 2\\n#define vSpecularUV vMainUV2\\n#else\\nvarying vec2 vSpecularUV;\\n#endif\\nuniform sampler2D specularSampler;\\n#endif\\n#ifdef ALPHATEST\\nuniform float alphaCutOff;\\n#endif\\n\\n#include<fresnelFunction>\\n\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\nuniform samplerCube reflectionCubeSampler;\\n#else\\nuniform sampler2D reflection2DSampler;\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<imageProcessingFunctions>\\n#include<bumpFragmentFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n#include<fogFragmentDeclaration>\\n#define CUSTOM_FRAGMENT_DEFINITIONS\\nvoid main(void) {\\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\\n#include<clipPlaneFragment>\\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\\n\\nvec4 baseColor=vec4(1.,1.,1.,1.);\\nvec3 diffuseColor=vDiffuseColor.rgb;\\n\\nfloat alpha=vDiffuseColor.a;\\n\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\\n#endif\\n#include<bumpFragment>\\n#ifdef TWOSIDEDLIGHTING\\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#endif\\n#ifdef DIFFUSE\\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\\n#ifdef ALPHATEST\\nif (baseColor.a<alphaCutOff)\\ndiscard;\\n#endif\\n#ifdef ALPHAFROMDIFFUSE\\nalpha*=baseColor.a;\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\\nbaseColor.rgb*=vDiffuseInfos.y;\\n#endif\\n#include<depthPrePass>\\n#ifdef VERTEXCOLOR\\nbaseColor.rgb*=vColor.rgb;\\n#endif\\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\\n\\nvec3 baseAmbientColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\\n\\n#ifdef SPECULARTERM\\nfloat glossiness=vSpecularColor.a;\\nvec3 specularColor=vSpecularColor.rgb;\\n#ifdef SPECULAR\\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\\nspecularColor=specularMapColor.rgb;\\n#ifdef GLOSSINESS\\nglossiness=glossiness*specularMapColor.a;\\n#endif\\n#endif\\n#else\\nfloat glossiness=0.;\\n#endif\\n\\nvec3 diffuseBase=vec3(0.,0.,0.);\\nlightingInfo info;\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\nfloat shadow=1.;\\n#ifdef LIGHTMAP\\nvec3 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset).rgb*vLightmapInfos.y;\\n#endif\\n#include<lightFragment>[0..maxSimultaneousLights]\\n\\nvec3 refractionColor=vec3(0.,0.,0.);\\n#ifdef REFRACTION\\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\\n#ifdef REFRACTIONMAP_3D\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nif (dot(refractionVector,viewDirectionW)<1.0) {\\nrefractionColor=textureCube(refractionCubeSampler,refractionVector).rgb;\\n}\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\nrefractionColor=texture2D(refraction2DSampler,refractionCoords).rgb;\\n#endif\\n#ifdef IS_REFRACTION_LINEAR\\nrefractionColor=toGammaSpace(refractionColor);\\n#endif\\nrefractionColor*=vRefractionInfos.x;\\n#endif\\n\\nvec3 reflectionColor=vec3(0.,0.,0.);\\n#ifdef REFLECTION\\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_3D\\n#ifdef ROUGHNESS\\nfloat bias=vReflectionInfos.y;\\n#ifdef SPECULARTERM\\n#ifdef SPECULAR\\n#ifdef GLOSSINESS\\nbias*=(1.0-specularMapColor.a);\\n#endif\\n#endif\\n#endif\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias).rgb;\\n#else\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW).rgb;\\n#endif\\n#else\\nvec2 coords=vReflectionUVW.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\ncoords/=vReflectionUVW.z;\\n#endif\\ncoords.y=1.0-coords.y;\\nreflectionColor=texture2D(reflection2DSampler,coords).rgb;\\n#endif\\n#ifdef IS_REFLECTION_LINEAR\\nreflectionColor=toGammaSpace(reflectionColor);\\n#endif\\nreflectionColor*=vReflectionInfos.x;\\n#ifdef REFLECTIONFRESNEL\\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\\n#ifdef REFLECTIONFRESNELFROMSPECULAR\\n#ifdef SPECULARTERM\\nreflectionColor*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#else\\nreflectionColor*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#else\\nreflectionColor*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#endif\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\\nrefractionColor*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\\n#endif\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#ifdef OPACITYRGB\\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\\n#else\\nalpha*=opacityMap.a*vOpacityInfos.y;\\n#endif\\n#endif\\n#ifdef VERTEXALPHA\\nalpha*=vColor.a;\\n#endif\\n#ifdef OPACITYFRESNEL\\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\\n#endif\\n\\nvec3 emissiveColor=vEmissiveColor;\\n#ifdef EMISSIVE\\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\\n#endif\\n\\n#ifdef DIFFUSEFRESNEL\\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#endif\\n#endif\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase*specularColor;\\n#ifdef SPECULAROVERALPHA\\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n#else\\nvec3 finalSpecular=vec3(0.0);\\n#endif\\n#ifdef REFLECTIONOVERALPHA\\nalpha=clamp(alpha+dot(reflectionColor,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor+emissiveColor+refractionColor,0.0,1.0),alpha);\\n#else\\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor+refractionColor,alpha);\\n#endif\\n\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\ncolor.rgb*=lightmapColor;\\n#else\\ncolor.rgb+=lightmapColor;\\n#endif\\n#endif\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FOG\\ncolor.rgb=max(color.rgb,0.);\\n#include<logDepthFragment>\\n#include<fogFragment>\\n\\n\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\ncolor.rgb=toLinearSpace(color.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\ncolor.rgb=toLinearSpace(color.rgb);\\ncolor=applyImageProcessing(color);\\n#endif\\n#endif\\n#ifdef PREMULTIPLYALPHA\\n\\ncolor.rgb*=color.a;\\n#endif\\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\\ngl_FragColor=color;\\n}\\n\",\n    pbrVertexShader: \"precision highp float;\\n#include<__decl__pbrVertex>\\n\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2; \\n#endif \\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<helperFunctions>\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\n#if defined(ALBEDO) && ALBEDODIRECTUV == 0\\nvarying vec2 vAlbedoUV;\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nvarying vec2 vAmbientUV;\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nvarying vec2 vOpacityUV;\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nvarying vec2 vEmissiveUV;\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nvarying vec2 vLightmapUV;\\n#endif\\n#if defined(REFLECTIVITY) && REFLECTIVITYDIRECTUV == 0\\nvarying vec2 vReflectivityUV;\\n#endif\\n#if defined(MICROSURFACEMAP) && MICROSURFACEMAPDIRECTUV == 0\\nvarying vec2 vMicroSurfaceSamplerUV;\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nvarying vec2 vBumpUV;\\n#endif\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\nvarying vec3 vEnvironmentIrradiance;\\n#include<harmonicsFunctions>\\n#endif\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\nvoid main(void) {\\nvec3 positionUpdated=position;\\n#ifdef NORMAL\\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\n#ifdef REFLECTIONMAP_SKYBOX_TRANSFORMED\\nvPositionUVW=(reflectionMatrix*vec4(positionUpdated,1.0)).xyz;\\n#else\\nvPositionUVW=positionUpdated;\\n#endif\\n#endif \\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\nvPositionW=vec3(worldPos);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normalUpdated);\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\nvEnvironmentIrradiance=environmentIrradianceJones(reflectionVector);\\n#endif\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uv;\\n#endif \\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif \\n#if defined(ALBEDO) && ALBEDODIRECTUV == 0 \\nif (vAlbedoInfos.x == 0.)\\n{\\nvAlbedoUV=vec2(albedoMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0 \\nif (vAmbientInfos.x == 0.)\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0 \\nif (vOpacityInfos.x == 0.)\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0 \\nif (vEmissiveInfos.x == 0.)\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0 \\nif (vLightmapInfos.x == 0.)\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(REFLECTIVITY) && REFLECTIVITYDIRECTUV == 0 \\nif (vReflectivityInfos.x == 0.)\\n{\\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(MICROSURFACEMAP) && MICROSURFACEMAPDIRECTUV == 0 \\nif (vMicroSurfaceSamplerInfos.x == 0.)\\n{\\nvMicroSurfaceSamplerUV=vec2(microSurfaceSamplerMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvMicroSurfaceSamplerUV=vec2(microSurfaceSamplerMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0 \\nif (vBumpInfos.x == 0.)\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n\\n#include<bumpVertex>\\n\\n#include<clipPlaneVertex>\\n\\n#include<fogVertex>\\n\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n\\n#ifdef VERTEXCOLOR\\nvColor=color;\\n#endif\\n\\n#ifdef POINTSIZE\\ngl_PointSize=pointSize;\\n#endif\\n\\n#include<logDepthVertex>\\n}\",\n    pbrPixelShader: \"#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\n#extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\nprecision highp float;\\n#include<__decl__pbrFragment>\\nuniform vec4 vEyePosition;\\nuniform vec3 vAmbientColor;\\nuniform vec4 vCameraInfos;\\n\\nvarying vec3 vPositionW;\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif \\n#ifdef MAINUV2 \\nvarying vec2 vMainUV2;\\n#endif \\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\\nvarying vec3 vEnvironmentIrradiance;\\n#endif\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n\\n#ifdef ALBEDO\\n#if ALBEDODIRECTUV == 1\\n#define vAlbedoUV vMainUV1\\n#elif ALBEDODIRECTUV == 2\\n#define vAlbedoUV vMainUV2\\n#else\\nvarying vec2 vAlbedoUV;\\n#endif\\nuniform sampler2D albedoSampler;\\n#endif\\n#ifdef AMBIENT\\n#if AMBIENTDIRECTUV == 1\\n#define vAmbientUV vMainUV1\\n#elif AMBIENTDIRECTUV == 2\\n#define vAmbientUV vMainUV2\\n#else\\nvarying vec2 vAmbientUV;\\n#endif\\nuniform sampler2D ambientSampler;\\n#endif\\n#ifdef OPACITY\\n#if OPACITYDIRECTUV == 1\\n#define vOpacityUV vMainUV1\\n#elif OPACITYDIRECTUV == 2\\n#define vOpacityUV vMainUV2\\n#else\\nvarying vec2 vOpacityUV;\\n#endif\\nuniform sampler2D opacitySampler;\\n#endif\\n#ifdef EMISSIVE\\n#if EMISSIVEDIRECTUV == 1\\n#define vEmissiveUV vMainUV1\\n#elif EMISSIVEDIRECTUV == 2\\n#define vEmissiveUV vMainUV2\\n#else\\nvarying vec2 vEmissiveUV;\\n#endif\\nuniform sampler2D emissiveSampler;\\n#endif\\n#ifdef LIGHTMAP\\n#if LIGHTMAPDIRECTUV == 1\\n#define vLightmapUV vMainUV1\\n#elif LIGHTMAPDIRECTUV == 2\\n#define vLightmapUV vMainUV2\\n#else\\nvarying vec2 vLightmapUV;\\n#endif\\nuniform sampler2D lightmapSampler;\\n#endif\\n#ifdef REFLECTIVITY\\n#if REFLECTIVITYDIRECTUV == 1\\n#define vReflectivityUV vMainUV1\\n#elif REFLECTIVITYDIRECTUV == 2\\n#define vReflectivityUV vMainUV2\\n#else\\nvarying vec2 vReflectivityUV;\\n#endif\\nuniform sampler2D reflectivitySampler;\\n#endif\\n#ifdef MICROSURFACEMAP\\n#if MICROSURFACEMAPDIRECTUV == 1\\n#define vMicroSurfaceSamplerUV vMainUV1\\n#elif MICROSURFACEMAPDIRECTUV == 2\\n#define vMicroSurfaceSamplerUV vMainUV2\\n#else\\nvarying vec2 vMicroSurfaceSamplerUV;\\n#endif\\nuniform sampler2D microSurfaceSampler;\\n#endif\\n\\n#ifdef REFRACTION\\n#ifdef REFRACTIONMAP_3D\\n#define sampleRefraction(s,c) textureCube(s,c)\\nuniform samplerCube refractionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube refractionSamplerLow;\\nuniform samplerCube refractionSamplerHigh;\\n#endif\\n#else\\n#define sampleRefraction(s,c) texture2D(s,c)\\nuniform sampler2D refractionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform samplerCube refractionSamplerLow;\\nuniform samplerCube refractionSamplerHigh;\\n#endif\\n#endif\\n#endif\\n\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\n#define sampleReflection(s,c) textureCube(s,c)\\nuniform samplerCube reflectionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#else\\n#define sampleReflection(s,c) texture2D(s,c)\\nuniform sampler2D reflectionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#ifdef ENVIRONMENTBRDF\\nuniform sampler2D environmentBrdfSampler;\\n#endif\\n\\n#ifndef FROMLINEARSPACE\\n#define FROMLINEARSPACE;\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\n\\n#include<shadowsFragmentFunctions>\\n#include<pbrFunctions>\\n#include<harmonicsFunctions>\\n#include<pbrLightFunctions>\\n#include<bumpFragmentFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n\\n#include<fogFragmentDeclaration>\\nvoid main(void) {\\n#include<clipPlaneFragment>\\n\\n\\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\\n#endif\\n#include<bumpFragment>\\n#ifdef SPECULARAA\\nvec3 nDfdx=dFdx(normalW.xyz);\\nvec3 nDfdy=dFdy(normalW.xyz);\\nfloat slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));\\n\\nfloat geometricRoughnessFactor=pow(clamp(slopeSquare ,0.,1.),0.333);\\n\\nfloat geometricAlphaGFactor=sqrt(slopeSquare);\\n#else\\nfloat geometricRoughnessFactor=0.;\\n#endif\\n#if defined(FORCENORMALFORWARD) && defined(NORMAL)\\nvec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;\\n#if defined(TWOSIDEDLIGHTING)\\nfaceNormal=gl_FrontFacing ? faceNormal : -faceNormal;\\n#endif\\nnormalW*=sign(dot(normalW,faceNormal));\\n#endif\\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)\\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#endif\\n\\n\\nvec3 surfaceAlbedo=vAlbedoColor.rgb;\\n\\nfloat alpha=vAlbedoColor.a;\\n#ifdef ALBEDO\\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\\nalpha*=albedoTexture.a;\\n#endif\\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\\nsurfaceAlbedo*=vAlbedoInfos.y;\\n#endif\\n\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#ifdef OPACITYRGB\\nalpha=getLuminance(opacityMap.rgb);\\n#else\\nalpha*=opacityMap.a;\\n#endif\\nalpha*=vOpacityInfos.y;\\n#endif\\n#ifdef VERTEXALPHA\\nalpha*=vColor.a;\\n#endif\\n#if !defined(LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\\n#ifdef ALPHATEST\\nif (alpha<ALPHATESTVALUE)\\ndiscard;\\n#ifndef ALPHABLEND\\n\\nalpha=1.0;\\n#endif\\n#endif\\n#endif\\n#include<depthPrePass>\\n#ifdef VERTEXCOLOR\\nsurfaceAlbedo*=vColor.rgb;\\n#endif\\n\\nvec3 ambientOcclusionColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\\n#ifdef AMBIENTINGRAYSCALE\\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\\n#endif\\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\\n#endif\\n#ifdef UNLIT\\nvec3 diffuseBase=vec3(1.,1.,1.);\\n#else\\n\\nfloat microSurface=vReflectivityColor.a;\\nvec3 surfaceReflectivityColor=vReflectivityColor.rgb;\\n#ifdef METALLICWORKFLOW\\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\\n#ifdef REFLECTIVITY\\nvec4 surfaceMetallicColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\\n#ifdef AOSTOREINMETALMAPRED\\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicColorMap.r,surfaceMetallicColorMap.r,surfaceMetallicColorMap.r);\\nambientOcclusionColor=mix(ambientOcclusionColor,aoStoreInMetalMap,vReflectivityInfos.z);\\n#endif\\n#ifdef METALLNESSSTOREINMETALMAPBLUE\\nmetallicRoughness.r*=surfaceMetallicColorMap.b;\\n#else\\nmetallicRoughness.r*=surfaceMetallicColorMap.r;\\n#endif\\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\\nmetallicRoughness.g*=surfaceMetallicColorMap.a;\\n#else\\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\\nmetallicRoughness.g*=surfaceMetallicColorMap.g;\\n#endif\\n#endif\\n#endif\\n#ifdef MICROSURFACEMAP\\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\\nmetallicRoughness.g*=microSurfaceTexel.r;\\n#endif\\n\\nmicroSurface=1.0-metallicRoughness.g;\\n\\nvec3 baseColor=surfaceAlbedo;\\n\\n\\nconst vec3 DefaultSpecularReflectanceDielectric=vec3(0.04,0.04,0.04);\\n\\nsurfaceAlbedo=mix(baseColor.rgb*(1.0-DefaultSpecularReflectanceDielectric.r),vec3(0.,0.,0.),metallicRoughness.r);\\n\\nsurfaceReflectivityColor=mix(DefaultSpecularReflectanceDielectric,baseColor,metallicRoughness.r);\\n#else\\n#ifdef REFLECTIVITY\\nvec4 surfaceReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\\nsurfaceReflectivityColor*=toLinearSpace(surfaceReflectivityColorMap.rgb);\\nsurfaceReflectivityColor*=vReflectivityInfos.y;\\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\\nmicroSurface*=surfaceReflectivityColorMap.a;\\nmicroSurface*=vReflectivityInfos.z;\\n#else\\n#ifdef MICROSURFACEAUTOMATIC\\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\\n#endif\\n#ifdef MICROSURFACEMAP\\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\\nmicroSurface*=microSurfaceTexel.r;\\n#endif\\n#endif\\n#endif\\n#endif\\n\\nmicroSurface=clamp(microSurface,0.,1.);\\n\\nfloat roughness=1.-microSurface;\\n\\n#ifdef ALPHAFRESNEL\\n#if defined(ALPHATEST) || defined(ALPHABLEND)\\n\\n\\n\\nfloat opacityPerceptual=alpha;\\n#ifdef LINEARALPHAFRESNEL\\nfloat opacity0=opacityPerceptual;\\n#else\\nfloat opacity0=opacityPerceptual*opacityPerceptual;\\n#endif\\nfloat opacity90=fresnelGrazingReflectance(opacity0);\\nvec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);\\n\\nalpha=fresnelSchlickEnvironmentGGX(clamp(dot(viewDirectionW,normalForward),0.0,1.0),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\\n#ifdef ALPHATEST\\nif (alpha<ALPHATESTVALUE)\\ndiscard;\\n#ifndef ALPHABLEND\\n\\nalpha=1.0;\\n#endif\\n#endif\\n#endif\\n#endif\\n\\n\\nfloat NdotVUnclamped=dot(normalW,viewDirectionW);\\nfloat NdotV=clamp(NdotVUnclamped,0.,1.)+0.00001;\\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\\n#ifdef SPECULARAA\\n\\n\\nalphaG+=(0.75*geometricAlphaGFactor);\\n#endif\\n\\n#ifdef REFRACTION\\nvec4 environmentRefraction=vec4(0.,0.,0.,0.);\\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\\n#ifdef REFRACTIONMAP_OPPOSITEZ\\nrefractionVector.z*=-1.0;\\n#endif\\n\\n#ifdef REFRACTIONMAP_3D\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nvec3 refractionCoords=refractionVector;\\nrefractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\n#endif\\n#ifdef LODINREFRACTIONALPHA\\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\\n#else\\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,alphaG,1.0);\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\n\\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\\n#ifdef LODINREFRACTIONALPHA\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);\\nfloat requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\\n#else\\nfloat requestedRefractionLOD=refractionLOD;\\n#endif\\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);\\n#else\\nfloat lodRefractionNormalized=clamp(refractionLOD/log2(vRefractionMicrosurfaceInfos.x),0.,1.);\\nfloat lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;\\nvec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);\\nif(lodRefractionNormalizedDoubled<1.0){\\nenvironmentRefraction=mix(\\nsampleRefraction(refractionSamplerHigh,refractionCoords),\\nenvironmentRefractionMid,\\nlodRefractionNormalizedDoubled\\n);\\n}else{\\nenvironmentRefraction=mix(\\nenvironmentRefractionMid,\\nsampleRefraction(refractionSamplerLow,refractionCoords),\\nlodRefractionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#ifdef GAMMAREFRACTION\\nenvironmentRefraction.rgb=fromRGBD(environmentRefraction);\\n#endif\\n#ifdef RGBDREFRACTION\\nenvironmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);\\n#endif\\n\\nenvironmentRefraction.rgb*=vRefractionInfos.x;\\n#endif\\n\\n#ifdef REFLECTION\\nvec4 environmentRadiance=vec4(0.,0.,0.,0.);\\nvec3 environmentIrradiance=vec3(0.,0.,0.);\\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\n\\n#ifdef REFLECTIONMAP_3D\\nvec3 reflectionCoords=reflectionVector;\\n#else\\nvec2 reflectionCoords=reflectionVector.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\nreflectionCoords/=reflectionVector.z;\\n#endif\\nreflectionCoords.y=1.0-reflectionCoords.y;\\n#endif\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\\n#else\\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,1.);\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\n\\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\\n#ifdef LODINREFLECTIONALPHA\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);\\nfloat requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\\n#else\\nfloat requestedReflectionLOD=reflectionLOD;\\n#endif\\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,requestedReflectionLOD);\\n#else\\nfloat lodReflectionNormalized=clamp(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x),0.,1.);\\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\\nvec4 environmentSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);\\nif(lodReflectionNormalizedDoubled<1.0){\\nenvironmentRadiance=mix(\\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\\nenvironmentSpecularMid,\\nlodReflectionNormalizedDoubled\\n);\\n}else{\\nenvironmentRadiance=mix(\\nenvironmentSpecularMid,\\nsampleReflection(reflectionSamplerLow,reflectionCoords),\\nlodReflectionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#ifdef RGBDREFLECTION\\nenvironmentRadiance.rgb=fromRGBD(environmentRadiance);\\n#endif\\n#ifdef GAMMAREFLECTION\\nenvironmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);\\n#endif\\n\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if defined(NORMAL) && defined(USESPHERICALINVERTEX)\\nenvironmentIrradiance=vEnvironmentIrradiance;\\n#else\\nvec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nirradianceVector.z*=-1.0;\\n#endif\\nenvironmentIrradiance=environmentIrradianceJones(irradianceVector);\\n#endif\\n#endif\\n\\nenvironmentRadiance.rgb*=vReflectionInfos.x;\\nenvironmentRadiance.rgb*=vReflectionColor.rgb;\\nenvironmentIrradiance*=vReflectionColor.rgb;\\n#endif\\n\\n\\n\\nfloat reflectance=max(max(surfaceReflectivityColor.r,surfaceReflectivityColor.g),surfaceReflectivityColor.b);\\nfloat reflectance90=fresnelGrazingReflectance(reflectance);\\nvec3 specularEnvironmentR0=surfaceReflectivityColor.rgb;\\nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0)*reflectance90;\\n\\nvec3 diffuseBase=vec3(0.,0.,0.);\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\n#ifdef LIGHTMAP\\nvec3 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset).rgb;\\n#ifdef GAMMALIGHTMAP\\nlightmapColor=toLinearSpace(lightmapColor);\\n#endif\\nlightmapColor*=vLightmapInfos.y;\\n#endif\\nlightingInfo info;\\npointLightingInfo pointInfo;\\nspotLightingInfo spotInfo;\\nfloat shadow=1.; \\nfloat NdotL=-1.;\\n#include<lightFragment>[0..maxSimultaneousLights]\\n\\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\n\\nvec2 brdfSamplerUV=vec2(NdotV,roughness);\\n\\nvec4 environmentBrdf=texture2D(environmentBrdfSampler,brdfSamplerUV);\\nvec3 specularEnvironmentReflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\\n#ifdef RADIANCEOCCLUSION\\n#ifdef AMBIENTINGRAYSCALE\\nfloat ambientMonochrome=ambientOcclusionColor.r;\\n#else\\nfloat ambientMonochrome=getLuminance(ambientOcclusionColor);\\n#endif\\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\\nspecularEnvironmentReflectance*=seo;\\n#endif\\n#ifdef HORIZONOCCLUSION\\n#ifdef BUMP\\n#ifdef REFLECTIONMAP_3D\\nfloat eho=environmentHorizonOcclusion(-viewDirectionW,normalW);\\nspecularEnvironmentReflectance*=eho;\\n#endif\\n#endif\\n#endif\\n#else\\n\\nvec3 specularEnvironmentReflectance=fresnelSchlickEnvironmentGGX(NdotV,specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\\n#endif\\n\\n#ifdef REFRACTION\\nvec3 refractance=vec3(0.0,0.0,0.0);\\nvec3 transmission=vec3(1.0,1.0,1.0);\\n#ifdef LINKREFRACTIONTOTRANSPARENCY\\n\\ntransmission*=(1.0-alpha);\\n\\n\\nvec3 mixedAlbedo=surfaceAlbedo;\\nfloat maxChannel=max(max(mixedAlbedo.r,mixedAlbedo.g),mixedAlbedo.b);\\nvec3 tint=clamp(maxChannel*mixedAlbedo,0.0,1.0);\\n\\nsurfaceAlbedo*=alpha;\\n\\nenvironmentIrradiance*=alpha;\\n\\nenvironmentRefraction.rgb*=tint;\\n\\nalpha=1.0;\\n#endif\\n\\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);\\nspecularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,alpha);\\n\\ntransmission*=1.0-specularEnvironmentReflectance;\\n\\nrefractance=transmission;\\n#endif\\n\\n\\n\\n\\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\\n\\n#ifdef REFLECTION\\nvec3 finalIrradiance=environmentIrradiance;\\nfinalIrradiance*=surfaceAlbedo.rgb;\\n#endif\\n\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase;\\nfinalSpecular=max(finalSpecular,0.0);\\n\\nvec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\\n#endif\\n\\n#ifdef REFLECTION\\nvec3 finalRadiance=environmentRadiance.rgb;\\nfinalRadiance*=specularEnvironmentReflectance;\\n\\nvec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\\n#endif\\n\\n#ifdef REFRACTION\\nvec3 finalRefraction=environmentRefraction.rgb;\\nfinalRefraction*=refractance;\\n#endif\\n\\n#ifdef ALPHABLEND\\nfloat luminanceOverAlpha=0.0;\\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\\n#endif\\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\\n#endif\\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA)\\nalpha=clamp(alpha+luminanceOverAlpha*luminanceOverAlpha,0.,1.);\\n#endif\\n#endif\\n#endif\\n\\nvec3 finalDiffuse=diffuseBase;\\nfinalDiffuse.rgb+=vAmbientColor;\\nfinalDiffuse*=surfaceAlbedo.rgb;\\nfinalDiffuse=max(finalDiffuse,0.0);\\n\\nvec3 finalEmissive=vEmissiveColor;\\n#ifdef EMISSIVE\\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\\nfinalEmissive*=vEmissiveInfos.y;\\n#endif\\n\\n#ifdef AMBIENT\\nvec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),ambientOcclusionColor,vAmbientInfos.w);\\n#else\\nvec3 ambientOcclusionForDirectDiffuse=ambientOcclusionColor;\\n#endif\\n\\n\\n\\nvec4 finalColor=vec4(\\nfinalDiffuse*ambientOcclusionForDirectDiffuse*vLightingIntensity.x +\\n#ifndef UNLIT\\n#ifdef REFLECTION\\nfinalIrradiance*ambientOcclusionColor*vLightingIntensity.z +\\n#endif\\n#ifdef SPECULARTERM\\n\\n\\nfinalSpecularScaled +\\n#endif\\n#ifdef REFLECTION\\n\\n\\nfinalRadianceScaled +\\n#endif\\n#ifdef REFRACTION\\nfinalRefraction*vLightingIntensity.z +\\n#endif\\n#endif\\nfinalEmissive*vLightingIntensity.y,\\nalpha);\\n\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\nfinalColor.rgb*=lightmapColor;\\n#else\\nfinalColor.rgb+=lightmapColor;\\n#endif\\n#endif\\n#endif\\n\\nfinalColor=max(finalColor,0.0);\\n#include<logDepthFragment>\\n#include<fogFragment>(color,finalColor)\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\n\\n\\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\\n#else\\n\\nfinalColor=applyImageProcessing(finalColor);\\n#endif\\n#ifdef PREMULTIPLYALPHA\\n\\nfinalColor.rgb*=finalColor.a;\\n#endif\\ngl_FragColor=finalColor;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\",\n    rgbdEncodePixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#include<helperFunctions>\\nvoid main(void) \\n{\\ngl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);\\n}\",\n    rgbdDecodePixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#include<helperFunctions>\\nvoid main(void) \\n{\\ngl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);\\n}\",\n    spritesVertexShader: \"\\nattribute vec4 position;\\nattribute vec4 options;\\nattribute vec4 cellInfo;\\nattribute vec4 color;\\n\\nuniform vec2 textureInfos;\\nuniform mat4 view;\\nuniform mat4 projection;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n#include<fogVertexDeclaration>\\nvoid main(void) { \\nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; \\nvec2 cornerPos;\\nfloat angle=position.w;\\nvec2 size=vec2(options.x,options.y);\\nvec2 offset=options.zw;\\nvec2 uvScale=textureInfos.xy;\\ncornerPos=vec2(offset.x-0.5,offset.y-0.5)*size;\\n\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\n\\nviewPos+=rotatedCorner;\\ngl_Position=projection*vec4(viewPos,1.0); \\n\\nvColor=color;\\n\\nvec2 uvOffset=vec2(abs(offset.x-cellInfo.x),1.0-abs(offset.y-cellInfo.y));\\nvUV=(uvOffset+cellInfo.zw)*uvScale;\\n\\n#ifdef FOG\\nvFogDistance=viewPos;\\n#endif\\n}\",\n    spritesPixelShader: \"uniform bool alphaTest;\\nvarying vec4 vColor;\\n\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n\\n#include<fogFragmentDeclaration>\\nvoid main(void) {\\nvec4 color=texture2D(diffuseSampler,vUV);\\nif (alphaTest) \\n{\\nif (color.a<0.95)\\ndiscard;\\n}\\ncolor*=vColor;\\n#include<fogFragment>\\ngl_FragColor=color;\\n}\",\n    particlesVertexShader: \"\\nattribute vec3 position;\\nattribute vec4 color;\\nattribute float angle;\\nattribute vec2 size;\\n#ifdef ANIMATESHEET \\nattribute float cellIndex;\\n#endif\\n#ifndef BILLBOARD \\nattribute vec3 direction;\\n#endif\\n#ifdef BILLBOARDSTRETCHED\\nattribute vec3 direction; \\n#endif\\n#ifdef RAMPGRADIENT\\nattribute vec4 remapData;\\n#endif\\nattribute vec2 offset;\\n\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 translationPivot;\\n#ifdef ANIMATESHEET \\nuniform vec3 particlesInfos; \\n#endif\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n#ifdef RAMPGRADIENT\\nvarying vec4 remapRanges;\\n#endif\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\\nuniform mat4 invView;\\n#endif\\n#include<clipPlaneVertexDeclaration>\\n#ifdef BILLBOARD\\nuniform vec3 eyePosition; \\n#endif\\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\\nvec3 zaxis=normalize(cross(yaxis,xaxis));\\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\\nmat3 rotMatrix=mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner; \\n}\\n#ifdef BILLBOARDSTRETCHED\\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\\nvec3 normalizedToCamera=normalize(toCamera);\\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\\nmat3 rotMatrix=mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner; \\n}\\n#endif\\nvoid main(void) { \\nvec2 cornerPos;\\ncornerPos=(vec2(offset.x-0.5,offset.y-0.5)-translationPivot)*size+translationPivot;\\n#ifdef BILLBOARD \\n\\nvec3 rotatedCorner;\\n#ifdef BILLBOARDY \\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=position-eyePosition;\\nyaxis.y=0.;\\nvec3 worldPos=rotate(normalize(yaxis),rotatedCorner);\\nvec3 viewPos=(view*vec4(worldPos,1.0)).xyz; \\n#elif defined(BILLBOARDSTRETCHED)\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 toCamera=position-eyePosition; \\nvec3 worldPos=rotateAlign(toCamera,rotatedCorner);\\nvec3 viewPos=(view*vec4(worldPos,1.0)).xyz; \\n#else\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner; \\n#endif\\n#ifdef RAMPGRADIENT\\nremapRanges=remapData;\\n#endif\\n\\ngl_Position=projection*vec4(viewPos,1.0); \\n#else\\n\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=normalize(direction);\\nvec3 worldPos=rotate(yaxis,rotatedCorner);\\ngl_Position=projection*view*vec4(worldPos,1.0); \\n#endif \\nvColor=color;\\n#ifdef ANIMATESHEET\\nfloat rowOffset=floor(cellIndex/particlesInfos.z);\\nfloat columnOffset=cellIndex-rowOffset*particlesInfos.z;\\nvec2 uvScale=particlesInfos.xy;\\nvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\\n#else\\nvUV=offset;\\n#endif\\n\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\\nvec4 worldPos=invView*vec4(viewPos,1.0);\\n#endif\\n#include<clipPlaneVertex>\\n}\",\n    particlesPixelShader: \"\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\nuniform vec4 textureMask;\\nuniform sampler2D diffuseSampler;\\n#include<clipPlaneFragmentDeclaration>\\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\n#ifdef RAMPGRADIENT\\nvarying vec4 remapRanges;\\nuniform sampler2D rampSampler;\\n#endif\\nvoid main(void) {\\n#include<clipPlaneFragment>\\nvec4 textureColor=texture2D(diffuseSampler,vUV);\\nvec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\\n#ifdef RAMPGRADIENT\\nfloat alpha=baseColor.a;\\nfloat remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);\\nvec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));\\nbaseColor.rgb*=rampColor.rgb;\\n\\nfloat finalAlpha=baseColor.a;\\nbaseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);\\n#endif\\n#ifdef BLENDMULTIPLYMODE\\nfloat sourceAlpha=vColor.a*textureColor.a;\\nbaseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);\\n#endif\\n\\n\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\\nbaseColor=applyImageProcessing(baseColor);\\n#endif\\n#endif\\ngl_FragColor=baseColor;\\n}\",\n    colorVertexShader: \"\\nattribute vec3 position;\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\n\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\nvoid main(void) {\\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#ifdef VERTEXCOLOR\\n\\nvColor=color;\\n#endif\\n}\",\n    colorPixelShader: \"#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#else\\nuniform vec4 color;\\n#endif\\nvoid main(void) {\\n#ifdef VERTEXCOLOR\\ngl_FragColor=vColor;\\n#else\\ngl_FragColor=color;\\n#endif\\n}\",\n    gpuRenderParticlesVertexShader: \"#version 300 es\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 translationPivot;\\n\\nin vec3 position;\\nin float age;\\nin float life;\\nin vec3 size;\\n#ifndef BILLBOARD\\nin vec3 initialDirection;\\n#endif\\n#ifdef BILLBOARDSTRETCHED\\nin vec3 direction;\\n#endif\\nin float angle;\\n#ifdef ANIMATESHEET\\nin float cellIndex;\\n#endif\\nin vec2 offset;\\nin vec2 uv;\\nout vec2 vUV;\\nout vec4 vColor;\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\\nuniform mat4 invView;\\n#endif\\n#include<clipPlaneVertexDeclaration2>\\n#ifdef COLORGRADIENTS\\nuniform sampler2D colorGradientSampler;\\n#else\\nuniform vec4 colorDead;\\nin vec4 color;\\n#endif\\n#ifdef ANIMATESHEET\\nuniform vec3 sheetInfos;\\n#endif\\n#ifdef BILLBOARD\\nuniform vec3 eyePosition; \\n#endif\\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\\nvec3 zaxis=normalize(cross(yaxis,xaxis));\\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\\nmat3 rotMatrix=mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner;\\n}\\n#ifdef BILLBOARDSTRETCHED\\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\\nvec3 normalizedToCamera=normalize(toCamera);\\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\\nmat3 rotMatrix=mat3(row0,row1,row2);\\nvec3 alignedCorner=rotMatrix*rotatedCorner;\\nreturn position+alignedCorner; \\n}\\n#endif\\nvoid main() {\\n#ifdef ANIMATESHEET\\nfloat rowOffset=floor(cellIndex/sheetInfos.z);\\nfloat columnOffset=cellIndex-rowOffset*sheetInfos.z;\\nvec2 uvScale=sheetInfos.xy;\\nvec2 uvOffset=vec2(uv.x ,1.0-uv.y);\\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\\n#else \\nvUV=uv;\\n#endif\\nfloat ratio=age/life;\\n#ifdef COLORGRADIENTS\\nvColor=texture(colorGradientSampler,vec2(ratio,0));\\n#else\\nvColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);\\n#endif\\nvec2 cornerPos=(offset-translationPivot)*size.yz*size.x+translationPivot;\\n#ifdef BILLBOARD\\nvec4 rotatedCorner;\\nrotatedCorner.w=0.;\\n#ifdef BILLBOARDY \\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.y=0.;\\nvec3 yaxis=position-eyePosition;\\nyaxis.y=0.;\\nvec3 worldPos=rotate(normalize(yaxis),rotatedCorner.xyz);\\nvec4 viewPosition=(view*vec4(worldPos,1.0)); \\n#elif defined(BILLBOARDSTRETCHED)\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\nvec3 toCamera=position-eyePosition; \\nvec3 worldPos=rotateAlign(toCamera,rotatedCorner.xyz);\\nvec4 viewPosition=(view*vec4(worldPos,1.0)); \\n#else\\n\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\n\\nvec4 viewPosition=view*vec4(position,1.0)+rotatedCorner;\\n#endif\\n#else\\n\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=0.;\\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nvec3 yaxis=normalize(initialDirection);\\nvec3 worldPos=rotate(yaxis,rotatedCorner);\\n\\nvec4 viewPosition=view*vec4(worldPos,1.0); \\n#endif\\ngl_Position=projection*viewPosition;\\n\\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4)\\nvec4 worldPos=invView*viewPosition;\\n#endif \\n#include<clipPlaneVertex>\\n}\",\n    gpuRenderParticlesPixelShader: \"#version 300 es\\nuniform sampler2D textureSampler;\\nin vec2 vUV;\\nin vec4 vColor;\\nout vec4 outFragColor;\\n#include<clipPlaneFragmentDeclaration2> \\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\nvoid main() {\\n#include<clipPlaneFragment> \\nvec4 textureColor=texture(textureSampler,vUV);\\noutFragColor=textureColor*vColor;\\n#ifdef BLENDMULTIPLYMODE\\nfloat alpha=vColor.a*textureColor.a;\\noutFragColor.rgb=outFragColor.rgb*alpha+vec3(1.0)*(1.0-alpha); \\n#endif \\n\\n\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\noutFragColor.rgb=toLinearSpace(outFragColor.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\noutFragColor.rgb=toLinearSpace(outFragColor.rgb);\\noutFragColor=applyImageProcessing(outFragColor);\\n#endif\\n#endif\\n}\\n\",\n    gpuUpdateParticlesVertexShader: \"#version 300 es\\n#define PI 3.14159\\nuniform float currentCount;\\nuniform float timeDelta;\\nuniform float stopFactor;\\nuniform mat4 emitterWM;\\nuniform vec2 lifeTime;\\nuniform vec2 emitPower;\\nuniform vec2 sizeRange;\\nuniform vec4 scaleRange;\\n#ifndef COLORGRADIENTS\\nuniform vec4 color1;\\nuniform vec4 color2;\\n#endif\\nuniform vec3 gravity;\\nuniform sampler2D randomSampler;\\nuniform sampler2D randomSampler2;\\nuniform vec4 angleRange;\\n#ifdef BOXEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\nuniform vec3 minEmitBox;\\nuniform vec3 maxEmitBox;\\n#endif\\n#ifdef POINTEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#endif\\n#ifdef HEMISPHERICEMITTER\\nuniform float radius;\\nuniform float radiusRange;\\nuniform float directionRandomizer;\\n#endif\\n#ifdef SPHEREEMITTER\\nuniform float radius;\\nuniform float radiusRange;\\n#ifdef DIRECTEDSPHEREEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#else\\nuniform float directionRandomizer;\\n#endif\\n#endif\\n#ifdef CYLINDEREMITTER\\nuniform float radius;\\nuniform float height;\\nuniform float radiusRange;\\n#ifdef DIRECTEDCYLINDEREMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#else\\nuniform float directionRandomizer;\\n#endif\\n#endif\\n#ifdef CONEEMITTER\\nuniform vec2 radius;\\nuniform float coneAngle;\\nuniform vec2 height;\\nuniform float directionRandomizer;\\n#endif\\n\\nin vec3 position;\\nin float age;\\nin float life;\\nin vec4 seed;\\nin vec3 size;\\n#ifndef COLORGRADIENTS\\nin vec4 color;\\n#endif\\nin vec3 direction;\\n#ifndef BILLBOARD\\nin vec3 initialDirection;\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nin float angle;\\n#else\\nin vec2 angle;\\n#endif\\n#ifdef ANIMATESHEET\\nin float cellIndex;\\n#ifdef ANIMATESHEETRANDOMSTART\\nin float cellStartOffset;\\n#endif\\n#endif\\n#ifdef NOISE\\nin vec3 noiseCoordinates1;\\nin vec3 noiseCoordinates2;\\n#endif\\n\\nout vec3 outPosition;\\nout float outAge;\\nout float outLife;\\nout vec4 outSeed;\\nout vec3 outSize;\\n#ifndef COLORGRADIENTS\\nout vec4 outColor;\\n#endif\\nout vec3 outDirection;\\n#ifndef BILLBOARD\\nout vec3 outInitialDirection;\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nout float outAngle;\\n#else\\nout vec2 outAngle;\\n#endif\\n#ifdef ANIMATESHEET\\nout float outCellIndex;\\n#ifdef ANIMATESHEETRANDOMSTART\\nout float outCellStartOffset;\\n#endif\\n#endif\\n#ifdef NOISE\\nout vec3 outNoiseCoordinates1;\\nout vec3 outNoiseCoordinates2;\\n#endif\\n#ifdef SIZEGRADIENTS\\nuniform sampler2D sizeGradientSampler;\\n#endif \\n#ifdef ANGULARSPEEDGRADIENTS\\nuniform sampler2D angularSpeedGradientSampler;\\n#endif \\n#ifdef VELOCITYGRADIENTS\\nuniform sampler2D velocityGradientSampler;\\n#endif\\n#ifdef LIMITVELOCITYGRADIENTS\\nuniform sampler2D limitVelocityGradientSampler;\\nuniform float limitVelocityDamping;\\n#endif\\n#ifdef DRAGGRADIENTS\\nuniform sampler2D dragGradientSampler;\\n#endif\\n#ifdef NOISE\\nuniform vec3 noiseStrength;\\nuniform sampler2D noiseSampler;\\n#endif\\n#ifdef ANIMATESHEET\\nuniform vec3 cellInfos;\\n#endif\\nvec3 getRandomVec3(float offset) {\\nreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\\n}\\nvec4 getRandomVec4(float offset) {\\nreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\\n}\\nvoid main() {\\nfloat newAge=age+timeDelta; \\n\\nif (newAge>=life && stopFactor != 0.) {\\nvec3 position;\\nvec3 direction;\\n\\nvec4 randoms=getRandomVec4(seed.x);\\n\\noutLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\\noutAge=mod(newAge,outLife);\\n\\noutSeed=seed;\\n\\n#ifdef SIZEGRADIENTS \\noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\\n#else\\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\\n#endif\\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\\noutSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; \\n#ifndef COLORGRADIENTS\\n\\noutColor=color1+(color2-color1)*randoms.b;\\n#endif\\n\\n#ifndef ANGULARSPEEDGRADIENTS \\noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\\noutAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\\n#else\\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\\n#endif \\n\\n#ifdef POINTEMITTER\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nposition=vec3(0,0,0);\\ndirection=direction1+(direction2-direction1)*randoms3;\\n#elif defined(BOXEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nposition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\\ndirection=direction1+(direction2-direction1)*randoms3; \\n#elif defined(HEMISPHERICEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\n\\nfloat phi=2.0*PI*randoms2.x;\\nfloat theta=acos(2.0*randoms2.y-1.0);\\nfloat randX=cos(phi)*sin(theta);\\nfloat randY=cos(theta);\\nfloat randZ=sin(phi)*sin(theta);\\nposition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\\ndirection=position+directionRandomizer*randoms3; \\n#elif defined(SPHEREEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\n\\nfloat phi=2.0*PI*randoms2.x;\\nfloat theta=acos(2.0*randoms2.y-1.0);\\nfloat randX=cos(phi)*sin(theta);\\nfloat randY=cos(theta);\\nfloat randZ=sin(phi)*sin(theta);\\nposition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\\n#ifdef DIRECTEDSPHEREEMITTER\\ndirection=direction1+(direction2-direction1)*randoms3;\\n#else\\n\\ndirection=position+directionRandomizer*randoms3;\\n#endif\\n#elif defined(CYLINDEREMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\n\\nfloat yPos=(randoms2.x-0.5)*height;\\nfloat angle=randoms2.y*PI*2.;\\nfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\\nfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\\nfloat xPos=positionRadius*cos(angle);\\nfloat zPos=positionRadius*sin(angle);\\nposition=vec3(xPos,yPos,zPos);\\n#ifdef DIRECTEDCYLINDEREMITTER\\ndirection=direction1+(direction2-direction1)*randoms3;\\n#else\\n\\nangle=angle+((randoms3.x-0.5)*PI);\\ndirection=vec3(cos(angle),randoms3.y-0.5,sin(angle));\\ndirection=normalize(direction);\\n#endif\\n#elif defined(CONEEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nfloat s=2.0*PI*randoms2.x;\\n#ifdef CONEEMITTERSPAWNPOINT\\nfloat h=0.00001;\\n#else\\nfloat h=randoms2.y*height.y;\\n\\nh=1.-h*h; \\n#endif\\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\\nlRadius=lRadius*h;\\nfloat randX=lRadius*sin(s);\\nfloat randZ=lRadius*cos(s);\\nfloat randY=h*height.x;\\nposition=vec3(randX,randY,randZ); \\n\\nif (abs(cos(coneAngle)) == 1.0) {\\ndirection=vec3(0.,1.0,0.);\\n} else {\\nvec3 randoms3=getRandomVec3(seed.z);\\ndirection=position+directionRandomizer*randoms3;\\n}\\n#else \\n\\nposition=vec3(0.,0.,0.);\\n\\ndirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\\n#endif\\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\\noutPosition=(emitterWM*vec4(position,1.)).xyz;\\nvec3 initial=(emitterWM*vec4(direction,0.)).xyz;\\noutDirection=initial*power;\\n#ifndef BILLBOARD \\noutInitialDirection=initial;\\n#endif\\n#ifdef ANIMATESHEET \\noutCellIndex=cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\noutCellStartOffset=randoms.a*outLife;\\n#endif \\n#endif\\n#ifdef NOISE\\noutNoiseCoordinates1=noiseCoordinates1;\\noutNoiseCoordinates2=noiseCoordinates2;\\n#endif\\n} else {\\nfloat directionScale=timeDelta;\\noutAge=newAge;\\nfloat ageGradient=newAge/life;\\n#ifdef VELOCITYGRADIENTS\\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\\n#endif\\n#ifdef DRAGGRADIENTS\\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\\n#endif\\noutPosition=position+direction*directionScale;\\noutLife=life;\\noutSeed=seed;\\n#ifndef COLORGRADIENTS \\noutColor=color;\\n#endif\\n#ifdef SIZEGRADIENTS\\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\\noutSize.yz=size.yz;\\n#else\\noutSize=size;\\n#endif \\n#ifndef BILLBOARD \\noutInitialDirection=initialDirection;\\n#endif\\nvec3 updatedDirection=direction+gravity*timeDelta;\\n#ifdef LIMITVELOCITYGRADIENTS\\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\\nfloat currentVelocity=length(updatedDirection);\\nif (currentVelocity>limitVelocity) {\\nupdatedDirection=updatedDirection*limitVelocityDamping;\\n}\\n#endif\\noutDirection=updatedDirection;\\n#ifdef NOISE\\nvec3 localPosition=outPosition-emitterWM[3].xyz;\\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\\nfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\\nfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\\nvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\\noutDirection=outDirection+force*timeDelta;\\noutNoiseCoordinates1=noiseCoordinates1;\\noutNoiseCoordinates2=noiseCoordinates2;\\n#endif \\n#ifdef ANGULARSPEEDGRADIENTS\\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\\noutAngle=angle+angularSpeed*timeDelta;\\n#else\\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\\n#endif\\n#ifdef ANIMATESHEET \\nfloat offsetAge=outAge;\\nfloat dist=cellInfos.y-cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\noutCellStartOffset=cellStartOffset;\\noffsetAge+=cellStartOffset;\\n#endif \\nfloat ratio=clamp(mod(offsetAge*cellInfos.z,life)/life,0.,1.0);\\noutCellIndex=float(int(cellInfos.x+ratio*dist));\\n#endif\\n}\\n}\",\n    gpuUpdateParticlesPixelShader: \"#version 300 es\\nvoid main() {\\ndiscard;\\n}\\n\",\n    postprocessVertexShader: \"\\nattribute vec2 position;\\nuniform vec2 scale;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvUV=(position*madd+madd)*scale;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\n    passPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nvoid main(void) \\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\n}\",\n    shadowMapVertexShader: \"\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\nuniform vec3 lightData;\\n#endif\\n#include<bonesDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n\\n#include<instancesDeclaration>\\n#include<helperFunctions>\\nuniform mat4 viewProjection;\\nuniform vec3 biasAndScale;\\nuniform vec2 depthValues;\\nvarying float vDepthMetric;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#include<bonesVertex>\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\n\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvec3 worldNor=normalize(normalWorld*normal);\\n#ifdef DIRECTIONINLIGHTDATA\\nvec3 worldLightDir=normalize(-lightData.xyz);\\n#else\\nvec3 directionToLight=lightData.xyz-worldPos.xyz;\\nvec3 worldLightDir=normalize(directionToLight);\\n#endif\\nfloat ndl=dot(worldNor,worldLightDir);\\nfloat sinNL=sqrt(1.0-ndl*ndl);\\nfloat normalBias=biasAndScale.y*sinNL;\\nworldPos.xyz-=worldNor*normalBias;\\n#endif\\n\\ngl_Position=viewProjection*worldPos;\\n#ifdef DEPTHTEXTURE\\n\\ngl_Position.z+=biasAndScale.x*gl_Position.w;\\n#endif\\n\\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y))+biasAndScale.x;\\n#ifdef ALPHATEST\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\n    shadowMapPixelShader: \"#ifndef FLOAT\\nvec4 pack(float depth)\\n{\\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\\nvec4 res=fract(depth*bit_shift);\\nres-=res.xxyz*bit_mask;\\nreturn res;\\n}\\n#endif\\nvarying float vDepthMetric;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\nuniform vec3 biasAndScale;\\nuniform vec2 depthValues;\\nvoid main(void)\\n{\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\nfloat depth=vDepthMetric;\\n#ifdef ESM\\ndepth=clamp(exp(-min(87.,biasAndScale.z*depth)),0.,1.);\\n#endif\\n#ifdef FLOAT\\ngl_FragColor=vec4(depth,1.0,1.0,1.0);\\n#else\\ngl_FragColor=pack(depth);\\n#endif\\n}\",\n    depthBoxBlurPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec2 screenSize;\\nvoid main(void)\\n{\\nvec4 colorDepth=vec4(0.0);\\nfor (int x=-OFFSET; x<=OFFSET; x++)\\nfor (int y=-OFFSET; y<=OFFSET; y++)\\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\\n}\",\n    proceduralVertexShader: \"\\nattribute vec2 position;\\n\\nvarying vec2 vPosition;\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvPosition=position;\\nvUV=position*madd+madd;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\n    depthVertexShader: \"\\nattribute vec3 position;\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nuniform vec2 depthValues;\\n#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\nvarying float vDepthMetric;\\nvoid main(void)\\n{\\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\n    depthPixelShader: \"#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\nvarying float vDepthMetric;\\nvoid main(void)\\n{\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=vec4(vDepthMetric,vDepthMetric*vDepthMetric,0.0,1.0);\\n}\",\n    geometryVertexShader: \"precision highp float;\\nprecision highp int;\\n#include<bonesDeclaration>\\n#include<instancesDeclaration>\\nattribute vec3 position;\\nattribute vec3 normal;\\n#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nvarying vec2 uv;\\n#endif\\n#ifdef UV2\\nvarying vec2 uv2;\\n#endif\\n#endif\\n\\nuniform mat4 viewProjection;\\nuniform mat4 view;\\nvarying vec3 vNormalV;\\nvarying vec4 vViewPos;\\n#ifdef POSITION\\nvarying vec3 vPosition;\\n#endif\\nvoid main(void)\\n{\\n#include<instancesVertex>\\n#include<bonesVertex>\\nvec4 pos=vec4(finalWorld*vec4(position,1.0));\\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normal,0.0)));\\nvViewPos=view*pos;\\n#ifdef POSITION\\nvPosition=pos.xyz/pos.w;\\n#endif\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\n    geometryPixelShader: \"#extension GL_EXT_draw_buffers : require\\nprecision highp float;\\nprecision highp int;\\nvarying vec3 vNormalV;\\nvarying vec4 vViewPos;\\n#ifdef POSITION\\nvarying vec3 vPosition;\\n#endif\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef POSITION\\n#include<mrtFragmentDeclaration>[3]\\n#else\\n#include<mrtFragmentDeclaration>[2]\\n#endif\\nvoid main() {\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\ngl_FragData[0]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\\n\\ngl_FragData[1]=vec4(normalize(vNormalV),1.0);\\n\\n#ifdef POSITION\\ngl_FragData[2]=vec4(vPosition,1.0);\\n#endif\\n}\",\n    ssaoPixelShader: \"\\nuniform sampler2D textureSampler;\\nvarying vec2 vUV;\\n#ifdef SSAO\\nuniform sampler2D randomSampler;\\nuniform float randTextureTiles;\\nuniform float samplesFactor;\\nuniform vec3 sampleSphere[SAMPLES];\\nuniform float totalStrength;\\nuniform float radius;\\nuniform float area;\\nuniform float fallOff;\\nuniform float base;\\nvec3 normalFromDepth(float depth,vec2 coords)\\n{\\nvec2 offset1=vec2(0.0,radius);\\nvec2 offset2=vec2(radius,0.0);\\nfloat depth1=texture2D(textureSampler,coords+offset1).r;\\nfloat depth2=texture2D(textureSampler,coords+offset2).r;\\nvec3 p1=vec3(offset1,depth1-depth);\\nvec3 p2=vec3(offset2,depth2-depth);\\nvec3 normal=cross(p1,p2);\\nnormal.z=-normal.z;\\nreturn normalize(normal);\\n}\\nvoid main()\\n{\\nvec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);\\nfloat depth=texture2D(textureSampler,vUV).r;\\nvec3 position=vec3(vUV,depth);\\nvec3 normal=normalFromDepth(depth,vUV);\\nfloat radiusDepth=radius/depth;\\nfloat occlusion=0.0;\\nvec3 ray;\\nvec3 hemiRay;\\nfloat occlusionDepth;\\nfloat difference;\\nfor (int i=0; i<SAMPLES; i++)\\n{\\nray=radiusDepth*reflect(sampleSphere[i],random);\\nhemiRay=position+sign(dot(ray,normal))*ray;\\nocclusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;\\ndifference=depth-occlusionDepth;\\nocclusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));\\n}\\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\\nfloat result=clamp(ao+base,0.0,1.0);\\ngl_FragColor.r=result;\\ngl_FragColor.g=result;\\ngl_FragColor.b=result;\\ngl_FragColor.a=1.0;\\n}\\n#endif\\n\",\n    ssao2PixelShader: \"\\nprecision highp float;\\nuniform sampler2D textureSampler;\\nuniform float near;\\nuniform float far;\\nuniform float radius;\\nfloat scales[16]=float[16](\\n0.1,\\n0.11406250000000001,\\n0.131640625,\\n0.15625,\\n0.187890625,\\n0.2265625,\\n0.272265625,\\n0.325,\\n0.384765625,\\n0.4515625,\\n0.525390625,\\n0.60625,\\n0.694140625,\\n0.7890625,\\n0.891015625,\\n1.0\\n);\\nvarying vec2 vUV;\\nfloat perspectiveDepthToViewZ( const in float invClipZ,const in float near,const in float far ) {\\nreturn ( near*far )/( ( far-near )*invClipZ-far );\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ,const in float near,const in float far ) {\\nreturn ( near*far/viewZ+far)/( far-near );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ,const in float near,const in float far ) {\\nreturn ( viewZ+near )/( near-far );\\n}\\n#ifdef SSAO\\nuniform sampler2D randomSampler;\\nuniform sampler2D normalSampler;\\nuniform float randTextureTiles;\\nuniform float samplesFactor;\\nuniform vec3 sampleSphere[SAMPLES];\\nuniform float totalStrength;\\nuniform float base;\\nuniform float xViewport;\\nuniform float yViewport;\\nuniform float maxZ;\\nuniform float minZAspect;\\nuniform vec2 texelSize;\\nuniform mat4 projection;\\nvoid main()\\n{\\nvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\\nfloat depth=texture2D(textureSampler,vUV).r;\\nfloat depthSign=depth/abs(depth);\\ndepth=depth*depthSign;\\nvec3 normal=texture2D(normalSampler,vUV).rgb; \\nfloat occlusion=0.0;\\nfloat correctedRadius=min(radius,minZAspect*depth/near);\\nvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\\nvec3 origin=vViewRay*depth;\\nvec3 rvec=random*2.0-1.0;\\nrvec.z=0.0;\\n\\nfloat dotProduct=dot(rvec,normal);\\nrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\\nvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\\nvec3 bitangent=cross(normal,tangent);\\nmat3 tbn=mat3(tangent,bitangent,normal);\\nfloat difference;\\nfor (int i=0; i<SAMPLES; ++i) {\\n\\nvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\\nsamplePosition=samplePosition*correctedRadius+origin;\\n\\nvec4 offset=vec4(samplePosition,1.0);\\noffset=projection*offset;\\noffset.xyz/=offset.w;\\noffset.xy=offset.xy*0.5+0.5;\\nif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\\ncontinue;\\n}\\n\\nfloat sampleDepth=abs(texture2D(textureSampler,offset.xy).r);\\n\\ndifference=depthSign*samplePosition.z-sampleDepth;\\nfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\\nocclusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;\\n}\\nocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\\nfloat result=clamp(ao+base,0.0,1.0);\\ngl_FragColor=vec4(vec3(result),1.0);\\n}\\n#endif\\n#ifdef BILATERAL_BLUR\\nuniform sampler2D depthSampler;\\nuniform float outSize;\\nuniform float samplerOffsets[SAMPLES];\\nvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.3846153846)*direction;\\nvec2 off2=vec2(3.2307692308)*direction;\\ncolor+=texture2D(image,uv)*0.2270270270;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\\nreturn color;\\n}\\nvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\ncolor+=texture2D(image,uv)*0.1964825501511404;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\\ncolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\\nreturn color;\\n}\\nvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\nfloat compareDepth=abs(texture2D(depthSampler,uv).r);\\nfloat sampleDepth;\\nfloat weight;\\nfloat weightSum=30.0;\\ncolor+=texture2D(image,uv)*30.0;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off3/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off3/resolution))*weight;\\nreturn color/weightSum;\\n}\\nvoid main()\\n{\\n#if EXPENSIVE\\nfloat compareDepth=abs(texture2D(depthSampler,vUV).r);\\nfloat texelsize=1.0/outSize;\\nfloat result=0.0;\\nfloat weightSum=0.0;\\nfor (int i=0; i<SAMPLES; ++i)\\n{\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\\n#endif\\nvec2 samplePos=vUV+sampleOffset;\\nfloat sampleDepth=abs(texture2D(depthSampler,samplePos).r);\\nfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\\nresult+=texture2D(textureSampler,samplePos).r*weight;\\nweightSum+=weight;\\n}\\nresult/=weightSum;\\ngl_FragColor.rgb=vec3(result);\\ngl_FragColor.a=1.0;\\n#else\\nvec4 color;\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#endif\\ngl_FragColor.rgb=vec3(color.r);\\ngl_FragColor.a=1.0;\\n#endif\\n}\\n#endif\\n\",\n    ssaoCombinePixelShader: \"uniform sampler2D textureSampler;\\nuniform sampler2D originalColor;\\nuniform vec4 viewport;\\nvarying vec2 vUV;\\nvoid main(void) {\\nvec4 ssaoColor=texture2D(textureSampler,viewport.xy+vUV*viewport.zw);\\nvec4 sceneColor=texture2D(originalColor,vUV);\\ngl_FragColor=sceneColor*ssaoColor;\\n}\\n\",\n    lensHighlightsPixelShader: \"\\nuniform sampler2D textureSampler; \\n\\nuniform float gain;\\nuniform float threshold;\\nuniform float screen_width;\\nuniform float screen_height;\\n\\nvarying vec2 vUV;\\n\\nvec4 highlightColor(vec4 color) {\\nvec4 highlight=color;\\nfloat luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));\\nfloat lum_threshold;\\nif (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\\nelse { lum_threshold=0.5+0.44*threshold; }\\nluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);\\nhighlight*=luminance*gain;\\nhighlight.a=1.0;\\nreturn highlight;\\n}\\nvoid main(void)\\n{\\nvec4 original=texture2D(textureSampler,vUV);\\n\\nif (gain == -1.0) {\\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\\nreturn;\\n}\\nfloat w=2.0/screen_width;\\nfloat h=2.0/screen_height;\\nfloat weight=1.0;\\n\\nvec4 blurred=vec4(0.0,0.0,0.0,0.0);\\n#ifdef PENTAGON\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\\n#else\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\\n#endif\\nblurred/=39.0;\\ngl_FragColor=blurred;\\n\\n}\",\n    depthOfFieldPixelShader: \"\\n\\n\\n\\n\\nuniform sampler2D textureSampler;\\nuniform sampler2D highlightsSampler;\\nuniform sampler2D depthSampler;\\nuniform sampler2D grainSampler;\\n\\nuniform float grain_amount;\\nuniform bool blur_noise;\\nuniform float screen_width;\\nuniform float screen_height;\\nuniform float distortion;\\nuniform bool dof_enabled;\\n\\nuniform float screen_distance; \\nuniform float aperture;\\nuniform float darken;\\nuniform float edge_blur;\\nuniform bool highlights;\\n\\nuniform float near;\\nuniform float far;\\n\\nvarying vec2 vUV;\\n\\n#define PI 3.14159265\\n#define TWOPI 6.28318530\\n#define inverse_focal_length 0.1 \\n\\nvec2 centered_screen_pos;\\nvec2 distorted_coords;\\nfloat radius2;\\nfloat radius;\\n\\nvec2 rand(vec2 co)\\n{\\nfloat noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));\\nfloat noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));\\nreturn clamp(vec2(noise1,noise2),0.0,1.0);\\n}\\n\\nvec2 getDistortedCoords(vec2 coords) {\\nif (distortion == 0.0) { return coords; }\\nvec2 direction=1.0*normalize(centered_screen_pos);\\nvec2 dist_coords=vec2(0.5,0.5);\\ndist_coords.x=0.5+direction.x*radius2*1.0;\\ndist_coords.y=0.5+direction.y*radius2*1.0;\\nfloat dist_amount=clamp(distortion*0.23,0.0,1.0);\\ndist_coords=mix(coords,dist_coords,dist_amount);\\nreturn dist_coords;\\n}\\n\\nfloat sampleScreen(inout vec4 color,const in vec2 offset,const in float weight) {\\n\\nvec2 coords=distorted_coords;\\nfloat angle=rand(coords*100.0).x*TWOPI;\\ncoords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));\\ncolor+=texture2D(textureSampler,coords)*weight;\\nreturn weight;\\n}\\n\\nfloat getBlurLevel(float size) {\\nreturn min(3.0,ceil(size/1.0));\\n}\\n\\nvec4 getBlurColor(float size) {\\nvec4 col=texture2D(textureSampler,distorted_coords);\\nif (size == 0.0) { return col; }\\n\\n\\nfloat blur_level=getBlurLevel(size);\\nfloat w=(size/screen_width);\\nfloat h=(size/screen_height);\\nfloat total_weight=1.0;\\nvec2 sample_coords;\\ntotal_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);\\ntotal_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);\\ntotal_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);\\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);\\ntotal_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);\\ntotal_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);\\ntotal_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);\\ntotal_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);\\ntotal_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);\\ntotal_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);\\nif (blur_level>1.0) {\\ntotal_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);\\ntotal_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);\\ntotal_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);\\ntotal_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);\\ntotal_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);\\ntotal_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);\\ntotal_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);\\ntotal_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);\\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);\\ntotal_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);\\n}\\nif (blur_level>2.0) {\\ntotal_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);\\ntotal_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);\\ntotal_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);\\ntotal_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);\\ntotal_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);\\ntotal_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);\\ntotal_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);\\ntotal_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);\\ntotal_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);\\n}\\ncol/=total_weight; \\n\\nif (darken>0.0) {\\ncol.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);\\n}\\n\\n\\n\\n\\nreturn col;\\n}\\nvoid main(void)\\n{\\n\\ncentered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\\nradius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;\\nradius=sqrt(radius2);\\ndistorted_coords=getDistortedCoords(vUV); \\nvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); \\nfloat depth=texture2D(depthSampler,distorted_coords).r; \\nfloat distance=near+(far-near)*depth; \\nvec4 color=texture2D(textureSampler,vUV); \\n\\n\\nfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));\\n\\nif (dof_enabled == false || coc<0.07) { coc=0.0; }\\n\\nfloat edge_blur_amount=0.0;\\nif (edge_blur>0.0) {\\nedge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;\\n}\\n\\nfloat blur_amount=max(edge_blur_amount,coc);\\n\\nif (blur_amount == 0.0) {\\ngl_FragColor=texture2D(textureSampler,distorted_coords);\\n}\\nelse {\\n\\ngl_FragColor=getBlurColor(blur_amount*1.7);\\n\\nif (highlights) {\\ngl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;\\n}\\nif (blur_noise) {\\n\\nvec2 noise=rand(distorted_coords)*0.01*blur_amount;\\nvec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);\\ngl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;\\n}\\n}\\n\\nif (grain_amount>0.0) {\\nvec4 grain_color=texture2D(grainSampler,texels_coords*0.003);\\ngl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;\\n}\\n}\\n\",\n    standardPixelShader: \"uniform sampler2D textureSampler;\\nvarying vec2 vUV;\\n#if defined(PASS_POST_PROCESS)\\nvoid main(void)\\n{\\nvec4 color=texture2D(textureSampler,vUV);\\ngl_FragColor=color;\\n}\\n#endif\\n#if defined(DOWN_SAMPLE_X4)\\nuniform vec2 dsOffsets[16];\\nvoid main(void)\\n{\\nvec4 average=vec4(0.0,0.0,0.0,0.0);\\naverage=texture2D(textureSampler,vUV+dsOffsets[0]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[1]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[2]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[3]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[4]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[5]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[6]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[7]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[8]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[9]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[10]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[11]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[12]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[13]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[14]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[15]);\\naverage/=16.0;\\ngl_FragColor=average;\\n}\\n#endif\\n#if defined(BRIGHT_PASS)\\nuniform vec2 dsOffsets[4];\\nuniform float brightThreshold;\\nvoid main(void)\\n{\\nvec4 average=vec4(0.0,0.0,0.0,0.0);\\naverage=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));\\naverage*=0.25;\\nfloat luminance=length(average.rgb);\\nif (luminance<brightThreshold) {\\naverage=vec4(0.0,0.0,0.0,1.0);\\n}\\ngl_FragColor=average;\\n}\\n#endif\\n#if defined(TEXTURE_ADDER)\\nuniform sampler2D otherSampler;\\nuniform sampler2D lensSampler;\\nuniform float exposure;\\nvoid main(void)\\n{\\nvec3 colour=texture2D(textureSampler,vUV).rgb;\\ncolour*=exposure;\\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\\ncolour=retColor*retColor;\\ncolour+=colour*texture2D(lensSampler,vUV).rgb;\\nvec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);\\ngl_FragColor=finalColor;\\n}\\n#endif\\n#if defined(VLS)\\n#define PI 3.1415926535897932384626433832795\\nuniform mat4 shadowViewProjection;\\nuniform mat4 lightWorld;\\nuniform vec3 cameraPosition;\\nuniform vec3 sunDirection;\\nuniform vec3 sunColor;\\nuniform vec2 depthValues;\\nuniform float scatteringCoefficient;\\nuniform float scatteringPower;\\nuniform sampler2D shadowMapSampler;\\nuniform sampler2D positionSampler;\\nfloat computeScattering(float lightDotView)\\n{\\nfloat result=1.0-scatteringCoefficient*scatteringCoefficient;\\nresult/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));\\nreturn result;\\n}\\nvoid main(void)\\n{\\n\\nvec3 worldPos=texture2D(positionSampler,vUV).rgb;\\nvec3 startPosition=cameraPosition;\\nvec3 rayVector=worldPos-startPosition;\\nfloat rayLength=length(rayVector);\\nvec3 rayDirection=rayVector/rayLength;\\nfloat stepLength=rayLength/NB_STEPS;\\nvec3 stepL=rayDirection*stepLength;\\nvec3 currentPosition=startPosition;\\nvec3 accumFog=vec3(0.0);\\nfor (int i=0; i<int(NB_STEPS); i++)\\n{\\nvec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);\\nfloat depthMetric=(worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depthMetric,0.0,1.0);\\nworldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;\\nworldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);\\nfloat shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;\\nif (shadowMapValue>shadowPixelDepth)\\naccumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));\\ncurrentPosition+=stepL;\\n}\\naccumFog/=NB_STEPS;\\nvec3 color=accumFog*scatteringPower;\\ngl_FragColor=vec4(color*exp(color) ,1.0);\\n}\\n#endif\\n#if defined(VLSMERGE)\\nuniform sampler2D originalSampler;\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);\\n}\\n#endif\\n#if defined(LUMINANCE)\\nuniform vec2 lumOffsets[4];\\nvoid main()\\n{\\nfloat average=0.0;\\nvec4 color=vec4(0.0);\\nfloat maximum=-1e20;\\nvec3 weight=vec3(0.299,0.587,0.114);\\nfor (int i=0; i<4; i++)\\n{\\ncolor=texture2D(textureSampler,vUV+ lumOffsets[i]);\\n\\nfloat GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));\\n\\n#ifdef WEIGHTED_AVERAGE\\nfloat GreyValue=dot(color.rgb,weight);\\n#endif\\n#ifdef BRIGHTNESS\\nfloat GreyValue=max(color.r,max(color.g,color.b));\\n#endif\\n#ifdef HSL_COMPONENT\\nfloat GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));\\n#endif\\n#ifdef MAGNITUDE\\nfloat GreyValue=length(color.rgb);\\n#endif\\nmaximum=max(maximum,GreyValue);\\naverage+=(0.25*log(1e-5+GreyValue));\\n}\\naverage=exp(average);\\ngl_FragColor=vec4(average,maximum,0.0,1.0);\\n}\\n#endif\\n#if defined(LUMINANCE_DOWN_SAMPLE)\\nuniform vec2 dsOffsets[9];\\nuniform float halfDestPixelSize;\\n#ifdef FINAL_DOWN_SAMPLER\\nvec4 pack(float value) {\\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\\nvec4 res=fract(value*bit_shift);\\nres-=res.xxyz*bit_mask;\\nreturn res;\\n}\\n#endif\\nvoid main()\\n{\\nvec4 color=vec4(0.0);\\nfloat average=0.0;\\nfor (int i=0; i<9; i++)\\n{\\ncolor=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);\\naverage+=color.r;\\n}\\naverage/=9.0;\\n#ifdef FINAL_DOWN_SAMPLER\\ngl_FragColor=pack(average);\\n#else\\ngl_FragColor=vec4(average,average,0.0,1.0);\\n#endif\\n}\\n#endif\\n#if defined(HDR)\\nuniform sampler2D textureAdderSampler;\\nuniform float averageLuminance;\\nvoid main()\\n{\\nvec4 color=texture2D(textureAdderSampler,vUV);\\nvec4 adjustedColor=color/averageLuminance;\\ncolor=adjustedColor;\\ncolor.a=1.0;\\ngl_FragColor=color;\\n}\\n#endif\\n#if defined(LENS_FLARE)\\n#define GHOSTS 3\\nuniform sampler2D lensColorSampler;\\nuniform float strength;\\nuniform float ghostDispersal;\\nuniform float haloWidth;\\nuniform vec2 resolution;\\nuniform float distortionStrength;\\nfloat hash(vec2 p)\\n{\\nfloat h=dot(p,vec2(127.1,311.7));\\nreturn -1.0+2.0*fract(sin(h)*43758.5453123);\\n}\\nfloat noise(in vec2 p)\\n{\\nvec2 i=floor(p);\\nvec2 f=fract(p);\\nvec2 u=f*f*(3.0-2.0*f);\\nreturn mix(mix(hash(i+vec2(0.0,0.0)),\\nhash(i+vec2(1.0,0.0)),u.x),\\nmix(hash(i+vec2(0.0,1.0)),\\nhash(i+vec2(1.0,1.0)),u.x),u.y);\\n}\\nfloat fbm(vec2 p)\\n{\\nfloat f=0.0;\\nf+=0.5000*noise(p); p*=2.02;\\nf+=0.2500*noise(p); p*=2.03;\\nf+=0.1250*noise(p); p*=2.01;\\nf+=0.0625*noise(p); p*=2.04;\\nf/=0.9375;\\nreturn f;\\n}\\nvec3 pattern(vec2 uv)\\n{\\nvec2 p=-1.0+2.0*uv;\\nfloat p2=dot(p,p);\\nfloat f=fbm(vec2(15.0*p2))/2.0;\\nfloat r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));\\nfloat g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));\\nfloat b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));\\nreturn (1.0-f)*vec3(r,g,b);\\n}\\nfloat luminance(vec3 color)\\n{\\nreturn dot(color.rgb,vec3(0.2126,0.7152,0.0722));\\n}\\nvec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)\\n{\\nreturn vec4(\\ntexture2D(tex,texcoord+direction*distortion.r).r,\\ntexture2D(tex,texcoord+direction*distortion.g).g,\\ntexture2D(tex,texcoord+direction*distortion.b).b,\\n1.0\\n);\\n}\\nvoid main(void)\\n{\\nvec2 uv=-vUV+vec2(1.0);\\nvec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;\\nvec2 texelSize=1.0/resolution;\\nvec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);\\nvec4 result=vec4(0.0);\\nfloat ghostIndice=1.0;\\nfor (int i=0; i<GHOSTS; ++i)\\n{\\nvec2 offset=fract(uv+ghostDir*ghostIndice);\\nfloat weight=length(vec2(0.5)-offset)/length(vec2(0.5));\\nweight=pow(1.0-weight,10.0);\\nresult+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;\\nghostIndice+=1.0;\\n}\\nvec2 haloVec=normalize(ghostDir)*haloWidth;\\nfloat weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));\\nweight=pow(1.0-weight,10.0);\\nresult+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;\\nresult*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));\\ngl_FragColor=result;\\n}\\n#endif\\n#if defined(LENS_FLARE_COMPOSE)\\nuniform sampler2D otherSampler;\\nuniform sampler2D lensDirtSampler;\\nuniform sampler2D lensStarSampler;\\nuniform mat4 lensStarMatrix;\\nvoid main(void)\\n{\\nvec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;\\nvec4 lensMod=texture2D(lensDirtSampler,vUV);\\nlensMod+=texture2D(lensStarSampler,vUV);\\nvec4 result=texture2D(textureSampler,vUV)*lensMod;\\ngl_FragColor=texture2D(otherSampler,vUV)+result;\\n}\\n#endif\\n#if defined(DEPTH_OF_FIELD)\\nuniform sampler2D otherSampler;\\nuniform sampler2D depthSampler;\\nuniform float distance;\\nvoid main(void)\\n{\\nvec4 sharp=texture2D(otherSampler,vUV);\\nvec4 blur=texture2D(textureSampler,vUV);\\nfloat dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);\\nfloat factor=0.0;\\nif (dist<0.05)\\nfactor=1.0;\\nelse if (dist<0.1)\\nfactor=20.0*(0.1-dist);\\nelse if (dist<0.5)\\nfactor=0.0;\\nelse\\nfactor=2.0*(dist-0.5);\\nfactor=clamp(factor,0.0,0.90);\\ngl_FragColor=mix(sharp,blur,factor);\\n}\\n#endif\\n#if defined(MOTION_BLUR)\\nuniform mat4 inverseViewProjection;\\nuniform mat4 prevViewProjection;\\nuniform vec2 screenSize;\\nuniform float motionScale;\\nuniform float motionStrength;\\nuniform sampler2D depthSampler;\\nvoid main(void)\\n{\\nvec2 texelSize=1.0/screenSize;\\nfloat depth=texture2D(depthSampler,vUV).r;\\nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);\\ncpos=cpos*inverseViewProjection;\\nvec4 ppos=cpos*prevViewProjection;\\nppos.xyz/=ppos.w;\\nppos.xy=ppos.xy*0.5+0.5;\\nvec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;\\nfloat speed=length(velocity/texelSize);\\nint nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));\\nvec4 result=texture2D(textureSampler,vUV);\\nfor (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {\\nif (i>=nSamples)\\nbreak;\\nvec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\\nresult+=texture2D(textureSampler,offset1);\\n}\\ngl_FragColor=result/float(nSamples);\\n}\\n#endif\\n\",\n    fxaaVertexShader: \"\\nattribute vec2 position;\\nuniform vec2 texelSize;\\n\\nvarying vec2 vUV;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\nvarying vec2 sampleCoordNW;\\nvarying vec2 sampleCoordSE;\\nvarying vec2 sampleCoordNE;\\nvarying vec2 sampleCoordSW;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvUV=(position*madd+madd);\\nsampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;\\nsampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;\\nsampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;\\nsampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;\\nsampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;\\nsampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;\\nsampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;\\nsampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\n    fxaaPixelShader: \"uniform sampler2D textureSampler;\\nuniform vec2 texelSize;\\nvarying vec2 vUV;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\nvarying vec2 sampleCoordNW;\\nvarying vec2 sampleCoordSE;\\nvarying vec2 sampleCoordNE;\\nvarying vec2 sampleCoordSW;\\nconst float fxaaQualitySubpix=1.0;\\nconst float fxaaQualityEdgeThreshold=0.166;\\nconst float fxaaQualityEdgeThresholdMin=0.0833;\\nconst vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);\\n#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)\\nvoid main(){\\nvec2 posM;\\nposM.x=vUV.x;\\nposM.y=vUV.y;\\nvec4 rgbyM=texture2D(textureSampler,vUV,0.0);\\nfloat lumaM=FxaaLuma(rgbyM);\\nfloat lumaS=FxaaLuma(texture2D(textureSampler,sampleCoordS,0.0));\\nfloat lumaE=FxaaLuma(texture2D(textureSampler,sampleCoordE,0.0));\\nfloat lumaN=FxaaLuma(texture2D(textureSampler,sampleCoordN,0.0));\\nfloat lumaW=FxaaLuma(texture2D(textureSampler,sampleCoordW,0.0));\\nfloat maxSM=max(lumaS,lumaM);\\nfloat minSM=min(lumaS,lumaM);\\nfloat maxESM=max(lumaE,maxSM);\\nfloat minESM=min(lumaE,minSM);\\nfloat maxWN=max(lumaN,lumaW);\\nfloat minWN=min(lumaN,lumaW);\\nfloat rangeMax=max(maxWN,maxESM);\\nfloat rangeMin=min(minWN,minESM);\\nfloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;\\nfloat range=rangeMax-rangeMin;\\nfloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\\n#ifndef MALI\\nif(range<rangeMaxClamped) \\n{\\ngl_FragColor=rgbyM;\\nreturn;\\n}\\n#endif\\nfloat lumaNW=FxaaLuma(texture2D(textureSampler,sampleCoordNW,0.0));\\nfloat lumaSE=FxaaLuma(texture2D(textureSampler,sampleCoordSE,0.0));\\nfloat lumaNE=FxaaLuma(texture2D(textureSampler,sampleCoordNE,0.0));\\nfloat lumaSW=FxaaLuma(texture2D(textureSampler,sampleCoordSW,0.0));\\nfloat lumaNS=lumaN+lumaS;\\nfloat lumaWE=lumaW+lumaE;\\nfloat subpixRcpRange=1.0/range;\\nfloat subpixNSWE=lumaNS+lumaWE;\\nfloat edgeHorz1=(-2.0*lumaM)+lumaNS;\\nfloat edgeVert1=(-2.0*lumaM)+lumaWE;\\nfloat lumaNESE=lumaNE+lumaSE;\\nfloat lumaNWNE=lumaNW+lumaNE;\\nfloat edgeHorz2=(-2.0*lumaE)+lumaNESE;\\nfloat edgeVert2=(-2.0*lumaN)+lumaNWNE;\\nfloat lumaNWSW=lumaNW+lumaSW;\\nfloat lumaSWSE=lumaSW+lumaSE;\\nfloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);\\nfloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);\\nfloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;\\nfloat edgeVert3=(-2.0*lumaS)+lumaSWSE;\\nfloat edgeHorz=abs(edgeHorz3)+edgeHorz4;\\nfloat edgeVert=abs(edgeVert3)+edgeVert4;\\nfloat subpixNWSWNESE=lumaNWSW+lumaNESE;\\nfloat lengthSign=texelSize.x;\\nbool horzSpan=edgeHorz>=edgeVert;\\nfloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;\\nif (!horzSpan)\\n{\\nlumaN=lumaW;\\n}\\nif (!horzSpan) \\n{\\nlumaS=lumaE;\\n}\\nif (horzSpan) \\n{\\nlengthSign=texelSize.y;\\n}\\nfloat subpixB=(subpixA*(1.0/12.0))-lumaM;\\nfloat gradientN=lumaN-lumaM;\\nfloat gradientS=lumaS-lumaM;\\nfloat lumaNN=lumaN+lumaM;\\nfloat lumaSS=lumaS+lumaM;\\nbool pairN=abs(gradientN)>=abs(gradientS);\\nfloat gradient=max(abs(gradientN),abs(gradientS));\\nif (pairN)\\n{\\nlengthSign=-lengthSign;\\n}\\nfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);\\nvec2 posB;\\nposB.x=posM.x;\\nposB.y=posM.y;\\nvec2 offNP;\\noffNP.x=(!horzSpan) ? 0.0 : texelSize.x;\\noffNP.y=(horzSpan) ? 0.0 : texelSize.y;\\nif (!horzSpan) \\n{\\nposB.x+=lengthSign*0.5;\\n}\\nif (horzSpan)\\n{\\nposB.y+=lengthSign*0.5;\\n}\\nvec2 posN;\\nposN.x=posB.x-offNP.x*1.5;\\nposN.y=posB.y-offNP.y*1.5;\\nvec2 posP;\\nposP.x=posB.x+offNP.x*1.5;\\nposP.y=posB.y+offNP.y*1.5;\\nfloat subpixD=((-2.0)*subpixC)+3.0;\\nfloat lumaEndN=FxaaLuma(texture2D(textureSampler,posN,0.0));\\nfloat subpixE=subpixC*subpixC;\\nfloat lumaEndP=FxaaLuma(texture2D(textureSampler,posP,0.0));\\nif (!pairN) \\n{\\nlumaNN=lumaSS;\\n}\\nfloat gradientScaled=gradient*1.0/4.0;\\nfloat lumaMM=lumaM-lumaNN*0.5;\\nfloat subpixF=subpixD*subpixE;\\nbool lumaMLTZero=lumaMM<0.0;\\nlumaEndN-=lumaNN*0.5;\\nlumaEndP-=lumaNN*0.5;\\nbool doneN=abs(lumaEndN)>=gradientScaled;\\nbool doneP=abs(lumaEndP)>=gradientScaled;\\nif (!doneN) \\n{\\nposN.x-=offNP.x*3.0;\\n}\\nif (!doneN) \\n{\\nposN.y-=offNP.y*3.0;\\n}\\nbool doneNP=(!doneN) || (!doneP);\\nif (!doneP) \\n{\\nposP.x+=offNP.x*3.0;\\n}\\nif (!doneP)\\n{\\nposP.y+=offNP.y*3.0;\\n}\\nif (doneNP)\\n{\\nif (!doneN) lumaEndN=FxaaLuma(texture2D(textureSampler,posN.xy,0.0));\\nif (!doneP) lumaEndP=FxaaLuma(texture2D(textureSampler,posP.xy,0.0));\\nif (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;\\nif (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;\\ndoneN=abs(lumaEndN)>=gradientScaled;\\ndoneP=abs(lumaEndP)>=gradientScaled;\\nif (!doneN) posN.x-=offNP.x*12.0;\\nif (!doneN) posN.y-=offNP.y*12.0;\\ndoneNP=(!doneN) || (!doneP);\\nif (!doneP) posP.x+=offNP.x*12.0;\\nif (!doneP) posP.y+=offNP.y*12.0;\\n}\\nfloat dstN=posM.x-posN.x;\\nfloat dstP=posP.x-posM.x;\\nif (!horzSpan)\\n{\\ndstN=posM.y-posN.y;\\n}\\nif (!horzSpan) \\n{\\ndstP=posP.y-posM.y;\\n}\\nbool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;\\nfloat spanLength=(dstP+dstN);\\nbool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;\\nfloat spanLengthRcp=1.0/spanLength;\\nbool directionN=dstN<dstP;\\nfloat dst=min(dstN,dstP);\\nbool goodSpan=directionN ? goodSpanN : goodSpanP;\\nfloat subpixG=subpixF*subpixF;\\nfloat pixelOffset=(dst*(-spanLengthRcp))+0.5;\\nfloat subpixH=subpixG*fxaaQualitySubpix;\\nfloat pixelOffsetGood=goodSpan ? pixelOffset : 0.0;\\nfloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);\\nif (!horzSpan)\\n{\\nposM.x+=pixelOffsetSubpix*lengthSign;\\n}\\nif (horzSpan)\\n{\\nposM.y+=pixelOffsetSubpix*lengthSign;\\n}\\n#ifdef MALI\\nif(range<rangeMaxClamped) \\n{\\ngl_FragColor=rgbyM;\\n}\\nelse\\n{\\ngl_FragColor=texture2D(textureSampler,posM,0.0);\\n}\\n#else\\ngl_FragColor=texture2D(textureSampler,posM,0.0);\\n#endif\\n}\",\n    chromaticAberrationPixelShader: \"\\nuniform sampler2D textureSampler; \\n\\nuniform float chromatic_aberration;\\nuniform float radialIntensity;\\nuniform vec2 direction;\\nuniform vec2 centerPosition;\\nuniform float screen_width;\\nuniform float screen_height;\\n\\nvarying vec2 vUV;\\nvoid main(void)\\n{\\nvec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);\\nvec2 directionOfEffect=direction;\\nif(directionOfEffect.x == 0. && directionOfEffect.y == 0.){\\ndirectionOfEffect=normalize(centered_screen_pos);\\n}\\nfloat radius2=centered_screen_pos.x*centered_screen_pos.x\\n+centered_screen_pos.y*centered_screen_pos.y;\\nfloat radius=sqrt(radius2);\\nvec4 original=texture2D(textureSampler,vUV);\\n\\nvec3 ref_indices=vec3(-0.3,0.0,0.3);\\nfloat ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;\\nfloat ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;\\n\\nvec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);\\nvec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);\\nvec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);\\noriginal.r=texture2D(textureSampler,ref_coords_r).r;\\noriginal.g=texture2D(textureSampler,ref_coords_g).g;\\noriginal.b=texture2D(textureSampler,ref_coords_b).b;\\noriginal.a=clamp(texture2D(textureSampler,ref_coords_r).a+texture2D(textureSampler,ref_coords_g).a+texture2D(textureSampler,ref_coords_b).a,0.,1.);\\ngl_FragColor=original;\\n}\",\n    grainPixelShader: \"#include<helperFunctions>\\n\\nuniform sampler2D textureSampler; \\n\\nuniform float intensity;\\nuniform float animatedSeed;\\n\\nvarying vec2 vUV;\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\nvec2 seed=vUV*(animatedSeed);\\nfloat grain=dither(seed,intensity);\\n\\nfloat lum=getLuminance(gl_FragColor.rgb);\\nfloat grainAmount=(cos(-PI+(lum*PI*2.))+1.)/2.;\\ngl_FragColor.rgb+=grain*grainAmount;\\ngl_FragColor.rgb=max(gl_FragColor.rgb,0.0);\\n}\",\n    sharpenPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 screenSize;\\nuniform vec2 sharpnessAmounts;\\nvoid main(void)\\n{\\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\\nvec4 color=texture2D(textureSampler,vUV);\\nvec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0)) +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1)) -\\ncolor*4.0;\\ngl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);\\n}\",\n    kernelBlurVertexShader: \"\\nattribute vec2 position;\\n\\nuniform vec2 delta;\\n\\nvarying vec2 sampleCenter;\\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nsampleCenter=(position*madd+madd);\\n#include<kernelBlurVertex>[0..varyingCount]\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\n    kernelBlurPixelShader: \"\\nuniform sampler2D textureSampler;\\nuniform vec2 delta;\\n\\nvarying vec2 sampleCenter;\\n#ifdef DOF\\nuniform sampler2D circleOfConfusionSampler;\\nuniform vec2 cameraMinMaxZ;\\nfloat sampleDistance(const in vec2 offset) {\\nfloat depth=texture2D(circleOfConfusionSampler,offset).g; \\nreturn cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth; \\n}\\nfloat sampleCoC(const in vec2 offset) {\\nfloat coc=texture2D(circleOfConfusionSampler,offset).r; \\nreturn coc; \\n}\\n#endif\\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\\n#ifdef PACKEDFLOAT\\nvec4 pack(float depth)\\n{\\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\\nvec4 res=fract(depth*bit_shift);\\nres-=res.xxyz*bit_mask;\\nreturn res;\\n}\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\\n#endif\\nvoid main(void)\\n{\\nfloat computedWeight=0.0;\\n#ifdef PACKEDFLOAT \\nfloat blend=0.;\\n#else\\nvec4 blend=vec4(0.);\\n#endif\\n#ifdef DOF\\nfloat sumOfWeights=CENTER_WEIGHT; \\nfloat factor=0.0;\\n\\n#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\\n#else\\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\\n#endif\\n#endif\\n#include<kernelBlurFragment>[0..varyingCount]\\n#include<kernelBlurFragment2>[0..depCount]\\n#ifdef PACKEDFLOAT\\ngl_FragColor=pack(blend);\\n#else\\ngl_FragColor=blend;\\n#endif\\n#ifdef DOF\\ngl_FragColor/=sumOfWeights;\\n#endif\\n}\",\n    depthOfFieldMergePixelShader: \"uniform sampler2D textureSampler;\\nvarying vec2 vUV;\\nuniform sampler2D circleOfConfusionSampler;\\nuniform sampler2D blurStep0;\\n#if BLUR_LEVEL>0\\nuniform sampler2D blurStep1;\\n#endif\\n#if BLUR_LEVEL>1\\nuniform sampler2D blurStep2;\\n#endif\\nvoid main(void)\\n{\\nfloat coc=texture2D(circleOfConfusionSampler,vUV).r;\\n#if BLUR_LEVEL == 0\\nvec4 original=texture2D(textureSampler,vUV);\\nvec4 blurred0=texture2D(blurStep0,vUV);\\ngl_FragColor=mix(original,blurred0,coc);\\n#endif\\n#if BLUR_LEVEL == 1\\nif(coc<0.5){\\nvec4 original=texture2D(textureSampler,vUV);\\nvec4 blurred1=texture2D(blurStep1,vUV);\\ngl_FragColor=mix(original,blurred1,coc/0.5);\\n}else{\\nvec4 blurred0=texture2D(blurStep0,vUV); \\nvec4 blurred1=texture2D(blurStep1,vUV);\\ngl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);\\n}\\n#endif\\n#if BLUR_LEVEL == 2\\nif(coc<0.33){\\nvec4 original=texture2D(textureSampler,vUV);\\nvec4 blurred2=texture2D(blurStep2,vUV);\\ngl_FragColor=mix(original,blurred2,coc/0.33);\\n}else if(coc<0.66){\\nvec4 blurred1=texture2D(blurStep1,vUV);\\nvec4 blurred2=texture2D(blurStep2,vUV);\\ngl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);\\n}else{\\nvec4 blurred0=texture2D(blurStep0,vUV);\\nvec4 blurred1=texture2D(blurStep1,vUV);\\ngl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);\\n}\\n#endif\\n}\\n\",\n    circleOfConfusionPixelShader: \"\\nuniform sampler2D depthSampler;\\n\\nvarying vec2 vUV;\\n\\nuniform vec2 cameraMinMaxZ;\\n\\nuniform float focusDistance;\\nuniform float cocPrecalculation;\\nvoid main(void)\\n{\\nfloat depth=texture2D(depthSampler,vUV).r;\\nfloat pixelDistance=(cameraMinMaxZ.x+(cameraMinMaxZ.y-cameraMinMaxZ.x)*depth)*1000.0; \\nfloat coc=abs(cocPrecalculation* ((focusDistance-pixelDistance)/pixelDistance));\\ncoc=clamp(coc,0.0,1.0);\\ngl_FragColor=vec4(coc,depth,coc,1.0);\\n}\\n\",\n    bloomMergePixelShader: \"uniform sampler2D textureSampler;\\nuniform sampler2D bloomBlur;\\nvarying vec2 vUV;\\nuniform float bloomWeight;\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\nvec3 blurred=texture2D(bloomBlur,vUV).rgb;\\ngl_FragColor.rgb=gl_FragColor.rgb+(blurred.rgb*bloomWeight); \\n}\\n\",\n    extractHighlightsPixelShader: \"#include<helperFunctions>\\n\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform float threshold;\\nuniform float exposure;\\nvoid main(void) \\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\nfloat luma=getLuminance(gl_FragColor.rgb*exposure);\\ngl_FragColor.rgb=step(threshold,luma)*gl_FragColor.rgb;\\n}\",\n    refractionPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D refractionSampler;\\n\\nuniform vec3 baseColor;\\nuniform float depth;\\nuniform float colorLevel;\\nvoid main() {\\nfloat ref=1.0-texture2D(refractionSampler,vUV).r;\\nvec2 uv=vUV-vec2(0.5);\\nvec2 offset=uv*depth*ref;\\nvec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;\\ngl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);\\n}\",\n    blackAndWhitePixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform float degree;\\nvoid main(void) \\n{\\nvec3 color=texture2D(textureSampler,vUV).rgb;\\nfloat luminance=dot(color,vec3(0.3,0.59,0.11)); \\nvec3 blackAndWhite=vec3(luminance,luminance,luminance);\\ngl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);\\n}\",\n    convolutionPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 screenSize;\\nuniform float kernel[9];\\nvoid main(void)\\n{\\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\\nvec4 colorSum =\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];\\nfloat kernelWeight =\\nkernel[0] +\\nkernel[1] +\\nkernel[2] +\\nkernel[3] +\\nkernel[4] +\\nkernel[5] +\\nkernel[6] +\\nkernel[7] +\\nkernel[8];\\nif (kernelWeight<=0.0) {\\nkernelWeight=1.0;\\n}\\ngl_FragColor=vec4((colorSum/kernelWeight).rgb,1);\\n}\",\n    filterPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform mat4 kernelMatrix;\\nvoid main(void)\\n{\\nvec3 baseColor=texture2D(textureSampler,vUV).rgb;\\nvec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;\\ngl_FragColor=vec4(updatedColor,1.0);\\n}\",\n    volumetricLightScatteringPixelShader: \"uniform sampler2D textureSampler;\\nuniform sampler2D lightScatteringSampler;\\nuniform float decay;\\nuniform float exposure;\\nuniform float weight;\\nuniform float density;\\nuniform vec2 meshPositionOnScreen;\\nvarying vec2 vUV;\\nvoid main(void) {\\nvec2 tc=vUV;\\nvec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);\\ndeltaTexCoord*=1.0/float(NUM_SAMPLES)*density;\\nfloat illuminationDecay=1.0;\\nvec4 color=texture2D(lightScatteringSampler,tc)*0.4;\\nfor(int i=0; i<NUM_SAMPLES; i++) {\\ntc-=deltaTexCoord;\\nvec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;\\ndataSample*=illuminationDecay*weight;\\ncolor+=dataSample;\\nilluminationDecay*=decay;\\n}\\nvec4 realColor=texture2D(textureSampler,vUV);\\ngl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\\n}\\n\",\n    volumetricLightScatteringPassPixelShader: \"#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\n#endif\\n#if defined(ALPHATEST)\\nuniform sampler2D diffuseSampler;\\n#endif\\nvoid main(void)\\n{\\n#if defined(ALPHATEST)\\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);\\nif (diffuseColor.a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\\n}\\n\",\n    colorCorrectionPixelShader: \"\\nuniform sampler2D textureSampler; \\nuniform sampler2D colorTable; \\n\\nvarying vec2 vUV;\\n\\nconst float SLICE_COUNT=16.0; \\n\\nvec4 sampleAs3DTexture(sampler2D textureSampler,vec3 uv,float width) {\\nfloat sliceSize=1.0/width; \\nfloat slicePixelSize=sliceSize/width; \\nfloat sliceInnerSize=slicePixelSize*(width-1.0); \\nfloat zSlice0=min(floor(uv.z*width),width-1.0);\\nfloat zSlice1=min(zSlice0+1.0,width-1.0);\\nfloat xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;\\nfloat s0=xOffset+(zSlice0*sliceSize);\\nfloat s1=xOffset+(zSlice1*sliceSize);\\nvec4 slice0Color=texture2D(textureSampler,vec2(s0,uv.y));\\nvec4 slice1Color=texture2D(textureSampler,vec2(s1,uv.y));\\nfloat zOffset=mod(uv.z*width,1.0);\\nvec4 result=mix(slice0Color,slice1Color,zOffset);\\nreturn result;\\n}\\nvoid main(void)\\n{\\nvec4 screen_color=texture2D(textureSampler,vUV);\\ngl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);\\n}\",\n    tonemapPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform float _ExposureAdjustment;\\n#if defined(HABLE_TONEMAPPING)\\nconst float A=0.15;\\nconst float B=0.50;\\nconst float C=0.10;\\nconst float D=0.20;\\nconst float E=0.02;\\nconst float F=0.30;\\nconst float W=11.2;\\n#endif\\nfloat Luminance(vec3 c)\\n{\\nreturn dot(c,vec3(0.22,0.707,0.071));\\n}\\nvoid main(void) \\n{\\nvec3 colour=texture2D(textureSampler,vUV).rgb;\\n#if defined(REINHARD_TONEMAPPING)\\nfloat lum=Luminance(colour.rgb); \\nfloat lumTm=lum*_ExposureAdjustment;\\nfloat scale=lumTm/(1.0+lumTm); \\ncolour*=scale/lum;\\n#elif defined(HABLE_TONEMAPPING)\\ncolour*=_ExposureAdjustment;\\nconst float ExposureBias=2.0;\\nvec3 x=ExposureBias*colour;\\nvec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\\nx=vec3(W,W,W);\\nvec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\\ncolour=curr*whiteScale;\\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\\ncolour*=_ExposureAdjustment;\\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\\ncolour=retColor*retColor;\\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\\ncolour=vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\\n#endif\\ngl_FragColor=vec4(colour.rgb,1.0);\\n}\",\n    displayPassPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D passSampler;\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(passSampler,vUV);\\n}\",\n    highlightsPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nconst vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);\\nvoid main(void) \\n{\\nvec4 tex=texture2D(textureSampler,vUV);\\nvec3 c=tex.rgb;\\nfloat luma=dot(c.rgb,RGBLuminanceCoefficients);\\n\\n\\ngl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a); \\n}\",\n    imageProcessingPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\nvoid main(void)\\n{\\nvec4 result=texture2D(textureSampler,vUV);\\n#ifdef IMAGEPROCESSING\\n#ifndef FROMLINEARSPACE\\n\\nresult.rgb=toLinearSpace(result.rgb);\\n#endif\\nresult=applyImageProcessing(result);\\n#else\\n\\n#ifdef FROMLINEARSPACE\\nresult=applyImageProcessing(result);\\n#endif\\n#endif\\ngl_FragColor=result;\\n}\",\n    lensFlareVertexShader: \"\\nattribute vec2 position;\\n\\nuniform mat4 viewportMatrix;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvUV=position*madd+madd;\\ngl_Position=viewportMatrix*vec4(position,0.0,1.0);\\n}\",\n    lensFlarePixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec4 color;\\nvoid main(void) {\\nvec4 baseColor=texture2D(textureSampler,vUV);\\ngl_FragColor=baseColor*color;\\n}\",\n    anaglyphPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D leftSampler;\\nvoid main(void)\\n{\\nvec4 leftFrag=texture2D(leftSampler,vUV);\\nleftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);\\nvec4 rightFrag=texture2D(textureSampler,vUV);\\nrightFrag=vec4(rightFrag.r,1.0,1.0,1.0);\\ngl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);\\n}\",\n    stereoscopicInterlacePixelShader: \"const vec3 TWO=vec3(2.0,2.0,2.0);\\nvarying vec2 vUV;\\nuniform sampler2D camASampler;\\nuniform sampler2D textureSampler;\\nuniform vec2 stepSize;\\nvoid main(void)\\n{\\nbool useCamB;\\nvec2 texCoord1;\\nvec2 texCoord2;\\nvec3 frag1;\\nvec3 frag2;\\n#ifdef IS_STEREOSCOPIC_HORIZ\\nuseCamB=vUV.x>0.5;\\ntexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\\ntexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\\n#else\\nuseCamB=vUV.y>0.5;\\ntexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\\ntexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\\n#endif\\n\\nif (useCamB){\\nfrag1=texture2D(textureSampler,texCoord1).rgb;\\nfrag2=texture2D(textureSampler,texCoord2).rgb;\\n}else{\\nfrag1=texture2D(camASampler ,texCoord1).rgb;\\nfrag2=texture2D(camASampler ,texCoord2).rgb;\\n}\\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);\\n}\",\n    vrDistortionCorrectionPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 LensCenter;\\nuniform vec2 Scale;\\nuniform vec2 ScaleIn;\\nuniform vec4 HmdWarpParam;\\nvec2 HmdWarp(vec2 in01) {\\nvec2 theta=(in01-LensCenter)*ScaleIn; \\nfloat rSq=theta.x*theta.x+theta.y*theta.y;\\nvec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);\\nreturn LensCenter+Scale*rvector;\\n}\\nvoid main(void)\\n{\\nvec2 tc=HmdWarp(vUV);\\nif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);\\nelse{\\ngl_FragColor=texture2D(textureSampler,tc);\\n}\\n}\",\n    glowBlurPostProcessPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec2 screenSize;\\nuniform vec2 direction;\\nuniform float blurWidth;\\n\\nfloat getLuminance(vec3 color)\\n{\\nreturn dot(color,vec3(0.2126,0.7152,0.0722));\\n}\\nvoid main(void)\\n{\\nfloat weights[7];\\nweights[0]=0.05;\\nweights[1]=0.1;\\nweights[2]=0.2;\\nweights[3]=0.3;\\nweights[4]=0.2;\\nweights[5]=0.1;\\nweights[6]=0.05;\\nvec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);\\nvec2 texelStep=texelSize*direction*blurWidth;\\nvec2 start=vUV-3.0*texelStep;\\nvec4 baseColor=vec4(0.,0.,0.,0.);\\nvec2 texelOffset=vec2(0.,0.);\\nfor (int i=0; i<7; i++)\\n{\\n\\nvec4 texel=texture2D(textureSampler,start+texelOffset);\\nbaseColor.a+=texel.a*weights[i];\\n\\nfloat luminance=getLuminance(baseColor.rgb);\\nfloat luminanceTexel=getLuminance(texel.rgb);\\nfloat choice=step(luminanceTexel,luminance);\\nbaseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;\\ntexelOffset+=texelStep;\\n}\\ngl_FragColor=baseColor;\\n}\",\n    glowMapGenerationPixelShader: \"#ifdef ALPHATEST\\nvarying vec2 vUVDiffuse;\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef EMISSIVE\\nvarying vec2 vUVEmissive;\\nuniform sampler2D emissiveSampler;\\n#endif\\nuniform vec4 color;\\nvoid main(void)\\n{\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUVDiffuse).a<0.4)\\ndiscard;\\n#endif\\n#ifdef EMISSIVE\\ngl_FragColor=texture2D(emissiveSampler,vUVEmissive)*color;\\n#else\\ngl_FragColor=color;\\n#endif\\n}\",\n    glowMapGenerationVertexShader: \"\\nattribute vec3 position;\\n#include<bonesDeclaration>\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nvarying vec4 vPosition;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef ALPHATEST\\nvarying vec2 vUVDiffuse;\\nuniform mat4 diffuseMatrix;\\n#endif\\n#ifdef EMISSIVE\\nvarying vec2 vUVEmissive;\\nuniform mat4 emissiveMatrix;\\n#endif\\nvoid main(void)\\n{\\nvec3 positionUpdated=position;\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#ifdef CUBEMAP\\nvPosition=finalWorld*vec4(positionUpdated,1.0);\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#else\\nvPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\ngl_Position=vPosition;\\n#endif\\n#ifdef ALPHATEST\\n#ifdef DIFFUSEUV1\\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef DIFFUSEUV2\\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#ifdef EMISSIVE\\n#ifdef EMISSIVEUV1\\nvUVEmissive=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef EMISSIVEUV2\\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\n    glowMapMergePixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#ifdef EMISSIVE\\nuniform sampler2D textureSampler2;\\n#endif\\n\\nuniform float offset;\\nvoid main(void) {\\nvec4 baseColor=texture2D(textureSampler,vUV);\\n#ifdef EMISSIVE\\nbaseColor+=texture2D(textureSampler2,vUV);\\nbaseColor*=offset;\\n#else\\nbaseColor.a=abs(offset-baseColor.a);\\n#ifdef STROKE\\nfloat alpha=smoothstep(.0,.1,baseColor.a);\\nbaseColor.a=alpha;\\nbaseColor.rgb=baseColor.rgb*alpha;\\n#endif\\n#endif\\ngl_FragColor=baseColor;\\n}\",\n    glowMapMergeVertexShader: \"\\nattribute vec2 position;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) {\\nvUV=position*madd+madd;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\n    lineVertexShader: \"\\nattribute vec3 position;\\nattribute vec4 normal;\\n\\nuniform mat4 worldViewProjection;\\nuniform float width;\\nuniform float aspectRatio;\\nvoid main(void) {\\nvec4 viewPosition=worldViewProjection*vec4(position,1.0);\\nvec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);\\nvec2 currentScreen=viewPosition.xy/viewPosition.w;\\nvec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;\\ncurrentScreen.x*=aspectRatio;\\nnextScreen.x*=aspectRatio;\\nvec2 dir=normalize(nextScreen-currentScreen);\\nvec2 normalDir=vec2(-dir.y,dir.x);\\nnormalDir*=width/2.0;\\nnormalDir.x/=aspectRatio;\\nvec4 offset=vec4(normalDir*normal.w,0.0,0.0);\\ngl_Position=viewPosition+offset;\\n}\",\n    linePixelShader: \"uniform vec4 color;\\nvoid main(void) {\\ngl_FragColor=color;\\n}\",\n    outlineVertexShader: \"\\nattribute vec3 position;\\nattribute vec3 normal;\\n#include<bonesDeclaration>\\n\\nuniform float offset;\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\n#include<logDepthDeclaration>\\nvoid main(void)\\n{\\nvec3 offsetPosition=position+normal*offset;\\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(offsetPosition,1.0);\\n#ifdef ALPHATEST\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#include<logDepthVertex>\\n}\\n\",\n    outlinePixelShader: \"#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\nuniform vec4 color;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\n#include<logDepthDeclaration>\\nvoid main(void) {\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\n#include<logDepthFragment>\\ngl_FragColor=color;\\n}\",\n    layerVertexShader: \"\\nattribute vec2 position;\\n\\nuniform vec2 scale;\\nuniform vec2 offset;\\nuniform mat4 textureMatrix;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvec2 shiftedPosition=position*scale+offset;\\nvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\\ngl_Position=vec4(shiftedPosition,0.0,1.0);\\n}\",\n    layerPixelShader: \"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec4 color;\\nvoid main(void) {\\nvec4 baseColor=texture2D(textureSampler,vUV);\\n#ifdef ALPHATEST\\nif (baseColor.a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=baseColor*color;\\n}\",\n    backgroundVertexShader: \"precision highp float;\\n#include<__decl__backgroundVertex>\\n#include<helperFunctions>\\n\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2; \\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nvarying vec2 vDiffuseUV;\\n#endif\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\nvoid main(void) {\\n#ifdef REFLECTIONMAP_SKYBOX\\n#ifdef REFLECTIONMAP_SKYBOX_TRANSFORMED\\nvPositionUVW=(reflectionMatrix*vec4(position,1.0)).xyz;\\n#else\\nvPositionUVW=position;\\n#endif\\n#endif \\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\nvec4 worldPos=finalWorld*vec4(position,1.0);\\nvPositionW=vec3(worldPos);\\n#ifdef NORMAL\\nmat3 normalWorld=mat3(finalWorld);\\n#ifdef NONUNIFORMSCALING\\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\\n#endif\\nvNormalW=normalize(normalWorld*normal);\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));\\n#ifdef EQUIRECTANGULAR_RELFECTION_FOV\\nmat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));\\nvec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));\\nif (fFovMultiplier<=1.0) {\\nvDirectionW=normalize(segment);\\n} else {\\nvDirectionW=normalize(vDirectionW+(vDirectionW-segment));\\n}\\n#endif\\n#endif\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uv;\\n#endif \\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0 \\nif (vDiffuseInfos.x == 0.)\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n\\n#include<clipPlaneVertex>\\n\\n#include<fogVertex>\\n\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n\\n#ifdef VERTEXCOLOR\\nvColor=color;\\n#endif\\n\\n#ifdef POINTSIZE\\ngl_PointSize=pointSize;\\n#endif\\n}\\n\",\n    backgroundPixelShader: \"#ifdef TEXTURELODSUPPORT\\n#extension GL_EXT_shader_texture_lod : enable\\n#endif\\nprecision highp float;\\n#include<__decl__backgroundFragment>\\n#define RECIPROCAL_PI2 0.15915494\\n\\nuniform vec3 vEyePosition;\\n\\nvarying vec3 vPositionW;\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif \\n#ifdef MAINUV2 \\nvarying vec2 vMainUV2; \\n#endif \\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef DIFFUSE\\n#if DIFFUSEDIRECTUV == 1\\n#define vDiffuseUV vMainUV1\\n#elif DIFFUSEDIRECTUV == 2\\n#define vDiffuseUV vMainUV2\\n#else\\nvarying vec2 vDiffuseUV;\\n#endif\\nuniform sampler2D diffuseSampler;\\n#endif\\n\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\n#define sampleReflection(s,c) textureCube(s,c)\\nuniform samplerCube reflectionSampler;\\n#ifdef TEXTURELODSUPPORT\\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#else\\n#define sampleReflection(s,c) texture2D(s,c)\\nuniform sampler2D reflectionSampler;\\n#ifdef TEXTURELODSUPPORT\\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n\\n#ifndef FROMLINEARSPACE\\n#define FROMLINEARSPACE;\\n#endif\\n\\n#ifndef SHADOWONLY\\n#define SHADOWONLY;\\n#endif\\n#include<imageProcessingDeclaration>\\n\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<helperFunctions>\\n#include<lightsFragmentFunctions>\\n#include<shadowsFragmentFunctions>\\n#include<imageProcessingFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n\\n#include<fogFragmentDeclaration>\\n#ifdef REFLECTIONFRESNEL\\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\\n{\\n\\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow(clamp(1.0-VdotN,0.,1.),5.0);\\n}\\n#endif\\nvoid main(void) {\\n#include<clipPlaneFragment>\\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\\n\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=vec3(0.0,1.0,0.0);\\n#endif\\n\\nfloat shadow=1.;\\nfloat globalShadow=0.;\\nfloat shadowLightCount=0.;\\n#include<lightFragment>[0..maxSimultaneousLights]\\n#ifdef SHADOWINUSE\\nglobalShadow/=shadowLightCount;\\n#else\\nglobalShadow=1.0;\\n#endif\\n\\nvec4 reflectionColor=vec4(1.,1.,1.,1.);\\n#ifdef REFLECTION\\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\n\\n#ifdef REFLECTIONMAP_3D\\nvec3 reflectionCoords=reflectionVector;\\n#else\\nvec2 reflectionCoords=reflectionVector.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\nreflectionCoords/=reflectionVector.z;\\n#endif\\nreflectionCoords.y=1.0-reflectionCoords.y;\\n#endif\\n#ifdef REFLECTIONBLUR\\nfloat reflectionLOD=vReflectionInfos.y;\\n#ifdef TEXTURELODSUPPORT\\n\\nreflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\\nreflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);\\n#else\\nfloat lodReflectionNormalized=clamp(reflectionLOD,0.,1.);\\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\\nvec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);\\nif(lodReflectionNormalizedDoubled<1.0){\\nreflectionColor=mix(\\nsampleReflection(reflectionSamplerHigh,reflectionCoords),\\nreflectionSpecularMid,\\nlodReflectionNormalizedDoubled\\n);\\n} else {\\nreflectionColor=mix(\\nreflectionSpecularMid,\\nsampleReflection(reflectionSamplerLow,reflectionCoords),\\nlodReflectionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#else\\nvec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);\\nreflectionColor=reflectionSample;\\n#endif\\n#ifdef RGBDREFLECTION\\nreflectionColor.rgb=fromRGBD(reflectionColor);\\n#endif\\n#ifdef GAMMAREFLECTION\\nreflectionColor.rgb=toLinearSpace(reflectionColor.rgb);\\n#endif\\n#ifdef REFLECTIONBGR\\nreflectionColor.rgb=reflectionColor.bgr;\\n#endif\\n\\nreflectionColor.rgb*=vReflectionInfos.x;\\n#endif\\n\\nvec3 diffuseColor=vec3(1.,1.,1.);\\nfloat finalAlpha=alpha;\\n#ifdef DIFFUSE\\nvec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);\\n#ifdef GAMMADIFFUSE\\ndiffuseMap.rgb=toLinearSpace(diffuseMap.rgb);\\n#endif\\n\\ndiffuseMap.rgb*=vDiffuseInfos.y;\\n#ifdef DIFFUSEHASALPHA\\nfinalAlpha*=diffuseMap.a;\\n#endif\\ndiffuseColor=diffuseMap.rgb;\\n#endif\\n\\n#ifdef REFLECTIONFRESNEL\\nvec3 colorBase=diffuseColor;\\n#else\\nvec3 colorBase=reflectionColor.rgb*diffuseColor;\\n#endif\\ncolorBase=max(colorBase,0.0);\\n\\n#ifdef USERGBCOLOR\\nvec3 finalColor=colorBase;\\n#else\\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\\nvec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);\\n#else\\nvec3 mainColor=vPrimaryColor.rgb;\\n#endif\\nvec3 finalColor=colorBase*mainColor;\\n#endif\\n\\n#ifdef REFLECTIONFRESNEL\\nvec3 reflectionAmount=vReflectionControl.xxx;\\nvec3 reflectionReflectance0=vReflectionControl.yyy;\\nvec3 reflectionReflectance90=vReflectionControl.zzz;\\nfloat VdotN=dot(normalize(vEyePosition),normalW);\\nvec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(clamp(VdotN,0.0,1.0),reflectionReflectance0,reflectionReflectance90,1.0);\\nreflectionAmount*=planarReflectionFresnel;\\n#ifdef REFLECTIONFALLOFF\\nfloat reflectionDistanceFalloff=1.0-clamp(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w,0.0,1.0);\\nreflectionDistanceFalloff*=reflectionDistanceFalloff;\\nreflectionAmount*=reflectionDistanceFalloff;\\n#endif\\nfinalColor=mix(finalColor,reflectionColor.rgb,clamp(reflectionAmount,0.,1.));\\n#endif\\n#ifdef OPACITYFRESNEL\\nfloat viewAngleToFloor=dot(normalW,normalize(vEyePosition-vBackgroundCenter));\\n\\nconst float startAngle=0.1;\\nfloat fadeFactor=clamp(viewAngleToFloor/startAngle,0.0,1.0);\\nfinalAlpha*=fadeFactor*fadeFactor;\\n#endif\\n\\n#ifdef SHADOWINUSE\\nfinalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);\\n#endif\\n\\nvec4 color=vec4(finalColor,finalAlpha);\\n#include<fogFragment>\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\n\\n\\ncolor.rgb=clamp(color.rgb,0.,30.0);\\n#else\\n\\ncolor=applyImageProcessing(color);\\n#endif\\n#ifdef PREMULTIPLYALPHA\\n\\ncolor.rgb*=color.a;\\n#endif\\n#ifdef NOISE\\ncolor.rgb+=dither(vPositionW.xy,0.5);\\ncolor=max(color,0.0);\\n#endif\\ngl_FragColor=color;\\n}\\n\",\n    noisePixelShader: \"\\n\\nuniform float brightness;\\nuniform float persistence;\\nuniform float timeScale;\\n\\nvarying vec2 vUV;\\n\\nvec2 hash22(vec2 p)\\n{\\np=p*mat2(127.1,311.7,269.5,183.3);\\np=-1.0+2.0*fract(sin(p)*43758.5453123);\\nreturn sin(p*6.283+timeScale);\\n}\\nfloat interpolationNoise(vec2 p)\\n{\\nvec2 pi=floor(p);\\nvec2 pf=p-pi;\\nvec2 w=pf*pf*(3.-2.*pf);\\nfloat f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\\nfloat f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\\nfloat f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\\nfloat f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\\nfloat xm1=mix(f00,f10,w.x);\\nfloat xm2=mix(f01,f11,w.x);\\nfloat ym=mix(xm1,xm2,w.y); \\nreturn ym;\\n}\\nfloat perlinNoise2D(float x,float y)\\n{\\nfloat sum=0.0;\\nfloat frequency=0.0;\\nfloat amplitude=0.0;\\nfor(int i=0; i<OCTAVES; i++)\\n{\\nfrequency=pow(2.0,float(i));\\namplitude=pow(persistence,float(i));\\nsum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;\\n}\\nreturn sum;\\n}\\n\\nvoid main(void)\\n{\\nfloat x=abs(vUV.x);\\nfloat y=abs(vUV.y);\\nfloat noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);\\ngl_FragColor=vec4(noise,noise,noise,1.0);\\n}\\n\"\n  }, $a.Effect.IncludesShadersStore = {\n    depthPrePass: \"#ifdef DEPTHPREPASS\\ngl_FragColor=vec4(0.,0.,0.,1.0);\\nreturn;\\n#endif\",\n    bonesDeclaration: \"#if NUM_BONE_INFLUENCERS>0\\nuniform mat4 mBones[BonesPerMesh];\\nattribute vec4 matricesIndices;\\nattribute vec4 matricesWeights;\\n#if NUM_BONE_INFLUENCERS>4\\nattribute vec4 matricesIndicesExtra;\\nattribute vec4 matricesWeightsExtra;\\n#endif\\n#endif\",\n    instancesDeclaration: \"#ifdef INSTANCES\\nattribute vec4 world0;\\nattribute vec4 world1;\\nattribute vec4 world2;\\nattribute vec4 world3;\\n#else\\nuniform mat4 world;\\n#endif\",\n    pointCloudVertexDeclaration: \"#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\",\n    bumpVertexDeclaration: \"#if defined(BUMP) || defined(PARALLAX)\\n#if defined(TANGENT) && defined(NORMAL) \\nvarying mat3 vTBN;\\n#endif\\n#endif\\n\",\n    clipPlaneVertexDeclaration: \"#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nuniform vec4 vClipPlane2;\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nuniform vec4 vClipPlane3;\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nuniform vec4 vClipPlane4;\\nvarying float fClipDistance4;\\n#endif\",\n    fogVertexDeclaration: \"#ifdef FOG\\nvarying vec3 vFogDistance;\\n#endif\",\n    morphTargetsVertexGlobalDeclaration: \"#ifdef MORPHTARGETS\\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\\n#endif\",\n    morphTargetsVertexDeclaration: \"#ifdef MORPHTARGETS\\nattribute vec3 position{X};\\n#ifdef MORPHTARGETS_NORMAL\\nattribute vec3 normal{X};\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\nattribute vec3 tangent{X};\\n#endif\\n#endif\",\n    logDepthDeclaration: \"#ifdef LOGARITHMICDEPTH\\nuniform float logarithmicDepthConstant;\\nvarying float vFragmentDepth;\\n#endif\",\n    morphTargetsVertex: \"#ifdef MORPHTARGETS\\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\\n#endif\\n#endif\",\n    instancesVertex: \"#ifdef INSTANCES\\nmat4 finalWorld=mat4(world0,world1,world2,world3);\\n#else\\nmat4 finalWorld=world;\\n#endif\",\n    bonesVertex: \"#if NUM_BONE_INFLUENCERS>0\\nmat4 influence;\\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif \\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif \\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif \\nfinalWorld=finalWorld*influence;\\n#endif\",\n    bumpVertex: \"#if defined(BUMP) || defined(PARALLAX)\\n#if defined(TANGENT) && defined(NORMAL)\\nvec3 tbnNormal=normalize(normalUpdated);\\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\\n#endif\\n#endif\",\n    clipPlaneVertex: \"#ifdef CLIPPLANE\\nfClipDistance=dot(worldPos,vClipPlane);\\n#endif\\n#ifdef CLIPPLANE2\\nfClipDistance2=dot(worldPos,vClipPlane2);\\n#endif\\n#ifdef CLIPPLANE3\\nfClipDistance3=dot(worldPos,vClipPlane3);\\n#endif\\n#ifdef CLIPPLANE4\\nfClipDistance4=dot(worldPos,vClipPlane4);\\n#endif\",\n    fogVertex: \"#ifdef FOG\\nvFogDistance=(view*worldPos).xyz;\\n#endif\",\n    shadowsVertex: \"#ifdef SHADOWS\\n#if defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\\nvDepthMetric{X}=((vPositionFromLight{X}.z+light{X}.depthValues.x)/(light{X}.depthValues.y));\\n#endif\\n#endif\",\n    pointCloudVertex: \"#ifdef POINTSIZE\\ngl_PointSize=pointSize;\\n#endif\",\n    logDepthVertex: \"#ifdef LOGARITHMICDEPTH\\nvFragmentDepth=1.0+gl_Position.w;\\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\\n#endif\",\n    helperFunctions: \"const float PI=3.1415926535897932384626433832795;\\nconst float LinearEncodePowerApprox=2.2;\\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\\nmat3 transposeMat3(mat3 inMatrix) {\\nvec3 i0=inMatrix[0];\\nvec3 i1=inMatrix[1];\\nvec3 i2=inMatrix[2];\\nmat3 outMatrix=mat3(\\nvec3(i0.x,i1.x,i2.x),\\nvec3(i0.y,i1.y,i2.y),\\nvec3(i0.z,i1.z,i2.z)\\n);\\nreturn outMatrix;\\n}\\n\\nmat3 inverseMat3(mat3 inMatrix) {\\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\\nfloat b01=a22*a11-a12*a21;\\nfloat b11=-a22*a10+a12*a20;\\nfloat b21=a21*a10-a11*a20;\\nfloat det=a00*b01+a01*b11+a02*b21;\\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\\n}\\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\\n{\\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.0,clamp(dot(clipSpace,clipSpace),0.,1.));\\nreturn mix(value,1.0,mask);\\n}\\nvec3 applyEaseInOut(vec3 x){\\nreturn x*x*(3.0-2.0*x);\\n}\\nvec3 toLinearSpace(vec3 color)\\n{\\nreturn pow(color,vec3(LinearEncodePowerApprox));\\n}\\nvec3 toGammaSpace(vec3 color)\\n{\\nreturn pow(color,vec3(GammaEncodePowerApprox));\\n}\\nfloat square(float value)\\n{\\nreturn value*value;\\n}\\nfloat getLuminance(vec3 color)\\n{\\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\\n}\\n\\nfloat getRand(vec2 seed) {\\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\\n}\\nfloat dither(vec2 seed,float varianceAmount) {\\nfloat rand=getRand(seed);\\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\\nreturn dither;\\n}\\n\\nconst float rgbdMaxRange=255.0;\\nvec4 toRGBD(vec3 color) {\\nfloat maxRGB=max(0.0000001,max(color.r,max(color.g,color.b)));\\nfloat D=max(rgbdMaxRange/maxRGB,1.);\\nD=clamp(floor(D)/255.0,0.,1.);\\n\\nvec3 rgb=color.rgb*D;\\n\\nrgb=toGammaSpace(rgb);\\nreturn vec4(rgb,D); \\n}\\nvec3 fromRGBD(vec4 rgbd) {\\n\\nrgbd.rgb=toLinearSpace(rgbd.rgb);\\n\\nreturn rgbd.rgb/rgbd.a;\\n}\",\n    lightFragmentDeclaration: \"#ifdef LIGHT{X}\\nuniform vec4 vLightData{X};\\nuniform vec4 vLightDiffuse{X};\\n#ifdef SPECULARTERM\\nuniform vec3 vLightSpecular{X};\\n#else\\nvec3 vLightSpecular{X}=vec3(0.);\\n#endif\\n#ifdef SHADOW{X}\\n#if defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\nuniform vec4 shadowsInfo{X};\\nuniform vec2 depthValues{X};\\n#endif\\n#ifdef SPOTLIGHT{X}\\nuniform vec4 vLightDirection{X};\\nuniform vec4 vLightFalloff{X};\\n#elif defined(POINTLIGHT{X})\\nuniform vec4 vLightFalloff{X};\\n#elif defined(HEMILIGHT{X})\\nuniform vec3 vLightGround{X};\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#endif\",\n    lightsFragmentFunctions: \"\\nstruct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n#ifdef NDOTL\\nfloat ndl;\\n#endif\\n};\\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 lightVectorW;\\nfloat attenuation=1.0;\\nif (lightData.w == 0.)\\n{\\nvec3 direction=lightData.xyz-vPositionW;\\nattenuation=max(0.,1.0-length(direction)/range);\\nlightVectorW=normalize(direction);\\n}\\nelse\\n{\\nlightVectorW=normalize(-lightData.xyz);\\n}\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 direction=lightData.xyz-vPositionW;\\nvec3 lightVectorW=normalize(direction);\\nfloat attenuation=max(0.,1.0-length(direction)/range);\\n\\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\\nif (cosAngle>=lightDirection.w)\\n{\\ncosAngle=max(0.,pow(cosAngle,lightData.w));\\nattenuation*=cosAngle;\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nresult.diffuse=vec3(0.);\\n#ifdef SPECULARTERM\\nresult.specular=vec3(0.);\\n#endif\\n#ifdef NDOTL\\nresult.ndl=0.;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\\nlightingInfo result;\\n\\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor;\\n#endif\\nreturn result;\\n}\\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\\nstrq/=strq.w;\\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\\nreturn textureColor;\\n}\",\n    lightUboDeclaration: \"#ifdef LIGHT{X}\\nuniform Light{X}\\n{\\nvec4 vLightData;\\nvec4 vLightDiffuse;\\nvec3 vLightSpecular;\\n#ifdef SPOTLIGHT{X}\\nvec4 vLightDirection;\\nvec4 vLightFalloff;\\n#elif defined(POINTLIGHT{X})\\nvec4 vLightFalloff;\\n#elif defined(HEMILIGHT{X})\\nvec3 vLightGround;\\n#endif\\nvec4 shadowsInfo;\\nvec2 depthValues;\\n} light{X};\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\nuniform mat4 textureProjectionMatrix{X};\\nuniform sampler2D projectionLightSampler{X};\\n#endif\\n#ifdef SHADOW{X}\\n#if defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X}; \\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\n#if defined(SHADOWPCSS{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\nuniform highp sampler2D depthSampler{X};\\n#elif defined(SHADOWPCF{X})\\nuniform highp sampler2DShadow shadowSampler{X};\\n#else\\nuniform sampler2D shadowSampler{X};\\n#endif\\nuniform mat4 lightMatrix{X};\\n#endif\\n#endif\\n#endif\",\n    defaultVertexDeclaration: \"\\nuniform mat4 viewProjection;\\nuniform mat4 view;\\n#ifdef DIFFUSE\\nuniform mat4 diffuseMatrix;\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\nuniform mat4 specularMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef REFLECTION\\nuniform mat4 reflectionMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\",\n    defaultFragmentDeclaration: \"uniform vec4 vDiffuseColor;\\n#ifdef SPECULARTERM\\nuniform vec4 vSpecularColor;\\n#endif\\nuniform vec3 vEmissiveColor;\\n\\n#ifdef DIFFUSE\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY \\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform vec2 vTangentSpaceParams;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\n#ifndef REFRACTIONMAP_3D\\nuniform mat4 refractionMatrix;\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nuniform vec4 refractionLeftColor;\\nuniform vec4 refractionRightColor;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\n#endif\\n#ifdef DIFFUSEFRESNEL\\nuniform vec4 diffuseLeftColor;\\nuniform vec4 diffuseRightColor;\\n#endif\\n#ifdef OPACITYFRESNEL\\nuniform vec4 opacityParts;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nuniform vec4 emissiveLeftColor;\\nuniform vec4 emissiveRightColor;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\n#ifdef REFLECTIONMAP_SKYBOX\\n#else\\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\\nuniform mat4 reflectionMatrix;\\n#endif\\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\\nuniform vec3 vReflectionPosition;\\nuniform vec3 vReflectionSize; \\n#endif\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 reflectionLeftColor;\\nuniform vec4 reflectionRightColor;\\n#endif\\n#endif\",\n    defaultUboDeclaration: \"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nvec4 diffuseLeftColor;\\nvec4 diffuseRightColor;\\nvec4 opacityParts;\\nvec4 reflectionLeftColor;\\nvec4 reflectionRightColor;\\nvec4 refractionLeftColor;\\nvec4 refractionRightColor;\\nvec4 emissiveLeftColor; \\nvec4 emissiveRightColor;\\nvec2 vDiffuseInfos;\\nvec2 vAmbientInfos;\\nvec2 vOpacityInfos;\\nvec2 vReflectionInfos;\\nvec3 vReflectionPosition;\\nvec3 vReflectionSize;\\nvec2 vEmissiveInfos;\\nvec2 vLightmapInfos;\\nvec2 vSpecularInfos;\\nvec3 vBumpInfos;\\nmat4 diffuseMatrix;\\nmat4 ambientMatrix;\\nmat4 opacityMatrix;\\nmat4 reflectionMatrix;\\nmat4 emissiveMatrix;\\nmat4 lightmapMatrix;\\nmat4 specularMatrix;\\nmat4 bumpMatrix; \\nvec4 vTangentSpaceParams;\\nmat4 refractionMatrix;\\nvec4 vRefractionInfos;\\nvec4 vSpecularColor;\\nvec3 vEmissiveColor;\\nvec4 vDiffuseColor;\\nfloat pointSize; \\n};\\nuniform Scene {\\nmat4 viewProjection;\\nmat4 view;\\n};\",\n    shadowsFragmentFunctions: \"#ifdef SHADOWS\\n#ifndef SHADOWFLOAT\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\\n#endif\\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nif (depth>shadow)\\n{\\nreturn darkness;\\n}\\nreturn 1.0;\\n}\\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\nfloat visibility=1.;\\nvec3 poissonDisk[4];\\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\\n#else\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\\n#endif\\nreturn min(1.0,visibility+darkness);\\n}\\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \\nreturn esm;\\n}\\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn esm;\\n}\\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadow=texture2D(shadowSampler,uv).x;\\n#endif\\nif (shadowPixelDepth>shadow)\\n{\\nreturn computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff);\\n}\\nreturn 1.;\\n}\\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\nfloat visibility=1.;\\nvec2 poissonDisk[4];\\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\\npoissonDisk[3]=vec2(0.34495938,0.29387760);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\\n#else\\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\n#endif\\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\\n}\\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\\n}\\n#ifdef WEBGL2\\n\\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nfloat shadow=texture2D(shadowSampler,uvDepth);\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n\\n\\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \\nuv+=0.5; \\nvec2 st=fract(uv); \\nvec2 base_uv=floor(uv)-0.5; \\nbase_uv*=shadowMapSizeAndInverse.y; \\n\\n\\n\\n\\nvec2 uvw0=3.-2.*st;\\nvec2 uvw1=1.+2.*st;\\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow=shadow/16.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\n\\n\\n\\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \\nuv+=0.5; \\nvec2 st=fract(uv); \\nvec2 base_uv=floor(uv)-0.5; \\nbase_uv*=shadowMapSizeAndInverse.y; \\n\\n\\nvec2 uvw0=4.-3.*st;\\nvec2 uvw1=vec2(7.);\\nvec2 uvw2=1.+3.*st;\\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\\nfloat shadow=0.;\\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z));\\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z));\\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z));\\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z));\\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z));\\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z));\\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z));\\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z));\\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z));\\nshadow=shadow/144.;\\nshadow=mix(darkness,1.,shadow);\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\nconst vec3 PoissonSamplers32[64]=vec3[64](\\nvec3(0.06407013,0.05409927,0.),\\nvec3(0.7366577,0.5789394,0.),\\nvec3(-0.6270542,-0.5320278,0.),\\nvec3(-0.4096107,0.8411095,0.),\\nvec3(0.6849564,-0.4990818,0.),\\nvec3(-0.874181,-0.04579735,0.),\\nvec3(0.9989998,0.0009880066,0.),\\nvec3(-0.004920578,-0.9151649,0.),\\nvec3(0.1805763,0.9747483,0.),\\nvec3(-0.2138451,0.2635818,0.),\\nvec3(0.109845,0.3884785,0.),\\nvec3(0.06876755,-0.3581074,0.),\\nvec3(0.374073,-0.7661266,0.),\\nvec3(0.3079132,-0.1216763,0.),\\nvec3(-0.3794335,-0.8271583,0.),\\nvec3(-0.203878,-0.07715034,0.),\\nvec3(0.5912697,0.1469799,0.),\\nvec3(-0.88069,0.3031784,0.),\\nvec3(0.5040108,0.8283722,0.),\\nvec3(-0.5844124,0.5494877,0.),\\nvec3(0.6017799,-0.1726654,0.),\\nvec3(-0.5554981,0.1559997,0.),\\nvec3(-0.3016369,-0.3900928,0.),\\nvec3(-0.5550632,-0.1723762,0.),\\nvec3(0.925029,0.2995041,0.),\\nvec3(-0.2473137,0.5538505,0.),\\nvec3(0.9183037,-0.2862392,0.),\\nvec3(0.2469421,0.6718712,0.),\\nvec3(0.3916397,-0.4328209,0.),\\nvec3(-0.03576927,-0.6220032,0.),\\nvec3(-0.04661255,0.7995201,0.),\\nvec3(0.4402924,0.3640312,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.),\\nvec3(0.,0.,0.)\\n);\\nconst vec3 PoissonSamplers64[64]=vec3[64](\\nvec3(-0.613392,0.617481,0.),\\nvec3(0.170019,-0.040254,0.),\\nvec3(-0.299417,0.791925,0.),\\nvec3(0.645680,0.493210,0.),\\nvec3(-0.651784,0.717887,0.),\\nvec3(0.421003,0.027070,0.),\\nvec3(-0.817194,-0.271096,0.),\\nvec3(-0.705374,-0.668203,0.),\\nvec3(0.977050,-0.108615,0.),\\nvec3(0.063326,0.142369,0.),\\nvec3(0.203528,0.214331,0.),\\nvec3(-0.667531,0.326090,0.),\\nvec3(-0.098422,-0.295755,0.),\\nvec3(-0.885922,0.215369,0.),\\nvec3(0.566637,0.605213,0.),\\nvec3(0.039766,-0.396100,0.),\\nvec3(0.751946,0.453352,0.),\\nvec3(0.078707,-0.715323,0.),\\nvec3(-0.075838,-0.529344,0.),\\nvec3(0.724479,-0.580798,0.),\\nvec3(0.222999,-0.215125,0.),\\nvec3(-0.467574,-0.405438,0.),\\nvec3(-0.248268,-0.814753,0.),\\nvec3(0.354411,-0.887570,0.),\\nvec3(0.175817,0.382366,0.),\\nvec3(0.487472,-0.063082,0.),\\nvec3(-0.084078,0.898312,0.),\\nvec3(0.488876,-0.783441,0.),\\nvec3(0.470016,0.217933,0.),\\nvec3(-0.696890,-0.549791,0.),\\nvec3(-0.149693,0.605762,0.),\\nvec3(0.034211,0.979980,0.),\\nvec3(0.503098,-0.308878,0.),\\nvec3(-0.016205,-0.872921,0.),\\nvec3(0.385784,-0.393902,0.),\\nvec3(-0.146886,-0.859249,0.),\\nvec3(0.643361,0.164098,0.),\\nvec3(0.634388,-0.049471,0.),\\nvec3(-0.688894,0.007843,0.),\\nvec3(0.464034,-0.188818,0.),\\nvec3(-0.440840,0.137486,0.),\\nvec3(0.364483,0.511704,0.),\\nvec3(0.034028,0.325968,0.),\\nvec3(0.099094,-0.308023,0.),\\nvec3(0.693960,-0.366253,0.),\\nvec3(0.678884,-0.204688,0.),\\nvec3(0.001801,0.780328,0.),\\nvec3(0.145177,-0.898984,0.),\\nvec3(0.062655,-0.611866,0.),\\nvec3(0.315226,-0.604297,0.),\\nvec3(-0.780145,0.486251,0.),\\nvec3(-0.371868,0.882138,0.),\\nvec3(0.200476,0.494430,0.),\\nvec3(-0.494552,-0.711051,0.),\\nvec3(0.612476,0.705252,0.),\\nvec3(-0.578845,-0.768792,0.),\\nvec3(-0.772454,-0.090976,0.),\\nvec3(0.504440,0.372295,0.),\\nvec3(0.155736,0.065157,0.),\\nvec3(0.391522,0.849605,0.),\\nvec3(-0.620106,-0.328104,0.),\\nvec3(0.789239,-0.419965,0.),\\nvec3(-0.545396,0.538133,0.),\\nvec3(-0.178564,-0.596057,0.)\\n);\\n\\n\\n\\n\\n\\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\\n{\\nif (depthMetric>1.0 || depthMetric<0.0) {\\nreturn 1.0;\\n}\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\\nfloat blockerDepth=0.0;\\nfloat sumBlockerDepth=0.0;\\nfloat numBlocker=0.0;\\nfor (int i=0; i<searchTapCount; i ++) {\\nblockerDepth=texture(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy)).r;\\nif (blockerDepth<depthMetric) {\\nsumBlockerDepth+=blockerDepth;\\nnumBlocker++;\\n}\\n}\\nif (numBlocker<1.0) {\\nreturn 1.0;\\n}\\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\\n\\nfloat AAOffset=shadowMapSizeInverse*10.;\\n\\n\\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\\nfloat random=getRand(vPositionFromLight.xy);\\nfloat rotationAngle=random*3.1415926;\\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\\nfloat shadow=0.;\\nfor (int i=0; i<pcfTapCount; i++) {\\nvec3 offset=poissonSamplers[i];\\n\\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\\nshadow+=texture2D(shadowSampler,uvDepth+offset*filterRadius);\\n}\\nshadow/=float(pcfTapCount);\\n\\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\\n\\nshadow=mix(darkness,1.,shadow);\\n\\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\\n}\\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\\n}\\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\\n}\\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\\n{\\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\\n}\\n#endif\\n#endif\\n\",\n    fresnelFunction: \"#ifdef FRESNEL\\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\\n{\\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\\nreturn clamp(fresnelTerm,0.,1.);\\n}\\n#endif\",\n    reflectionFunction: \"#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\\n\\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\\nvec3 halfSize=cubeSize*0.5;\\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\\n\\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\\n\\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\\n\\nvec3 intersectPositionWS=vertexPos+origVec*distance;\\n\\nreturn intersectPositionWS-cubePos;\\n}\\n#endif\\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\\n{\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvec3 direction=normalize(vDirectionW);\\nfloat lon=atan(direction.z,direction.x);\\nfloat lat=acos(direction.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y; \\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\\nreturn vec3(1.0-s,t,0);\\n#else\\nreturn vec3(s,t,0);\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\\nvec3 cameraToVertex=normalize(worldPos.xyz-vEyePosition.xyz);\\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\\nfloat lon=atan(r.z,r.x);\\nfloat lat=acos(r.y);\\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\\nfloat s=sphereCoords.x*0.5+0.5;\\nfloat t=sphereCoords.y; \\nreturn vec3(s,t,0);\\n#endif\\n#ifdef REFLECTIONMAP_SPHERICAL\\nvec3 viewDir=normalize(vec3(view*worldPos));\\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\\nvec3 r=reflect(viewDir,viewNormal);\\nr.z=r.z-1.0;\\nfloat m=2.0*length(r);\\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\\n#endif\\n#ifdef REFLECTIONMAP_PLANAR\\nvec3 viewDir=worldPos.xyz-vEyePosition.xyz;\\nvec3 coords=normalize(reflect(viewDir,worldNormal));\\nreturn vec3(reflectionMatrix*vec4(coords,1));\\n#endif\\n#ifdef REFLECTIONMAP_CUBIC\\nvec3 viewDir=normalize(worldPos.xyz-vEyePosition.xyz);\\n\\nvec3 coords=reflect(viewDir,worldNormal);\\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,vReflectionSize,vReflectionPosition);\\n#endif\\ncoords=vec3(reflectionMatrix*vec4(coords,0));\\n#ifdef INVERTCUBICMAP\\ncoords.y*=-1.0;\\n#endif\\nreturn coords;\\n#endif\\n#ifdef REFLECTIONMAP_PROJECTION\\nreturn vec3(reflectionMatrix*(view*worldPos));\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nreturn vPositionUVW;\\n#endif\\n#ifdef REFLECTIONMAP_EXPLICIT\\nreturn vec3(0,0,0);\\n#endif\\n}\",\n    imageProcessingDeclaration: \"#ifdef EXPOSURE\\nuniform float exposureLinear;\\n#endif\\n#ifdef CONTRAST\\nuniform float contrast;\\n#endif\\n#ifdef VIGNETTE\\nuniform vec2 vInverseScreenSize;\\nuniform vec4 vignetteSettings1;\\nuniform vec4 vignetteSettings2;\\n#endif\\n#ifdef COLORCURVES\\nuniform vec4 vCameraColorCurveNegative;\\nuniform vec4 vCameraColorCurveNeutral;\\nuniform vec4 vCameraColorCurvePositive;\\n#endif\\n#ifdef COLORGRADING\\n#ifdef COLORGRADING3D\\nuniform highp sampler3D txColorTransform;\\n#else\\nuniform sampler2D txColorTransform;\\n#endif\\nuniform vec4 colorTransformSettings;\\n#endif\",\n    imageProcessingFunctions: \"#if defined(COLORGRADING) && !defined(COLORGRADING3D)\\n\\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\\n{\\nfloat sliceSize=2.0*sampler3dSetting.x; \\n#ifdef SAMPLER3DGREENDEPTH\\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\\n#else\\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\\n#endif\\nfloat sliceInteger=floor(sliceContinuous);\\n\\n\\nfloat sliceFraction=sliceContinuous-sliceInteger;\\n#ifdef SAMPLER3DGREENDEPTH\\nvec2 sliceUV=color.rb;\\n#else\\nvec2 sliceUV=color.rg;\\n#endif\\nsliceUV.x*=sliceSize;\\nsliceUV.x+=sliceInteger*sliceSize;\\nsliceUV=clamp(sliceUV,0.,1.);\\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\\nsliceUV.x+=sliceSize;\\nsliceUV=clamp(sliceUV,0.,1.);\\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\\n#ifdef SAMPLER3DBGRMAP\\ncolor.rgb=result.rgb;\\n#else\\ncolor.rgb=result.bgr;\\n#endif\\nreturn color;\\n}\\n#endif\\n#ifdef TONEMAPPING_ACES\\n\\n\\n\\n\\n\\nconst mat3 ACESInputMat=mat3(\\nvec3(0.59719,0.07600,0.02840),\\nvec3(0.35458,0.90834,0.13383),\\nvec3(0.04823,0.01566,0.83777)\\n);\\n\\nconst mat3 ACESOutputMat=mat3(\\nvec3( 1.60475,-0.10208,-0.00327),\\nvec3(-0.53108,1.10813,-0.07276),\\nvec3(-0.07367,-0.00605,1.07602)\\n);\\nvec3 RRTAndODTFit(vec3 v)\\n{\\nvec3 a=v*(v+0.0245786)-0.000090537;\\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\\nreturn a/b;\\n}\\nvec3 ACESFitted(vec3 color)\\n{\\ncolor=ACESInputMat*color;\\n\\ncolor=RRTAndODTFit(color);\\ncolor=ACESOutputMat*color;\\n\\ncolor=clamp(color,0.0,1.0);\\nreturn color;\\n}\\n#endif\\nvec4 applyImageProcessing(vec4 result) {\\n#ifdef EXPOSURE\\nresult.rgb*=exposureLinear;\\n#endif\\n#ifdef VIGNETTE\\n\\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\\nviewportXY=viewportXY*2.0-1.0;\\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\\n\\nvec3 vignetteColor=vignetteSettings2.rgb;\\n#ifdef VIGNETTEBLENDMODEMULTIPLY\\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\\nresult.rgb*=vignetteColorMultiplier;\\n#endif\\n#ifdef VIGNETTEBLENDMODEOPAQUE\\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\\n#endif\\n#endif\\n#ifdef TONEMAPPING\\n#ifdef TONEMAPPING_ACES\\nresult.rgb=ACESFitted(result.rgb);\\n#else\\nconst float tonemappingCalibration=1.590579;\\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\\n#endif\\n#endif\\n\\nresult.rgb=toGammaSpace(result.rgb);\\nresult.rgb=clamp(result.rgb,0.0,1.0);\\n#ifdef CONTRAST\\n\\nvec3 resultHighContrast=applyEaseInOut(result.rgb);\\nif (contrast<1.0) {\\n\\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\\n} else {\\n\\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\\n}\\n#endif\\n\\n#ifdef COLORGRADING\\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\\n#ifdef COLORGRADING3D\\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\\n#else\\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\\n#endif\\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\\n#endif\\n#ifdef COLORCURVES\\n\\nfloat luma=getLuminance(result.rgb);\\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\\nresult.rgb*=colorCurve.rgb;\\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\\n#endif\\nreturn result;\\n}\",\n    bumpFragmentFunctions: \"#ifdef BUMP\\n#if BUMPDIRECTUV == 1\\n#define vBumpUV vMainUV1\\n#elif BUMPDIRECTUV == 2\\n#define vBumpUV vMainUV2\\n#else\\nvarying vec2 vBumpUV;\\n#endif\\nuniform sampler2D bumpSampler;\\n#if defined(TANGENT) && defined(NORMAL) \\nvarying mat3 vTBN;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\nuniform mat4 normalMatrix;\\n#endif\\n\\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\\n{\\n\\nuv=gl_FrontFacing ? uv : -uv;\\n\\nvec3 dp1=dFdx(p);\\nvec3 dp2=dFdy(p);\\nvec2 duv1=dFdx(uv);\\nvec2 duv2=dFdy(uv);\\n\\nvec3 dp2perp=cross(dp2,normal);\\nvec3 dp1perp=cross(normal,dp1);\\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\\n\\ntangent*=vTangentSpaceParams.x;\\nbitangent*=vTangentSpaceParams.y;\\n\\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(bitangent,bitangent)));\\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\\n}\\nvec3 perturbNormal(mat3 cotangentFrame,vec2 uv)\\n{\\nvec3 map=texture2D(bumpSampler,uv).xyz;\\nmap=map*2.0-1.0;\\n#ifdef NORMALXYSCALE\\nmap=normalize(map*vec3(vBumpInfos.y,vBumpInfos.y,1.0));\\n#endif\\nreturn normalize(cotangentFrame*map);\\n}\\n#ifdef PARALLAX\\nconst float minSamples=4.;\\nconst float maxSamples=15.;\\nconst int iMaxSamples=15;\\n\\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\\nparallaxLimit*=parallaxScale;\\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\\nfloat stepSize=1.0/numSamples;\\n\\nfloat currRayHeight=1.0;\\nvec2 vCurrOffset=vec2(0,0);\\nvec2 vLastOffset=vec2(0,0);\\nfloat lastSampledHeight=1.0;\\nfloat currSampledHeight=1.0;\\nfor (int i=0; i<iMaxSamples; i++)\\n{\\ncurrSampledHeight=texture2D(bumpSampler,vBumpUV+vCurrOffset).w;\\n\\nif (currSampledHeight>currRayHeight)\\n{\\nfloat delta1=currSampledHeight-currRayHeight;\\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\\nfloat ratio=delta1/(delta1+delta2);\\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\\n\\nbreak;\\n}\\nelse\\n{\\ncurrRayHeight-=stepSize;\\nvLastOffset=vCurrOffset;\\nvCurrOffset+=stepSize*vMaxOffset;\\nlastSampledHeight=currSampledHeight;\\n}\\n}\\nreturn vCurrOffset;\\n}\\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\\n{\\n\\nfloat height=texture2D(bumpSampler,vBumpUV).w;\\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\\nreturn -texCoordOffset;\\n}\\n#endif\\n#endif\",\n    clipPlaneFragmentDeclaration: \"#ifdef CLIPPLANE\\nvarying float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nvarying float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nvarying float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nvarying float fClipDistance4;\\n#endif\",\n    fogFragmentDeclaration: \"#ifdef FOG\\n#define FOGMODE_NONE 0.\\n#define FOGMODE_EXP 1.\\n#define FOGMODE_EXP2 2.\\n#define FOGMODE_LINEAR 3.\\n#define E 2.71828\\nuniform vec4 vFogInfos;\\nuniform vec3 vFogColor;\\nvarying vec3 vFogDistance;\\nfloat CalcFogFactor()\\n{\\nfloat fogCoeff=1.0;\\nfloat fogStart=vFogInfos.y;\\nfloat fogEnd=vFogInfos.z;\\nfloat fogDensity=vFogInfos.w;\\nfloat fogDistance=length(vFogDistance);\\nif (FOGMODE_LINEAR == vFogInfos.x)\\n{\\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\\n}\\nelse if (FOGMODE_EXP == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\\n}\\nelse if (FOGMODE_EXP2 == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\\n}\\nreturn clamp(fogCoeff,0.0,1.0);\\n}\\n#endif\",\n    clipPlaneFragment: \"#ifdef CLIPPLANE\\nif (fClipDistance>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE2\\nif (fClipDistance2>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE3\\nif (fClipDistance3>0.0)\\n{\\ndiscard;\\n}\\n#endif\\n#ifdef CLIPPLANE4\\nif (fClipDistance4>0.0)\\n{\\ndiscard;\\n}\\n#endif\",\n    bumpFragment: \"vec2 uvOffset=vec2(0.0,0.0);\\n#if defined(BUMP) || defined(PARALLAX)\\n#ifdef NORMALXYSCALE\\nfloat normalScale=1.0;\\n#else \\nfloat normalScale=vBumpInfos.y;\\n#endif\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#else\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vBumpUV);\\n#endif\\n#endif\\n#ifdef PARALLAX\\nmat3 invTBN=transposeMat3(TBN);\\n#ifdef PARALLAXOCCLUSION\\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\\n#else\\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\\n#endif\\n#endif\\n#ifdef BUMP\\n#ifdef OBJECTSPACE_NORMALMAP\\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz*2.0-1.0);\\nnormalW=normalize(mat3(normalMatrix)*normalW); \\n#else\\nnormalW=perturbNormal(TBN,vBumpUV+uvOffset);\\n#endif\\n#endif\",\n    lightFragment: \"#ifdef LIGHT{X}\\n#if defined(SHADOWONLY) || (defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X}))\\n\\n#else\\n#ifdef PBR\\n#ifdef SPOTLIGHT{X}\\nspotInfo=computeSpotLightingInfo(light{X}.vLightData);\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\nspotInfo.attenuation=computeDistanceLightFalloff_GLTF(spotInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\nspotInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,spotInfo.directionToLightCenterW,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\nspotInfo.attenuation=computeDistanceLightFalloff_Physical(spotInfo.lightDistanceSquared);\\nspotInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,spotInfo.directionToLightCenterW,light{X}.vLightDirection.w);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\nspotInfo.attenuation=computeDistanceLightFalloff_Standard(spotInfo.lightOffset,light{X}.vLightFalloff.x);\\nspotInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,spotInfo.directionToLightCenterW,light{X}.vLightDirection.w,light{X}.vLightData.w);\\n#else\\nspotInfo.attenuation=computeDistanceLightFalloff(spotInfo.lightOffset,spotInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\nspotInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,spotInfo.directionToLightCenterW,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\\n#endif\\ninfo=computeSpotLighting(spotInfo,viewDirectionW,normalW,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightDiffuse.a,roughness,NdotV,specularEnvironmentR0,specularEnvironmentR90,geometricRoughnessFactor,NdotL);\\n#elif defined(POINTLIGHT{X})\\npointInfo=computePointLightingInfo(light{X}.vLightData);\\n#ifdef LIGHT_FALLOFF_GLTF{X}\\npointInfo.attenuation=computeDistanceLightFalloff_GLTF(pointInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\\npointInfo.attenuation=computeDistanceLightFalloff_Physical(pointInfo.lightDistanceSquared);\\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\\npointInfo.attenuation=computeDistanceLightFalloff_Standard(pointInfo.lightOffset,light{X}.vLightFalloff.x);\\n#else\\npointInfo.attenuation=computeDistanceLightFalloff(pointInfo.lightOffset,pointInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\\n#endif\\ninfo=computePointLighting(pointInfo,viewDirectionW,normalW,light{X}.vLightDiffuse.rgb,light{X}.vLightDiffuse.a,roughness,NdotV,specularEnvironmentR0,specularEnvironmentR90,geometricRoughnessFactor,NdotL);\\n#elif defined(HEMILIGHT{X})\\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightGround,roughness,NdotV,specularEnvironmentR0,specularEnvironmentR90,geometricRoughnessFactor,NdotL);\\n#elif defined(DIRLIGHT{X})\\ninfo=computeDirectionalLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightDiffuse.a,roughness,NdotV,specularEnvironmentR0,specularEnvironmentR90,geometricRoughnessFactor,NdotL);\\n#endif\\n#else\\n#ifdef SPOTLIGHT{X}\\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightDiffuse.a,glossiness);\\n#elif defined(HEMILIGHT{X})\\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightGround,glossiness);\\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightDiffuse.a,glossiness);\\n#endif\\n#endif\\n#ifdef PROJECTEDLIGHTTEXTURE{X}\\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\\n#endif\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCLOSEESM{X}\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWESM{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPOISSON{X})\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCF{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#elif defined(SHADOWPCSS{X})\\n#if defined(SHADOWLOWQUALITY{X})\\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#elif defined(SHADOWMEDIUMQUALITY{X})\\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#else\\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#else\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\\n#endif\\n#endif\\n#ifdef SHADOWONLY\\n#ifndef SHADOWINUSE\\n#define SHADOWINUSE\\n#endif\\nglobalShadow+=shadow;\\nshadowLightCount+=1.0;\\n#endif\\n#else\\nshadow=1.;\\n#endif\\n#ifndef SHADOWONLY\\n#ifdef CUSTOMUSERLIGHTING\\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\\n#ifdef SPECULARTERM\\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\\n#endif\\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\\ndiffuseBase+=lightmapColor*shadow;\\n#ifdef SPECULARTERM\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nspecularBase+=info.specular*shadow*lightmapColor;\\n#endif\\n#endif\\n#else\\ndiffuseBase+=info.diffuse*shadow;\\n#ifdef SPECULARTERM\\nspecularBase+=info.specular*shadow;\\n#endif\\n#endif\\n#endif\\n#endif\",\n    logDepthFragment: \"#ifdef LOGARITHMICDEPTH\\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\\n#endif\",\n    fogFragment: \"#ifdef FOG\\nfloat fog=CalcFogFactor();\\ncolor.rgb=fog*color.rgb+(1.0-fog)*vFogColor;\\n#endif\",\n    pbrVertexDeclaration: \"uniform mat4 view;\\nuniform mat4 viewProjection;\\n#ifdef ALBEDO\\nuniform mat4 albedoMatrix;\\nuniform vec2 vAlbedoInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec4 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#ifdef REFLECTIVITY \\nuniform vec3 vReflectivityInfos;\\nuniform mat4 reflectivityMatrix;\\n#endif\\n#ifdef MICROSURFACEMAP\\nuniform vec2 vMicroSurfaceSamplerInfos;\\nuniform mat4 microSurfaceSamplerMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\nuniform mat4 refractionMatrix;\\nuniform vec3 vRefractionMicrosurfaceInfos;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\n#endif\\n\",\n    pbrFragmentDeclaration: \"uniform vec3 vReflectionColor;\\nuniform vec4 vAlbedoColor;\\n\\nuniform vec4 vLightingIntensity;\\nuniform vec4 vReflectivityColor;\\nuniform vec3 vEmissiveColor;\\n\\n#ifdef ALBEDO\\nuniform vec2 vAlbedoInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec4 vAmbientInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform vec2 vTangentSpaceParams;\\n#endif\\n#ifdef OPACITY \\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef REFLECTIVITY\\nuniform vec3 vReflectivityInfos;\\n#endif\\n#ifdef MICROSURFACEMAP\\nuniform vec2 vMicroSurfaceSamplerInfos;\\n#endif\\n\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\\n\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\nuniform mat4 refractionMatrix;\\nuniform vec3 vRefractionMicrosurfaceInfos;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\\nuniform vec3 vReflectionPosition;\\nuniform vec3 vReflectionSize; \\n#endif\\n#endif\",\n    pbrUboDeclaration: \"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nuniform vec2 vAlbedoInfos;\\nuniform vec4 vAmbientInfos;\\nuniform vec2 vOpacityInfos;\\nuniform vec2 vEmissiveInfos;\\nuniform vec2 vLightmapInfos;\\nuniform vec3 vReflectivityInfos;\\nuniform vec2 vMicroSurfaceSamplerInfos;\\nuniform vec4 vRefractionInfos;\\nuniform vec2 vReflectionInfos;\\nuniform vec3 vReflectionPosition;\\nuniform vec3 vReflectionSize; \\nuniform vec3 vBumpInfos;\\nuniform mat4 albedoMatrix;\\nuniform mat4 ambientMatrix;\\nuniform mat4 opacityMatrix;\\nuniform mat4 emissiveMatrix;\\nuniform mat4 lightmapMatrix;\\nuniform mat4 reflectivityMatrix;\\nuniform mat4 microSurfaceSamplerMatrix;\\nuniform mat4 bumpMatrix;\\nuniform vec2 vTangentSpaceParams;\\nuniform mat4 refractionMatrix;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionColor;\\nuniform vec4 vAlbedoColor;\\nuniform vec4 vLightingIntensity;\\nuniform vec3 vRefractionMicrosurfaceInfos;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\nuniform vec4 vReflectivityColor;\\nuniform vec3 vEmissiveColor;\\nuniform float pointSize;\\n};\\nuniform Scene {\\nmat4 viewProjection;\\nmat4 view;\\n};\",\n    pbrFunctions: \"\\n#define RECIPROCAL_PI2 0.15915494\\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\\n\\nconst float kRougnhessToAlphaScale=0.1;\\nconst float kRougnhessToAlphaOffset=0.29248125;\\nfloat convertRoughnessToAverageSlope(float roughness)\\n{\\n\\nconst float kMinimumVariance=0.0005;\\nfloat alphaG=square(roughness)+kMinimumVariance;\\nreturn alphaG;\\n}\\n\\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot,float alphaG)\\n{\\nfloat tanSquared=(1.0-dot*dot)/(dot*dot);\\nreturn 2.0/(1.0+sqrt(1.0+alphaG*alphaG*tanSquared));\\n}\\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL,float NdotV,float alphaG)\\n{\\nreturn smithVisibilityG1_TrowbridgeReitzGGX(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGX(NdotV,alphaG);\\n}\\n\\n\\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\\n{\\n\\n\\n\\nfloat a2=square(alphaG);\\nfloat d=NdotH*NdotH*(a2-1.0)+1.0;\\nreturn a2/(PI*d*d);\\n}\\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\\n{\\nreturn reflectance0+(reflectance90-reflectance0)*pow(clamp(1.0-VdotH,0.,1.),5.0);\\n}\\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\\n{\\n\\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow(clamp(1.0-VdotN,0.,1.),5.0);\\n}\\n\\nvec3 computeSpecularTerm(float NdotH,float NdotL,float NdotV,float VdotH,float roughness,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor)\\n{\\nroughness=max(roughness,geometricRoughnessFactor);\\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\\nfloat visibility=smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL,NdotV,alphaG);\\nvisibility/=(4.0*NdotL*NdotV); \\nfloat specTerm=max(0.,visibility*distribution)*NdotL;\\nvec3 fresnel=fresnelSchlickGGX(VdotH,reflectance0,reflectance90);\\nreturn fresnel*specTerm;\\n}\\nfloat computeDiffuseTerm(float NdotL,float NdotV,float VdotH,float roughness)\\n{\\n\\n\\nfloat diffuseFresnelNV=pow(clamp(1.0-NdotL,0.000001,1.),5.0);\\nfloat diffuseFresnelNL=pow(clamp(1.0-NdotV,0.000001,1.),5.0);\\nfloat diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;\\nfloat fresnel =\\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\\nreturn fresnel*NdotL/PI;\\n}\\nfloat adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance)\\n{\\n#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)\\n\\nfloat lightRoughness=lightRadius/lightDistance;\\n\\nfloat totalRoughness=clamp(lightRoughness+roughness,0.,1.);\\nreturn totalRoughness;\\n#else\\nreturn roughness;\\n#endif\\n}\\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\\n{\\nconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\\nfloat reflectivityLuminance=getLuminance(reflectivityColor);\\nfloat reflectivityLuma=sqrt(reflectivityLuminance);\\nmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\\nreturn microSurface;\\n}\\n\\n\\nfloat fresnelGrazingReflectance(float reflectance0) {\\nfloat reflectance90=clamp(reflectance0*25.0,0.0,1.0);\\nreturn reflectance90;\\n}\\n\\n\\n#define UNPACK_LOD(x) (1.0-x)*255.0\\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {\\nfloat microsurfaceAverageSlope=alphaG;\\n\\n\\n\\n\\n\\n\\nmicrosurfaceAverageSlope*=sqrt(abs(NdotV));\\nfloat microsurfaceAverageSlopeTexels=microsurfaceAverageSlope*cubeMapDimensionPixels;\\nfloat lod=log2(microsurfaceAverageSlopeTexels);\\nreturn lod;\\n}\\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {\\n\\n\\nfloat temp=NdotVUnclamped+ambientOcclusion;\\nreturn clamp(square(temp)-1.0+ambientOcclusion,0.0,1.0);\\n}\\nfloat environmentHorizonOcclusion(vec3 view,vec3 normal) {\\n\\nvec3 reflection=reflect(view,normal);\\nfloat temp=clamp( 1.0+1.1*dot(reflection,normal),0.0,1.0);\\nreturn square(temp);\\n}\",\n    harmonicsFunctions: \"#ifdef USESPHERICALFROMREFLECTIONMAP\\nuniform vec3 vSphericalX;\\nuniform vec3 vSphericalY;\\nuniform vec3 vSphericalZ;\\nuniform vec3 vSphericalXX_ZZ;\\nuniform vec3 vSphericalYY_ZZ;\\nuniform vec3 vSphericalZZ;\\nuniform vec3 vSphericalXY;\\nuniform vec3 vSphericalYZ;\\nuniform vec3 vSphericalZX;\\nvec3 quaternionVectorRotation_ScaledSqrtTwo(vec4 Q,vec3 V){\\nvec3 T=cross(Q.xyz,V);\\nT+=Q.www*V;\\nreturn cross(Q.xyz,T)+V;\\n}\\nvec3 environmentIrradianceJones(vec3 normal)\\n{\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfloat Nx=normal.x;\\nfloat Ny=normal.y;\\nfloat Nz=normal.z;\\nvec3 C1=vSphericalZZ.rgb;\\nvec3 Cx=vSphericalX.rgb;\\nvec3 Cy=vSphericalY.rgb;\\nvec3 Cz=vSphericalZ.rgb;\\nvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\\nvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\\nvec3 Cxy=vSphericalXY.rgb;\\nvec3 Cyz=vSphericalYZ.rgb;\\nvec3 Czx=vSphericalZX.rgb;\\nvec3 a1=Cyy_zz*Ny+Cy;\\nvec3 a2=Cyz*Nz+a1;\\nvec3 b1=Czx*Nz+Cx;\\nvec3 b2=Cxy*Ny+b1;\\nvec3 b3=Cxx_zz*Nx+b2;\\nvec3 t1=Cz*Nz+C1;\\nvec3 t2=a2*Ny+t1;\\nvec3 t3=b3*Nx+t2;\\nreturn t3;\\n}\\n#endif\",\n    pbrLightFunctions: \"\\nstruct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n};\\nstruct pointLightingInfo\\n{\\nvec3 lightOffset;\\nfloat lightDistanceSquared;\\nfloat attenuation;\\n};\\nstruct spotLightingInfo\\n{\\nvec3 lightOffset;\\nfloat lightDistanceSquared;\\nvec3 directionToLightCenterW;\\nfloat attenuation;\\n};\\nfloat computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)\\n{\\nreturn max(0.,1.0-length(lightOffset)/range);\\n}\\nfloat computeDistanceLightFalloff_Physical(float lightDistanceSquared)\\n{\\nreturn 1.0/((lightDistanceSquared+0.001));\\n}\\nfloat computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)\\n{\\nconst float minDistanceSquared=0.01*0.01;\\nfloat lightDistanceFalloff=1.0/(max(lightDistanceSquared,minDistanceSquared));\\nfloat factor=lightDistanceSquared*inverseSquaredRange;\\nfloat attenuation=clamp(1.0-factor*factor,0.,1.);\\nattenuation*=attenuation;\\n\\nlightDistanceFalloff*=attenuation;\\nreturn lightDistanceFalloff;\\n}\\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)\\n{ \\n#ifdef USEPHYSICALLIGHTFALLOFF\\nreturn computeDistanceLightFalloff_Physical(lightDistanceSquared);\\n#elif defined(USEGLTFLIGHTFALLOFF)\\nreturn computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);\\n#else\\nreturn computeDistanceLightFalloff_Standard(lightOffset,range);\\n#endif\\n}\\nfloat computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)\\n{\\nfloat falloff=0.0;\\nfloat cosAngle=max(0.000000000000001,dot(-lightDirection,directionToLightCenterW));\\nif (cosAngle>=cosHalfAngle)\\n{\\nfalloff=max(0.,pow(cosAngle,exponent));\\n}\\nreturn falloff;\\n}\\nfloat computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)\\n{\\nconst float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \\n\\n\\n\\n\\n\\nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);\\n\\n\\nvec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);\\nfloat falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));\\nreturn falloff;\\n}\\nfloat computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)\\n{\\n\\n\\n\\nfloat cd=dot(-lightDirection,directionToLightCenterW);\\nfloat falloff=clamp(cd*lightAngleScale+lightAngleOffset,0.,1.);\\n\\nfalloff*=falloff;\\nreturn falloff;\\n}\\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)\\n{\\n#ifdef USEPHYSICALLIGHTFALLOFF\\nreturn computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);\\n#elif defined(USEGLTFLIGHTFALLOFF)\\nreturn computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);\\n#else\\nreturn computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);\\n#endif\\n}\\npointLightingInfo computePointLightingInfo(vec4 lightData) {\\npointLightingInfo result;\\nresult.lightOffset=lightData.xyz-vPositionW;\\nresult.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);\\nreturn result;\\n}\\nspotLightingInfo computeSpotLightingInfo(vec4 lightData) {\\nspotLightingInfo result;\\nresult.lightOffset=lightData.xyz-vPositionW;\\nresult.directionToLightCenterW=normalize(result.lightOffset);\\nresult.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);\\nreturn result;\\n}\\nlightingInfo computePointLighting(pointLightingInfo info,vec3 viewDirectionW,vec3 vNormal,vec3 diffuseColor,float lightRadius,float roughness,float NdotV,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,out float NdotL) {\\nlightingInfo result;\\nfloat lightDistance=sqrt(info.lightDistanceSquared);\\nvec3 lightDirection=normalize(info.lightOffset);\\n\\nroughness=adjustRoughnessFromLightProperties(roughness,lightRadius,lightDistance);\\n\\nvec3 H=normalize(viewDirectionW+lightDirection);\\nNdotL=clamp(dot(vNormal,lightDirection),0.00000000001,1.0);\\nfloat VdotH=clamp(dot(viewDirectionW,H),0.0,1.0);\\nfloat diffuseTerm=computeDiffuseTerm(NdotL,NdotV,VdotH,roughness);\\nresult.diffuse=diffuseTerm*diffuseColor*info.attenuation;\\n#ifdef SPECULARTERM\\n\\nfloat NdotH=clamp(dot(vNormal,H),0.000000000001,1.0);\\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,reflectance0,reflectance90,geometricRoughnessFactor);\\nresult.specular=specTerm*diffuseColor*info.attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeSpotLighting(spotLightingInfo info,vec3 viewDirectionW,vec3 vNormal,vec4 lightDirection,vec3 diffuseColor,float lightRadius,float roughness,float NdotV,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,out float NdotL) {\\nlightingInfo result;\\n\\nfloat lightDistance=sqrt(info.lightDistanceSquared);\\nroughness=adjustRoughnessFromLightProperties(roughness,lightRadius,lightDistance);\\n\\nvec3 H=normalize(viewDirectionW+info.directionToLightCenterW);\\nNdotL=clamp(dot(vNormal,info.directionToLightCenterW),0.000000000001,1.0);\\nfloat VdotH=clamp(dot(viewDirectionW,H),0.0,1.0);\\nfloat diffuseTerm=computeDiffuseTerm(NdotL,NdotV,VdotH,roughness);\\nresult.diffuse=diffuseTerm*diffuseColor*info.attenuation;\\n#ifdef SPECULARTERM\\n\\nfloat NdotH=clamp(dot(vNormal,H),0.000000000001,1.0);\\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,reflectance0,reflectance90,geometricRoughnessFactor);\\nresult.specular=specTerm*diffuseColor*info.attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeDirectionalLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float lightRadius,float roughness,float NdotV,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,out float NdotL) {\\nlightingInfo result;\\nfloat lightDistance=length(-lightData.xyz);\\nvec3 lightDirection=normalize(-lightData.xyz);\\n\\nroughness=adjustRoughnessFromLightProperties(roughness,lightRadius,lightDistance);\\n\\nvec3 H=normalize(viewDirectionW+lightDirection);\\nNdotL=clamp(dot(vNormal,lightDirection),0.00000000001,1.0);\\nfloat VdotH=clamp(dot(viewDirectionW,H),0.0,1.0);\\nfloat diffuseTerm=computeDiffuseTerm(NdotL,NdotV,VdotH,roughness);\\nresult.diffuse=diffuseTerm*diffuseColor;\\n#ifdef SPECULARTERM\\n\\nfloat NdotH=clamp(dot(vNormal,H),0.000000000001,1.0);\\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,reflectance0,reflectance90,geometricRoughnessFactor);\\nresult.specular=specTerm*diffuseColor;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float roughness,float NdotV,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,out float NdotL) {\\nlightingInfo result;\\n\\n\\n\\nNdotL=dot(vNormal,lightData.xyz)*0.5+0.5;\\nresult.diffuse=mix(groundColor,diffuseColor,NdotL);\\n#ifdef SPECULARTERM\\n\\nvec3 lightVectorW=normalize(lightData.xyz);\\nvec3 H=normalize(viewDirectionW+lightVectorW);\\nfloat NdotH=clamp(dot(vNormal,H),0.000000000001,1.0);\\nNdotL=clamp(NdotL,0.000000000001,1.0);\\nfloat VdotH=clamp(dot(viewDirectionW,H),0.0,1.0);\\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,reflectance0,reflectance90,geometricRoughnessFactor);\\nresult.specular=specTerm*diffuseColor;\\n#endif\\nreturn result;\\n}\\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\\nstrq/=strq.w;\\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\\nreturn toLinearSpace(textureColor);\\n}\",\n    clipPlaneVertexDeclaration2: \"#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nout float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nuniform vec4 vClipPlane2;\\nout float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nuniform vec4 vClipPlane3;\\nout float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nuniform vec4 vClipPlane4;\\nout float fClipDistance4;\\n#endif\",\n    clipPlaneFragmentDeclaration2: \"#ifdef CLIPPLANE\\nin float fClipDistance;\\n#endif\\n#ifdef CLIPPLANE2\\nin float fClipDistance2;\\n#endif\\n#ifdef CLIPPLANE3\\nin float fClipDistance3;\\n#endif\\n#ifdef CLIPPLANE4\\nin float fClipDistance4;\\n#endif\",\n    mrtFragmentDeclaration: \"#if __VERSION__>=200\\nlayout(location=0) out vec4 glFragData[{X}];\\n#endif\\n\",\n    bones300Declaration: \"#if NUM_BONE_INFLUENCERS>0\\nuniform mat4 mBones[BonesPerMesh];\\nin vec4 matricesIndices;\\nin vec4 matricesWeights;\\n#if NUM_BONE_INFLUENCERS>4\\nin vec4 matricesIndicesExtra;\\nin vec4 matricesWeightsExtra;\\n#endif\\n#endif\",\n    instances300Declaration: \"#ifdef INSTANCES\\nin vec4 world0;\\nin vec4 world1;\\nin vec4 world2;\\nin vec4 world3;\\n#else\\nuniform mat4 world;\\n#endif\",\n    kernelBlurFragment: \"#ifdef DOF\\nfactor=sampleCoC(sampleCoord{X}); \\ncomputedWeight=KERNEL_WEIGHT{X}*factor;\\nsumOfWeights+=computedWeight;\\n#else\\ncomputedWeight=KERNEL_WEIGHT{X};\\n#endif\\n#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\\n#else\\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\\n#endif\",\n    kernelBlurFragment2: \"#ifdef DOF\\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\\ncomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\\nsumOfWeights+=computedWeight;\\n#else\\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\\n#endif\\n#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\\n#else\\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\\n#endif\",\n    kernelBlurVaryingDeclaration: \"varying vec2 sampleCoord{X};\",\n    kernelBlurVertex: \"sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};\",\n    backgroundVertexDeclaration: \"uniform mat4 view;\\nuniform mat4 viewProjection;\\nuniform float shadowLevel;\\n#ifdef DIFFUSE\\nuniform mat4 diffuseMatrix;\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\nuniform float fFovMultiplier;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\",\n    backgroundFragmentDeclaration: \" uniform vec4 vPrimaryColor;\\n#ifdef USEHIGHLIGHTANDSHADOWCOLORS\\nuniform vec4 vPrimaryColorShadow;\\n#endif\\nuniform float shadowLevel;\\nuniform float alpha;\\n#ifdef DIFFUSE\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\n#endif\\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\\nuniform vec3 vBackgroundCenter;\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 vReflectionControl;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\",\n    backgroundUboDeclaration: \"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nuniform vec4 vPrimaryColor;\\nuniform vec4 vPrimaryColorShadow;\\nuniform vec2 vDiffuseInfos;\\nuniform vec2 vReflectionInfos;\\nuniform mat4 diffuseMatrix;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\nuniform float fFovMultiplier;\\nuniform float pointSize;\\nuniform float shadowLevel;\\nuniform float alpha;\\n#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)\\nuniform vec3 vBackgroundCenter;\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 vReflectionControl;\\n#endif\\n};\\nuniform Scene {\\nmat4 viewProjection;\\nmat4 view;\\n};\"\n  };\n  var tl = \"undefined\" != typeof global ? global : \"undefined\" != typeof window ? window : this;\n  return tl.BABYLON = $a, void 0 !== m && (tl.Earcut = {\n    earcut: m\n  }), $a;\n});","map":null,"metadata":{},"sourceType":"script"}