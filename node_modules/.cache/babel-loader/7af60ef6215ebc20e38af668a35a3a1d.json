{"ast":null,"code":"// Polyfills\nif (Number.EPSILON === undefined) {\n  Number.EPSILON = Math.pow(2, -52);\n} //\n\n\nif (Math.sign === undefined) {\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n  Math.sign = function (x) {\n    return x < 0 ? -1 : x > 0 ? 1 : +x;\n  };\n}\n\nif (Function.prototype.name === undefined) {\n  // Missing in IE9-11.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n  Object.defineProperty(Function.prototype, 'name', {\n    get: function () {\n      return this.toString().match(/^\\s*function\\s*([^\\(\\s]*)/)[1];\n    }\n  });\n}\n\nif (Object.assign === undefined) {\n  // Missing in IE.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n  (function () {\n    Object.assign = function (target) {\n      'use strict';\n\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  })();\n}\n/*\r\n * A list of constants built-in for\r\n * the physics engine.\r\n */\n\n\nvar REVISION = '1.0.9'; // BroadPhase\n\nvar BR_NULL = 0;\nvar BR_BRUTE_FORCE = 1;\nvar BR_SWEEP_AND_PRUNE = 2;\nvar BR_BOUNDING_VOLUME_TREE = 3; // Body type\n\nvar BODY_NULL = 0;\nvar BODY_DYNAMIC = 1;\nvar BODY_STATIC = 2;\nvar BODY_KINEMATIC = 3;\nvar BODY_GHOST = 4; // Shape type\n\nvar SHAPE_NULL = 0;\nvar SHAPE_SPHERE = 1;\nvar SHAPE_BOX = 2;\nvar SHAPE_CYLINDER = 3;\nvar SHAPE_PLANE = 4;\nvar SHAPE_PARTICLE = 5;\nvar SHAPE_TETRA = 6; // Joint type\n\nvar JOINT_NULL = 0;\nvar JOINT_DISTANCE = 1;\nvar JOINT_BALL_AND_SOCKET = 2;\nvar JOINT_HINGE = 3;\nvar JOINT_WHEEL = 4;\nvar JOINT_SLIDER = 5;\nvar JOINT_PRISMATIC = 6; // AABB aproximation\n\nvar AABB_PROX = 0.005;\nvar _Math = {\n  sqrt: Math.sqrt,\n  abs: Math.abs,\n  floor: Math.floor,\n  cos: Math.cos,\n  sin: Math.sin,\n  acos: Math.acos,\n  asin: Math.asin,\n  atan2: Math.atan2,\n  round: Math.round,\n  pow: Math.pow,\n  max: Math.max,\n  min: Math.min,\n  random: Math.random,\n  degtorad: 0.0174532925199432957,\n  radtodeg: 57.295779513082320876,\n  PI: 3.141592653589793,\n  TwoPI: 6.283185307179586,\n  PI90: 1.570796326794896,\n  PI270: 4.712388980384689,\n  INF: Infinity,\n  EPZ: 0.00001,\n  EPZ2: 0.000001,\n  lerp: function (x, y, t) {\n    return (1 - t) * x + t * y;\n  },\n  randInt: function (low, high) {\n    return low + _Math.floor(_Math.random() * (high - low + 1));\n  },\n  rand: function (low, high) {\n    return low + _Math.random() * (high - low);\n  },\n  generateUUID: function () {\n    // http://www.broofa.com/Tools/Math.uuid.htm\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = new Array(36);\n    var rnd = 0,\n        r;\n    return function generateUUID() {\n      for (var i = 0; i < 36; i++) {\n        if (i === 8 || i === 13 || i === 18 || i === 23) {\n          uuid[i] = '-';\n        } else if (i === 14) {\n          uuid[i] = '4';\n        } else {\n          if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;\n          r = rnd & 0xf;\n          rnd = rnd >> 4;\n          uuid[i] = chars[i === 19 ? r & 0x3 | 0x8 : r];\n        }\n      }\n\n      return uuid.join('');\n    };\n  }(),\n  int: function (x) {\n    return _Math.floor(x);\n  },\n  fix: function (x, n) {\n    return x.toFixed(n || 3, 10);\n  },\n  clamp: function (value, min, max) {\n    return _Math.max(min, _Math.min(max, value));\n  },\n  //clamp: function ( x, a, b ) { return ( x < a ) ? a : ( ( x > b ) ? b : x ); },\n  distance: function (p1, p2) {\n    var xd = p2[0] - p1[0];\n    var yd = p2[1] - p1[1];\n    var zd = p2[2] - p1[2];\n    return _Math.sqrt(xd * xd + yd * yd + zd * zd);\n  },\n\n  /*unwrapDegrees: function ( r ) {\r\n        r = r % 360;\r\n      if (r > 180) r -= 360;\r\n      if (r < -180) r += 360;\r\n      return r;\r\n    },\r\n    unwrapRadian: function( r ){\r\n        r = r % _Math.TwoPI;\r\n      if (r > _Math.PI) r -= _Math.TwoPI;\r\n      if (r < -_Math.PI) r += _Math.TwoPI;\r\n      return r;\r\n    },*/\n  acosClamp: function (cos) {\n    if (cos > 1) return 0;else if (cos < -1) return _Math.PI;else return _Math.acos(cos);\n  },\n  distanceVector: function (v1, v2) {\n    var xd = v1.x - v2.x;\n    var yd = v1.y - v2.y;\n    var zd = v1.z - v2.z;\n    return xd * xd + yd * yd + zd * zd;\n  },\n  dotVectors: function (a, b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n};\n\nfunction printError(clazz, msg) {\n  console.error(\"[OIMO] \" + clazz + \": \" + msg);\n} // A performance evaluator\n\n\nfunction InfoDisplay(world) {\n  this.parent = world;\n  this.infos = new Float32Array(13);\n  this.f = [0, 0, 0];\n  this.times = [0, 0, 0, 0];\n  this.broadPhase = this.parent.broadPhaseType;\n  this.version = REVISION;\n  this.fps = 0;\n  this.tt = 0;\n  this.broadPhaseTime = 0;\n  this.narrowPhaseTime = 0;\n  this.solvingTime = 0;\n  this.totalTime = 0;\n  this.updateTime = 0;\n  this.MaxBroadPhaseTime = 0;\n  this.MaxNarrowPhaseTime = 0;\n  this.MaxSolvingTime = 0;\n  this.MaxTotalTime = 0;\n  this.MaxUpdateTime = 0;\n}\n\nObject.assign(InfoDisplay.prototype, {\n  setTime: function (n) {\n    this.times[n || 0] = performance.now();\n  },\n  resetMax: function () {\n    this.MaxBroadPhaseTime = 0;\n    this.MaxNarrowPhaseTime = 0;\n    this.MaxSolvingTime = 0;\n    this.MaxTotalTime = 0;\n    this.MaxUpdateTime = 0;\n  },\n  calcBroadPhase: function () {\n    this.setTime(2);\n    this.broadPhaseTime = this.times[2] - this.times[1];\n  },\n  calcNarrowPhase: function () {\n    this.setTime(3);\n    this.narrowPhaseTime = this.times[3] - this.times[2];\n  },\n  calcEnd: function () {\n    this.setTime(2);\n    this.solvingTime = this.times[2] - this.times[1];\n    this.totalTime = this.times[2] - this.times[0];\n    this.updateTime = this.totalTime - (this.broadPhaseTime + this.narrowPhaseTime + this.solvingTime);\n    if (this.tt === 100) this.resetMax();\n\n    if (this.tt > 100) {\n      if (this.broadPhaseTime > this.MaxBroadPhaseTime) this.MaxBroadPhaseTime = this.broadPhaseTime;\n      if (this.narrowPhaseTime > this.MaxNarrowPhaseTime) this.MaxNarrowPhaseTime = this.narrowPhaseTime;\n      if (this.solvingTime > this.MaxSolvingTime) this.MaxSolvingTime = this.solvingTime;\n      if (this.totalTime > this.MaxTotalTime) this.MaxTotalTime = this.totalTime;\n      if (this.updateTime > this.MaxUpdateTime) this.MaxUpdateTime = this.updateTime;\n    }\n\n    this.upfps();\n    this.tt++;\n    if (this.tt > 500) this.tt = 0;\n  },\n  upfps: function () {\n    this.f[1] = Date.now();\n\n    if (this.f[1] - 1000 > this.f[0]) {\n      this.f[0] = this.f[1];\n      this.fps = this.f[2];\n      this.f[2] = 0;\n    }\n\n    this.f[2]++;\n  },\n  show: function () {\n    var info = [\"Oimo.js \" + this.version + \"<br>\", this.broadPhase + \"<br><br>\", \"FPS: \" + this.fps + \" fps<br><br>\", \"rigidbody \" + this.parent.numRigidBodies + \"<br>\", \"contact &nbsp;&nbsp;\" + this.parent.numContacts + \"<br>\", \"ct-point &nbsp;\" + this.parent.numContactPoints + \"<br>\", \"paircheck \" + this.parent.broadPhase.numPairChecks + \"<br>\", \"island &nbsp;&nbsp;&nbsp;\" + this.parent.numIslands + \"<br><br>\", \"Time in milliseconds<br><br>\", \"broadphase &nbsp;\" + _Math.fix(this.broadPhaseTime) + \" | \" + _Math.fix(this.MaxBroadPhaseTime) + \"<br>\", \"narrowphase \" + _Math.fix(this.narrowPhaseTime) + \" | \" + _Math.fix(this.MaxNarrowPhaseTime) + \"<br>\", \"solving &nbsp;&nbsp;&nbsp;&nbsp;\" + _Math.fix(this.solvingTime) + \" | \" + _Math.fix(this.MaxSolvingTime) + \"<br>\", \"total &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" + _Math.fix(this.totalTime) + \" | \" + _Math.fix(this.MaxTotalTime) + \"<br>\", \"updating &nbsp;&nbsp;&nbsp;\" + _Math.fix(this.updateTime) + \" | \" + _Math.fix(this.MaxUpdateTime) + \"<br>\"].join(\"\\n\");\n    return info;\n  },\n  toArray: function () {\n    this.infos[0] = this.parent.broadPhase.types;\n    this.infos[1] = this.parent.numRigidBodies;\n    this.infos[2] = this.parent.numContacts;\n    this.infos[3] = this.parent.broadPhase.numPairChecks;\n    this.infos[4] = this.parent.numContactPoints;\n    this.infos[5] = this.parent.numIslands;\n    this.infos[6] = this.broadPhaseTime;\n    this.infos[7] = this.narrowPhaseTime;\n    this.infos[8] = this.solvingTime;\n    this.infos[9] = this.updateTime;\n    this.infos[10] = this.totalTime;\n    this.infos[11] = this.fps;\n    return this.infos;\n  }\n});\n\nfunction Vec3(x, y, z) {\n  this.x = x || 0;\n  this.y = y || 0;\n  this.z = z || 0;\n}\n\nObject.assign(Vec3.prototype, {\n  Vec3: true,\n  set: function (x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  },\n  add: function (a, b) {\n    if (b !== undefined) return this.addVectors(a, b);\n    this.x += a.x;\n    this.y += a.y;\n    this.z += a.z;\n    return this;\n  },\n  addVectors: function (a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  },\n  addEqual: function (v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  },\n  sub: function (a, b) {\n    if (b !== undefined) return this.subVectors(a, b);\n    this.x -= a.x;\n    this.y -= a.y;\n    this.z -= a.z;\n    return this;\n  },\n  subVectors: function (a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  },\n  subEqual: function (v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  },\n  scale: function (v, s) {\n    this.x = v.x * s;\n    this.y = v.y * s;\n    this.z = v.z * s;\n    return this;\n  },\n  scaleEqual: function (s) {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    return this;\n  },\n  multiply: function (v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  },\n  multiplyScalar: function (s) {\n    this.x *= s;\n    this.y *= s;\n    this.z *= s;\n    return this;\n  },\n\n  /*scaleV: function( v ){\n       this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n   },\n   scaleVectorEqual: function( v ){\n       this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n   },*/\n  addScaledVector: function (v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  },\n  subScaledVector: function (v, s) {\n    this.x -= v.x * s;\n    this.y -= v.y * s;\n    this.z -= v.z * s;\n    return this;\n  },\n\n  /*addTime: function ( v, t ) {\n       this.x += v.x * t;\n      this.y += v.y * t;\n      this.z += v.z * t;\n      return this;\n   },\n  \n  addScale: function ( v, s ) {\n       this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n   },\n   subScale: function ( v, s ) {\n       this.x -= v.x * s;\n      this.y -= v.y * s;\n      this.z -= v.z * s;\n      return this;\n   },*/\n  cross: function (a, b) {\n    if (b !== undefined) return this.crossVectors(a, b);\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    this.x = y * a.z - z * a.y;\n    this.y = z * a.x - x * a.z;\n    this.z = x * a.y - y * a.x;\n    return this;\n  },\n  crossVectors: function (a, b) {\n    var ax = a.x,\n        ay = a.y,\n        az = a.z;\n    var bx = b.x,\n        by = b.y,\n        bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  },\n  tangent: function (a) {\n    var ax = a.x,\n        ay = a.y,\n        az = a.z;\n    this.x = ay * ax - az * az;\n    this.y = -az * ay - ax * ax;\n    this.z = ax * az + ay * ay;\n    return this;\n  },\n  invert: function (v) {\n    this.x = -v.x;\n    this.y = -v.y;\n    this.z = -v.z;\n    return this;\n  },\n  negate: function () {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  },\n  dot: function (v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  },\n  addition: function () {\n    return this.x + this.y + this.z;\n  },\n  lengthSq: function () {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  },\n  length: function () {\n    return _Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  },\n  copy: function (v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  },\n\n  /*mul: function( b, a, m ){\n       return this.mulMat( m, a ).add( b );\n   },\n   mulMat: function( m, a ){\n       var e = m.elements;\n      var x = a.x, y = a.y, z = a.z;\n       this.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\n      this.y = e[ 3 ] * x + e[ 4 ] * y + e[ 5 ] * z;\n      this.z = e[ 6 ] * x + e[ 7 ] * y + e[ 8 ] * z;\n      return this;\n   },*/\n  applyMatrix3: function (m, transpose) {\n    //if( transpose ) m = m.clone().transpose();\n    var x = this.x,\n        y = this.y,\n        z = this.z;\n    var e = m.elements;\n\n    if (transpose) {\n      this.x = e[0] * x + e[1] * y + e[2] * z;\n      this.y = e[3] * x + e[4] * y + e[5] * z;\n      this.z = e[6] * x + e[7] * y + e[8] * z;\n    } else {\n      this.x = e[0] * x + e[3] * y + e[6] * z;\n      this.y = e[1] * x + e[4] * y + e[7] * z;\n      this.z = e[2] * x + e[5] * y + e[8] * z;\n    }\n\n    return this;\n  },\n  applyQuaternion: function (q) {\n    var x = this.x;\n    var y = this.y;\n    var z = this.z;\n    var qx = q.x;\n    var qy = q.y;\n    var qz = q.z;\n    var qw = q.w; // calculate quat * vector\n\n    var ix = qw * x + qy * z - qz * y;\n    var iy = qw * y + qz * x - qx * z;\n    var iz = qw * z + qx * y - qy * x;\n    var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return this;\n  },\n  testZero: function () {\n    if (this.x !== 0 || this.y !== 0 || this.z !== 0) return true;else return false;\n  },\n  testDiff: function (v) {\n    return this.equals(v) ? false : true;\n  },\n  equals: function (v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  },\n  clone: function () {\n    return new this.constructor(this.x, this.y, this.z);\n  },\n  toString: function () {\n    return \"Vec3[\" + this.x.toFixed(4) + \", \" + this.y.toFixed(4) + \", \" + this.z.toFixed(4) + \"]\";\n  },\n  multiplyScalar: function (scalar) {\n    if (isFinite(scalar)) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n    } else {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    }\n\n    return this;\n  },\n  divideScalar: function (scalar) {\n    return this.multiplyScalar(1 / scalar);\n  },\n  normalize: function () {\n    return this.divideScalar(this.length());\n  },\n  toArray: function (array, offset) {\n    if (offset === undefined) offset = 0;\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n  },\n  fromArray: function (array, offset) {\n    if (offset === undefined) offset = 0;\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n});\n\nfunction Quat(x, y, z, w) {\n  this.x = x || 0;\n  this.y = y || 0;\n  this.z = z || 0;\n  this.w = w !== undefined ? w : 1;\n}\n\nObject.assign(Quat.prototype, {\n  Quat: true,\n  set: function (x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  },\n  addTime: function (v, t) {\n    var ax = v.x,\n        ay = v.y,\n        az = v.z;\n    var qw = this.w,\n        qx = this.x,\n        qy = this.y,\n        qz = this.z;\n    t *= 0.5;\n    this.x += t * (ax * qw + ay * qz - az * qy);\n    this.y += t * (ay * qw + az * qx - ax * qz);\n    this.z += t * (az * qw + ax * qy - ay * qx);\n    this.w += t * (-ax * qx - ay * qy - az * qz);\n    this.normalize();\n    return this;\n  },\n\n  /*mul: function( q1, q2 ){\n       var ax = q1.x, ay = q1.y, az = q1.z, as = q1.w,\n      bx = q2.x, by = q2.y, bz = q2.z, bs = q2.w;\n      this.x = ax * bs + as * bx + ay * bz - az * by;\n      this.y = ay * bs + as * by + az * bx - ax * bz;\n      this.z = az * bs + as * bz + ax * by - ay * bx;\n      this.w = as * bs - ax * bx - ay * by - az * bz;\n      return this;\n   },*/\n  multiply: function (q, p) {\n    if (p !== undefined) return this.multiplyQuaternions(q, p);\n    return this.multiplyQuaternions(this, q);\n  },\n  multiplyQuaternions: function (a, b) {\n    var qax = a.x,\n        qay = a.y,\n        qaz = a.z,\n        qaw = a.w;\n    var qbx = b.x,\n        qby = b.y,\n        qbz = b.z,\n        qbw = b.w;\n    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    return this;\n  },\n  setFromUnitVectors: function (v1, v2) {\n    var vx = new Vec3();\n    var r = v1.dot(v2) + 1;\n\n    if (r < _Math.EPS2) {\n      r = 0;\n      if (_Math.abs(v1.x) > _Math.abs(v1.z)) vx.set(-v1.y, v1.x, 0);else vx.set(0, -v1.z, v1.y);\n    } else {\n      vx.crossVectors(v1, v2);\n    }\n\n    this._x = vx.x;\n    this._y = vx.y;\n    this._z = vx.z;\n    this._w = r;\n    return this.normalize();\n  },\n  arc: function (v1, v2) {\n    var x1 = v1.x;\n    var y1 = v1.y;\n    var z1 = v1.z;\n    var x2 = v2.x;\n    var y2 = v2.y;\n    var z2 = v2.z;\n    var d = x1 * x2 + y1 * y2 + z1 * z2;\n\n    if (d == -1) {\n      x2 = y1 * x1 - z1 * z1;\n      y2 = -z1 * y1 - x1 * x1;\n      z2 = x1 * z1 + y1 * y1;\n      d = 1 / _Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);\n      this.w = 0;\n      this.x = x2 * d;\n      this.y = y2 * d;\n      this.z = z2 * d;\n      return this;\n    }\n\n    var cx = y1 * z2 - z1 * y2;\n    var cy = z1 * x2 - x1 * z2;\n    var cz = x1 * y2 - y1 * x2;\n    this.w = _Math.sqrt((1 + d) * 0.5);\n    d = 0.5 / this.w;\n    this.x = cx * d;\n    this.y = cy * d;\n    this.z = cz * d;\n    return this;\n  },\n  normalize: function () {\n    var l = this.length();\n\n    if (l === 0) {\n      this.set(0, 0, 0, 1);\n    } else {\n      l = 1 / l;\n      this.x = this.x * l;\n      this.y = this.y * l;\n      this.z = this.z * l;\n      this.w = this.w * l;\n    }\n\n    return this;\n  },\n  inverse: function () {\n    return this.conjugate().normalize();\n  },\n  invert: function (q) {\n    this.x = q.x;\n    this.y = q.y;\n    this.z = q.z;\n    this.w = q.w;\n    this.conjugate().normalize();\n    return this;\n  },\n  conjugate: function () {\n    this.x *= -1;\n    this.y *= -1;\n    this.z *= -1;\n    return this;\n  },\n  length: function () {\n    return _Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  },\n  lengthSq: function () {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  },\n  copy: function (q) {\n    this.x = q.x;\n    this.y = q.y;\n    this.z = q.z;\n    this.w = q.w;\n    return this;\n  },\n  clone: function (q) {\n    return new Quat(this.x, this.y, this.z, this.w);\n  },\n  testDiff: function (q) {\n    return this.equals(q) ? false : true;\n  },\n  equals: function (q) {\n    return this.x === q.x && this.y === q.y && this.z === q.z && this.w === q.w;\n  },\n  toString: function () {\n    return \"Quat[\" + this.x.toFixed(4) + \", (\" + this.y.toFixed(4) + \", \" + this.z.toFixed(4) + \", \" + this.w.toFixed(4) + \")]\";\n  },\n  setFromEuler: function (x, y, z) {\n    var c1 = Math.cos(x * 0.5);\n    var c2 = Math.cos(y * 0.5);\n    var c3 = Math.cos(z * 0.5);\n    var s1 = Math.sin(x * 0.5);\n    var s2 = Math.sin(y * 0.5);\n    var s3 = Math.sin(z * 0.5); // XYZ\n\n    this.x = s1 * c2 * c3 + c1 * s2 * s3;\n    this.y = c1 * s2 * c3 - s1 * c2 * s3;\n    this.z = c1 * c2 * s3 + s1 * s2 * c3;\n    this.w = c1 * c2 * c3 - s1 * s2 * s3;\n    return this;\n  },\n  setFromAxis: function (axis, rad) {\n    axis.normalize();\n    rad = rad * 0.5;\n\n    var s = _Math.sin(rad);\n\n    this.x = s * axis.x;\n    this.y = s * axis.y;\n    this.z = s * axis.z;\n    this.w = _Math.cos(rad);\n    return this;\n  },\n  setFromMat33: function (m) {\n    var trace = m[0] + m[4] + m[8];\n    var s;\n\n    if (trace > 0) {\n      s = _Math.sqrt(trace + 1.0);\n      this.w = 0.5 / s;\n      s = 0.5 / s;\n      this.x = (m[5] - m[7]) * s;\n      this.y = (m[6] - m[2]) * s;\n      this.z = (m[1] - m[3]) * s;\n    } else {\n      var out = [];\n      var i = 0;\n      if (m[4] > m[0]) i = 1;\n      if (m[8] > m[i * 3 + i]) i = 2;\n      var j = (i + 1) % 3;\n      var k = (i + 2) % 3;\n      s = _Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n      out[i] = 0.5 * fRoot;\n      s = 0.5 / fRoot;\n      this.w = (m[j * 3 + k] - m[k * 3 + j]) * s;\n      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * s;\n      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * s;\n      this.x = out[1];\n      this.y = out[2];\n      this.z = out[3];\n    }\n\n    return this;\n  },\n  toArray: function (array, offset) {\n    offset = offset || 0;\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n  },\n  fromArray: function (array, offset) {\n    offset = offset || 0;\n    this.set(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    return this;\n  }\n});\n\nfunction Mat33(e00, e01, e02, e10, e11, e12, e20, e21, e22) {\n  this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  if (arguments.length > 0) {\n    console.error('OIMO.Mat33: the constructor no longer reads arguments. use .set() instead.');\n  }\n}\n\nObject.assign(Mat33.prototype, {\n  Mat33: true,\n  set: function (e00, e01, e02, e10, e11, e12, e20, e21, e22) {\n    var te = this.elements;\n    te[0] = e00;\n    te[1] = e01;\n    te[2] = e02;\n    te[3] = e10;\n    te[4] = e11;\n    te[5] = e12;\n    te[6] = e20;\n    te[7] = e21;\n    te[8] = e22;\n    return this;\n  },\n  add: function (a, b) {\n    if (b !== undefined) return this.addMatrixs(a, b);\n    var e = this.elements,\n        te = a.elements;\n    e[0] += te[0];\n    e[1] += te[1];\n    e[2] += te[2];\n    e[3] += te[3];\n    e[4] += te[4];\n    e[5] += te[5];\n    e[6] += te[6];\n    e[7] += te[7];\n    e[8] += te[8];\n    return this;\n  },\n  addMatrixs: function (a, b) {\n    var te = this.elements,\n        tem1 = a.elements,\n        tem2 = b.elements;\n    te[0] = tem1[0] + tem2[0];\n    te[1] = tem1[1] + tem2[1];\n    te[2] = tem1[2] + tem2[2];\n    te[3] = tem1[3] + tem2[3];\n    te[4] = tem1[4] + tem2[4];\n    te[5] = tem1[5] + tem2[5];\n    te[6] = tem1[6] + tem2[6];\n    te[7] = tem1[7] + tem2[7];\n    te[8] = tem1[8] + tem2[8];\n    return this;\n  },\n  addEqual: function (m) {\n    var te = this.elements,\n        tem = m.elements;\n    te[0] += tem[0];\n    te[1] += tem[1];\n    te[2] += tem[2];\n    te[3] += tem[3];\n    te[4] += tem[4];\n    te[5] += tem[5];\n    te[6] += tem[6];\n    te[7] += tem[7];\n    te[8] += tem[8];\n    return this;\n  },\n  sub: function (a, b) {\n    if (b !== undefined) return this.subMatrixs(a, b);\n    var e = this.elements,\n        te = a.elements;\n    e[0] -= te[0];\n    e[1] -= te[1];\n    e[2] -= te[2];\n    e[3] -= te[3];\n    e[4] -= te[4];\n    e[5] -= te[5];\n    e[6] -= te[6];\n    e[7] -= te[7];\n    e[8] -= te[8];\n    return this;\n  },\n  subMatrixs: function (a, b) {\n    var te = this.elements,\n        tem1 = a.elements,\n        tem2 = b.elements;\n    te[0] = tem1[0] - tem2[0];\n    te[1] = tem1[1] - tem2[1];\n    te[2] = tem1[2] - tem2[2];\n    te[3] = tem1[3] - tem2[3];\n    te[4] = tem1[4] - tem2[4];\n    te[5] = tem1[5] - tem2[5];\n    te[6] = tem1[6] - tem2[6];\n    te[7] = tem1[7] - tem2[7];\n    te[8] = tem1[8] - tem2[8];\n    return this;\n  },\n  subEqual: function (m) {\n    var te = this.elements,\n        tem = m.elements;\n    te[0] -= tem[0];\n    te[1] -= tem[1];\n    te[2] -= tem[2];\n    te[3] -= tem[3];\n    te[4] -= tem[4];\n    te[5] -= tem[5];\n    te[6] -= tem[6];\n    te[7] -= tem[7];\n    te[8] -= tem[8];\n    return this;\n  },\n  scale: function (m, s) {\n    var te = this.elements,\n        tm = m.elements;\n    te[0] = tm[0] * s;\n    te[1] = tm[1] * s;\n    te[2] = tm[2] * s;\n    te[3] = tm[3] * s;\n    te[4] = tm[4] * s;\n    te[5] = tm[5] * s;\n    te[6] = tm[6] * s;\n    te[7] = tm[7] * s;\n    te[8] = tm[8] * s;\n    return this;\n  },\n  scaleEqual: function (s) {\n    // multiplyScalar\n    var te = this.elements;\n    te[0] *= s;\n    te[1] *= s;\n    te[2] *= s;\n    te[3] *= s;\n    te[4] *= s;\n    te[5] *= s;\n    te[6] *= s;\n    te[7] *= s;\n    te[8] *= s;\n    return this;\n  },\n  multiplyMatrices: function (m1, m2, transpose) {\n    if (transpose) m2 = m2.clone().transpose();\n    var te = this.elements;\n    var tm1 = m1.elements;\n    var tm2 = m2.elements;\n    var a0 = tm1[0],\n        a3 = tm1[3],\n        a6 = tm1[6];\n    var a1 = tm1[1],\n        a4 = tm1[4],\n        a7 = tm1[7];\n    var a2 = tm1[2],\n        a5 = tm1[5],\n        a8 = tm1[8];\n    var b0 = tm2[0],\n        b3 = tm2[3],\n        b6 = tm2[6];\n    var b1 = tm2[1],\n        b4 = tm2[4],\n        b7 = tm2[7];\n    var b2 = tm2[2],\n        b5 = tm2[5],\n        b8 = tm2[8];\n    te[0] = a0 * b0 + a1 * b3 + a2 * b6;\n    te[1] = a0 * b1 + a1 * b4 + a2 * b7;\n    te[2] = a0 * b2 + a1 * b5 + a2 * b8;\n    te[3] = a3 * b0 + a4 * b3 + a5 * b6;\n    te[4] = a3 * b1 + a4 * b4 + a5 * b7;\n    te[5] = a3 * b2 + a4 * b5 + a5 * b8;\n    te[6] = a6 * b0 + a7 * b3 + a8 * b6;\n    te[7] = a6 * b1 + a7 * b4 + a8 * b7;\n    te[8] = a6 * b2 + a7 * b5 + a8 * b8;\n    return this;\n  },\n\n  /*mul: function ( m1, m2, transpose ) {\r\n        if( transpose ) m2 = m2.clone().transpose();\r\n        var te = this.elements;\r\n      var tm1 = m1.elements;\r\n      var tm2 = m2.elements;\r\n      //var tmp;\r\n        var a0 = tm1[0], a3 = tm1[3], a6 = tm1[6];\r\n      var a1 = tm1[1], a4 = tm1[4], a7 = tm1[7];\r\n      var a2 = tm1[2], a5 = tm1[5], a8 = tm1[8];\r\n        var b0 = tm2[0], b3 = tm2[3], b6 = tm2[6];\r\n      var b1 = tm2[1], b4 = tm2[4], b7 = tm2[7];\r\n      var b2 = tm2[2], b5 = tm2[5], b8 = tm2[8];\r\n        /*if( transpose ){\r\n            tmp = b1; b1 = b3; b3 = tmp;\r\n          tmp = b2; b2 = b6; b6 = tmp;\r\n          tmp = b5; b5 = b7; b7 = tmp;\r\n        }\r\n        te[0] = a0*b0 + a1*b3 + a2*b6;\r\n      te[1] = a0*b1 + a1*b4 + a2*b7;\r\n      te[2] = a0*b2 + a1*b5 + a2*b8;\r\n      te[3] = a3*b0 + a4*b3 + a5*b6;\r\n      te[4] = a3*b1 + a4*b4 + a5*b7;\r\n      te[5] = a3*b2 + a4*b5 + a5*b8;\r\n      te[6] = a6*b0 + a7*b3 + a8*b6;\r\n      te[7] = a6*b1 + a7*b4 + a8*b7;\r\n      te[8] = a6*b2 + a7*b5 + a8*b8;\r\n        return this;\r\n    },*/\n  transpose: function (m) {\n    if (m !== undefined) {\n      var a = m.elements;\n      this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);\n      return this;\n    }\n\n    var te = this.elements;\n    var a01 = te[1],\n        a02 = te[2],\n        a12 = te[5];\n    te[1] = te[3];\n    te[2] = te[6];\n    te[3] = a01;\n    te[5] = te[7];\n    te[6] = a02;\n    te[7] = a12;\n    return this;\n  },\n\n  /*mulScale: function ( m, sx, sy, sz, Prepend ) {\r\n        var prepend = Prepend || false;\r\n      var te = this.elements, tm = m.elements;\r\n      if(prepend){\r\n          te[0] = sx*tm[0]; te[1] = sx*tm[1]; te[2] = sx*tm[2];\r\n          te[3] = sy*tm[3]; te[4] = sy*tm[4]; te[5] = sy*tm[5];\r\n          te[6] = sz*tm[6]; te[7] = sz*tm[7]; te[8] = sz*tm[8];\r\n      }else{\r\n          te[0] = tm[0]*sx; te[1] = tm[1]*sy; te[2] = tm[2]*sz;\r\n          te[3] = tm[3]*sx; te[4] = tm[4]*sy; te[5] = tm[5]*sz;\r\n          te[6] = tm[6]*sx; te[7] = tm[7]*sy; te[8] = tm[8]*sz;\r\n      }\r\n      return this;\r\n    },\r\n    transpose: function ( m ) {\r\n        var te = this.elements, tm = m.elements;\r\n      te[0] = tm[0]; te[1] = tm[3]; te[2] = tm[6];\r\n      te[3] = tm[1]; te[4] = tm[4]; te[5] = tm[7];\r\n      te[6] = tm[2]; te[7] = tm[5]; te[8] = tm[8];\r\n      return this;\r\n    },*/\n  setQuat: function (q) {\n    var te = this.elements;\n    var x = q.x,\n        y = q.y,\n        z = q.z,\n        w = q.w;\n    var x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    var xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    var yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    var wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n    te[0] = 1 - (yy + zz);\n    te[1] = xy - wz;\n    te[2] = xz + wy;\n    te[3] = xy + wz;\n    te[4] = 1 - (xx + zz);\n    te[5] = yz - wx;\n    te[6] = xz - wy;\n    te[7] = yz + wx;\n    te[8] = 1 - (xx + yy);\n    return this;\n  },\n  invert: function (m) {\n    var te = this.elements,\n        tm = m.elements,\n        a00 = tm[0],\n        a10 = tm[3],\n        a20 = tm[6],\n        a01 = tm[1],\n        a11 = tm[4],\n        a21 = tm[7],\n        a02 = tm[2],\n        a12 = tm[5],\n        a22 = tm[8],\n        b01 = a22 * a11 - a12 * a21,\n        b11 = -a22 * a10 + a12 * a20,\n        b21 = a21 * a10 - a11 * a20,\n        det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (det === 0) {\n      console.log(\"can't invert matrix, determinant is 0\");\n      return this.identity();\n    }\n\n    det = 1.0 / det;\n    te[0] = b01 * det;\n    te[1] = (-a22 * a01 + a02 * a21) * det;\n    te[2] = (a12 * a01 - a02 * a11) * det;\n    te[3] = b11 * det;\n    te[4] = (a22 * a00 - a02 * a20) * det;\n    te[5] = (-a12 * a00 + a02 * a10) * det;\n    te[6] = b21 * det;\n    te[7] = (-a21 * a00 + a01 * a20) * det;\n    te[8] = (a11 * a00 - a01 * a10) * det;\n    return this;\n  },\n  addOffset: function (m, v) {\n    var relX = v.x;\n    var relY = v.y;\n    var relZ = v.z;\n    var te = this.elements;\n    te[0] += m * (relY * relY + relZ * relZ);\n    te[4] += m * (relX * relX + relZ * relZ);\n    te[8] += m * (relX * relX + relY * relY);\n    var xy = m * relX * relY;\n    var yz = m * relY * relZ;\n    var zx = m * relZ * relX;\n    te[1] -= xy;\n    te[3] -= xy;\n    te[2] -= yz;\n    te[6] -= yz;\n    te[5] -= zx;\n    te[7] -= zx;\n    return this;\n  },\n  subOffset: function (m, v) {\n    var relX = v.x;\n    var relY = v.y;\n    var relZ = v.z;\n    var te = this.elements;\n    te[0] -= m * (relY * relY + relZ * relZ);\n    te[4] -= m * (relX * relX + relZ * relZ);\n    te[8] -= m * (relX * relX + relY * relY);\n    var xy = m * relX * relY;\n    var yz = m * relY * relZ;\n    var zx = m * relZ * relX;\n    te[1] += xy;\n    te[3] += xy;\n    te[2] += yz;\n    te[6] += yz;\n    te[5] += zx;\n    te[7] += zx;\n    return this;\n  },\n  // OK \n  multiplyScalar: function (s) {\n    var te = this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n    return this;\n  },\n  identity: function () {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    return this;\n  },\n  clone: function () {\n    return new Mat33().fromArray(this.elements);\n  },\n  copy: function (m) {\n    for (var i = 0; i < 9; i++) this.elements[i] = m.elements[i];\n\n    return this;\n  },\n  determinant: function () {\n    var te = this.elements;\n    var a = te[0],\n        b = te[1],\n        c = te[2],\n        d = te[3],\n        e = te[4],\n        f = te[5],\n        g = te[6],\n        h = te[7],\n        i = te[8];\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  },\n  fromArray: function (array, offset) {\n    if (offset === undefined) offset = 0;\n\n    for (var i = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n\n    return this;\n  },\n  toArray: function (array, offset) {\n    if (array === undefined) array = [];\n    if (offset === undefined) offset = 0;\n    var te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n});\n/**\r\n * An axis-aligned bounding box.\r\n *\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction AABB(minX, maxX, minY, maxY, minZ, maxZ) {\n  this.elements = new Float32Array(6);\n  var te = this.elements;\n  te[0] = minX || 0;\n  te[1] = minY || 0;\n  te[2] = minZ || 0;\n  te[3] = maxX || 0;\n  te[4] = maxY || 0;\n  te[5] = maxZ || 0;\n}\n\nObject.assign(AABB.prototype, {\n  AABB: true,\n  set: function (minX, maxX, minY, maxY, minZ, maxZ) {\n    var te = this.elements;\n    te[0] = minX;\n    te[3] = maxX;\n    te[1] = minY;\n    te[4] = maxY;\n    te[2] = minZ;\n    te[5] = maxZ;\n    return this;\n  },\n  intersectTest: function (aabb) {\n    var te = this.elements;\n    var ue = aabb.elements;\n    return te[0] > ue[3] || te[1] > ue[4] || te[2] > ue[5] || te[3] < ue[0] || te[4] < ue[1] || te[5] < ue[2] ? true : false;\n  },\n  intersectTestTwo: function (aabb) {\n    var te = this.elements;\n    var ue = aabb.elements;\n    return te[0] < ue[0] || te[1] < ue[1] || te[2] < ue[2] || te[3] > ue[3] || te[4] > ue[4] || te[5] > ue[5] ? true : false;\n  },\n  clone: function () {\n    return new this.constructor().fromArray(this.elements);\n  },\n  copy: function (aabb, margin) {\n    var m = margin || 0;\n    var me = aabb.elements;\n    this.set(me[0] - m, me[3] + m, me[1] - m, me[4] + m, me[2] - m, me[5] + m);\n    return this;\n  },\n  fromArray: function (array) {\n    this.elements.set(array);\n    return this;\n  },\n  // Set this AABB to the combined AABB of aabb1 and aabb2.\n  combine: function (aabb1, aabb2) {\n    var a = aabb1.elements;\n    var b = aabb2.elements;\n    var te = this.elements;\n    te[0] = a[0] < b[0] ? a[0] : b[0];\n    te[1] = a[1] < b[1] ? a[1] : b[1];\n    te[2] = a[2] < b[2] ? a[2] : b[2];\n    te[3] = a[3] > b[3] ? a[3] : b[3];\n    te[4] = a[4] > b[4] ? a[4] : b[4];\n    te[5] = a[5] > b[5] ? a[5] : b[5];\n    return this;\n  },\n  // Get the surface area.\n  surfaceArea: function () {\n    var te = this.elements;\n    var a = te[3] - te[0];\n    var h = te[4] - te[1];\n    var d = te[5] - te[2];\n    return 2 * (a * (h + d) + h * d);\n  },\n  // Get whether the AABB intersects with the point or not.\n  intersectsWithPoint: function (x, y, z) {\n    var te = this.elements;\n    return x >= te[0] && x <= te[3] && y >= te[1] && y <= te[4] && z >= te[2] && z <= te[5];\n  },\n\n  /**\r\n   * Set the AABB from an array\r\n   * of vertices. From THREE.\r\n   * @author WestLangley\r\n   * @author xprogram\r\n   */\n  setFromPoints: function (arr) {\n    this.makeEmpty();\n\n    for (var i = 0; i < arr.length; i++) {\n      this.expandByPoint(arr[i]);\n    }\n  },\n  makeEmpty: function () {\n    this.set(-Infinity, -Infinity, -Infinity, Infinity, Infinity, Infinity);\n  },\n  expandByPoint: function (pt) {\n    var te = this.elements;\n    this.set(_Math.min(te[0], pt.x), _Math.min(te[1], pt.y), _Math.min(te[2], pt.z), _Math.max(te[3], pt.x), _Math.max(te[4], pt.y), _Math.max(te[5], pt.z));\n  },\n  expandByScalar: function (s) {\n    var te = this.elements;\n    te[0] += -s;\n    te[1] += -s;\n    te[2] += -s;\n    te[3] += s;\n    te[4] += s;\n    te[5] += s;\n  }\n});\nvar count = 0;\n\nfunction ShapeIdCount() {\n  return count++;\n}\n/**\r\n * A shape is used to detect collisions of rigid bodies.\r\n *\r\n * @author saharan\r\n * @author lo-th\r\n */\n\n\nfunction Shape(config) {\n  this.type = SHAPE_NULL; // global identification of the shape should be unique to the shape.\n\n  this.id = ShapeIdCount(); // previous shape in parent rigid body. Used for fast interations.\n\n  this.prev = null; // next shape in parent rigid body. Used for fast interations.\n\n  this.next = null; // proxy of the shape used for broad-phase collision detection.\n\n  this.proxy = null; // parent rigid body of the shape.\n\n  this.parent = null; // linked list of the contacts with the shape.\n\n  this.contactLink = null; // number of the contacts with the shape.\n\n  this.numContacts = 0; // center of gravity of the shape in world coordinate system.\n\n  this.position = new Vec3(); // rotation matrix of the shape in world coordinate system.\n\n  this.rotation = new Mat33(); // position of the shape in parent's coordinate system.\n\n  this.relativePosition = new Vec3().copy(config.relativePosition); // rotation matrix of the shape in parent's coordinate system.\n\n  this.relativeRotation = new Mat33().copy(config.relativeRotation); // axis-aligned bounding box of the shape.\n\n  this.aabb = new AABB(); // density of the shape.\n\n  this.density = config.density; // coefficient of friction of the shape.\n\n  this.friction = config.friction; // coefficient of restitution of the shape.\n\n  this.restitution = config.restitution; // bits of the collision groups to which the shape belongs.\n\n  this.belongsTo = config.belongsTo; // bits of the collision groups with which the shape collides.\n\n  this.collidesWith = config.collidesWith;\n}\n\nObject.assign(Shape.prototype, {\n  Shape: true,\n  // Calculate the mass information of the shape.\n  calculateMassInfo: function (out) {\n    printError(\"Shape\", \"Inheritance error.\");\n  },\n  // Update the proxy of the shape.\n  updateProxy: function () {\n    printError(\"Shape\", \"Inheritance error.\");\n  }\n});\n/**\r\n * Box shape.\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction Box(config, Width, Height, Depth) {\n  Shape.call(this, config);\n  this.type = SHAPE_BOX;\n  this.width = Width;\n  this.height = Height;\n  this.depth = Depth;\n  this.halfWidth = Width * 0.5;\n  this.halfHeight = Height * 0.5;\n  this.halfDepth = Depth * 0.5;\n  this.dimentions = new Float32Array(18);\n  this.elements = new Float32Array(24);\n}\n\nBox.prototype = Object.assign(Object.create(Shape.prototype), {\n  constructor: Box,\n  calculateMassInfo: function (out) {\n    var mass = this.width * this.height * this.depth * this.density;\n    var divid = 1 / 12;\n    out.mass = mass;\n    out.inertia.set(mass * (this.height * this.height + this.depth * this.depth) * divid, 0, 0, 0, mass * (this.width * this.width + this.depth * this.depth) * divid, 0, 0, 0, mass * (this.width * this.width + this.height * this.height) * divid);\n  },\n  updateProxy: function () {\n    var te = this.rotation.elements;\n    var di = this.dimentions; // Width\n\n    di[0] = te[0];\n    di[1] = te[3];\n    di[2] = te[6]; // Height\n\n    di[3] = te[1];\n    di[4] = te[4];\n    di[5] = te[7]; // Depth\n\n    di[6] = te[2];\n    di[7] = te[5];\n    di[8] = te[8]; // half Width\n\n    di[9] = te[0] * this.halfWidth;\n    di[10] = te[3] * this.halfWidth;\n    di[11] = te[6] * this.halfWidth; // half Height\n\n    di[12] = te[1] * this.halfHeight;\n    di[13] = te[4] * this.halfHeight;\n    di[14] = te[7] * this.halfHeight; // half Depth\n\n    di[15] = te[2] * this.halfDepth;\n    di[16] = te[5] * this.halfDepth;\n    di[17] = te[8] * this.halfDepth;\n    var wx = di[9];\n    var wy = di[10];\n    var wz = di[11];\n    var hx = di[12];\n    var hy = di[13];\n    var hz = di[14];\n    var dx = di[15];\n    var dy = di[16];\n    var dz = di[17];\n    var x = this.position.x;\n    var y = this.position.y;\n    var z = this.position.z;\n    var v = this.elements; //v1\n\n    v[0] = x + wx + hx + dx;\n    v[1] = y + wy + hy + dy;\n    v[2] = z + wz + hz + dz; //v2\n\n    v[3] = x + wx + hx - dx;\n    v[4] = y + wy + hy - dy;\n    v[5] = z + wz + hz - dz; //v3\n\n    v[6] = x + wx - hx + dx;\n    v[7] = y + wy - hy + dy;\n    v[8] = z + wz - hz + dz; //v4\n\n    v[9] = x + wx - hx - dx;\n    v[10] = y + wy - hy - dy;\n    v[11] = z + wz - hz - dz; //v5\n\n    v[12] = x - wx + hx + dx;\n    v[13] = y - wy + hy + dy;\n    v[14] = z - wz + hz + dz; //v6\n\n    v[15] = x - wx + hx - dx;\n    v[16] = y - wy + hy - dy;\n    v[17] = z - wz + hz - dz; //v7\n\n    v[18] = x - wx - hx + dx;\n    v[19] = y - wy - hy + dy;\n    v[20] = z - wz - hz + dz; //v8\n\n    v[21] = x - wx - hx - dx;\n    v[22] = y - wy - hy - dy;\n    v[23] = z - wz - hz - dz;\n    var w = di[9] < 0 ? -di[9] : di[9];\n    var h = di[10] < 0 ? -di[10] : di[10];\n    var d = di[11] < 0 ? -di[11] : di[11];\n    w = di[12] < 0 ? w - di[12] : w + di[12];\n    h = di[13] < 0 ? h - di[13] : h + di[13];\n    d = di[14] < 0 ? d - di[14] : d + di[14];\n    w = di[15] < 0 ? w - di[15] : w + di[15];\n    h = di[16] < 0 ? h - di[16] : h + di[16];\n    d = di[17] < 0 ? d - di[17] : d + di[17];\n    var p = AABB_PROX;\n    this.aabb.set(this.position.x - w - p, this.position.x + w + p, this.position.y - h - p, this.position.y + h + p, this.position.z - d - p, this.position.z + d + p);\n    if (this.proxy != null) this.proxy.update();\n  }\n});\n/**\r\n * Sphere shape\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction Sphere(config, radius) {\n  Shape.call(this, config);\n  this.type = SHAPE_SPHERE; // radius of the shape.\n\n  this.radius = radius;\n}\n\nSphere.prototype = Object.assign(Object.create(Shape.prototype), {\n  constructor: Sphere,\n  volume: function () {\n    return _Math.PI * this.radius * 1.333333;\n  },\n  calculateMassInfo: function (out) {\n    var mass = this.volume() * this.radius * this.radius * this.density; //1.333 * _Math.PI * this.radius * this.radius * this.radius * this.density;\n\n    out.mass = mass;\n    var inertia = mass * this.radius * this.radius * 0.4;\n    out.inertia.set(inertia, 0, 0, 0, inertia, 0, 0, 0, inertia);\n  },\n  updateProxy: function () {\n    var p = AABB_PROX;\n    this.aabb.set(this.position.x - this.radius - p, this.position.x + this.radius + p, this.position.y - this.radius - p, this.position.y + this.radius + p, this.position.z - this.radius - p, this.position.z + this.radius + p);\n    if (this.proxy != null) this.proxy.update();\n  }\n});\n/**\r\n * Cylinder shape\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction Cylinder(config, radius, height) {\n  Shape.call(this, config);\n  this.type = SHAPE_CYLINDER;\n  this.radius = radius;\n  this.height = height;\n  this.halfHeight = height * 0.5;\n  this.normalDirection = new Vec3();\n  this.halfDirection = new Vec3();\n}\n\nCylinder.prototype = Object.assign(Object.create(Shape.prototype), {\n  constructor: Cylinder,\n  calculateMassInfo: function (out) {\n    var rsq = this.radius * this.radius;\n    var mass = _Math.PI * rsq * this.height * this.density;\n    var inertiaXZ = (0.25 * rsq + 0.0833 * this.height * this.height) * mass;\n    var inertiaY = 0.5 * rsq;\n    out.mass = mass;\n    out.inertia.set(inertiaXZ, 0, 0, 0, inertiaY, 0, 0, 0, inertiaXZ);\n  },\n  updateProxy: function () {\n    var te = this.rotation.elements;\n    var len, wx, hy, dz, xx, yy, zz, w, h, d, p;\n    xx = te[1] * te[1];\n    yy = te[4] * te[4];\n    zz = te[7] * te[7];\n    this.normalDirection.set(te[1], te[4], te[7]);\n    this.halfDirection.scale(this.normalDirection, this.halfHeight);\n    wx = 1 - xx;\n    len = _Math.sqrt(wx * wx + xx * yy + xx * zz);\n    if (len > 0) len = this.radius / len;\n    wx *= len;\n    hy = 1 - yy;\n    len = _Math.sqrt(yy * xx + hy * hy + yy * zz);\n    if (len > 0) len = this.radius / len;\n    hy *= len;\n    dz = 1 - zz;\n    len = _Math.sqrt(zz * xx + zz * yy + dz * dz);\n    if (len > 0) len = this.radius / len;\n    dz *= len;\n    w = this.halfDirection.x < 0 ? -this.halfDirection.x : this.halfDirection.x;\n    h = this.halfDirection.y < 0 ? -this.halfDirection.y : this.halfDirection.y;\n    d = this.halfDirection.z < 0 ? -this.halfDirection.z : this.halfDirection.z;\n    w = wx < 0 ? w - wx : w + wx;\n    h = hy < 0 ? h - hy : h + hy;\n    d = dz < 0 ? d - dz : d + dz;\n    p = AABB_PROX;\n    this.aabb.set(this.position.x - w - p, this.position.x + w + p, this.position.y - h - p, this.position.y + h + p, this.position.z - d - p, this.position.z + d + p);\n    if (this.proxy != null) this.proxy.update();\n  }\n});\n/**\r\n * Plane shape.\r\n * @author lo-th\r\n */\n\nfunction Plane(config, normal) {\n  Shape.call(this, config);\n  this.type = SHAPE_PLANE; // radius of the shape.\n\n  this.normal = new Vec3(0, 1, 0);\n}\n\nPlane.prototype = Object.assign(Object.create(Shape.prototype), {\n  constructor: Plane,\n  volume: function () {\n    return Number.MAX_VALUE;\n  },\n  calculateMassInfo: function (out) {\n    out.mass = this.density; //0.0001;\n\n    var inertia = 1;\n    out.inertia.set(inertia, 0, 0, 0, inertia, 0, 0, 0, inertia);\n  },\n  updateProxy: function () {\n    var p = AABB_PROX;\n    var min = -_Math.INF;\n    var max = _Math.INF;\n    var n = this.normal; // The plane AABB is infinite, except if the normal is pointing along any axis\n\n    this.aabb.set(n.x === -1 ? this.position.x - p : min, n.x === 1 ? this.position.x + p : max, n.y === -1 ? this.position.y - p : min, n.y === 1 ? this.position.y + p : max, n.z === -1 ? this.position.z - p : min, n.z === 1 ? this.position.z + p : max);\n    if (this.proxy != null) this.proxy.update();\n  }\n});\n/**\r\n * A Particule shape\r\n * @author lo-th\r\n */\n\nfunction Particle(config, normal) {\n  Shape.call(this, config);\n  this.type = SHAPE_PARTICLE;\n}\n\nParticle.prototype = Object.assign(Object.create(Shape.prototype), {\n  constructor: Particle,\n  volume: function () {\n    return Number.MAX_VALUE;\n  },\n  calculateMassInfo: function (out) {\n    var inertia = 0;\n    out.inertia.set(inertia, 0, 0, 0, inertia, 0, 0, 0, inertia);\n  },\n  updateProxy: function () {\n    var p = 0; //AABB_PROX;\n\n    this.aabb.set(this.position.x - p, this.position.x + p, this.position.y - p, this.position.y + p, this.position.z - p, this.position.z + p);\n    if (this.proxy != null) this.proxy.update();\n  }\n});\n/**\r\n * A shape configuration holds common configuration data for constructing a shape.\r\n * These configurations can be reused safely.\r\n *\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction ShapeConfig() {\n  // position of the shape in parent's coordinate system.\n  this.relativePosition = new Vec3(); // rotation matrix of the shape in parent's coordinate system.\n\n  this.relativeRotation = new Mat33(); // coefficient of friction of the shape.\n\n  this.friction = 0.2; // 0.4\n  // coefficient of restitution of the shape.\n\n  this.restitution = 0.2; // density of the shape.\n\n  this.density = 1; // bits of the collision groups to which the shape belongs.\n\n  this.belongsTo = 1; // bits of the collision groups with which the shape collides.\n\n  this.collidesWith = 0xffffffff;\n}\n/**\n* An information of limit and motor.\n*\n* @author saharan\n*/\n\n\nfunction LimitMotor(axis, fixed) {\n  fixed = fixed || false; // The axis of the constraint.\n\n  this.axis = axis; // The current angle for rotational constraints.\n\n  this.angle = 0; // The lower limit. Set lower > upper to disable\n\n  this.lowerLimit = fixed ? 0 : 1; //  The upper limit. Set lower > upper to disable.\n\n  this.upperLimit = 0; // The target motor speed.\n\n  this.motorSpeed = 0; // The maximum motor force or torque. Set 0 to disable.\n\n  this.maxMotorForce = 0; // The frequency of the spring. Set 0 to disable.\n\n  this.frequency = 0; // The damping ratio of the spring. Set 0 for no damping, 1 for critical damping.\n\n  this.dampingRatio = 0;\n}\n\nObject.assign(LimitMotor.prototype, {\n  LimitMotor: true,\n  // Set limit data into this constraint.\n  setLimit: function (lowerLimit, upperLimit) {\n    this.lowerLimit = lowerLimit;\n    this.upperLimit = upperLimit;\n  },\n  // Set motor data into this constraint.\n  setMotor: function (motorSpeed, maxMotorForce) {\n    this.motorSpeed = motorSpeed;\n    this.maxMotorForce = maxMotorForce;\n  },\n  // Set spring data into this constraint.\n  setSpring: function (frequency, dampingRatio) {\n    this.frequency = frequency;\n    this.dampingRatio = dampingRatio;\n  }\n});\n/**\r\n * The base class of all type of the constraints.\r\n *\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction Constraint() {\n  // parent world of the constraint.\n  this.parent = null; // first body of the constraint.\n\n  this.body1 = null; // second body of the constraint.\n\n  this.body2 = null; // Internal\n\n  this.addedToIsland = false;\n}\n\nObject.assign(Constraint.prototype, {\n  Constraint: true,\n  // Prepare for solving the constraint\n  preSolve: function (timeStep, invTimeStep) {\n    printError(\"Constraint\", \"Inheritance error.\");\n  },\n  // Solve the constraint. This is usually called iteratively.\n  solve: function () {\n    printError(\"Constraint\", \"Inheritance error.\");\n  },\n  // Do the post-processing.\n  postSolve: function () {\n    printError(\"Constraint\", \"Inheritance error.\");\n  }\n});\n\nfunction JointLink(joint) {\n  // The previous joint link.\n  this.prev = null; // The next joint link.\n\n  this.next = null; // The other rigid body connected to the joint.\n\n  this.body = null; // The joint of the link.\n\n  this.joint = joint;\n}\n/**\n * Joints are used to constrain the motion between two rigid bodies.\n *\n * @author saharan\n * @author lo-th\n */\n\n\nfunction Joint(config) {\n  Constraint.call(this);\n  this.scale = 1;\n  this.invScale = 1; // joint name\n\n  this.name = \"\";\n  this.id = NaN; // The type of the joint.\n\n  this.type = JOINT_NULL; //  The previous joint in the world.\n\n  this.prev = null; // The next joint in the world.\n\n  this.next = null;\n  this.body1 = config.body1;\n  this.body2 = config.body2; // anchor point on the first rigid body in local coordinate system.\n\n  this.localAnchorPoint1 = new Vec3().copy(config.localAnchorPoint1); // anchor point on the second rigid body in local coordinate system.\n\n  this.localAnchorPoint2 = new Vec3().copy(config.localAnchorPoint2); // anchor point on the first rigid body in world coordinate system relative to the body's origin.\n\n  this.relativeAnchorPoint1 = new Vec3(); // anchor point on the second rigid body in world coordinate system relative to the body's origin.\n\n  this.relativeAnchorPoint2 = new Vec3(); //  anchor point on the first rigid body in world coordinate system.\n\n  this.anchorPoint1 = new Vec3(); // anchor point on the second rigid body in world coordinate system.\n\n  this.anchorPoint2 = new Vec3(); // Whether allow collision between connected rigid bodies or not.\n\n  this.allowCollision = config.allowCollision;\n  this.b1Link = new JointLink(this);\n  this.b2Link = new JointLink(this);\n}\n\nJoint.prototype = Object.assign(Object.create(Constraint.prototype), {\n  constructor: Joint,\n  setId: function (n) {\n    this.id = i;\n  },\n  setParent: function (world) {\n    this.parent = world;\n    this.scale = this.parent.scale;\n    this.invScale = this.parent.invScale;\n    this.id = this.parent.numJoints;\n    if (!this.name) this.name = 'J' + this.id;\n  },\n  // Update all the anchor points.\n  updateAnchorPoints: function () {\n    this.relativeAnchorPoint1.copy(this.localAnchorPoint1).applyMatrix3(this.body1.rotation, true);\n    this.relativeAnchorPoint2.copy(this.localAnchorPoint2).applyMatrix3(this.body2.rotation, true);\n    this.anchorPoint1.add(this.relativeAnchorPoint1, this.body1.position);\n    this.anchorPoint2.add(this.relativeAnchorPoint2, this.body2.position);\n  },\n  // Attach the joint from the bodies.\n  attach: function (isX) {\n    this.b1Link.body = this.body2;\n    this.b2Link.body = this.body1;\n\n    if (isX) {\n      this.body1.jointLink.push(this.b1Link);\n      this.body2.jointLink.push(this.b2Link);\n    } else {\n      if (this.body1.jointLink != null) (this.b1Link.next = this.body1.jointLink).prev = this.b1Link;else this.b1Link.next = null;\n      this.body1.jointLink = this.b1Link;\n      this.body1.numJoints++;\n      if (this.body2.jointLink != null) (this.b2Link.next = this.body2.jointLink).prev = this.b2Link;else this.b2Link.next = null;\n      this.body2.jointLink = this.b2Link;\n      this.body2.numJoints++;\n    }\n  },\n  // Detach the joint from the bodies.\n  detach: function (isX) {\n    if (isX) {\n      this.body1.jointLink.splice(this.body1.jointLink.indexOf(this.b1Link), 1);\n      this.body2.jointLink.splice(this.body2.jointLink.indexOf(this.b2Link), 1);\n    } else {\n      var prev = this.b1Link.prev;\n      var next = this.b1Link.next;\n      if (prev != null) prev.next = next;\n      if (next != null) next.prev = prev;\n      if (this.body1.jointLink == this.b1Link) this.body1.jointLink = next;\n      this.b1Link.prev = null;\n      this.b1Link.next = null;\n      this.b1Link.body = null;\n      this.body1.numJoints--;\n      prev = this.b2Link.prev;\n      next = this.b2Link.next;\n      if (prev != null) prev.next = next;\n      if (next != null) next.prev = prev;\n      if (this.body2.jointLink == this.b2Link) this.body2.jointLink = next;\n      this.b2Link.prev = null;\n      this.b2Link.next = null;\n      this.b2Link.body = null;\n      this.body2.numJoints--;\n    }\n\n    this.b1Link.body = null;\n    this.b2Link.body = null;\n  },\n  // Awake the bodies.\n  awake: function () {\n    this.body1.awake();\n    this.body2.awake();\n  },\n  // calculation function\n  preSolve: function (timeStep, invTimeStep) {},\n  solve: function () {},\n  postSolve: function () {},\n  // Delete process\n  remove: function () {\n    this.dispose();\n  },\n  dispose: function () {\n    this.parent.removeJoint(this);\n  },\n  // Three js add\n  getPosition: function () {\n    var p1 = new Vec3().scale(this.anchorPoint1, this.scale);\n    var p2 = new Vec3().scale(this.anchorPoint2, this.scale);\n    return [p1, p2];\n  }\n});\n/**\n* A linear constraint for all axes for various joints.\n* @author saharan\n*/\n\nfunction LinearConstraint(joint) {\n  this.m1 = NaN;\n  this.m2 = NaN;\n  this.ii1 = null;\n  this.ii2 = null;\n  this.dd = null;\n  this.r1x = NaN;\n  this.r1y = NaN;\n  this.r1z = NaN;\n  this.r2x = NaN;\n  this.r2y = NaN;\n  this.r2z = NaN;\n  this.ax1x = NaN;\n  this.ax1y = NaN;\n  this.ax1z = NaN;\n  this.ay1x = NaN;\n  this.ay1y = NaN;\n  this.ay1z = NaN;\n  this.az1x = NaN;\n  this.az1y = NaN;\n  this.az1z = NaN;\n  this.ax2x = NaN;\n  this.ax2y = NaN;\n  this.ax2z = NaN;\n  this.ay2x = NaN;\n  this.ay2y = NaN;\n  this.ay2z = NaN;\n  this.az2x = NaN;\n  this.az2y = NaN;\n  this.az2z = NaN;\n  this.vel = NaN;\n  this.velx = NaN;\n  this.vely = NaN;\n  this.velz = NaN;\n  this.joint = joint;\n  this.r1 = joint.relativeAnchorPoint1;\n  this.r2 = joint.relativeAnchorPoint2;\n  this.p1 = joint.anchorPoint1;\n  this.p2 = joint.anchorPoint2;\n  this.b1 = joint.body1;\n  this.b2 = joint.body2;\n  this.l1 = this.b1.linearVelocity;\n  this.l2 = this.b2.linearVelocity;\n  this.a1 = this.b1.angularVelocity;\n  this.a2 = this.b2.angularVelocity;\n  this.i1 = this.b1.inverseInertia;\n  this.i2 = this.b2.inverseInertia;\n  this.impx = 0;\n  this.impy = 0;\n  this.impz = 0;\n}\n\nObject.assign(LinearConstraint.prototype, {\n  LinearConstraint: true,\n  preSolve: function (timeStep, invTimeStep) {\n    this.r1x = this.r1.x;\n    this.r1y = this.r1.y;\n    this.r1z = this.r1.z;\n    this.r2x = this.r2.x;\n    this.r2y = this.r2.y;\n    this.r2z = this.r2.z;\n    this.m1 = this.b1.inverseMass;\n    this.m2 = this.b2.inverseMass;\n    this.ii1 = this.i1.clone();\n    this.ii2 = this.i2.clone();\n    var ii1 = this.ii1.elements;\n    var ii2 = this.ii2.elements;\n    this.ax1x = this.r1z * ii1[1] + -this.r1y * ii1[2];\n    this.ax1y = this.r1z * ii1[4] + -this.r1y * ii1[5];\n    this.ax1z = this.r1z * ii1[7] + -this.r1y * ii1[8];\n    this.ay1x = -this.r1z * ii1[0] + this.r1x * ii1[2];\n    this.ay1y = -this.r1z * ii1[3] + this.r1x * ii1[5];\n    this.ay1z = -this.r1z * ii1[6] + this.r1x * ii1[8];\n    this.az1x = this.r1y * ii1[0] + -this.r1x * ii1[1];\n    this.az1y = this.r1y * ii1[3] + -this.r1x * ii1[4];\n    this.az1z = this.r1y * ii1[6] + -this.r1x * ii1[7];\n    this.ax2x = this.r2z * ii2[1] + -this.r2y * ii2[2];\n    this.ax2y = this.r2z * ii2[4] + -this.r2y * ii2[5];\n    this.ax2z = this.r2z * ii2[7] + -this.r2y * ii2[8];\n    this.ay2x = -this.r2z * ii2[0] + this.r2x * ii2[2];\n    this.ay2y = -this.r2z * ii2[3] + this.r2x * ii2[5];\n    this.ay2z = -this.r2z * ii2[6] + this.r2x * ii2[8];\n    this.az2x = this.r2y * ii2[0] + -this.r2x * ii2[1];\n    this.az2y = this.r2y * ii2[3] + -this.r2x * ii2[4];\n    this.az2z = this.r2y * ii2[6] + -this.r2x * ii2[7]; // calculate point-to-point mass matrix\n    // from impulse equation\n    // \n    // M = ([/m] - [r^][/I][r^]) ^ -1\n    // \n    // where\n    // \n    // [/m] = |1/m, 0, 0|\n    //        |0, 1/m, 0|\n    //        |0, 0, 1/m|\n    // \n    // [r^] = |0, -rz, ry|\n    //        |rz, 0, -rx|\n    //        |-ry, rx, 0|\n    // \n    // [/I] = Inverted moment inertia\n\n    var rxx = this.m1 + this.m2;\n    var kk = new Mat33().set(rxx, 0, 0, 0, rxx, 0, 0, 0, rxx);\n    var k = kk.elements;\n    k[0] += ii1[4] * this.r1z * this.r1z - (ii1[7] + ii1[5]) * this.r1y * this.r1z + ii1[8] * this.r1y * this.r1y;\n    k[1] += (ii1[6] * this.r1y + ii1[5] * this.r1x) * this.r1z - ii1[3] * this.r1z * this.r1z - ii1[8] * this.r1x * this.r1y;\n    k[2] += (ii1[3] * this.r1y - ii1[4] * this.r1x) * this.r1z - ii1[6] * this.r1y * this.r1y + ii1[7] * this.r1x * this.r1y;\n    k[3] += (ii1[2] * this.r1y + ii1[7] * this.r1x) * this.r1z - ii1[1] * this.r1z * this.r1z - ii1[8] * this.r1x * this.r1y;\n    k[4] += ii1[0] * this.r1z * this.r1z - (ii1[6] + ii1[2]) * this.r1x * this.r1z + ii1[8] * this.r1x * this.r1x;\n    k[5] += (ii1[1] * this.r1x - ii1[0] * this.r1y) * this.r1z - ii1[7] * this.r1x * this.r1x + ii1[6] * this.r1x * this.r1y;\n    k[6] += (ii1[1] * this.r1y - ii1[4] * this.r1x) * this.r1z - ii1[2] * this.r1y * this.r1y + ii1[5] * this.r1x * this.r1y;\n    k[7] += (ii1[3] * this.r1x - ii1[0] * this.r1y) * this.r1z - ii1[5] * this.r1x * this.r1x + ii1[2] * this.r1x * this.r1y;\n    k[8] += ii1[0] * this.r1y * this.r1y - (ii1[3] + ii1[1]) * this.r1x * this.r1y + ii1[4] * this.r1x * this.r1x;\n    k[0] += ii2[4] * this.r2z * this.r2z - (ii2[7] + ii2[5]) * this.r2y * this.r2z + ii2[8] * this.r2y * this.r2y;\n    k[1] += (ii2[6] * this.r2y + ii2[5] * this.r2x) * this.r2z - ii2[3] * this.r2z * this.r2z - ii2[8] * this.r2x * this.r2y;\n    k[2] += (ii2[3] * this.r2y - ii2[4] * this.r2x) * this.r2z - ii2[6] * this.r2y * this.r2y + ii2[7] * this.r2x * this.r2y;\n    k[3] += (ii2[2] * this.r2y + ii2[7] * this.r2x) * this.r2z - ii2[1] * this.r2z * this.r2z - ii2[8] * this.r2x * this.r2y;\n    k[4] += ii2[0] * this.r2z * this.r2z - (ii2[6] + ii2[2]) * this.r2x * this.r2z + ii2[8] * this.r2x * this.r2x;\n    k[5] += (ii2[1] * this.r2x - ii2[0] * this.r2y) * this.r2z - ii2[7] * this.r2x * this.r2x + ii2[6] * this.r2x * this.r2y;\n    k[6] += (ii2[1] * this.r2y - ii2[4] * this.r2x) * this.r2z - ii2[2] * this.r2y * this.r2y + ii2[5] * this.r2x * this.r2y;\n    k[7] += (ii2[3] * this.r2x - ii2[0] * this.r2y) * this.r2z - ii2[5] * this.r2x * this.r2x + ii2[2] * this.r2x * this.r2y;\n    k[8] += ii2[0] * this.r2y * this.r2y - (ii2[3] + ii2[1]) * this.r2x * this.r2y + ii2[4] * this.r2x * this.r2x;\n    var inv = 1 / (k[0] * (k[4] * k[8] - k[7] * k[5]) + k[3] * (k[7] * k[2] - k[1] * k[8]) + k[6] * (k[1] * k[5] - k[4] * k[2]));\n    this.dd = new Mat33().set(k[4] * k[8] - k[5] * k[7], k[2] * k[7] - k[1] * k[8], k[1] * k[5] - k[2] * k[4], k[5] * k[6] - k[3] * k[8], k[0] * k[8] - k[2] * k[6], k[2] * k[3] - k[0] * k[5], k[3] * k[7] - k[4] * k[6], k[1] * k[6] - k[0] * k[7], k[0] * k[4] - k[1] * k[3]).scaleEqual(inv);\n    this.velx = this.p2.x - this.p1.x;\n    this.vely = this.p2.y - this.p1.y;\n    this.velz = this.p2.z - this.p1.z;\n\n    var len = _Math.sqrt(this.velx * this.velx + this.vely * this.vely + this.velz * this.velz);\n\n    if (len > 0.005) {\n      len = (0.005 - len) / len * invTimeStep * 0.05;\n      this.velx *= len;\n      this.vely *= len;\n      this.velz *= len;\n    } else {\n      this.velx = 0;\n      this.vely = 0;\n      this.velz = 0;\n    }\n\n    this.impx *= 0.95;\n    this.impy *= 0.95;\n    this.impz *= 0.95;\n    this.l1.x += this.impx * this.m1;\n    this.l1.y += this.impy * this.m1;\n    this.l1.z += this.impz * this.m1;\n    this.a1.x += this.impx * this.ax1x + this.impy * this.ay1x + this.impz * this.az1x;\n    this.a1.y += this.impx * this.ax1y + this.impy * this.ay1y + this.impz * this.az1y;\n    this.a1.z += this.impx * this.ax1z + this.impy * this.ay1z + this.impz * this.az1z;\n    this.l2.x -= this.impx * this.m2;\n    this.l2.y -= this.impy * this.m2;\n    this.l2.z -= this.impz * this.m2;\n    this.a2.x -= this.impx * this.ax2x + this.impy * this.ay2x + this.impz * this.az2x;\n    this.a2.y -= this.impx * this.ax2y + this.impy * this.ay2y + this.impz * this.az2y;\n    this.a2.z -= this.impx * this.ax2z + this.impy * this.ay2z + this.impz * this.az2z;\n  },\n  solve: function () {\n    var d = this.dd.elements;\n    var rvx = this.l2.x - this.l1.x + this.a2.y * this.r2z - this.a2.z * this.r2y - this.a1.y * this.r1z + this.a1.z * this.r1y - this.velx;\n    var rvy = this.l2.y - this.l1.y + this.a2.z * this.r2x - this.a2.x * this.r2z - this.a1.z * this.r1x + this.a1.x * this.r1z - this.vely;\n    var rvz = this.l2.z - this.l1.z + this.a2.x * this.r2y - this.a2.y * this.r2x - this.a1.x * this.r1y + this.a1.y * this.r1x - this.velz;\n    var nimpx = rvx * d[0] + rvy * d[1] + rvz * d[2];\n    var nimpy = rvx * d[3] + rvy * d[4] + rvz * d[5];\n    var nimpz = rvx * d[6] + rvy * d[7] + rvz * d[8];\n    this.impx += nimpx;\n    this.impy += nimpy;\n    this.impz += nimpz;\n    this.l1.x += nimpx * this.m1;\n    this.l1.y += nimpy * this.m1;\n    this.l1.z += nimpz * this.m1;\n    this.a1.x += nimpx * this.ax1x + nimpy * this.ay1x + nimpz * this.az1x;\n    this.a1.y += nimpx * this.ax1y + nimpy * this.ay1y + nimpz * this.az1y;\n    this.a1.z += nimpx * this.ax1z + nimpy * this.ay1z + nimpz * this.az1z;\n    this.l2.x -= nimpx * this.m2;\n    this.l2.y -= nimpy * this.m2;\n    this.l2.z -= nimpz * this.m2;\n    this.a2.x -= nimpx * this.ax2x + nimpy * this.ay2x + nimpz * this.az2x;\n    this.a2.y -= nimpx * this.ax2y + nimpy * this.ay2y + nimpz * this.az2y;\n    this.a2.z -= nimpx * this.ax2z + nimpy * this.ay2z + nimpz * this.az2z;\n  }\n});\n/**\n* A three-axis rotational constraint for various joints.\n* @author saharan\n*/\n\nfunction Rotational3Constraint(joint, limitMotor1, limitMotor2, limitMotor3) {\n  this.cfm1 = NaN;\n  this.cfm2 = NaN;\n  this.cfm3 = NaN;\n  this.i1e00 = NaN;\n  this.i1e01 = NaN;\n  this.i1e02 = NaN;\n  this.i1e10 = NaN;\n  this.i1e11 = NaN;\n  this.i1e12 = NaN;\n  this.i1e20 = NaN;\n  this.i1e21 = NaN;\n  this.i1e22 = NaN;\n  this.i2e00 = NaN;\n  this.i2e01 = NaN;\n  this.i2e02 = NaN;\n  this.i2e10 = NaN;\n  this.i2e11 = NaN;\n  this.i2e12 = NaN;\n  this.i2e20 = NaN;\n  this.i2e21 = NaN;\n  this.i2e22 = NaN;\n  this.ax1 = NaN;\n  this.ay1 = NaN;\n  this.az1 = NaN;\n  this.ax2 = NaN;\n  this.ay2 = NaN;\n  this.az2 = NaN;\n  this.ax3 = NaN;\n  this.ay3 = NaN;\n  this.az3 = NaN;\n  this.a1x1 = NaN; // jacoians\n\n  this.a1y1 = NaN;\n  this.a1z1 = NaN;\n  this.a2x1 = NaN;\n  this.a2y1 = NaN;\n  this.a2z1 = NaN;\n  this.a1x2 = NaN;\n  this.a1y2 = NaN;\n  this.a1z2 = NaN;\n  this.a2x2 = NaN;\n  this.a2y2 = NaN;\n  this.a2z2 = NaN;\n  this.a1x3 = NaN;\n  this.a1y3 = NaN;\n  this.a1z3 = NaN;\n  this.a2x3 = NaN;\n  this.a2y3 = NaN;\n  this.a2z3 = NaN;\n  this.lowerLimit1 = NaN;\n  this.upperLimit1 = NaN;\n  this.limitVelocity1 = NaN;\n  this.limitState1 = 0; // -1: at lower, 0: locked, 1: at upper, 2: free\n\n  this.enableMotor1 = false;\n  this.motorSpeed1 = NaN;\n  this.maxMotorForce1 = NaN;\n  this.maxMotorImpulse1 = NaN;\n  this.lowerLimit2 = NaN;\n  this.upperLimit2 = NaN;\n  this.limitVelocity2 = NaN;\n  this.limitState2 = 0; // -1: at lower, 0: locked, 1: at upper, 2: free\n\n  this.enableMotor2 = false;\n  this.motorSpeed2 = NaN;\n  this.maxMotorForce2 = NaN;\n  this.maxMotorImpulse2 = NaN;\n  this.lowerLimit3 = NaN;\n  this.upperLimit3 = NaN;\n  this.limitVelocity3 = NaN;\n  this.limitState3 = 0; // -1: at lower, 0: locked, 1: at upper, 2: free\n\n  this.enableMotor3 = false;\n  this.motorSpeed3 = NaN;\n  this.maxMotorForce3 = NaN;\n  this.maxMotorImpulse3 = NaN;\n  this.k00 = NaN; // K = J*M*JT\n\n  this.k01 = NaN;\n  this.k02 = NaN;\n  this.k10 = NaN;\n  this.k11 = NaN;\n  this.k12 = NaN;\n  this.k20 = NaN;\n  this.k21 = NaN;\n  this.k22 = NaN;\n  this.kv00 = NaN; // diagonals without CFMs\n\n  this.kv11 = NaN;\n  this.kv22 = NaN;\n  this.dv00 = NaN; // ...inverted\n\n  this.dv11 = NaN;\n  this.dv22 = NaN;\n  this.d00 = NaN; // K^-1\n\n  this.d01 = NaN;\n  this.d02 = NaN;\n  this.d10 = NaN;\n  this.d11 = NaN;\n  this.d12 = NaN;\n  this.d20 = NaN;\n  this.d21 = NaN;\n  this.d22 = NaN;\n  this.limitMotor1 = limitMotor1;\n  this.limitMotor2 = limitMotor2;\n  this.limitMotor3 = limitMotor3;\n  this.b1 = joint.body1;\n  this.b2 = joint.body2;\n  this.a1 = this.b1.angularVelocity;\n  this.a2 = this.b2.angularVelocity;\n  this.i1 = this.b1.inverseInertia;\n  this.i2 = this.b2.inverseInertia;\n  this.limitImpulse1 = 0;\n  this.motorImpulse1 = 0;\n  this.limitImpulse2 = 0;\n  this.motorImpulse2 = 0;\n  this.limitImpulse3 = 0;\n  this.motorImpulse3 = 0;\n}\n\nObject.assign(Rotational3Constraint.prototype, {\n  Rotational3Constraint: true,\n  preSolve: function (timeStep, invTimeStep) {\n    this.ax1 = this.limitMotor1.axis.x;\n    this.ay1 = this.limitMotor1.axis.y;\n    this.az1 = this.limitMotor1.axis.z;\n    this.ax2 = this.limitMotor2.axis.x;\n    this.ay2 = this.limitMotor2.axis.y;\n    this.az2 = this.limitMotor2.axis.z;\n    this.ax3 = this.limitMotor3.axis.x;\n    this.ay3 = this.limitMotor3.axis.y;\n    this.az3 = this.limitMotor3.axis.z;\n    this.lowerLimit1 = this.limitMotor1.lowerLimit;\n    this.upperLimit1 = this.limitMotor1.upperLimit;\n    this.motorSpeed1 = this.limitMotor1.motorSpeed;\n    this.maxMotorForce1 = this.limitMotor1.maxMotorForce;\n    this.enableMotor1 = this.maxMotorForce1 > 0;\n    this.lowerLimit2 = this.limitMotor2.lowerLimit;\n    this.upperLimit2 = this.limitMotor2.upperLimit;\n    this.motorSpeed2 = this.limitMotor2.motorSpeed;\n    this.maxMotorForce2 = this.limitMotor2.maxMotorForce;\n    this.enableMotor2 = this.maxMotorForce2 > 0;\n    this.lowerLimit3 = this.limitMotor3.lowerLimit;\n    this.upperLimit3 = this.limitMotor3.upperLimit;\n    this.motorSpeed3 = this.limitMotor3.motorSpeed;\n    this.maxMotorForce3 = this.limitMotor3.maxMotorForce;\n    this.enableMotor3 = this.maxMotorForce3 > 0;\n    var ti1 = this.i1.elements;\n    var ti2 = this.i2.elements;\n    this.i1e00 = ti1[0];\n    this.i1e01 = ti1[1];\n    this.i1e02 = ti1[2];\n    this.i1e10 = ti1[3];\n    this.i1e11 = ti1[4];\n    this.i1e12 = ti1[5];\n    this.i1e20 = ti1[6];\n    this.i1e21 = ti1[7];\n    this.i1e22 = ti1[8];\n    this.i2e00 = ti2[0];\n    this.i2e01 = ti2[1];\n    this.i2e02 = ti2[2];\n    this.i2e10 = ti2[3];\n    this.i2e11 = ti2[4];\n    this.i2e12 = ti2[5];\n    this.i2e20 = ti2[6];\n    this.i2e21 = ti2[7];\n    this.i2e22 = ti2[8];\n    var frequency1 = this.limitMotor1.frequency;\n    var frequency2 = this.limitMotor2.frequency;\n    var frequency3 = this.limitMotor3.frequency;\n    var enableSpring1 = frequency1 > 0;\n    var enableSpring2 = frequency2 > 0;\n    var enableSpring3 = frequency3 > 0;\n    var enableLimit1 = this.lowerLimit1 <= this.upperLimit1;\n    var enableLimit2 = this.lowerLimit2 <= this.upperLimit2;\n    var enableLimit3 = this.lowerLimit3 <= this.upperLimit3;\n    var angle1 = this.limitMotor1.angle;\n\n    if (enableLimit1) {\n      if (this.lowerLimit1 == this.upperLimit1) {\n        if (this.limitState1 != 0) {\n          this.limitState1 = 0;\n          this.limitImpulse1 = 0;\n        }\n\n        this.limitVelocity1 = this.lowerLimit1 - angle1;\n      } else if (angle1 < this.lowerLimit1) {\n        if (this.limitState1 != -1) {\n          this.limitState1 = -1;\n          this.limitImpulse1 = 0;\n        }\n\n        this.limitVelocity1 = this.lowerLimit1 - angle1;\n      } else if (angle1 > this.upperLimit1) {\n        if (this.limitState1 != 1) {\n          this.limitState1 = 1;\n          this.limitImpulse1 = 0;\n        }\n\n        this.limitVelocity1 = this.upperLimit1 - angle1;\n      } else {\n        this.limitState1 = 2;\n        this.limitImpulse1 = 0;\n        this.limitVelocity1 = 0;\n      }\n\n      if (!enableSpring1) {\n        if (this.limitVelocity1 > 0.02) this.limitVelocity1 -= 0.02;else if (this.limitVelocity1 < -0.02) this.limitVelocity1 += 0.02;else this.limitVelocity1 = 0;\n      }\n    } else {\n      this.limitState1 = 2;\n      this.limitImpulse1 = 0;\n    }\n\n    var angle2 = this.limitMotor2.angle;\n\n    if (enableLimit2) {\n      if (this.lowerLimit2 == this.upperLimit2) {\n        if (this.limitState2 != 0) {\n          this.limitState2 = 0;\n          this.limitImpulse2 = 0;\n        }\n\n        this.limitVelocity2 = this.lowerLimit2 - angle2;\n      } else if (angle2 < this.lowerLimit2) {\n        if (this.limitState2 != -1) {\n          this.limitState2 = -1;\n          this.limitImpulse2 = 0;\n        }\n\n        this.limitVelocity2 = this.lowerLimit2 - angle2;\n      } else if (angle2 > this.upperLimit2) {\n        if (this.limitState2 != 1) {\n          this.limitState2 = 1;\n          this.limitImpulse2 = 0;\n        }\n\n        this.limitVelocity2 = this.upperLimit2 - angle2;\n      } else {\n        this.limitState2 = 2;\n        this.limitImpulse2 = 0;\n        this.limitVelocity2 = 0;\n      }\n\n      if (!enableSpring2) {\n        if (this.limitVelocity2 > 0.02) this.limitVelocity2 -= 0.02;else if (this.limitVelocity2 < -0.02) this.limitVelocity2 += 0.02;else this.limitVelocity2 = 0;\n      }\n    } else {\n      this.limitState2 = 2;\n      this.limitImpulse2 = 0;\n    }\n\n    var angle3 = this.limitMotor3.angle;\n\n    if (enableLimit3) {\n      if (this.lowerLimit3 == this.upperLimit3) {\n        if (this.limitState3 != 0) {\n          this.limitState3 = 0;\n          this.limitImpulse3 = 0;\n        }\n\n        this.limitVelocity3 = this.lowerLimit3 - angle3;\n      } else if (angle3 < this.lowerLimit3) {\n        if (this.limitState3 != -1) {\n          this.limitState3 = -1;\n          this.limitImpulse3 = 0;\n        }\n\n        this.limitVelocity3 = this.lowerLimit3 - angle3;\n      } else if (angle3 > this.upperLimit3) {\n        if (this.limitState3 != 1) {\n          this.limitState3 = 1;\n          this.limitImpulse3 = 0;\n        }\n\n        this.limitVelocity3 = this.upperLimit3 - angle3;\n      } else {\n        this.limitState3 = 2;\n        this.limitImpulse3 = 0;\n        this.limitVelocity3 = 0;\n      }\n\n      if (!enableSpring3) {\n        if (this.limitVelocity3 > 0.02) this.limitVelocity3 -= 0.02;else if (this.limitVelocity3 < -0.02) this.limitVelocity3 += 0.02;else this.limitVelocity3 = 0;\n      }\n    } else {\n      this.limitState3 = 2;\n      this.limitImpulse3 = 0;\n    }\n\n    if (this.enableMotor1 && (this.limitState1 != 0 || enableSpring1)) {\n      this.maxMotorImpulse1 = this.maxMotorForce1 * timeStep;\n    } else {\n      this.motorImpulse1 = 0;\n      this.maxMotorImpulse1 = 0;\n    }\n\n    if (this.enableMotor2 && (this.limitState2 != 0 || enableSpring2)) {\n      this.maxMotorImpulse2 = this.maxMotorForce2 * timeStep;\n    } else {\n      this.motorImpulse2 = 0;\n      this.maxMotorImpulse2 = 0;\n    }\n\n    if (this.enableMotor3 && (this.limitState3 != 0 || enableSpring3)) {\n      this.maxMotorImpulse3 = this.maxMotorForce3 * timeStep;\n    } else {\n      this.motorImpulse3 = 0;\n      this.maxMotorImpulse3 = 0;\n    } // build jacobians\n\n\n    this.a1x1 = this.ax1 * this.i1e00 + this.ay1 * this.i1e01 + this.az1 * this.i1e02;\n    this.a1y1 = this.ax1 * this.i1e10 + this.ay1 * this.i1e11 + this.az1 * this.i1e12;\n    this.a1z1 = this.ax1 * this.i1e20 + this.ay1 * this.i1e21 + this.az1 * this.i1e22;\n    this.a2x1 = this.ax1 * this.i2e00 + this.ay1 * this.i2e01 + this.az1 * this.i2e02;\n    this.a2y1 = this.ax1 * this.i2e10 + this.ay1 * this.i2e11 + this.az1 * this.i2e12;\n    this.a2z1 = this.ax1 * this.i2e20 + this.ay1 * this.i2e21 + this.az1 * this.i2e22;\n    this.a1x2 = this.ax2 * this.i1e00 + this.ay2 * this.i1e01 + this.az2 * this.i1e02;\n    this.a1y2 = this.ax2 * this.i1e10 + this.ay2 * this.i1e11 + this.az2 * this.i1e12;\n    this.a1z2 = this.ax2 * this.i1e20 + this.ay2 * this.i1e21 + this.az2 * this.i1e22;\n    this.a2x2 = this.ax2 * this.i2e00 + this.ay2 * this.i2e01 + this.az2 * this.i2e02;\n    this.a2y2 = this.ax2 * this.i2e10 + this.ay2 * this.i2e11 + this.az2 * this.i2e12;\n    this.a2z2 = this.ax2 * this.i2e20 + this.ay2 * this.i2e21 + this.az2 * this.i2e22;\n    this.a1x3 = this.ax3 * this.i1e00 + this.ay3 * this.i1e01 + this.az3 * this.i1e02;\n    this.a1y3 = this.ax3 * this.i1e10 + this.ay3 * this.i1e11 + this.az3 * this.i1e12;\n    this.a1z3 = this.ax3 * this.i1e20 + this.ay3 * this.i1e21 + this.az3 * this.i1e22;\n    this.a2x3 = this.ax3 * this.i2e00 + this.ay3 * this.i2e01 + this.az3 * this.i2e02;\n    this.a2y3 = this.ax3 * this.i2e10 + this.ay3 * this.i2e11 + this.az3 * this.i2e12;\n    this.a2z3 = this.ax3 * this.i2e20 + this.ay3 * this.i2e21 + this.az3 * this.i2e22; // build an impulse matrix\n\n    this.k00 = this.ax1 * (this.a1x1 + this.a2x1) + this.ay1 * (this.a1y1 + this.a2y1) + this.az1 * (this.a1z1 + this.a2z1);\n    this.k01 = this.ax1 * (this.a1x2 + this.a2x2) + this.ay1 * (this.a1y2 + this.a2y2) + this.az1 * (this.a1z2 + this.a2z2);\n    this.k02 = this.ax1 * (this.a1x3 + this.a2x3) + this.ay1 * (this.a1y3 + this.a2y3) + this.az1 * (this.a1z3 + this.a2z3);\n    this.k10 = this.ax2 * (this.a1x1 + this.a2x1) + this.ay2 * (this.a1y1 + this.a2y1) + this.az2 * (this.a1z1 + this.a2z1);\n    this.k11 = this.ax2 * (this.a1x2 + this.a2x2) + this.ay2 * (this.a1y2 + this.a2y2) + this.az2 * (this.a1z2 + this.a2z2);\n    this.k12 = this.ax2 * (this.a1x3 + this.a2x3) + this.ay2 * (this.a1y3 + this.a2y3) + this.az2 * (this.a1z3 + this.a2z3);\n    this.k20 = this.ax3 * (this.a1x1 + this.a2x1) + this.ay3 * (this.a1y1 + this.a2y1) + this.az3 * (this.a1z1 + this.a2z1);\n    this.k21 = this.ax3 * (this.a1x2 + this.a2x2) + this.ay3 * (this.a1y2 + this.a2y2) + this.az3 * (this.a1z2 + this.a2z2);\n    this.k22 = this.ax3 * (this.a1x3 + this.a2x3) + this.ay3 * (this.a1y3 + this.a2y3) + this.az3 * (this.a1z3 + this.a2z3);\n    this.kv00 = this.k00;\n    this.kv11 = this.k11;\n    this.kv22 = this.k22;\n    this.dv00 = 1 / this.kv00;\n    this.dv11 = 1 / this.kv11;\n    this.dv22 = 1 / this.kv22;\n\n    if (enableSpring1 && this.limitState1 != 2) {\n      var omega = 6.2831853 * frequency1;\n      var k = omega * omega * timeStep;\n      var dmp = invTimeStep / (k + 2 * this.limitMotor1.dampingRatio * omega);\n      this.cfm1 = this.kv00 * dmp;\n      this.limitVelocity1 *= k * dmp;\n    } else {\n      this.cfm1 = 0;\n      this.limitVelocity1 *= invTimeStep * 0.05;\n    }\n\n    if (enableSpring2 && this.limitState2 != 2) {\n      omega = 6.2831853 * frequency2;\n      k = omega * omega * timeStep;\n      dmp = invTimeStep / (k + 2 * this.limitMotor2.dampingRatio * omega);\n      this.cfm2 = this.kv11 * dmp;\n      this.limitVelocity2 *= k * dmp;\n    } else {\n      this.cfm2 = 0;\n      this.limitVelocity2 *= invTimeStep * 0.05;\n    }\n\n    if (enableSpring3 && this.limitState3 != 2) {\n      omega = 6.2831853 * frequency3;\n      k = omega * omega * timeStep;\n      dmp = invTimeStep / (k + 2 * this.limitMotor3.dampingRatio * omega);\n      this.cfm3 = this.kv22 * dmp;\n      this.limitVelocity3 *= k * dmp;\n    } else {\n      this.cfm3 = 0;\n      this.limitVelocity3 *= invTimeStep * 0.05;\n    }\n\n    this.k00 += this.cfm1;\n    this.k11 += this.cfm2;\n    this.k22 += this.cfm3;\n    var inv = 1 / (this.k00 * (this.k11 * this.k22 - this.k21 * this.k12) + this.k10 * (this.k21 * this.k02 - this.k01 * this.k22) + this.k20 * (this.k01 * this.k12 - this.k11 * this.k02));\n    this.d00 = (this.k11 * this.k22 - this.k12 * this.k21) * inv;\n    this.d01 = (this.k02 * this.k21 - this.k01 * this.k22) * inv;\n    this.d02 = (this.k01 * this.k12 - this.k02 * this.k11) * inv;\n    this.d10 = (this.k12 * this.k20 - this.k10 * this.k22) * inv;\n    this.d11 = (this.k00 * this.k22 - this.k02 * this.k20) * inv;\n    this.d12 = (this.k02 * this.k10 - this.k00 * this.k12) * inv;\n    this.d20 = (this.k10 * this.k21 - this.k11 * this.k20) * inv;\n    this.d21 = (this.k01 * this.k20 - this.k00 * this.k21) * inv;\n    this.d22 = (this.k00 * this.k11 - this.k01 * this.k10) * inv;\n    this.limitImpulse1 *= 0.95;\n    this.motorImpulse1 *= 0.95;\n    this.limitImpulse2 *= 0.95;\n    this.motorImpulse2 *= 0.95;\n    this.limitImpulse3 *= 0.95;\n    this.motorImpulse3 *= 0.95;\n    var totalImpulse1 = this.limitImpulse1 + this.motorImpulse1;\n    var totalImpulse2 = this.limitImpulse2 + this.motorImpulse2;\n    var totalImpulse3 = this.limitImpulse3 + this.motorImpulse3;\n    this.a1.x += totalImpulse1 * this.a1x1 + totalImpulse2 * this.a1x2 + totalImpulse3 * this.a1x3;\n    this.a1.y += totalImpulse1 * this.a1y1 + totalImpulse2 * this.a1y2 + totalImpulse3 * this.a1y3;\n    this.a1.z += totalImpulse1 * this.a1z1 + totalImpulse2 * this.a1z2 + totalImpulse3 * this.a1z3;\n    this.a2.x -= totalImpulse1 * this.a2x1 + totalImpulse2 * this.a2x2 + totalImpulse3 * this.a2x3;\n    this.a2.y -= totalImpulse1 * this.a2y1 + totalImpulse2 * this.a2y2 + totalImpulse3 * this.a2y3;\n    this.a2.z -= totalImpulse1 * this.a2z1 + totalImpulse2 * this.a2z2 + totalImpulse3 * this.a2z3;\n  },\n  solve_: function () {\n    var rvx = this.a2.x - this.a1.x;\n    var rvy = this.a2.y - this.a1.y;\n    var rvz = this.a2.z - this.a1.z;\n    this.limitVelocity3 = 30;\n    var rvn1 = rvx * this.ax1 + rvy * this.ay1 + rvz * this.az1 - this.limitVelocity1;\n    var rvn2 = rvx * this.ax2 + rvy * this.ay2 + rvz * this.az2 - this.limitVelocity2;\n    var rvn3 = rvx * this.ax3 + rvy * this.ay3 + rvz * this.az3 - this.limitVelocity3;\n    var dLimitImpulse1 = rvn1 * this.d00 + rvn2 * this.d01 + rvn3 * this.d02;\n    var dLimitImpulse2 = rvn1 * this.d10 + rvn2 * this.d11 + rvn3 * this.d12;\n    var dLimitImpulse3 = rvn1 * this.d20 + rvn2 * this.d21 + rvn3 * this.d22;\n    this.limitImpulse1 += dLimitImpulse1;\n    this.limitImpulse2 += dLimitImpulse2;\n    this.limitImpulse3 += dLimitImpulse3;\n    this.a1.x += dLimitImpulse1 * this.a1x1 + dLimitImpulse2 * this.a1x2 + dLimitImpulse3 * this.a1x3;\n    this.a1.y += dLimitImpulse1 * this.a1y1 + dLimitImpulse2 * this.a1y2 + dLimitImpulse3 * this.a1y3;\n    this.a1.z += dLimitImpulse1 * this.a1z1 + dLimitImpulse2 * this.a1z2 + dLimitImpulse3 * this.a1z3;\n    this.a2.x -= dLimitImpulse1 * this.a2x1 + dLimitImpulse2 * this.a2x2 + dLimitImpulse3 * this.a2x3;\n    this.a2.y -= dLimitImpulse1 * this.a2y1 + dLimitImpulse2 * this.a2y2 + dLimitImpulse3 * this.a2y3;\n    this.a2.z -= dLimitImpulse1 * this.a2z1 + dLimitImpulse2 * this.a2z2 + dLimitImpulse3 * this.a2z3;\n  },\n  solve: function () {\n    var rvx = this.a2.x - this.a1.x;\n    var rvy = this.a2.y - this.a1.y;\n    var rvz = this.a2.z - this.a1.z;\n    var rvn1 = rvx * this.ax1 + rvy * this.ay1 + rvz * this.az1;\n    var rvn2 = rvx * this.ax2 + rvy * this.ay2 + rvz * this.az2;\n    var rvn3 = rvx * this.ax3 + rvy * this.ay3 + rvz * this.az3;\n    var oldMotorImpulse1 = this.motorImpulse1;\n    var oldMotorImpulse2 = this.motorImpulse2;\n    var oldMotorImpulse3 = this.motorImpulse3;\n    var dMotorImpulse1 = 0;\n    var dMotorImpulse2 = 0;\n    var dMotorImpulse3 = 0;\n\n    if (this.enableMotor1) {\n      dMotorImpulse1 = (rvn1 - this.motorSpeed1) * this.dv00;\n      this.motorImpulse1 += dMotorImpulse1;\n\n      if (this.motorImpulse1 > this.maxMotorImpulse1) {\n        // clamp motor impulse\n        this.motorImpulse1 = this.maxMotorImpulse1;\n      } else if (this.motorImpulse1 < -this.maxMotorImpulse1) {\n        this.motorImpulse1 = -this.maxMotorImpulse1;\n      }\n\n      dMotorImpulse1 = this.motorImpulse1 - oldMotorImpulse1;\n    }\n\n    if (this.enableMotor2) {\n      dMotorImpulse2 = (rvn2 - this.motorSpeed2) * this.dv11;\n      this.motorImpulse2 += dMotorImpulse2;\n\n      if (this.motorImpulse2 > this.maxMotorImpulse2) {\n        // clamp motor impulse\n        this.motorImpulse2 = this.maxMotorImpulse2;\n      } else if (this.motorImpulse2 < -this.maxMotorImpulse2) {\n        this.motorImpulse2 = -this.maxMotorImpulse2;\n      }\n\n      dMotorImpulse2 = this.motorImpulse2 - oldMotorImpulse2;\n    }\n\n    if (this.enableMotor3) {\n      dMotorImpulse3 = (rvn3 - this.motorSpeed3) * this.dv22;\n      this.motorImpulse3 += dMotorImpulse3;\n\n      if (this.motorImpulse3 > this.maxMotorImpulse3) {\n        // clamp motor impulse\n        this.motorImpulse3 = this.maxMotorImpulse3;\n      } else if (this.motorImpulse3 < -this.maxMotorImpulse3) {\n        this.motorImpulse3 = -this.maxMotorImpulse3;\n      }\n\n      dMotorImpulse3 = this.motorImpulse3 - oldMotorImpulse3;\n    } // apply motor impulse to relative velocity\n\n\n    rvn1 += dMotorImpulse1 * this.kv00 + dMotorImpulse2 * this.k01 + dMotorImpulse3 * this.k02;\n    rvn2 += dMotorImpulse1 * this.k10 + dMotorImpulse2 * this.kv11 + dMotorImpulse3 * this.k12;\n    rvn3 += dMotorImpulse1 * this.k20 + dMotorImpulse2 * this.k21 + dMotorImpulse3 * this.kv22; // subtract target velocity and applied impulse\n\n    rvn1 -= this.limitVelocity1 + this.limitImpulse1 * this.cfm1;\n    rvn2 -= this.limitVelocity2 + this.limitImpulse2 * this.cfm2;\n    rvn3 -= this.limitVelocity3 + this.limitImpulse3 * this.cfm3;\n    var oldLimitImpulse1 = this.limitImpulse1;\n    var oldLimitImpulse2 = this.limitImpulse2;\n    var oldLimitImpulse3 = this.limitImpulse3;\n    var dLimitImpulse1 = rvn1 * this.d00 + rvn2 * this.d01 + rvn3 * this.d02;\n    var dLimitImpulse2 = rvn1 * this.d10 + rvn2 * this.d11 + rvn3 * this.d12;\n    var dLimitImpulse3 = rvn1 * this.d20 + rvn2 * this.d21 + rvn3 * this.d22;\n    this.limitImpulse1 += dLimitImpulse1;\n    this.limitImpulse2 += dLimitImpulse2;\n    this.limitImpulse3 += dLimitImpulse3; // clamp\n\n    var clampState = 0;\n\n    if (this.limitState1 == 2 || this.limitImpulse1 * this.limitState1 < 0) {\n      dLimitImpulse1 = -oldLimitImpulse1;\n      rvn2 += dLimitImpulse1 * this.k10;\n      rvn3 += dLimitImpulse1 * this.k20;\n      clampState |= 1;\n    }\n\n    if (this.limitState2 == 2 || this.limitImpulse2 * this.limitState2 < 0) {\n      dLimitImpulse2 = -oldLimitImpulse2;\n      rvn1 += dLimitImpulse2 * this.k01;\n      rvn3 += dLimitImpulse2 * this.k21;\n      clampState |= 2;\n    }\n\n    if (this.limitState3 == 2 || this.limitImpulse3 * this.limitState3 < 0) {\n      dLimitImpulse3 = -oldLimitImpulse3;\n      rvn1 += dLimitImpulse3 * this.k02;\n      rvn2 += dLimitImpulse3 * this.k12;\n      clampState |= 4;\n    } // update un-clamped impulse\n    // TODO: isolate division\n\n\n    var det;\n\n    switch (clampState) {\n      case 1:\n        // update 2 3\n        det = 1 / (this.k11 * this.k22 - this.k12 * this.k21);\n        dLimitImpulse2 = (this.k22 * rvn2 + -this.k12 * rvn3) * det;\n        dLimitImpulse3 = (-this.k21 * rvn2 + this.k11 * rvn3) * det;\n        break;\n\n      case 2:\n        // update 1 3\n        det = 1 / (this.k00 * this.k22 - this.k02 * this.k20);\n        dLimitImpulse1 = (this.k22 * rvn1 + -this.k02 * rvn3) * det;\n        dLimitImpulse3 = (-this.k20 * rvn1 + this.k00 * rvn3) * det;\n        break;\n\n      case 3:\n        // update 3\n        dLimitImpulse3 = rvn3 / this.k22;\n        break;\n\n      case 4:\n        // update 1 2\n        det = 1 / (this.k00 * this.k11 - this.k01 * this.k10);\n        dLimitImpulse1 = (this.k11 * rvn1 + -this.k01 * rvn2) * det;\n        dLimitImpulse2 = (-this.k10 * rvn1 + this.k00 * rvn2) * det;\n        break;\n\n      case 5:\n        // update 2\n        dLimitImpulse2 = rvn2 / this.k11;\n        break;\n\n      case 6:\n        // update 1\n        dLimitImpulse1 = rvn1 / this.k00;\n        break;\n    }\n\n    this.limitImpulse1 = dLimitImpulse1 + oldLimitImpulse1;\n    this.limitImpulse2 = dLimitImpulse2 + oldLimitImpulse2;\n    this.limitImpulse3 = dLimitImpulse3 + oldLimitImpulse3;\n    var dImpulse1 = dMotorImpulse1 + dLimitImpulse1;\n    var dImpulse2 = dMotorImpulse2 + dLimitImpulse2;\n    var dImpulse3 = dMotorImpulse3 + dLimitImpulse3; // apply impulse\n\n    this.a1.x += dImpulse1 * this.a1x1 + dImpulse2 * this.a1x2 + dImpulse3 * this.a1x3;\n    this.a1.y += dImpulse1 * this.a1y1 + dImpulse2 * this.a1y2 + dImpulse3 * this.a1y3;\n    this.a1.z += dImpulse1 * this.a1z1 + dImpulse2 * this.a1z2 + dImpulse3 * this.a1z3;\n    this.a2.x -= dImpulse1 * this.a2x1 + dImpulse2 * this.a2x2 + dImpulse3 * this.a2x3;\n    this.a2.y -= dImpulse1 * this.a2y1 + dImpulse2 * this.a2y2 + dImpulse3 * this.a2y3;\n    this.a2.z -= dImpulse1 * this.a2z1 + dImpulse2 * this.a2z2 + dImpulse3 * this.a2z3;\n    rvx = this.a2.x - this.a1.x;\n    rvy = this.a2.y - this.a1.y;\n    rvz = this.a2.z - this.a1.z;\n    rvn2 = rvx * this.ax2 + rvy * this.ay2 + rvz * this.az2;\n  }\n});\n/**\n * A hinge joint allows only for relative rotation of rigid bodies along the axis.\n *\n * @author saharan\n * @author lo-th\n */\n\nfunction HingeJoint(config, lowerAngleLimit, upperAngleLimit) {\n  Joint.call(this, config);\n  this.type = JOINT_HINGE; // The axis in the first body's coordinate system.\n\n  this.localAxis1 = config.localAxis1.clone().normalize(); // The axis in the second body's coordinate system.\n\n  this.localAxis2 = config.localAxis2.clone().normalize(); // make angle axis\n\n  var arc = new Mat33().setQuat(new Quat().setFromUnitVectors(this.localAxis1, this.localAxis2));\n  this.localAngle1 = new Vec3().tangent(this.localAxis1).normalize();\n  this.localAngle2 = this.localAngle1.clone().applyMatrix3(arc, true);\n  this.ax1 = new Vec3();\n  this.ax2 = new Vec3();\n  this.an1 = new Vec3();\n  this.an2 = new Vec3();\n  this.tmp = new Vec3();\n  this.nor = new Vec3();\n  this.tan = new Vec3();\n  this.bin = new Vec3(); // The rotational limit and motor information of the joint.\n\n  this.limitMotor = new LimitMotor(this.nor, false);\n  this.limitMotor.lowerLimit = lowerAngleLimit;\n  this.limitMotor.upperLimit = upperAngleLimit;\n  this.lc = new LinearConstraint(this);\n  this.r3 = new Rotational3Constraint(this, this.limitMotor, new LimitMotor(this.tan, true), new LimitMotor(this.bin, true));\n}\n\nHingeJoint.prototype = Object.assign(Object.create(Joint.prototype), {\n  constructor: HingeJoint,\n  preSolve: function (timeStep, invTimeStep) {\n    this.updateAnchorPoints();\n    this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, true);\n    this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, true);\n    this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, true);\n    this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, true); // normal tangent binormal\n\n    this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize();\n    this.tan.tangent(this.nor).normalize();\n    this.bin.crossVectors(this.nor, this.tan); // calculate hinge angle\n\n    var limite = _Math.acosClamp(_Math.dotVectors(this.an1, this.an2));\n\n    this.tmp.crossVectors(this.an1, this.an2);\n    if (_Math.dotVectors(this.nor, this.tmp) < 0) this.limitMotor.angle = -limite;else this.limitMotor.angle = limite;\n    this.tmp.crossVectors(this.ax1, this.ax2);\n    this.r3.limitMotor2.angle = _Math.dotVectors(this.tan, this.tmp);\n    this.r3.limitMotor3.angle = _Math.dotVectors(this.bin, this.tmp); // preSolve\n\n    this.r3.preSolve(timeStep, invTimeStep);\n    this.lc.preSolve(timeStep, invTimeStep);\n  },\n  solve: function () {\n    this.r3.solve();\n    this.lc.solve();\n  },\n  postSolve: function () {}\n});\n/**\n * A ball-and-socket joint limits relative translation on two anchor points on rigid bodies.\n *\n * @author saharan\n * @author lo-th\n */\n\nfunction BallAndSocketJoint(config) {\n  Joint.call(this, config);\n  this.type = JOINT_BALL_AND_SOCKET;\n  this.lc = new LinearConstraint(this);\n}\n\nBallAndSocketJoint.prototype = Object.assign(Object.create(Joint.prototype), {\n  constructor: BallAndSocketJoint,\n  preSolve: function (timeStep, invTimeStep) {\n    this.updateAnchorPoints(); // preSolve\n\n    this.lc.preSolve(timeStep, invTimeStep);\n  },\n  solve: function () {\n    this.lc.solve();\n  },\n  postSolve: function () {}\n});\n/**\n* A translational constraint for various joints.\n* @author saharan\n*/\n\nfunction TranslationalConstraint(joint, limitMotor) {\n  this.cfm = NaN;\n  this.m1 = NaN;\n  this.m2 = NaN;\n  this.i1e00 = NaN;\n  this.i1e01 = NaN;\n  this.i1e02 = NaN;\n  this.i1e10 = NaN;\n  this.i1e11 = NaN;\n  this.i1e12 = NaN;\n  this.i1e20 = NaN;\n  this.i1e21 = NaN;\n  this.i1e22 = NaN;\n  this.i2e00 = NaN;\n  this.i2e01 = NaN;\n  this.i2e02 = NaN;\n  this.i2e10 = NaN;\n  this.i2e11 = NaN;\n  this.i2e12 = NaN;\n  this.i2e20 = NaN;\n  this.i2e21 = NaN;\n  this.i2e22 = NaN;\n  this.motorDenom = NaN;\n  this.invMotorDenom = NaN;\n  this.invDenom = NaN;\n  this.ax = NaN;\n  this.ay = NaN;\n  this.az = NaN;\n  this.r1x = NaN;\n  this.r1y = NaN;\n  this.r1z = NaN;\n  this.r2x = NaN;\n  this.r2y = NaN;\n  this.r2z = NaN;\n  this.t1x = NaN;\n  this.t1y = NaN;\n  this.t1z = NaN;\n  this.t2x = NaN;\n  this.t2y = NaN;\n  this.t2z = NaN;\n  this.l1x = NaN;\n  this.l1y = NaN;\n  this.l1z = NaN;\n  this.l2x = NaN;\n  this.l2y = NaN;\n  this.l2z = NaN;\n  this.a1x = NaN;\n  this.a1y = NaN;\n  this.a1z = NaN;\n  this.a2x = NaN;\n  this.a2y = NaN;\n  this.a2z = NaN;\n  this.lowerLimit = NaN;\n  this.upperLimit = NaN;\n  this.limitVelocity = NaN;\n  this.limitState = 0; // -1: at lower, 0: locked, 1: at upper, 2: free\n\n  this.enableMotor = false;\n  this.motorSpeed = NaN;\n  this.maxMotorForce = NaN;\n  this.maxMotorImpulse = NaN;\n  this.limitMotor = limitMotor;\n  this.b1 = joint.body1;\n  this.b2 = joint.body2;\n  this.p1 = joint.anchorPoint1;\n  this.p2 = joint.anchorPoint2;\n  this.r1 = joint.relativeAnchorPoint1;\n  this.r2 = joint.relativeAnchorPoint2;\n  this.l1 = this.b1.linearVelocity;\n  this.l2 = this.b2.linearVelocity;\n  this.a1 = this.b1.angularVelocity;\n  this.a2 = this.b2.angularVelocity;\n  this.i1 = this.b1.inverseInertia;\n  this.i2 = this.b2.inverseInertia;\n  this.limitImpulse = 0;\n  this.motorImpulse = 0;\n}\n\nObject.assign(TranslationalConstraint.prototype, {\n  TranslationalConstraint: true,\n  preSolve: function (timeStep, invTimeStep) {\n    this.ax = this.limitMotor.axis.x;\n    this.ay = this.limitMotor.axis.y;\n    this.az = this.limitMotor.axis.z;\n    this.lowerLimit = this.limitMotor.lowerLimit;\n    this.upperLimit = this.limitMotor.upperLimit;\n    this.motorSpeed = this.limitMotor.motorSpeed;\n    this.maxMotorForce = this.limitMotor.maxMotorForce;\n    this.enableMotor = this.maxMotorForce > 0;\n    this.m1 = this.b1.inverseMass;\n    this.m2 = this.b2.inverseMass;\n    var ti1 = this.i1.elements;\n    var ti2 = this.i2.elements;\n    this.i1e00 = ti1[0];\n    this.i1e01 = ti1[1];\n    this.i1e02 = ti1[2];\n    this.i1e10 = ti1[3];\n    this.i1e11 = ti1[4];\n    this.i1e12 = ti1[5];\n    this.i1e20 = ti1[6];\n    this.i1e21 = ti1[7];\n    this.i1e22 = ti1[8];\n    this.i2e00 = ti2[0];\n    this.i2e01 = ti2[1];\n    this.i2e02 = ti2[2];\n    this.i2e10 = ti2[3];\n    this.i2e11 = ti2[4];\n    this.i2e12 = ti2[5];\n    this.i2e20 = ti2[6];\n    this.i2e21 = ti2[7];\n    this.i2e22 = ti2[8];\n    var dx = this.p2.x - this.p1.x;\n    var dy = this.p2.y - this.p1.y;\n    var dz = this.p2.z - this.p1.z;\n    var d = dx * this.ax + dy * this.ay + dz * this.az;\n    var frequency = this.limitMotor.frequency;\n    var enableSpring = frequency > 0;\n    var enableLimit = this.lowerLimit <= this.upperLimit;\n\n    if (enableSpring && d > 20 || d < -20) {\n      enableSpring = false;\n    }\n\n    if (enableLimit) {\n      if (this.lowerLimit == this.upperLimit) {\n        if (this.limitState != 0) {\n          this.limitState = 0;\n          this.limitImpulse = 0;\n        }\n\n        this.limitVelocity = this.lowerLimit - d;\n        if (!enableSpring) d = this.lowerLimit;\n      } else if (d < this.lowerLimit) {\n        if (this.limitState != -1) {\n          this.limitState = -1;\n          this.limitImpulse = 0;\n        }\n\n        this.limitVelocity = this.lowerLimit - d;\n        if (!enableSpring) d = this.lowerLimit;\n      } else if (d > this.upperLimit) {\n        if (this.limitState != 1) {\n          this.limitState = 1;\n          this.limitImpulse = 0;\n        }\n\n        this.limitVelocity = this.upperLimit - d;\n        if (!enableSpring) d = this.upperLimit;\n      } else {\n        this.limitState = 2;\n        this.limitImpulse = 0;\n        this.limitVelocity = 0;\n      }\n\n      if (!enableSpring) {\n        if (this.limitVelocity > 0.005) this.limitVelocity -= 0.005;else if (this.limitVelocity < -0.005) this.limitVelocity += 0.005;else this.limitVelocity = 0;\n      }\n    } else {\n      this.limitState = 2;\n      this.limitImpulse = 0;\n    }\n\n    if (this.enableMotor && (this.limitState != 0 || enableSpring)) {\n      this.maxMotorImpulse = this.maxMotorForce * timeStep;\n    } else {\n      this.motorImpulse = 0;\n      this.maxMotorImpulse = 0;\n    }\n\n    var rdx = d * this.ax;\n    var rdy = d * this.ay;\n    var rdz = d * this.az;\n    var w1 = this.m1 / (this.m1 + this.m2);\n    var w2 = 1 - w1;\n    this.r1x = this.r1.x + rdx * w1;\n    this.r1y = this.r1.y + rdy * w1;\n    this.r1z = this.r1.z + rdz * w1;\n    this.r2x = this.r2.x - rdx * w2;\n    this.r2y = this.r2.y - rdy * w2;\n    this.r2z = this.r2.z - rdz * w2;\n    this.t1x = this.r1y * this.az - this.r1z * this.ay;\n    this.t1y = this.r1z * this.ax - this.r1x * this.az;\n    this.t1z = this.r1x * this.ay - this.r1y * this.ax;\n    this.t2x = this.r2y * this.az - this.r2z * this.ay;\n    this.t2y = this.r2z * this.ax - this.r2x * this.az;\n    this.t2z = this.r2x * this.ay - this.r2y * this.ax;\n    this.l1x = this.ax * this.m1;\n    this.l1y = this.ay * this.m1;\n    this.l1z = this.az * this.m1;\n    this.l2x = this.ax * this.m2;\n    this.l2y = this.ay * this.m2;\n    this.l2z = this.az * this.m2;\n    this.a1x = this.t1x * this.i1e00 + this.t1y * this.i1e01 + this.t1z * this.i1e02;\n    this.a1y = this.t1x * this.i1e10 + this.t1y * this.i1e11 + this.t1z * this.i1e12;\n    this.a1z = this.t1x * this.i1e20 + this.t1y * this.i1e21 + this.t1z * this.i1e22;\n    this.a2x = this.t2x * this.i2e00 + this.t2y * this.i2e01 + this.t2z * this.i2e02;\n    this.a2y = this.t2x * this.i2e10 + this.t2y * this.i2e11 + this.t2z * this.i2e12;\n    this.a2z = this.t2x * this.i2e20 + this.t2y * this.i2e21 + this.t2z * this.i2e22;\n    this.motorDenom = this.m1 + this.m2 + this.ax * (this.a1y * this.r1z - this.a1z * this.r1y + this.a2y * this.r2z - this.a2z * this.r2y) + this.ay * (this.a1z * this.r1x - this.a1x * this.r1z + this.a2z * this.r2x - this.a2x * this.r2z) + this.az * (this.a1x * this.r1y - this.a1y * this.r1x + this.a2x * this.r2y - this.a2y * this.r2x);\n    this.invMotorDenom = 1 / this.motorDenom;\n\n    if (enableSpring && this.limitState != 2) {\n      var omega = 6.2831853 * frequency;\n      var k = omega * omega * timeStep;\n      var dmp = invTimeStep / (k + 2 * this.limitMotor.dampingRatio * omega);\n      this.cfm = this.motorDenom * dmp;\n      this.limitVelocity *= k * dmp;\n    } else {\n      this.cfm = 0;\n      this.limitVelocity *= invTimeStep * 0.05;\n    }\n\n    this.invDenom = 1 / (this.motorDenom + this.cfm);\n    var totalImpulse = this.limitImpulse + this.motorImpulse;\n    this.l1.x += totalImpulse * this.l1x;\n    this.l1.y += totalImpulse * this.l1y;\n    this.l1.z += totalImpulse * this.l1z;\n    this.a1.x += totalImpulse * this.a1x;\n    this.a1.y += totalImpulse * this.a1y;\n    this.a1.z += totalImpulse * this.a1z;\n    this.l2.x -= totalImpulse * this.l2x;\n    this.l2.y -= totalImpulse * this.l2y;\n    this.l2.z -= totalImpulse * this.l2z;\n    this.a2.x -= totalImpulse * this.a2x;\n    this.a2.y -= totalImpulse * this.a2y;\n    this.a2.z -= totalImpulse * this.a2z;\n  },\n  solve: function () {\n    var rvn = this.ax * (this.l2.x - this.l1.x) + this.ay * (this.l2.y - this.l1.y) + this.az * (this.l2.z - this.l1.z) + this.t2x * this.a2.x - this.t1x * this.a1.x + this.t2y * this.a2.y - this.t1y * this.a1.y + this.t2z * this.a2.z - this.t1z * this.a1.z; // motor part\n\n    var newMotorImpulse;\n\n    if (this.enableMotor) {\n      newMotorImpulse = (rvn - this.motorSpeed) * this.invMotorDenom;\n      var oldMotorImpulse = this.motorImpulse;\n      this.motorImpulse += newMotorImpulse;\n      if (this.motorImpulse > this.maxMotorImpulse) this.motorImpulse = this.maxMotorImpulse;else if (this.motorImpulse < -this.maxMotorImpulse) this.motorImpulse = -this.maxMotorImpulse;\n      newMotorImpulse = this.motorImpulse - oldMotorImpulse;\n      rvn -= newMotorImpulse * this.motorDenom;\n    } else newMotorImpulse = 0; // limit part\n\n\n    var newLimitImpulse;\n\n    if (this.limitState != 2) {\n      newLimitImpulse = (rvn - this.limitVelocity - this.limitImpulse * this.cfm) * this.invDenom;\n      var oldLimitImpulse = this.limitImpulse;\n      this.limitImpulse += newLimitImpulse;\n      if (this.limitImpulse * this.limitState < 0) this.limitImpulse = 0;\n      newLimitImpulse = this.limitImpulse - oldLimitImpulse;\n    } else newLimitImpulse = 0;\n\n    var totalImpulse = newLimitImpulse + newMotorImpulse;\n    this.l1.x += totalImpulse * this.l1x;\n    this.l1.y += totalImpulse * this.l1y;\n    this.l1.z += totalImpulse * this.l1z;\n    this.a1.x += totalImpulse * this.a1x;\n    this.a1.y += totalImpulse * this.a1y;\n    this.a1.z += totalImpulse * this.a1z;\n    this.l2.x -= totalImpulse * this.l2x;\n    this.l2.y -= totalImpulse * this.l2y;\n    this.l2.z -= totalImpulse * this.l2z;\n    this.a2.x -= totalImpulse * this.a2x;\n    this.a2.y -= totalImpulse * this.a2y;\n    this.a2.z -= totalImpulse * this.a2z;\n  }\n});\n/**\n * A distance joint limits the distance between two anchor points on rigid bodies.\n *\n * @author saharan\n * @author lo-th\n */\n\nfunction DistanceJoint(config, minDistance, maxDistance) {\n  Joint.call(this, config);\n  this.type = JOINT_DISTANCE;\n  this.nor = new Vec3(); // The limit and motor information of the joint.\n\n  this.limitMotor = new LimitMotor(this.nor, true);\n  this.limitMotor.lowerLimit = minDistance;\n  this.limitMotor.upperLimit = maxDistance;\n  this.t = new TranslationalConstraint(this, this.limitMotor);\n}\n\nDistanceJoint.prototype = Object.assign(Object.create(Joint.prototype), {\n  constructor: DistanceJoint,\n  preSolve: function (timeStep, invTimeStep) {\n    this.updateAnchorPoints();\n    this.nor.sub(this.anchorPoint2, this.anchorPoint1).normalize(); // preSolve\n\n    this.t.preSolve(timeStep, invTimeStep);\n  },\n  solve: function () {\n    this.t.solve();\n  },\n  postSolve: function () {}\n});\n/**\n* An angular constraint for all axes for various joints.\n* @author saharan\n*/\n\nfunction AngularConstraint(joint, targetOrientation) {\n  this.joint = joint;\n  this.targetOrientation = new Quat().invert(targetOrientation);\n  this.relativeOrientation = new Quat();\n  this.ii1 = null;\n  this.ii2 = null;\n  this.dd = null;\n  this.vel = new Vec3();\n  this.imp = new Vec3();\n  this.rn0 = new Vec3();\n  this.rn1 = new Vec3();\n  this.rn2 = new Vec3();\n  this.b1 = joint.body1;\n  this.b2 = joint.body2;\n  this.a1 = this.b1.angularVelocity;\n  this.a2 = this.b2.angularVelocity;\n  this.i1 = this.b1.inverseInertia;\n  this.i2 = this.b2.inverseInertia;\n}\n\nObject.assign(AngularConstraint.prototype, {\n  AngularConstraint: true,\n  preSolve: function (timeStep, invTimeStep) {\n    var inv, len, v;\n    this.ii1 = this.i1.clone();\n    this.ii2 = this.i2.clone();\n    v = new Mat33().add(this.ii1, this.ii2).elements;\n    inv = 1 / (v[0] * (v[4] * v[8] - v[7] * v[5]) + v[3] * (v[7] * v[2] - v[1] * v[8]) + v[6] * (v[1] * v[5] - v[4] * v[2]));\n    this.dd = new Mat33().set(v[4] * v[8] - v[5] * v[7], v[2] * v[7] - v[1] * v[8], v[1] * v[5] - v[2] * v[4], v[5] * v[6] - v[3] * v[8], v[0] * v[8] - v[2] * v[6], v[2] * v[3] - v[0] * v[5], v[3] * v[7] - v[4] * v[6], v[1] * v[6] - v[0] * v[7], v[0] * v[4] - v[1] * v[3]).multiplyScalar(inv);\n    this.relativeOrientation.invert(this.b1.orientation).multiply(this.targetOrientation).multiply(this.b2.orientation);\n    inv = this.relativeOrientation.w * 2;\n    this.vel.copy(this.relativeOrientation).multiplyScalar(inv);\n    len = this.vel.length();\n\n    if (len > 0.02) {\n      len = (0.02 - len) / len * invTimeStep * 0.05;\n      this.vel.multiplyScalar(len);\n    } else {\n      this.vel.set(0, 0, 0);\n    }\n\n    this.rn1.copy(this.imp).applyMatrix3(this.ii1, true);\n    this.rn2.copy(this.imp).applyMatrix3(this.ii2, true);\n    this.a1.add(this.rn1);\n    this.a2.sub(this.rn2);\n  },\n  solve: function () {\n    var r = this.a2.clone().sub(this.a1).sub(this.vel);\n    this.rn0.copy(r).applyMatrix3(this.dd, true);\n    this.rn1.copy(this.rn0).applyMatrix3(this.ii1, true);\n    this.rn2.copy(this.rn0).applyMatrix3(this.ii2, true);\n    this.imp.add(this.rn0);\n    this.a1.add(this.rn1);\n    this.a2.sub(this.rn2);\n  }\n});\n/**\n* A three-axis translational constraint for various joints.\n* @author saharan\n*/\n\nfunction Translational3Constraint(joint, limitMotor1, limitMotor2, limitMotor3) {\n  this.m1 = NaN;\n  this.m2 = NaN;\n  this.i1e00 = NaN;\n  this.i1e01 = NaN;\n  this.i1e02 = NaN;\n  this.i1e10 = NaN;\n  this.i1e11 = NaN;\n  this.i1e12 = NaN;\n  this.i1e20 = NaN;\n  this.i1e21 = NaN;\n  this.i1e22 = NaN;\n  this.i2e00 = NaN;\n  this.i2e01 = NaN;\n  this.i2e02 = NaN;\n  this.i2e10 = NaN;\n  this.i2e11 = NaN;\n  this.i2e12 = NaN;\n  this.i2e20 = NaN;\n  this.i2e21 = NaN;\n  this.i2e22 = NaN;\n  this.ax1 = NaN;\n  this.ay1 = NaN;\n  this.az1 = NaN;\n  this.ax2 = NaN;\n  this.ay2 = NaN;\n  this.az2 = NaN;\n  this.ax3 = NaN;\n  this.ay3 = NaN;\n  this.az3 = NaN;\n  this.r1x = NaN;\n  this.r1y = NaN;\n  this.r1z = NaN;\n  this.r2x = NaN;\n  this.r2y = NaN;\n  this.r2z = NaN;\n  this.t1x1 = NaN; // jacobians\n\n  this.t1y1 = NaN;\n  this.t1z1 = NaN;\n  this.t2x1 = NaN;\n  this.t2y1 = NaN;\n  this.t2z1 = NaN;\n  this.l1x1 = NaN;\n  this.l1y1 = NaN;\n  this.l1z1 = NaN;\n  this.l2x1 = NaN;\n  this.l2y1 = NaN;\n  this.l2z1 = NaN;\n  this.a1x1 = NaN;\n  this.a1y1 = NaN;\n  this.a1z1 = NaN;\n  this.a2x1 = NaN;\n  this.a2y1 = NaN;\n  this.a2z1 = NaN;\n  this.t1x2 = NaN;\n  this.t1y2 = NaN;\n  this.t1z2 = NaN;\n  this.t2x2 = NaN;\n  this.t2y2 = NaN;\n  this.t2z2 = NaN;\n  this.l1x2 = NaN;\n  this.l1y2 = NaN;\n  this.l1z2 = NaN;\n  this.l2x2 = NaN;\n  this.l2y2 = NaN;\n  this.l2z2 = NaN;\n  this.a1x2 = NaN;\n  this.a1y2 = NaN;\n  this.a1z2 = NaN;\n  this.a2x2 = NaN;\n  this.a2y2 = NaN;\n  this.a2z2 = NaN;\n  this.t1x3 = NaN;\n  this.t1y3 = NaN;\n  this.t1z3 = NaN;\n  this.t2x3 = NaN;\n  this.t2y3 = NaN;\n  this.t2z3 = NaN;\n  this.l1x3 = NaN;\n  this.l1y3 = NaN;\n  this.l1z3 = NaN;\n  this.l2x3 = NaN;\n  this.l2y3 = NaN;\n  this.l2z3 = NaN;\n  this.a1x3 = NaN;\n  this.a1y3 = NaN;\n  this.a1z3 = NaN;\n  this.a2x3 = NaN;\n  this.a2y3 = NaN;\n  this.a2z3 = NaN;\n  this.lowerLimit1 = NaN;\n  this.upperLimit1 = NaN;\n  this.limitVelocity1 = NaN;\n  this.limitState1 = 0; // -1: at lower, 0: locked, 1: at upper, 2: unlimited\n\n  this.enableMotor1 = false;\n  this.motorSpeed1 = NaN;\n  this.maxMotorForce1 = NaN;\n  this.maxMotorImpulse1 = NaN;\n  this.lowerLimit2 = NaN;\n  this.upperLimit2 = NaN;\n  this.limitVelocity2 = NaN;\n  this.limitState2 = 0; // -1: at lower, 0: locked, 1: at upper, 2: unlimited\n\n  this.enableMotor2 = false;\n  this.motorSpeed2 = NaN;\n  this.maxMotorForce2 = NaN;\n  this.maxMotorImpulse2 = NaN;\n  this.lowerLimit3 = NaN;\n  this.upperLimit3 = NaN;\n  this.limitVelocity3 = NaN;\n  this.limitState3 = 0; // -1: at lower, 0: locked, 1: at upper, 2: unlimited\n\n  this.enableMotor3 = false;\n  this.motorSpeed3 = NaN;\n  this.maxMotorForce3 = NaN;\n  this.maxMotorImpulse3 = NaN;\n  this.k00 = NaN; // K = J*M*JT\n\n  this.k01 = NaN;\n  this.k02 = NaN;\n  this.k10 = NaN;\n  this.k11 = NaN;\n  this.k12 = NaN;\n  this.k20 = NaN;\n  this.k21 = NaN;\n  this.k22 = NaN;\n  this.kv00 = NaN; // diagonals without CFMs\n\n  this.kv11 = NaN;\n  this.kv22 = NaN;\n  this.dv00 = NaN; // ...inverted\n\n  this.dv11 = NaN;\n  this.dv22 = NaN;\n  this.d00 = NaN; // K^-1\n\n  this.d01 = NaN;\n  this.d02 = NaN;\n  this.d10 = NaN;\n  this.d11 = NaN;\n  this.d12 = NaN;\n  this.d20 = NaN;\n  this.d21 = NaN;\n  this.d22 = NaN;\n  this.limitMotor1 = limitMotor1;\n  this.limitMotor2 = limitMotor2;\n  this.limitMotor3 = limitMotor3;\n  this.b1 = joint.body1;\n  this.b2 = joint.body2;\n  this.p1 = joint.anchorPoint1;\n  this.p2 = joint.anchorPoint2;\n  this.r1 = joint.relativeAnchorPoint1;\n  this.r2 = joint.relativeAnchorPoint2;\n  this.l1 = this.b1.linearVelocity;\n  this.l2 = this.b2.linearVelocity;\n  this.a1 = this.b1.angularVelocity;\n  this.a2 = this.b2.angularVelocity;\n  this.i1 = this.b1.inverseInertia;\n  this.i2 = this.b2.inverseInertia;\n  this.limitImpulse1 = 0;\n  this.motorImpulse1 = 0;\n  this.limitImpulse2 = 0;\n  this.motorImpulse2 = 0;\n  this.limitImpulse3 = 0;\n  this.motorImpulse3 = 0;\n  this.cfm1 = 0; // Constraint Force Mixing\n\n  this.cfm2 = 0;\n  this.cfm3 = 0;\n  this.weight = -1;\n}\n\nObject.assign(Translational3Constraint.prototype, {\n  Translational3Constraint: true,\n  preSolve: function (timeStep, invTimeStep) {\n    this.ax1 = this.limitMotor1.axis.x;\n    this.ay1 = this.limitMotor1.axis.y;\n    this.az1 = this.limitMotor1.axis.z;\n    this.ax2 = this.limitMotor2.axis.x;\n    this.ay2 = this.limitMotor2.axis.y;\n    this.az2 = this.limitMotor2.axis.z;\n    this.ax3 = this.limitMotor3.axis.x;\n    this.ay3 = this.limitMotor3.axis.y;\n    this.az3 = this.limitMotor3.axis.z;\n    this.lowerLimit1 = this.limitMotor1.lowerLimit;\n    this.upperLimit1 = this.limitMotor1.upperLimit;\n    this.motorSpeed1 = this.limitMotor1.motorSpeed;\n    this.maxMotorForce1 = this.limitMotor1.maxMotorForce;\n    this.enableMotor1 = this.maxMotorForce1 > 0;\n    this.lowerLimit2 = this.limitMotor2.lowerLimit;\n    this.upperLimit2 = this.limitMotor2.upperLimit;\n    this.motorSpeed2 = this.limitMotor2.motorSpeed;\n    this.maxMotorForce2 = this.limitMotor2.maxMotorForce;\n    this.enableMotor2 = this.maxMotorForce2 > 0;\n    this.lowerLimit3 = this.limitMotor3.lowerLimit;\n    this.upperLimit3 = this.limitMotor3.upperLimit;\n    this.motorSpeed3 = this.limitMotor3.motorSpeed;\n    this.maxMotorForce3 = this.limitMotor3.maxMotorForce;\n    this.enableMotor3 = this.maxMotorForce3 > 0;\n    this.m1 = this.b1.inverseMass;\n    this.m2 = this.b2.inverseMass;\n    var ti1 = this.i1.elements;\n    var ti2 = this.i2.elements;\n    this.i1e00 = ti1[0];\n    this.i1e01 = ti1[1];\n    this.i1e02 = ti1[2];\n    this.i1e10 = ti1[3];\n    this.i1e11 = ti1[4];\n    this.i1e12 = ti1[5];\n    this.i1e20 = ti1[6];\n    this.i1e21 = ti1[7];\n    this.i1e22 = ti1[8];\n    this.i2e00 = ti2[0];\n    this.i2e01 = ti2[1];\n    this.i2e02 = ti2[2];\n    this.i2e10 = ti2[3];\n    this.i2e11 = ti2[4];\n    this.i2e12 = ti2[5];\n    this.i2e20 = ti2[6];\n    this.i2e21 = ti2[7];\n    this.i2e22 = ti2[8];\n    var dx = this.p2.x - this.p1.x;\n    var dy = this.p2.y - this.p1.y;\n    var dz = this.p2.z - this.p1.z;\n    var d1 = dx * this.ax1 + dy * this.ay1 + dz * this.az1;\n    var d2 = dx * this.ax2 + dy * this.ay2 + dz * this.az2;\n    var d3 = dx * this.ax3 + dy * this.ay3 + dz * this.az3;\n    var frequency1 = this.limitMotor1.frequency;\n    var frequency2 = this.limitMotor2.frequency;\n    var frequency3 = this.limitMotor3.frequency;\n    var enableSpring1 = frequency1 > 0;\n    var enableSpring2 = frequency2 > 0;\n    var enableSpring3 = frequency3 > 0;\n    var enableLimit1 = this.lowerLimit1 <= this.upperLimit1;\n    var enableLimit2 = this.lowerLimit2 <= this.upperLimit2;\n    var enableLimit3 = this.lowerLimit3 <= this.upperLimit3; // for stability\n\n    if (enableSpring1 && d1 > 20 || d1 < -20) {\n      enableSpring1 = false;\n    }\n\n    if (enableSpring2 && d2 > 20 || d2 < -20) {\n      enableSpring2 = false;\n    }\n\n    if (enableSpring3 && d3 > 20 || d3 < -20) {\n      enableSpring3 = false;\n    }\n\n    if (enableLimit1) {\n      if (this.lowerLimit1 == this.upperLimit1) {\n        if (this.limitState1 != 0) {\n          this.limitState1 = 0;\n          this.limitImpulse1 = 0;\n        }\n\n        this.limitVelocity1 = this.lowerLimit1 - d1;\n        if (!enableSpring1) d1 = this.lowerLimit1;\n      } else if (d1 < this.lowerLimit1) {\n        if (this.limitState1 != -1) {\n          this.limitState1 = -1;\n          this.limitImpulse1 = 0;\n        }\n\n        this.limitVelocity1 = this.lowerLimit1 - d1;\n        if (!enableSpring1) d1 = this.lowerLimit1;\n      } else if (d1 > this.upperLimit1) {\n        if (this.limitState1 != 1) {\n          this.limitState1 = 1;\n          this.limitImpulse1 = 0;\n        }\n\n        this.limitVelocity1 = this.upperLimit1 - d1;\n        if (!enableSpring1) d1 = this.upperLimit1;\n      } else {\n        this.limitState1 = 2;\n        this.limitImpulse1 = 0;\n        this.limitVelocity1 = 0;\n      }\n\n      if (!enableSpring1) {\n        if (this.limitVelocity1 > 0.005) this.limitVelocity1 -= 0.005;else if (this.limitVelocity1 < -0.005) this.limitVelocity1 += 0.005;else this.limitVelocity1 = 0;\n      }\n    } else {\n      this.limitState1 = 2;\n      this.limitImpulse1 = 0;\n    }\n\n    if (enableLimit2) {\n      if (this.lowerLimit2 == this.upperLimit2) {\n        if (this.limitState2 != 0) {\n          this.limitState2 = 0;\n          this.limitImpulse2 = 0;\n        }\n\n        this.limitVelocity2 = this.lowerLimit2 - d2;\n        if (!enableSpring2) d2 = this.lowerLimit2;\n      } else if (d2 < this.lowerLimit2) {\n        if (this.limitState2 != -1) {\n          this.limitState2 = -1;\n          this.limitImpulse2 = 0;\n        }\n\n        this.limitVelocity2 = this.lowerLimit2 - d2;\n        if (!enableSpring2) d2 = this.lowerLimit2;\n      } else if (d2 > this.upperLimit2) {\n        if (this.limitState2 != 1) {\n          this.limitState2 = 1;\n          this.limitImpulse2 = 0;\n        }\n\n        this.limitVelocity2 = this.upperLimit2 - d2;\n        if (!enableSpring2) d2 = this.upperLimit2;\n      } else {\n        this.limitState2 = 2;\n        this.limitImpulse2 = 0;\n        this.limitVelocity2 = 0;\n      }\n\n      if (!enableSpring2) {\n        if (this.limitVelocity2 > 0.005) this.limitVelocity2 -= 0.005;else if (this.limitVelocity2 < -0.005) this.limitVelocity2 += 0.005;else this.limitVelocity2 = 0;\n      }\n    } else {\n      this.limitState2 = 2;\n      this.limitImpulse2 = 0;\n    }\n\n    if (enableLimit3) {\n      if (this.lowerLimit3 == this.upperLimit3) {\n        if (this.limitState3 != 0) {\n          this.limitState3 = 0;\n          this.limitImpulse3 = 0;\n        }\n\n        this.limitVelocity3 = this.lowerLimit3 - d3;\n        if (!enableSpring3) d3 = this.lowerLimit3;\n      } else if (d3 < this.lowerLimit3) {\n        if (this.limitState3 != -1) {\n          this.limitState3 = -1;\n          this.limitImpulse3 = 0;\n        }\n\n        this.limitVelocity3 = this.lowerLimit3 - d3;\n        if (!enableSpring3) d3 = this.lowerLimit3;\n      } else if (d3 > this.upperLimit3) {\n        if (this.limitState3 != 1) {\n          this.limitState3 = 1;\n          this.limitImpulse3 = 0;\n        }\n\n        this.limitVelocity3 = this.upperLimit3 - d3;\n        if (!enableSpring3) d3 = this.upperLimit3;\n      } else {\n        this.limitState3 = 2;\n        this.limitImpulse3 = 0;\n        this.limitVelocity3 = 0;\n      }\n\n      if (!enableSpring3) {\n        if (this.limitVelocity3 > 0.005) this.limitVelocity3 -= 0.005;else if (this.limitVelocity3 < -0.005) this.limitVelocity3 += 0.005;else this.limitVelocity3 = 0;\n      }\n    } else {\n      this.limitState3 = 2;\n      this.limitImpulse3 = 0;\n    }\n\n    if (this.enableMotor1 && (this.limitState1 != 0 || enableSpring1)) {\n      this.maxMotorImpulse1 = this.maxMotorForce1 * timeStep;\n    } else {\n      this.motorImpulse1 = 0;\n      this.maxMotorImpulse1 = 0;\n    }\n\n    if (this.enableMotor2 && (this.limitState2 != 0 || enableSpring2)) {\n      this.maxMotorImpulse2 = this.maxMotorForce2 * timeStep;\n    } else {\n      this.motorImpulse2 = 0;\n      this.maxMotorImpulse2 = 0;\n    }\n\n    if (this.enableMotor3 && (this.limitState3 != 0 || enableSpring3)) {\n      this.maxMotorImpulse3 = this.maxMotorForce3 * timeStep;\n    } else {\n      this.motorImpulse3 = 0;\n      this.maxMotorImpulse3 = 0;\n    }\n\n    var rdx = d1 * this.ax1 + d2 * this.ax2 + d3 * this.ax2;\n    var rdy = d1 * this.ay1 + d2 * this.ay2 + d3 * this.ay2;\n    var rdz = d1 * this.az1 + d2 * this.az2 + d3 * this.az2;\n    var w1 = this.m2 / (this.m1 + this.m2);\n    if (this.weight >= 0) w1 = this.weight; // use given weight\n\n    var w2 = 1 - w1;\n    this.r1x = this.r1.x + rdx * w1;\n    this.r1y = this.r1.y + rdy * w1;\n    this.r1z = this.r1.z + rdz * w1;\n    this.r2x = this.r2.x - rdx * w2;\n    this.r2y = this.r2.y - rdy * w2;\n    this.r2z = this.r2.z - rdz * w2; // build jacobians\n\n    this.t1x1 = this.r1y * this.az1 - this.r1z * this.ay1;\n    this.t1y1 = this.r1z * this.ax1 - this.r1x * this.az1;\n    this.t1z1 = this.r1x * this.ay1 - this.r1y * this.ax1;\n    this.t2x1 = this.r2y * this.az1 - this.r2z * this.ay1;\n    this.t2y1 = this.r2z * this.ax1 - this.r2x * this.az1;\n    this.t2z1 = this.r2x * this.ay1 - this.r2y * this.ax1;\n    this.l1x1 = this.ax1 * this.m1;\n    this.l1y1 = this.ay1 * this.m1;\n    this.l1z1 = this.az1 * this.m1;\n    this.l2x1 = this.ax1 * this.m2;\n    this.l2y1 = this.ay1 * this.m2;\n    this.l2z1 = this.az1 * this.m2;\n    this.a1x1 = this.t1x1 * this.i1e00 + this.t1y1 * this.i1e01 + this.t1z1 * this.i1e02;\n    this.a1y1 = this.t1x1 * this.i1e10 + this.t1y1 * this.i1e11 + this.t1z1 * this.i1e12;\n    this.a1z1 = this.t1x1 * this.i1e20 + this.t1y1 * this.i1e21 + this.t1z1 * this.i1e22;\n    this.a2x1 = this.t2x1 * this.i2e00 + this.t2y1 * this.i2e01 + this.t2z1 * this.i2e02;\n    this.a2y1 = this.t2x1 * this.i2e10 + this.t2y1 * this.i2e11 + this.t2z1 * this.i2e12;\n    this.a2z1 = this.t2x1 * this.i2e20 + this.t2y1 * this.i2e21 + this.t2z1 * this.i2e22;\n    this.t1x2 = this.r1y * this.az2 - this.r1z * this.ay2;\n    this.t1y2 = this.r1z * this.ax2 - this.r1x * this.az2;\n    this.t1z2 = this.r1x * this.ay2 - this.r1y * this.ax2;\n    this.t2x2 = this.r2y * this.az2 - this.r2z * this.ay2;\n    this.t2y2 = this.r2z * this.ax2 - this.r2x * this.az2;\n    this.t2z2 = this.r2x * this.ay2 - this.r2y * this.ax2;\n    this.l1x2 = this.ax2 * this.m1;\n    this.l1y2 = this.ay2 * this.m1;\n    this.l1z2 = this.az2 * this.m1;\n    this.l2x2 = this.ax2 * this.m2;\n    this.l2y2 = this.ay2 * this.m2;\n    this.l2z2 = this.az2 * this.m2;\n    this.a1x2 = this.t1x2 * this.i1e00 + this.t1y2 * this.i1e01 + this.t1z2 * this.i1e02;\n    this.a1y2 = this.t1x2 * this.i1e10 + this.t1y2 * this.i1e11 + this.t1z2 * this.i1e12;\n    this.a1z2 = this.t1x2 * this.i1e20 + this.t1y2 * this.i1e21 + this.t1z2 * this.i1e22;\n    this.a2x2 = this.t2x2 * this.i2e00 + this.t2y2 * this.i2e01 + this.t2z2 * this.i2e02;\n    this.a2y2 = this.t2x2 * this.i2e10 + this.t2y2 * this.i2e11 + this.t2z2 * this.i2e12;\n    this.a2z2 = this.t2x2 * this.i2e20 + this.t2y2 * this.i2e21 + this.t2z2 * this.i2e22;\n    this.t1x3 = this.r1y * this.az3 - this.r1z * this.ay3;\n    this.t1y3 = this.r1z * this.ax3 - this.r1x * this.az3;\n    this.t1z3 = this.r1x * this.ay3 - this.r1y * this.ax3;\n    this.t2x3 = this.r2y * this.az3 - this.r2z * this.ay3;\n    this.t2y3 = this.r2z * this.ax3 - this.r2x * this.az3;\n    this.t2z3 = this.r2x * this.ay3 - this.r2y * this.ax3;\n    this.l1x3 = this.ax3 * this.m1;\n    this.l1y3 = this.ay3 * this.m1;\n    this.l1z3 = this.az3 * this.m1;\n    this.l2x3 = this.ax3 * this.m2;\n    this.l2y3 = this.ay3 * this.m2;\n    this.l2z3 = this.az3 * this.m2;\n    this.a1x3 = this.t1x3 * this.i1e00 + this.t1y3 * this.i1e01 + this.t1z3 * this.i1e02;\n    this.a1y3 = this.t1x3 * this.i1e10 + this.t1y3 * this.i1e11 + this.t1z3 * this.i1e12;\n    this.a1z3 = this.t1x3 * this.i1e20 + this.t1y3 * this.i1e21 + this.t1z3 * this.i1e22;\n    this.a2x3 = this.t2x3 * this.i2e00 + this.t2y3 * this.i2e01 + this.t2z3 * this.i2e02;\n    this.a2y3 = this.t2x3 * this.i2e10 + this.t2y3 * this.i2e11 + this.t2z3 * this.i2e12;\n    this.a2z3 = this.t2x3 * this.i2e20 + this.t2y3 * this.i2e21 + this.t2z3 * this.i2e22; // build an impulse matrix\n\n    var m12 = this.m1 + this.m2;\n    this.k00 = (this.ax1 * this.ax1 + this.ay1 * this.ay1 + this.az1 * this.az1) * m12;\n    this.k01 = (this.ax1 * this.ax2 + this.ay1 * this.ay2 + this.az1 * this.az2) * m12;\n    this.k02 = (this.ax1 * this.ax3 + this.ay1 * this.ay3 + this.az1 * this.az3) * m12;\n    this.k10 = (this.ax2 * this.ax1 + this.ay2 * this.ay1 + this.az2 * this.az1) * m12;\n    this.k11 = (this.ax2 * this.ax2 + this.ay2 * this.ay2 + this.az2 * this.az2) * m12;\n    this.k12 = (this.ax2 * this.ax3 + this.ay2 * this.ay3 + this.az2 * this.az3) * m12;\n    this.k20 = (this.ax3 * this.ax1 + this.ay3 * this.ay1 + this.az3 * this.az1) * m12;\n    this.k21 = (this.ax3 * this.ax2 + this.ay3 * this.ay2 + this.az3 * this.az2) * m12;\n    this.k22 = (this.ax3 * this.ax3 + this.ay3 * this.ay3 + this.az3 * this.az3) * m12;\n    this.k00 += this.t1x1 * this.a1x1 + this.t1y1 * this.a1y1 + this.t1z1 * this.a1z1;\n    this.k01 += this.t1x1 * this.a1x2 + this.t1y1 * this.a1y2 + this.t1z1 * this.a1z2;\n    this.k02 += this.t1x1 * this.a1x3 + this.t1y1 * this.a1y3 + this.t1z1 * this.a1z3;\n    this.k10 += this.t1x2 * this.a1x1 + this.t1y2 * this.a1y1 + this.t1z2 * this.a1z1;\n    this.k11 += this.t1x2 * this.a1x2 + this.t1y2 * this.a1y2 + this.t1z2 * this.a1z2;\n    this.k12 += this.t1x2 * this.a1x3 + this.t1y2 * this.a1y3 + this.t1z2 * this.a1z3;\n    this.k20 += this.t1x3 * this.a1x1 + this.t1y3 * this.a1y1 + this.t1z3 * this.a1z1;\n    this.k21 += this.t1x3 * this.a1x2 + this.t1y3 * this.a1y2 + this.t1z3 * this.a1z2;\n    this.k22 += this.t1x3 * this.a1x3 + this.t1y3 * this.a1y3 + this.t1z3 * this.a1z3;\n    this.k00 += this.t2x1 * this.a2x1 + this.t2y1 * this.a2y1 + this.t2z1 * this.a2z1;\n    this.k01 += this.t2x1 * this.a2x2 + this.t2y1 * this.a2y2 + this.t2z1 * this.a2z2;\n    this.k02 += this.t2x1 * this.a2x3 + this.t2y1 * this.a2y3 + this.t2z1 * this.a2z3;\n    this.k10 += this.t2x2 * this.a2x1 + this.t2y2 * this.a2y1 + this.t2z2 * this.a2z1;\n    this.k11 += this.t2x2 * this.a2x2 + this.t2y2 * this.a2y2 + this.t2z2 * this.a2z2;\n    this.k12 += this.t2x2 * this.a2x3 + this.t2y2 * this.a2y3 + this.t2z2 * this.a2z3;\n    this.k20 += this.t2x3 * this.a2x1 + this.t2y3 * this.a2y1 + this.t2z3 * this.a2z1;\n    this.k21 += this.t2x3 * this.a2x2 + this.t2y3 * this.a2y2 + this.t2z3 * this.a2z2;\n    this.k22 += this.t2x3 * this.a2x3 + this.t2y3 * this.a2y3 + this.t2z3 * this.a2z3;\n    this.kv00 = this.k00;\n    this.kv11 = this.k11;\n    this.kv22 = this.k22;\n    this.dv00 = 1 / this.kv00;\n    this.dv11 = 1 / this.kv11;\n    this.dv22 = 1 / this.kv22;\n\n    if (enableSpring1 && this.limitState1 != 2) {\n      var omega = 6.2831853 * frequency1;\n      var k = omega * omega * timeStep;\n      var dmp = invTimeStep / (k + 2 * this.limitMotor1.dampingRatio * omega);\n      this.cfm1 = this.kv00 * dmp;\n      this.limitVelocity1 *= k * dmp;\n    } else {\n      this.cfm1 = 0;\n      this.limitVelocity1 *= invTimeStep * 0.05;\n    }\n\n    if (enableSpring2 && this.limitState2 != 2) {\n      omega = 6.2831853 * frequency2;\n      k = omega * omega * timeStep;\n      dmp = invTimeStep / (k + 2 * this.limitMotor2.dampingRatio * omega);\n      this.cfm2 = this.kv11 * dmp;\n      this.limitVelocity2 *= k * dmp;\n    } else {\n      this.cfm2 = 0;\n      this.limitVelocity2 *= invTimeStep * 0.05;\n    }\n\n    if (enableSpring3 && this.limitState3 != 2) {\n      omega = 6.2831853 * frequency3;\n      k = omega * omega * timeStep;\n      dmp = invTimeStep / (k + 2 * this.limitMotor3.dampingRatio * omega);\n      this.cfm3 = this.kv22 * dmp;\n      this.limitVelocity3 *= k * dmp;\n    } else {\n      this.cfm3 = 0;\n      this.limitVelocity3 *= invTimeStep * 0.05;\n    }\n\n    this.k00 += this.cfm1;\n    this.k11 += this.cfm2;\n    this.k22 += this.cfm3;\n    var inv = 1 / (this.k00 * (this.k11 * this.k22 - this.k21 * this.k12) + this.k10 * (this.k21 * this.k02 - this.k01 * this.k22) + this.k20 * (this.k01 * this.k12 - this.k11 * this.k02));\n    this.d00 = (this.k11 * this.k22 - this.k12 * this.k21) * inv;\n    this.d01 = (this.k02 * this.k21 - this.k01 * this.k22) * inv;\n    this.d02 = (this.k01 * this.k12 - this.k02 * this.k11) * inv;\n    this.d10 = (this.k12 * this.k20 - this.k10 * this.k22) * inv;\n    this.d11 = (this.k00 * this.k22 - this.k02 * this.k20) * inv;\n    this.d12 = (this.k02 * this.k10 - this.k00 * this.k12) * inv;\n    this.d20 = (this.k10 * this.k21 - this.k11 * this.k20) * inv;\n    this.d21 = (this.k01 * this.k20 - this.k00 * this.k21) * inv;\n    this.d22 = (this.k00 * this.k11 - this.k01 * this.k10) * inv; // warm starting\n\n    var totalImpulse1 = this.limitImpulse1 + this.motorImpulse1;\n    var totalImpulse2 = this.limitImpulse2 + this.motorImpulse2;\n    var totalImpulse3 = this.limitImpulse3 + this.motorImpulse3;\n    this.l1.x += totalImpulse1 * this.l1x1 + totalImpulse2 * this.l1x2 + totalImpulse3 * this.l1x3;\n    this.l1.y += totalImpulse1 * this.l1y1 + totalImpulse2 * this.l1y2 + totalImpulse3 * this.l1y3;\n    this.l1.z += totalImpulse1 * this.l1z1 + totalImpulse2 * this.l1z2 + totalImpulse3 * this.l1z3;\n    this.a1.x += totalImpulse1 * this.a1x1 + totalImpulse2 * this.a1x2 + totalImpulse3 * this.a1x3;\n    this.a1.y += totalImpulse1 * this.a1y1 + totalImpulse2 * this.a1y2 + totalImpulse3 * this.a1y3;\n    this.a1.z += totalImpulse1 * this.a1z1 + totalImpulse2 * this.a1z2 + totalImpulse3 * this.a1z3;\n    this.l2.x -= totalImpulse1 * this.l2x1 + totalImpulse2 * this.l2x2 + totalImpulse3 * this.l2x3;\n    this.l2.y -= totalImpulse1 * this.l2y1 + totalImpulse2 * this.l2y2 + totalImpulse3 * this.l2y3;\n    this.l2.z -= totalImpulse1 * this.l2z1 + totalImpulse2 * this.l2z2 + totalImpulse3 * this.l2z3;\n    this.a2.x -= totalImpulse1 * this.a2x1 + totalImpulse2 * this.a2x2 + totalImpulse3 * this.a2x3;\n    this.a2.y -= totalImpulse1 * this.a2y1 + totalImpulse2 * this.a2y2 + totalImpulse3 * this.a2y3;\n    this.a2.z -= totalImpulse1 * this.a2z1 + totalImpulse2 * this.a2z2 + totalImpulse3 * this.a2z3;\n  },\n  solve: function () {\n    var rvx = this.l2.x - this.l1.x + this.a2.y * this.r2z - this.a2.z * this.r2y - this.a1.y * this.r1z + this.a1.z * this.r1y;\n    var rvy = this.l2.y - this.l1.y + this.a2.z * this.r2x - this.a2.x * this.r2z - this.a1.z * this.r1x + this.a1.x * this.r1z;\n    var rvz = this.l2.z - this.l1.z + this.a2.x * this.r2y - this.a2.y * this.r2x - this.a1.x * this.r1y + this.a1.y * this.r1x;\n    var rvn1 = rvx * this.ax1 + rvy * this.ay1 + rvz * this.az1;\n    var rvn2 = rvx * this.ax2 + rvy * this.ay2 + rvz * this.az2;\n    var rvn3 = rvx * this.ax3 + rvy * this.ay3 + rvz * this.az3;\n    var oldMotorImpulse1 = this.motorImpulse1;\n    var oldMotorImpulse2 = this.motorImpulse2;\n    var oldMotorImpulse3 = this.motorImpulse3;\n    var dMotorImpulse1 = 0;\n    var dMotorImpulse2 = 0;\n    var dMotorImpulse3 = 0;\n\n    if (this.enableMotor1) {\n      dMotorImpulse1 = (rvn1 - this.motorSpeed1) * this.dv00;\n      this.motorImpulse1 += dMotorImpulse1;\n\n      if (this.motorImpulse1 > this.maxMotorImpulse1) {\n        // clamp motor impulse\n        this.motorImpulse1 = this.maxMotorImpulse1;\n      } else if (this.motorImpulse1 < -this.maxMotorImpulse1) {\n        this.motorImpulse1 = -this.maxMotorImpulse1;\n      }\n\n      dMotorImpulse1 = this.motorImpulse1 - oldMotorImpulse1;\n    }\n\n    if (this.enableMotor2) {\n      dMotorImpulse2 = (rvn2 - this.motorSpeed2) * this.dv11;\n      this.motorImpulse2 += dMotorImpulse2;\n\n      if (this.motorImpulse2 > this.maxMotorImpulse2) {\n        // clamp motor impulse\n        this.motorImpulse2 = this.maxMotorImpulse2;\n      } else if (this.motorImpulse2 < -this.maxMotorImpulse2) {\n        this.motorImpulse2 = -this.maxMotorImpulse2;\n      }\n\n      dMotorImpulse2 = this.motorImpulse2 - oldMotorImpulse2;\n    }\n\n    if (this.enableMotor3) {\n      dMotorImpulse3 = (rvn3 - this.motorSpeed3) * this.dv22;\n      this.motorImpulse3 += dMotorImpulse3;\n\n      if (this.motorImpulse3 > this.maxMotorImpulse3) {\n        // clamp motor impulse\n        this.motorImpulse3 = this.maxMotorImpulse3;\n      } else if (this.motorImpulse3 < -this.maxMotorImpulse3) {\n        this.motorImpulse3 = -this.maxMotorImpulse3;\n      }\n\n      dMotorImpulse3 = this.motorImpulse3 - oldMotorImpulse3;\n    } // apply motor impulse to relative velocity\n\n\n    rvn1 += dMotorImpulse1 * this.kv00 + dMotorImpulse2 * this.k01 + dMotorImpulse3 * this.k02;\n    rvn2 += dMotorImpulse1 * this.k10 + dMotorImpulse2 * this.kv11 + dMotorImpulse3 * this.k12;\n    rvn3 += dMotorImpulse1 * this.k20 + dMotorImpulse2 * this.k21 + dMotorImpulse3 * this.kv22; // subtract target velocity and applied impulse\n\n    rvn1 -= this.limitVelocity1 + this.limitImpulse1 * this.cfm1;\n    rvn2 -= this.limitVelocity2 + this.limitImpulse2 * this.cfm2;\n    rvn3 -= this.limitVelocity3 + this.limitImpulse3 * this.cfm3;\n    var oldLimitImpulse1 = this.limitImpulse1;\n    var oldLimitImpulse2 = this.limitImpulse2;\n    var oldLimitImpulse3 = this.limitImpulse3;\n    var dLimitImpulse1 = rvn1 * this.d00 + rvn2 * this.d01 + rvn3 * this.d02;\n    var dLimitImpulse2 = rvn1 * this.d10 + rvn2 * this.d11 + rvn3 * this.d12;\n    var dLimitImpulse3 = rvn1 * this.d20 + rvn2 * this.d21 + rvn3 * this.d22;\n    this.limitImpulse1 += dLimitImpulse1;\n    this.limitImpulse2 += dLimitImpulse2;\n    this.limitImpulse3 += dLimitImpulse3; // clamp\n\n    var clampState = 0;\n\n    if (this.limitState1 == 2 || this.limitImpulse1 * this.limitState1 < 0) {\n      dLimitImpulse1 = -oldLimitImpulse1;\n      rvn2 += dLimitImpulse1 * this.k10;\n      rvn3 += dLimitImpulse1 * this.k20;\n      clampState |= 1;\n    }\n\n    if (this.limitState2 == 2 || this.limitImpulse2 * this.limitState2 < 0) {\n      dLimitImpulse2 = -oldLimitImpulse2;\n      rvn1 += dLimitImpulse2 * this.k01;\n      rvn3 += dLimitImpulse2 * this.k21;\n      clampState |= 2;\n    }\n\n    if (this.limitState3 == 2 || this.limitImpulse3 * this.limitState3 < 0) {\n      dLimitImpulse3 = -oldLimitImpulse3;\n      rvn1 += dLimitImpulse3 * this.k02;\n      rvn2 += dLimitImpulse3 * this.k12;\n      clampState |= 4;\n    } // update un-clamped impulse\n    // TODO: isolate division\n\n\n    var det;\n\n    switch (clampState) {\n      case 1:\n        // update 2 3\n        det = 1 / (this.k11 * this.k22 - this.k12 * this.k21);\n        dLimitImpulse2 = (this.k22 * rvn2 + -this.k12 * rvn3) * det;\n        dLimitImpulse3 = (-this.k21 * rvn2 + this.k11 * rvn3) * det;\n        break;\n\n      case 2:\n        // update 1 3\n        det = 1 / (this.k00 * this.k22 - this.k02 * this.k20);\n        dLimitImpulse1 = (this.k22 * rvn1 + -this.k02 * rvn3) * det;\n        dLimitImpulse3 = (-this.k20 * rvn1 + this.k00 * rvn3) * det;\n        break;\n\n      case 3:\n        // update 3\n        dLimitImpulse3 = rvn3 / this.k22;\n        break;\n\n      case 4:\n        // update 1 2\n        det = 1 / (this.k00 * this.k11 - this.k01 * this.k10);\n        dLimitImpulse1 = (this.k11 * rvn1 + -this.k01 * rvn2) * det;\n        dLimitImpulse2 = (-this.k10 * rvn1 + this.k00 * rvn2) * det;\n        break;\n\n      case 5:\n        // update 2\n        dLimitImpulse2 = rvn2 / this.k11;\n        break;\n\n      case 6:\n        // update 1\n        dLimitImpulse1 = rvn1 / this.k00;\n        break;\n    }\n\n    this.limitImpulse1 = oldLimitImpulse1 + dLimitImpulse1;\n    this.limitImpulse2 = oldLimitImpulse2 + dLimitImpulse2;\n    this.limitImpulse3 = oldLimitImpulse3 + dLimitImpulse3;\n    var dImpulse1 = dMotorImpulse1 + dLimitImpulse1;\n    var dImpulse2 = dMotorImpulse2 + dLimitImpulse2;\n    var dImpulse3 = dMotorImpulse3 + dLimitImpulse3; // apply impulse\n\n    this.l1.x += dImpulse1 * this.l1x1 + dImpulse2 * this.l1x2 + dImpulse3 * this.l1x3;\n    this.l1.y += dImpulse1 * this.l1y1 + dImpulse2 * this.l1y2 + dImpulse3 * this.l1y3;\n    this.l1.z += dImpulse1 * this.l1z1 + dImpulse2 * this.l1z2 + dImpulse3 * this.l1z3;\n    this.a1.x += dImpulse1 * this.a1x1 + dImpulse2 * this.a1x2 + dImpulse3 * this.a1x3;\n    this.a1.y += dImpulse1 * this.a1y1 + dImpulse2 * this.a1y2 + dImpulse3 * this.a1y3;\n    this.a1.z += dImpulse1 * this.a1z1 + dImpulse2 * this.a1z2 + dImpulse3 * this.a1z3;\n    this.l2.x -= dImpulse1 * this.l2x1 + dImpulse2 * this.l2x2 + dImpulse3 * this.l2x3;\n    this.l2.y -= dImpulse1 * this.l2y1 + dImpulse2 * this.l2y2 + dImpulse3 * this.l2y3;\n    this.l2.z -= dImpulse1 * this.l2z1 + dImpulse2 * this.l2z2 + dImpulse3 * this.l2z3;\n    this.a2.x -= dImpulse1 * this.a2x1 + dImpulse2 * this.a2x2 + dImpulse3 * this.a2x3;\n    this.a2.y -= dImpulse1 * this.a2y1 + dImpulse2 * this.a2y2 + dImpulse3 * this.a2y3;\n    this.a2.z -= dImpulse1 * this.a2z1 + dImpulse2 * this.a2z2 + dImpulse3 * this.a2z3;\n  }\n});\n/**\n * A prismatic joint allows only for relative translation of rigid bodies along the axis.\n *\n * @author saharan\n * @author lo-th\n */\n\nfunction PrismaticJoint(config, lowerTranslation, upperTranslation) {\n  Joint.call(this, config);\n  this.type = JOINT_PRISMATIC; // The axis in the first body's coordinate system.\n\n  this.localAxis1 = config.localAxis1.clone().normalize(); // The axis in the second body's coordinate system.\n\n  this.localAxis2 = config.localAxis2.clone().normalize();\n  this.ax1 = new Vec3();\n  this.ax2 = new Vec3();\n  this.nor = new Vec3();\n  this.tan = new Vec3();\n  this.bin = new Vec3();\n  this.ac = new AngularConstraint(this, new Quat().setFromUnitVectors(this.localAxis1, this.localAxis2)); // The translational limit and motor information of the joint.\n\n  this.limitMotor = new LimitMotor(this.nor, true);\n  this.limitMotor.lowerLimit = lowerTranslation;\n  this.limitMotor.upperLimit = upperTranslation;\n  this.t3 = new Translational3Constraint(this, this.limitMotor, new LimitMotor(this.tan, true), new LimitMotor(this.bin, true));\n}\n\nPrismaticJoint.prototype = Object.assign(Object.create(Joint.prototype), {\n  constructor: PrismaticJoint,\n  preSolve: function (timeStep, invTimeStep) {\n    this.updateAnchorPoints();\n    this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, true);\n    this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, true); // normal tangent binormal\n\n    this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize();\n    this.tan.tangent(this.nor).normalize();\n    this.bin.crossVectors(this.nor, this.tan); // preSolve\n\n    this.ac.preSolve(timeStep, invTimeStep);\n    this.t3.preSolve(timeStep, invTimeStep);\n  },\n  solve: function () {\n    this.ac.solve();\n    this.t3.solve();\n  },\n  postSolve: function () {}\n});\n/**\n * A slider joint allows for relative translation and relative rotation between two rigid bodies along the axis.\n *\n * @author saharan\n * @author lo-th\n */\n\nfunction SliderJoint(config, lowerTranslation, upperTranslation) {\n  Joint.call(this, config);\n  this.type = JOINT_SLIDER; // The axis in the first body's coordinate system.\n\n  this.localAxis1 = config.localAxis1.clone().normalize(); // The axis in the second body's coordinate system.\n\n  this.localAxis2 = config.localAxis2.clone().normalize(); // make angle axis\n\n  var arc = new Mat33().setQuat(new Quat().setFromUnitVectors(this.localAxis1, this.localAxis2));\n  this.localAngle1 = new Vec3().tangent(this.localAxis1).normalize();\n  this.localAngle2 = this.localAngle1.clone().applyMatrix3(arc, true);\n  this.ax1 = new Vec3();\n  this.ax2 = new Vec3();\n  this.an1 = new Vec3();\n  this.an2 = new Vec3();\n  this.tmp = new Vec3();\n  this.nor = new Vec3();\n  this.tan = new Vec3();\n  this.bin = new Vec3(); // The limit and motor for the rotation\n\n  this.rotationalLimitMotor = new LimitMotor(this.nor, false);\n  this.r3 = new Rotational3Constraint(this, this.rotationalLimitMotor, new LimitMotor(this.tan, true), new LimitMotor(this.bin, true)); // The limit and motor for the translation.\n\n  this.translationalLimitMotor = new LimitMotor(this.nor, true);\n  this.translationalLimitMotor.lowerLimit = lowerTranslation;\n  this.translationalLimitMotor.upperLimit = upperTranslation;\n  this.t3 = new Translational3Constraint(this, this.translationalLimitMotor, new LimitMotor(this.tan, true), new LimitMotor(this.bin, true));\n}\n\nSliderJoint.prototype = Object.assign(Object.create(Joint.prototype), {\n  constructor: SliderJoint,\n  preSolve: function (timeStep, invTimeStep) {\n    this.updateAnchorPoints();\n    this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, true);\n    this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, true);\n    this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, true);\n    this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, true); // normal tangent binormal\n\n    this.nor.set(this.ax1.x * this.body2.inverseMass + this.ax2.x * this.body1.inverseMass, this.ax1.y * this.body2.inverseMass + this.ax2.y * this.body1.inverseMass, this.ax1.z * this.body2.inverseMass + this.ax2.z * this.body1.inverseMass).normalize();\n    this.tan.tangent(this.nor).normalize();\n    this.bin.crossVectors(this.nor, this.tan); // calculate hinge angle\n\n    this.tmp.crossVectors(this.an1, this.an2);\n\n    var limite = _Math.acosClamp(_Math.dotVectors(this.an1, this.an2));\n\n    if (_Math.dotVectors(this.nor, this.tmp) < 0) this.rotationalLimitMotor.angle = -limite;else this.rotationalLimitMotor.angle = limite; // angular error\n\n    this.tmp.crossVectors(this.ax1, this.ax2);\n    this.r3.limitMotor2.angle = _Math.dotVectors(this.tan, this.tmp);\n    this.r3.limitMotor3.angle = _Math.dotVectors(this.bin, this.tmp); // preSolve\n\n    this.r3.preSolve(timeStep, invTimeStep);\n    this.t3.preSolve(timeStep, invTimeStep);\n  },\n  solve: function () {\n    this.r3.solve();\n    this.t3.solve();\n  },\n  postSolve: function () {}\n});\n/**\n * A wheel joint allows for relative rotation between two rigid bodies along two axes.\n * The wheel joint also allows for relative translation for the suspension.\n *\n * @author saharan\n * @author lo-th\n */\n\nfunction WheelJoint(config) {\n  Joint.call(this, config);\n  this.type = JOINT_WHEEL; // The axis in the first body's coordinate system.\n\n  this.localAxis1 = config.localAxis1.clone().normalize(); // The axis in the second body's coordinate system.\n\n  this.localAxis2 = config.localAxis2.clone().normalize();\n  this.localAngle1 = new Vec3();\n  this.localAngle2 = new Vec3();\n\n  var dot = _Math.dotVectors(this.localAxis1, this.localAxis2);\n\n  if (dot > -1 && dot < 1) {\n    this.localAngle1.set(this.localAxis2.x - dot * this.localAxis1.x, this.localAxis2.y - dot * this.localAxis1.y, this.localAxis2.z - dot * this.localAxis1.z).normalize();\n    this.localAngle2.set(this.localAxis1.x - dot * this.localAxis2.x, this.localAxis1.y - dot * this.localAxis2.y, this.localAxis1.z - dot * this.localAxis2.z).normalize();\n  } else {\n    var arc = new Mat33().setQuat(new Quat().setFromUnitVectors(this.localAxis1, this.localAxis2));\n    this.localAngle1.tangent(this.localAxis1).normalize();\n    this.localAngle2 = this.localAngle1.clone().applyMatrix3(arc, true);\n  }\n\n  this.ax1 = new Vec3();\n  this.ax2 = new Vec3();\n  this.an1 = new Vec3();\n  this.an2 = new Vec3();\n  this.tmp = new Vec3();\n  this.nor = new Vec3();\n  this.tan = new Vec3();\n  this.bin = new Vec3(); // The translational limit and motor information of the joint.\n\n  this.translationalLimitMotor = new LimitMotor(this.tan, true);\n  this.translationalLimitMotor.frequency = 8;\n  this.translationalLimitMotor.dampingRatio = 1; // The first rotational limit and motor information of the joint.\n\n  this.rotationalLimitMotor1 = new LimitMotor(this.tan, false); // The second rotational limit and motor information of the joint.\n\n  this.rotationalLimitMotor2 = new LimitMotor(this.bin, false);\n  this.t3 = new Translational3Constraint(this, new LimitMotor(this.nor, true), this.translationalLimitMotor, new LimitMotor(this.bin, true));\n  this.t3.weight = 1;\n  this.r3 = new Rotational3Constraint(this, new LimitMotor(this.nor, true), this.rotationalLimitMotor1, this.rotationalLimitMotor2);\n}\n\nWheelJoint.prototype = Object.assign(Object.create(Joint.prototype), {\n  constructor: WheelJoint,\n  preSolve: function (timeStep, invTimeStep) {\n    this.updateAnchorPoints();\n    this.ax1.copy(this.localAxis1).applyMatrix3(this.body1.rotation, true);\n    this.an1.copy(this.localAngle1).applyMatrix3(this.body1.rotation, true);\n    this.ax2.copy(this.localAxis2).applyMatrix3(this.body2.rotation, true);\n    this.an2.copy(this.localAngle2).applyMatrix3(this.body2.rotation, true);\n    this.r3.limitMotor1.angle = _Math.dotVectors(this.ax1, this.ax2);\n\n    var limite = _Math.dotVectors(this.an1, this.ax2);\n\n    if (_Math.dotVectors(this.ax1, this.tmp.crossVectors(this.an1, this.ax2)) < 0) this.rotationalLimitMotor1.angle = -limite;else this.rotationalLimitMotor1.angle = limite;\n    limite = _Math.dotVectors(this.an2, this.ax1);\n    if (_Math.dotVectors(this.ax2, this.tmp.crossVectors(this.an2, this.ax1)) < 0) this.rotationalLimitMotor2.angle = -limite;else this.rotationalLimitMotor2.angle = limite;\n    this.nor.crossVectors(this.ax1, this.ax2).normalize();\n    this.tan.crossVectors(this.nor, this.ax2).normalize();\n    this.bin.crossVectors(this.nor, this.ax1).normalize();\n    this.r3.preSolve(timeStep, invTimeStep);\n    this.t3.preSolve(timeStep, invTimeStep);\n  },\n  solve: function () {\n    this.r3.solve();\n    this.t3.solve();\n  },\n  postSolve: function () {}\n});\n\nfunction JointConfig() {\n  this.scale = 1;\n  this.invScale = 1; // The first rigid body of the joint.\n\n  this.body1 = null; // The second rigid body of the joint.\n\n  this.body2 = null; // The anchor point on the first rigid body in local coordinate system.\n\n  this.localAnchorPoint1 = new Vec3(); //  The anchor point on the second rigid body in local coordinate system.\n\n  this.localAnchorPoint2 = new Vec3(); // The axis in the first body's coordinate system.\n  // his property is available in some joints.\n\n  this.localAxis1 = new Vec3(); // The axis in the second body's coordinate system.\n  // This property is available in some joints.\n\n  this.localAxis2 = new Vec3(); //  Whether allow collision between connected rigid bodies or not.\n\n  this.allowCollision = false;\n}\n/**\r\n * This class holds mass information of a shape.\r\n * @author lo-th\r\n * @author saharan\r\n */\n\n\nfunction MassInfo() {\n  // Mass of the shape.\n  this.mass = 0; // The moment inertia of the shape.\n\n  this.inertia = new Mat33();\n}\n/**\n* A link list of contacts.\n* @author saharan\n*/\n\n\nfunction ContactLink(contact) {\n  // The previous contact link.\n  this.prev = null; // The next contact link.\n\n  this.next = null; // The shape of the contact.\n\n  this.shape = null; // The other rigid body.\n\n  this.body = null; // The contact of the link.\n\n  this.contact = contact;\n}\n\nfunction ImpulseDataBuffer() {\n  this.lp1X = NaN;\n  this.lp1Y = NaN;\n  this.lp1Z = NaN;\n  this.lp2X = NaN;\n  this.lp2Y = NaN;\n  this.lp2Z = NaN;\n  this.impulse = NaN;\n}\n/**\n* The class holds details of the contact point.\n* @author saharan\n*/\n\n\nfunction ManifoldPoint() {\n  // Whether this manifold point is persisting or not.\n  this.warmStarted = false; //  The position of this manifold point.\n\n  this.position = new Vec3(); // The position in the first shape's coordinate.\n\n  this.localPoint1 = new Vec3(); //  The position in the second shape's coordinate.\n\n  this.localPoint2 = new Vec3(); // The normal vector of this manifold point.\n\n  this.normal = new Vec3(); // The tangent vector of this manifold point.\n\n  this.tangent = new Vec3(); // The binormal vector of this manifold point.\n\n  this.binormal = new Vec3(); // The impulse in normal direction.\n\n  this.normalImpulse = 0; // The impulse in tangent direction.\n\n  this.tangentImpulse = 0; // The impulse in binormal direction.\n\n  this.binormalImpulse = 0; // The denominator in normal direction.\n\n  this.normalDenominator = 0; // The denominator in tangent direction.\n\n  this.tangentDenominator = 0; // The denominator in binormal direction.\n\n  this.binormalDenominator = 0; // The depth of penetration.\n\n  this.penetration = 0;\n}\n/**\n* A contact manifold between two shapes.\n* @author saharan\n* @author lo-th\n*/\n\n\nfunction ContactManifold() {\n  // The first rigid body.\n  this.body1 = null; // The second rigid body.\n\n  this.body2 = null; // The number of manifold points.\n\n  this.numPoints = 0; // The manifold points.\n\n  this.points = [new ManifoldPoint(), new ManifoldPoint(), new ManifoldPoint(), new ManifoldPoint()];\n}\n\nContactManifold.prototype = {\n  constructor: ContactManifold,\n  //Reset the manifold.\n  reset: function (shape1, shape2) {\n    this.body1 = shape1.parent;\n    this.body2 = shape2.parent;\n    this.numPoints = 0;\n  },\n  //  Add a point into this manifold.\n  addPointVec: function (pos, norm, penetration, flip) {\n    var p = this.points[this.numPoints++];\n    p.position.copy(pos);\n    p.localPoint1.sub(pos, this.body1.position).applyMatrix3(this.body1.rotation);\n    p.localPoint2.sub(pos, this.body2.position).applyMatrix3(this.body2.rotation);\n    p.normal.copy(norm);\n    if (flip) p.normal.negate();\n    p.normalImpulse = 0;\n    p.penetration = penetration;\n    p.warmStarted = false;\n  },\n  //  Add a point into this manifold.\n  addPoint: function (x, y, z, nx, ny, nz, penetration, flip) {\n    var p = this.points[this.numPoints++];\n    p.position.set(x, y, z);\n    p.localPoint1.sub(p.position, this.body1.position).applyMatrix3(this.body1.rotation);\n    p.localPoint2.sub(p.position, this.body2.position).applyMatrix3(this.body2.rotation);\n    p.normalImpulse = 0;\n    p.normal.set(nx, ny, nz);\n    if (flip) p.normal.negate();\n    p.penetration = penetration;\n    p.warmStarted = false;\n  }\n};\n\nfunction ContactPointDataBuffer() {\n  this.nor = new Vec3();\n  this.tan = new Vec3();\n  this.bin = new Vec3();\n  this.norU1 = new Vec3();\n  this.tanU1 = new Vec3();\n  this.binU1 = new Vec3();\n  this.norU2 = new Vec3();\n  this.tanU2 = new Vec3();\n  this.binU2 = new Vec3();\n  this.norT1 = new Vec3();\n  this.tanT1 = new Vec3();\n  this.binT1 = new Vec3();\n  this.norT2 = new Vec3();\n  this.tanT2 = new Vec3();\n  this.binT2 = new Vec3();\n  this.norTU1 = new Vec3();\n  this.tanTU1 = new Vec3();\n  this.binTU1 = new Vec3();\n  this.norTU2 = new Vec3();\n  this.tanTU2 = new Vec3();\n  this.binTU2 = new Vec3();\n  this.norImp = 0;\n  this.tanImp = 0;\n  this.binImp = 0;\n  this.norDen = 0;\n  this.tanDen = 0;\n  this.binDen = 0;\n  this.norTar = 0;\n  this.next = null;\n  this.last = false;\n}\n/**\n* ...\n* @author saharan\n*/\n\n\nfunction ContactConstraint(manifold) {\n  Constraint.call(this); // The contact manifold of the constraint.\n\n  this.manifold = manifold; // The coefficient of restitution of the constraint.\n\n  this.restitution = NaN; // The coefficient of friction of the constraint.\n\n  this.friction = NaN;\n  this.p1 = null;\n  this.p2 = null;\n  this.lv1 = null;\n  this.lv2 = null;\n  this.av1 = null;\n  this.av2 = null;\n  this.i1 = null;\n  this.i2 = null; //this.ii1 = null;\n  //this.ii2 = null;\n\n  this.tmp = new Vec3();\n  this.tmpC1 = new Vec3();\n  this.tmpC2 = new Vec3();\n  this.tmpP1 = new Vec3();\n  this.tmpP2 = new Vec3();\n  this.tmplv1 = new Vec3();\n  this.tmplv2 = new Vec3();\n  this.tmpav1 = new Vec3();\n  this.tmpav2 = new Vec3();\n  this.m1 = NaN;\n  this.m2 = NaN;\n  this.num = 0;\n  this.ps = manifold.points;\n  this.cs = new ContactPointDataBuffer();\n  this.cs.next = new ContactPointDataBuffer();\n  this.cs.next.next = new ContactPointDataBuffer();\n  this.cs.next.next.next = new ContactPointDataBuffer();\n}\n\nContactConstraint.prototype = Object.assign(Object.create(Constraint.prototype), {\n  constructor: ContactConstraint,\n  // Attach the constraint to the bodies.\n  attach: function () {\n    this.p1 = this.body1.position;\n    this.p2 = this.body2.position;\n    this.lv1 = this.body1.linearVelocity;\n    this.av1 = this.body1.angularVelocity;\n    this.lv2 = this.body2.linearVelocity;\n    this.av2 = this.body2.angularVelocity;\n    this.i1 = this.body1.inverseInertia;\n    this.i2 = this.body2.inverseInertia;\n  },\n  // Detach the constraint from the bodies.\n  detach: function () {\n    this.p1 = null;\n    this.p2 = null;\n    this.lv1 = null;\n    this.lv2 = null;\n    this.av1 = null;\n    this.av2 = null;\n    this.i1 = null;\n    this.i2 = null;\n  },\n  preSolve: function (timeStep, invTimeStep) {\n    this.m1 = this.body1.inverseMass;\n    this.m2 = this.body2.inverseMass;\n    var m1m2 = this.m1 + this.m2;\n    this.num = this.manifold.numPoints;\n    var c = this.cs;\n    var p, rvn, len, norImp, norTar, sepV, i1, i2;\n\n    for (var i = 0; i < this.num; i++) {\n      p = this.ps[i];\n      this.tmpP1.sub(p.position, this.p1);\n      this.tmpP2.sub(p.position, this.p2);\n      this.tmpC1.crossVectors(this.av1, this.tmpP1);\n      this.tmpC2.crossVectors(this.av2, this.tmpP2);\n      c.norImp = p.normalImpulse;\n      c.tanImp = p.tangentImpulse;\n      c.binImp = p.binormalImpulse;\n      c.nor.copy(p.normal);\n      this.tmp.set(this.lv2.x + this.tmpC2.x - (this.lv1.x + this.tmpC1.x), this.lv2.y + this.tmpC2.y - (this.lv1.y + this.tmpC1.y), this.lv2.z + this.tmpC2.z - (this.lv1.z + this.tmpC1.z));\n      rvn = _Math.dotVectors(c.nor, this.tmp);\n      c.tan.set(this.tmp.x - rvn * c.nor.x, this.tmp.y - rvn * c.nor.y, this.tmp.z - rvn * c.nor.z);\n      len = _Math.dotVectors(c.tan, c.tan);\n\n      if (len <= 0.04) {\n        c.tan.tangent(c.nor);\n      }\n\n      c.tan.normalize();\n      c.bin.crossVectors(c.nor, c.tan);\n      c.norU1.scale(c.nor, this.m1);\n      c.norU2.scale(c.nor, this.m2);\n      c.tanU1.scale(c.tan, this.m1);\n      c.tanU2.scale(c.tan, this.m2);\n      c.binU1.scale(c.bin, this.m1);\n      c.binU2.scale(c.bin, this.m2);\n      c.norT1.crossVectors(this.tmpP1, c.nor);\n      c.tanT1.crossVectors(this.tmpP1, c.tan);\n      c.binT1.crossVectors(this.tmpP1, c.bin);\n      c.norT2.crossVectors(this.tmpP2, c.nor);\n      c.tanT2.crossVectors(this.tmpP2, c.tan);\n      c.binT2.crossVectors(this.tmpP2, c.bin);\n      i1 = this.i1;\n      i2 = this.i2;\n      c.norTU1.copy(c.norT1).applyMatrix3(i1, true);\n      c.tanTU1.copy(c.tanT1).applyMatrix3(i1, true);\n      c.binTU1.copy(c.binT1).applyMatrix3(i1, true);\n      c.norTU2.copy(c.norT2).applyMatrix3(i2, true);\n      c.tanTU2.copy(c.tanT2).applyMatrix3(i2, true);\n      c.binTU2.copy(c.binT2).applyMatrix3(i2, true);\n      /*c.norTU1.mulMat( this.i1, c.norT1 );\n      c.tanTU1.mulMat( this.i1, c.tanT1 );\n      c.binTU1.mulMat( this.i1, c.binT1 );\n       c.norTU2.mulMat( this.i2, c.norT2 );\n      c.tanTU2.mulMat( this.i2, c.tanT2 );\n      c.binTU2.mulMat( this.i2, c.binT2 );*/\n\n      this.tmpC1.crossVectors(c.norTU1, this.tmpP1);\n      this.tmpC2.crossVectors(c.norTU2, this.tmpP2);\n      this.tmp.add(this.tmpC1, this.tmpC2);\n      c.norDen = 1 / (m1m2 + _Math.dotVectors(c.nor, this.tmp));\n      this.tmpC1.crossVectors(c.tanTU1, this.tmpP1);\n      this.tmpC2.crossVectors(c.tanTU2, this.tmpP2);\n      this.tmp.add(this.tmpC1, this.tmpC2);\n      c.tanDen = 1 / (m1m2 + _Math.dotVectors(c.tan, this.tmp));\n      this.tmpC1.crossVectors(c.binTU1, this.tmpP1);\n      this.tmpC2.crossVectors(c.binTU2, this.tmpP2);\n      this.tmp.add(this.tmpC1, this.tmpC2);\n      c.binDen = 1 / (m1m2 + _Math.dotVectors(c.bin, this.tmp));\n\n      if (p.warmStarted) {\n        norImp = p.normalImpulse;\n        this.lv1.addScaledVector(c.norU1, norImp);\n        this.av1.addScaledVector(c.norTU1, norImp);\n        this.lv2.subScaledVector(c.norU2, norImp);\n        this.av2.subScaledVector(c.norTU2, norImp);\n        c.norImp = norImp;\n        c.tanImp = 0;\n        c.binImp = 0;\n        rvn = 0; // disable bouncing\n      } else {\n        c.norImp = 0;\n        c.tanImp = 0;\n        c.binImp = 0;\n      }\n\n      if (rvn > -1) rvn = 0; // disable bouncing\n\n      norTar = this.restitution * -rvn;\n      sepV = -(p.penetration + 0.005) * invTimeStep * 0.05; // allow 0.5cm error\n\n      if (norTar < sepV) norTar = sepV;\n      c.norTar = norTar;\n      c.last = i == this.num - 1;\n      c = c.next;\n    }\n  },\n  solve: function () {\n    this.tmplv1.copy(this.lv1);\n    this.tmplv2.copy(this.lv2);\n    this.tmpav1.copy(this.av1);\n    this.tmpav2.copy(this.av2);\n    var oldImp1, newImp1, oldImp2, newImp2, rvn, norImp, tanImp, binImp, max, len;\n    var c = this.cs;\n\n    while (true) {\n      norImp = c.norImp;\n      tanImp = c.tanImp;\n      binImp = c.binImp;\n      max = -norImp * this.friction;\n      this.tmp.sub(this.tmplv2, this.tmplv1);\n      rvn = _Math.dotVectors(this.tmp, c.tan) + _Math.dotVectors(this.tmpav2, c.tanT2) - _Math.dotVectors(this.tmpav1, c.tanT1);\n      oldImp1 = tanImp;\n      newImp1 = rvn * c.tanDen;\n      tanImp += newImp1;\n      rvn = _Math.dotVectors(this.tmp, c.bin) + _Math.dotVectors(this.tmpav2, c.binT2) - _Math.dotVectors(this.tmpav1, c.binT1);\n      oldImp2 = binImp;\n      newImp2 = rvn * c.binDen;\n      binImp += newImp2; // cone friction clamp\n\n      len = tanImp * tanImp + binImp * binImp;\n\n      if (len > max * max) {\n        len = max / _Math.sqrt(len);\n        tanImp *= len;\n        binImp *= len;\n      }\n\n      newImp1 = tanImp - oldImp1;\n      newImp2 = binImp - oldImp2; //\n\n      this.tmp.set(c.tanU1.x * newImp1 + c.binU1.x * newImp2, c.tanU1.y * newImp1 + c.binU1.y * newImp2, c.tanU1.z * newImp1 + c.binU1.z * newImp2);\n      this.tmplv1.addEqual(this.tmp);\n      this.tmp.set(c.tanTU1.x * newImp1 + c.binTU1.x * newImp2, c.tanTU1.y * newImp1 + c.binTU1.y * newImp2, c.tanTU1.z * newImp1 + c.binTU1.z * newImp2);\n      this.tmpav1.addEqual(this.tmp);\n      this.tmp.set(c.tanU2.x * newImp1 + c.binU2.x * newImp2, c.tanU2.y * newImp1 + c.binU2.y * newImp2, c.tanU2.z * newImp1 + c.binU2.z * newImp2);\n      this.tmplv2.subEqual(this.tmp);\n      this.tmp.set(c.tanTU2.x * newImp1 + c.binTU2.x * newImp2, c.tanTU2.y * newImp1 + c.binTU2.y * newImp2, c.tanTU2.z * newImp1 + c.binTU2.z * newImp2);\n      this.tmpav2.subEqual(this.tmp); // restitution part\n\n      this.tmp.sub(this.tmplv2, this.tmplv1);\n      rvn = _Math.dotVectors(this.tmp, c.nor) + _Math.dotVectors(this.tmpav2, c.norT2) - _Math.dotVectors(this.tmpav1, c.norT1);\n      oldImp1 = norImp;\n      newImp1 = (rvn - c.norTar) * c.norDen;\n      norImp += newImp1;\n      if (norImp > 0) norImp = 0;\n      newImp1 = norImp - oldImp1;\n      this.tmplv1.addScaledVector(c.norU1, newImp1);\n      this.tmpav1.addScaledVector(c.norTU1, newImp1);\n      this.tmplv2.subScaledVector(c.norU2, newImp1);\n      this.tmpav2.subScaledVector(c.norTU2, newImp1);\n      c.norImp = norImp;\n      c.tanImp = tanImp;\n      c.binImp = binImp;\n      if (c.last) break;\n      c = c.next;\n    }\n\n    this.lv1.copy(this.tmplv1);\n    this.lv2.copy(this.tmplv2);\n    this.av1.copy(this.tmpav1);\n    this.av2.copy(this.tmpav2);\n  },\n  postSolve: function () {\n    var c = this.cs,\n        p;\n    var i = this.num;\n\n    while (i--) {\n      //for(var i=0;i<this.num;i++){\n      p = this.ps[i];\n      p.normal.copy(c.nor);\n      p.tangent.copy(c.tan);\n      p.binormal.copy(c.bin);\n      p.normalImpulse = c.norImp;\n      p.tangentImpulse = c.tanImp;\n      p.binormalImpulse = c.binImp;\n      p.normalDenominator = c.norDen;\n      p.tangentDenominator = c.tanDen;\n      p.binormalDenominator = c.binDen;\n      c = c.next;\n    }\n  }\n});\n/**\n* A contact is a pair of shapes whose axis-aligned bounding boxes are overlapping.\n* @author saharan\n*/\n\nfunction Contact() {\n  // The first shape.\n  this.shape1 = null; // The second shape.\n\n  this.shape2 = null; // The first rigid body.\n\n  this.body1 = null; // The second rigid body.\n\n  this.body2 = null; // The previous contact in the world.\n\n  this.prev = null; // The next contact in the world.\n\n  this.next = null; // Internal\n\n  this.persisting = false; // Whether both the rigid bodies are sleeping or not.\n\n  this.sleeping = false; // The collision detector between two shapes.\n\n  this.detector = null; // The contact constraint of the contact.\n\n  this.constraint = null; // Whether the shapes are touching or not.\n\n  this.touching = false; // shapes is very close and touching \n\n  this.close = false;\n  this.dist = _Math.INF;\n  this.b1Link = new ContactLink(this);\n  this.b2Link = new ContactLink(this);\n  this.s1Link = new ContactLink(this);\n  this.s2Link = new ContactLink(this); // The contact manifold of the contact.\n\n  this.manifold = new ContactManifold();\n  this.buffer = [new ImpulseDataBuffer(), new ImpulseDataBuffer(), new ImpulseDataBuffer(), new ImpulseDataBuffer()];\n  this.points = this.manifold.points;\n  this.constraint = new ContactConstraint(this.manifold);\n}\n\nObject.assign(Contact.prototype, {\n  Contact: true,\n  mixRestitution: function (restitution1, restitution2) {\n    return _Math.sqrt(restitution1 * restitution2);\n  },\n  mixFriction: function (friction1, friction2) {\n    return _Math.sqrt(friction1 * friction2);\n  },\n\n  /**\n  * Update the contact manifold.\n  */\n  updateManifold: function () {\n    this.constraint.restitution = this.mixRestitution(this.shape1.restitution, this.shape2.restitution);\n    this.constraint.friction = this.mixFriction(this.shape1.friction, this.shape2.friction);\n    var numBuffers = this.manifold.numPoints;\n    var i = numBuffers;\n\n    while (i--) {\n      //for(var i=0;i<numBuffers;i++){\n      var b = this.buffer[i];\n      var p = this.points[i];\n      b.lp1X = p.localPoint1.x;\n      b.lp1Y = p.localPoint1.y;\n      b.lp1Z = p.localPoint1.z;\n      b.lp2X = p.localPoint2.x;\n      b.lp2Y = p.localPoint2.y;\n      b.lp2Z = p.localPoint2.z;\n      b.impulse = p.normalImpulse;\n    }\n\n    this.manifold.numPoints = 0;\n    this.detector.detectCollision(this.shape1, this.shape2, this.manifold);\n    var num = this.manifold.numPoints;\n\n    if (num == 0) {\n      this.touching = false;\n      this.close = false;\n      this.dist = _Math.INF;\n      return;\n    }\n\n    if (this.touching || this.dist < 0.001) this.close = true;\n    this.touching = true;\n    i = num;\n\n    while (i--) {\n      //for(i=0; i<num; i++){\n      p = this.points[i];\n      var lp1x = p.localPoint1.x;\n      var lp1y = p.localPoint1.y;\n      var lp1z = p.localPoint1.z;\n      var lp2x = p.localPoint2.x;\n      var lp2y = p.localPoint2.y;\n      var lp2z = p.localPoint2.z;\n      var index = -1;\n      var minDistance = 0.0004;\n      var j = numBuffers;\n\n      while (j--) {\n        //for(var j=0;j<numBuffers;j++){\n        b = this.buffer[j];\n        var dx = b.lp1X - lp1x;\n        var dy = b.lp1Y - lp1y;\n        var dz = b.lp1Z - lp1z;\n        var distance1 = dx * dx + dy * dy + dz * dz;\n        dx = b.lp2X - lp2x;\n        dy = b.lp2Y - lp2y;\n        dz = b.lp2Z - lp2z;\n        var distance2 = dx * dx + dy * dy + dz * dz;\n\n        if (distance1 < distance2) {\n          if (distance1 < minDistance) {\n            minDistance = distance1;\n            index = j;\n          }\n        } else {\n          if (distance2 < minDistance) {\n            minDistance = distance2;\n            index = j;\n          }\n        }\n\n        if (minDistance < this.dist) this.dist = minDistance;\n      }\n\n      if (index != -1) {\n        var tmp = this.buffer[index];\n        this.buffer[index] = this.buffer[--numBuffers];\n        this.buffer[numBuffers] = tmp;\n        p.normalImpulse = tmp.impulse;\n        p.warmStarted = true;\n      } else {\n        p.normalImpulse = 0;\n        p.warmStarted = false;\n      }\n    }\n  },\n\n  /**\n  * Attach the contact to the shapes.\n  * @param   shape1\n  * @param   shape2\n  */\n  attach: function (shape1, shape2) {\n    this.shape1 = shape1;\n    this.shape2 = shape2;\n    this.body1 = shape1.parent;\n    this.body2 = shape2.parent;\n    this.manifold.body1 = this.body1;\n    this.manifold.body2 = this.body2;\n    this.constraint.body1 = this.body1;\n    this.constraint.body2 = this.body2;\n    this.constraint.attach();\n    this.s1Link.shape = shape2;\n    this.s1Link.body = this.body2;\n    this.s2Link.shape = shape1;\n    this.s2Link.body = this.body1;\n    if (shape1.contactLink != null) (this.s1Link.next = shape1.contactLink).prev = this.s1Link;else this.s1Link.next = null;\n    shape1.contactLink = this.s1Link;\n    shape1.numContacts++;\n    if (shape2.contactLink != null) (this.s2Link.next = shape2.contactLink).prev = this.s2Link;else this.s2Link.next = null;\n    shape2.contactLink = this.s2Link;\n    shape2.numContacts++;\n    this.b1Link.shape = shape2;\n    this.b1Link.body = this.body2;\n    this.b2Link.shape = shape1;\n    this.b2Link.body = this.body1;\n    if (this.body1.contactLink != null) (this.b1Link.next = this.body1.contactLink).prev = this.b1Link;else this.b1Link.next = null;\n    this.body1.contactLink = this.b1Link;\n    this.body1.numContacts++;\n    if (this.body2.contactLink != null) (this.b2Link.next = this.body2.contactLink).prev = this.b2Link;else this.b2Link.next = null;\n    this.body2.contactLink = this.b2Link;\n    this.body2.numContacts++;\n    this.prev = null;\n    this.next = null;\n    this.persisting = true;\n    this.sleeping = this.body1.sleeping && this.body2.sleeping;\n    this.manifold.numPoints = 0;\n  },\n\n  /**\n  * Detach the contact from the shapes.\n  */\n  detach: function () {\n    var prev = this.s1Link.prev;\n    var next = this.s1Link.next;\n    if (prev !== null) prev.next = next;\n    if (next !== null) next.prev = prev;\n    if (this.shape1.contactLink == this.s1Link) this.shape1.contactLink = next;\n    this.s1Link.prev = null;\n    this.s1Link.next = null;\n    this.s1Link.shape = null;\n    this.s1Link.body = null;\n    this.shape1.numContacts--;\n    prev = this.s2Link.prev;\n    next = this.s2Link.next;\n    if (prev !== null) prev.next = next;\n    if (next !== null) next.prev = prev;\n    if (this.shape2.contactLink == this.s2Link) this.shape2.contactLink = next;\n    this.s2Link.prev = null;\n    this.s2Link.next = null;\n    this.s2Link.shape = null;\n    this.s2Link.body = null;\n    this.shape2.numContacts--;\n    prev = this.b1Link.prev;\n    next = this.b1Link.next;\n    if (prev !== null) prev.next = next;\n    if (next !== null) next.prev = prev;\n    if (this.body1.contactLink == this.b1Link) this.body1.contactLink = next;\n    this.b1Link.prev = null;\n    this.b1Link.next = null;\n    this.b1Link.shape = null;\n    this.b1Link.body = null;\n    this.body1.numContacts--;\n    prev = this.b2Link.prev;\n    next = this.b2Link.next;\n    if (prev !== null) prev.next = next;\n    if (next !== null) next.prev = prev;\n    if (this.body2.contactLink == this.b2Link) this.body2.contactLink = next;\n    this.b2Link.prev = null;\n    this.b2Link.next = null;\n    this.b2Link.shape = null;\n    this.b2Link.body = null;\n    this.body2.numContacts--;\n    this.manifold.body1 = null;\n    this.manifold.body2 = null;\n    this.constraint.body1 = null;\n    this.constraint.body2 = null;\n    this.constraint.detach();\n    this.shape1 = null;\n    this.shape2 = null;\n    this.body1 = null;\n    this.body2 = null;\n  }\n});\n/**\r\n* The class of rigid body.\r\n* Rigid body has the shape of a single or multiple collision processing,\r\n* I can set the parameters individually.\r\n* @author saharan\r\n* @author lo-th\r\n*/\n\nfunction RigidBody(Position, Rotation) {\n  this.position = Position || new Vec3();\n  this.orientation = Rotation || new Quat();\n  this.scale = 1;\n  this.invScale = 1; // possible link to three Mesh;\n\n  this.mesh = null;\n  this.id = NaN;\n  this.name = \"\"; // The maximum number of shapes that can be added to a one rigid.\n  //this.MAX_SHAPES = 64;//64;\n\n  this.prev = null;\n  this.next = null; // I represent the kind of rigid body.\n  // Please do not change from the outside this variable.\n  // If you want to change the type of rigid body, always\n  // Please specify the type you want to set the arguments of setupMass method.\n\n  this.type = BODY_NULL;\n  this.massInfo = new MassInfo();\n  this.newPosition = new Vec3();\n  this.controlPos = false;\n  this.newOrientation = new Quat();\n  this.newRotation = new Vec3();\n  this.currentRotation = new Vec3();\n  this.controlRot = false;\n  this.controlRotInTime = false;\n  this.quaternion = new Quat();\n  this.pos = new Vec3(); // Is the translational velocity.\n\n  this.linearVelocity = new Vec3(); // Is the angular velocity.\n\n  this.angularVelocity = new Vec3(); //--------------------------------------------\n  //  Please do not change from the outside this variables.\n  //--------------------------------------------\n  // It is a world that rigid body has been added.\n\n  this.parent = null;\n  this.contactLink = null;\n  this.numContacts = 0; // An array of shapes that are included in the rigid body.\n\n  this.shapes = null; // The number of shapes that are included in the rigid body.\n\n  this.numShapes = 0; // It is the link array of joint that is connected to the rigid body.\n\n  this.jointLink = null; // The number of joints that are connected to the rigid body.\n\n  this.numJoints = 0; // It is the world coordinate of the center of gravity in the sleep just before.\n\n  this.sleepPosition = new Vec3(); // It is a quaternion that represents the attitude of sleep just before.\n\n  this.sleepOrientation = new Quat(); // I will show this rigid body to determine whether it is a rigid body static.\n\n  this.isStatic = false; // I indicates that this rigid body to determine whether it is a rigid body dynamic.\n\n  this.isDynamic = false;\n  this.isKinematic = false; // It is a rotation matrix representing the orientation.\n\n  this.rotation = new Mat33(); //--------------------------------------------\n  // It will be recalculated automatically from the shape, which is included.\n  //--------------------------------------------\n  // This is the weight.\n\n  this.mass = 0; // It is the reciprocal of the mass.\n\n  this.inverseMass = 0; // It is the inverse of the inertia tensor in the world system.\n\n  this.inverseInertia = new Mat33(); // It is the inertia tensor in the initial state.\n\n  this.localInertia = new Mat33(); // It is the inverse of the inertia tensor in the initial state.\n\n  this.inverseLocalInertia = new Mat33();\n  this.tmpInertia = new Mat33(); // I indicates rigid body whether it has been added to the simulation Island.\n\n  this.addedToIsland = false; // It shows how to sleep rigid body.\n\n  this.allowSleep = true; // This is the time from when the rigid body at rest.\n\n  this.sleepTime = 0; // I shows rigid body to determine whether it is a sleep state.\n\n  this.sleeping = false;\n}\n\nObject.assign(RigidBody.prototype, {\n  setParent: function (world) {\n    this.parent = world;\n    this.scale = this.parent.scale;\n    this.invScale = this.parent.invScale;\n    this.id = this.parent.numRigidBodies;\n    if (!this.name) this.name = this.id;\n    this.updateMesh();\n  },\n\n  /**\r\n   * I'll add a shape to rigid body.\r\n   * If you add a shape, please call the setupMass method to step up to the start of the next.\r\n   * @param   shape shape to Add\r\n   */\n  addShape: function (shape) {\n    if (shape.parent) {\n      printError(\"RigidBody\", \"It is not possible that you add a shape which already has an associated body.\");\n    }\n\n    if (this.shapes != null) (this.shapes.prev = shape).next = this.shapes;\n    this.shapes = shape;\n    shape.parent = this;\n    if (this.parent) this.parent.addShape(shape);\n    this.numShapes++;\n  },\n\n  /**\r\n   * I will delete the shape from the rigid body.\r\n   * If you delete a shape, please call the setupMass method to step up to the start of the next.\r\n   * @param shape {Shape} to delete\r\n   * @return void\r\n   */\n  removeShape: function (shape) {\n    var remove = shape;\n    if (remove.parent != this) return;\n    var prev = remove.prev;\n    var next = remove.next;\n    if (prev != null) prev.next = next;\n    if (next != null) next.prev = prev;\n    if (this.shapes == remove) this.shapes = next;\n    remove.prev = null;\n    remove.next = null;\n    remove.parent = null;\n    if (this.parent) this.parent.removeShape(remove);\n    this.numShapes--;\n  },\n  remove: function () {\n    this.dispose();\n  },\n  dispose: function () {\n    this.parent.removeRigidBody(this);\n  },\n  checkContact: function (name) {\n    this.parent.checkContact(this.name, name);\n  },\n\n  /**\r\n   * Calulates mass datas(center of gravity, mass, moment inertia, etc...).\r\n   * If the parameter type is set to BODY_STATIC, the rigid body will be fixed to the space.\r\n   * If the parameter adjustPosition is set to true, the shapes' relative positions and\r\n   * the rigid body's position will be adjusted to the center of gravity.\r\n   * @param type\r\n   * @param adjustPosition\r\n   * @return void\r\n   */\n  setupMass: function (type, AdjustPosition) {\n    var adjustPosition = AdjustPosition !== undefined ? AdjustPosition : true;\n    this.type = type || BODY_STATIC;\n    this.isDynamic = this.type === BODY_DYNAMIC;\n    this.isStatic = this.type === BODY_STATIC;\n    this.mass = 0;\n    this.localInertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    var tmpM = new Mat33();\n    var tmpV = new Vec3();\n\n    for (var shape = this.shapes; shape !== null; shape = shape.next) {\n      shape.calculateMassInfo(this.massInfo);\n      var shapeMass = this.massInfo.mass;\n      tmpV.addScaledVector(shape.relativePosition, shapeMass);\n      this.mass += shapeMass;\n      this.rotateInertia(shape.relativeRotation, this.massInfo.inertia, tmpM);\n      this.localInertia.add(tmpM); // add offset inertia\n\n      this.localInertia.addOffset(shapeMass, shape.relativePosition);\n    }\n\n    this.inverseMass = 1 / this.mass;\n    tmpV.scaleEqual(this.inverseMass);\n\n    if (adjustPosition) {\n      this.position.add(tmpV);\n\n      for (shape = this.shapes; shape !== null; shape = shape.next) {\n        shape.relativePosition.subEqual(tmpV);\n      } // subtract offset inertia\n\n\n      this.localInertia.subOffset(this.mass, tmpV);\n    }\n\n    this.inverseLocalInertia.invert(this.localInertia); //}\n\n    if (this.type === BODY_STATIC) {\n      this.inverseMass = 0;\n      this.inverseLocalInertia.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n\n    this.syncShapes();\n    this.awake();\n  },\n\n  /**\r\n   * Awake the rigid body.\r\n   */\n  awake: function () {\n    if (!this.allowSleep || !this.sleeping) return;\n    this.sleeping = false;\n    this.sleepTime = 0; // awake connected constraints\n\n    var cs = this.contactLink;\n\n    while (cs != null) {\n      cs.body.sleepTime = 0;\n      cs.body.sleeping = false;\n      cs = cs.next;\n    }\n\n    var js = this.jointLink;\n\n    while (js != null) {\n      js.body.sleepTime = 0;\n      js.body.sleeping = false;\n      js = js.next;\n    }\n\n    for (var shape = this.shapes; shape != null; shape = shape.next) {\n      shape.updateProxy();\n    }\n  },\n\n  /**\r\n   * Sleep the rigid body.\r\n   */\n  sleep: function () {\n    if (!this.allowSleep || this.sleeping) return;\n    this.linearVelocity.set(0, 0, 0);\n    this.angularVelocity.set(0, 0, 0);\n    this.sleepPosition.copy(this.position);\n    this.sleepOrientation.copy(this.orientation);\n    this.sleepTime = 0;\n    this.sleeping = true;\n\n    for (var shape = this.shapes; shape != null; shape = shape.next) {\n      shape.updateProxy();\n    }\n  },\n  testWakeUp: function () {\n    if (this.linearVelocity.testZero() || this.angularVelocity.testZero() || this.position.testDiff(this.sleepPosition) || this.orientation.testDiff(this.sleepOrientation)) this.awake(); // awake the body\n  },\n\n  /**\r\n   * Get whether the rigid body has not any connection with others.\r\n   * @return {void}\r\n   */\n  isLonely: function () {\n    return this.numJoints == 0 && this.numContacts == 0;\n  },\n\n  /**\r\n   * The time integration of the motion of a rigid body, you can update the information such as the shape.\r\n   * This method is invoked automatically when calling the step of the World,\r\n   * There is no need to call from outside usually.\r\n   * @param  timeStep time\r\n   * @return {void}\r\n   */\n  updatePosition: function (timeStep) {\n    switch (this.type) {\n      case BODY_STATIC:\n        this.linearVelocity.set(0, 0, 0);\n        this.angularVelocity.set(0, 0, 0); // ONLY FOR TEST\n\n        if (this.controlPos) {\n          this.position.copy(this.newPosition);\n          this.controlPos = false;\n        }\n\n        if (this.controlRot) {\n          this.orientation.copy(this.newOrientation);\n          this.controlRot = false;\n        }\n        /*this.linearVelocity.x=0;\r\n        this.linearVelocity.y=0;\r\n        this.linearVelocity.z=0;\r\n        this.angularVelocity.x=0;\r\n        this.angularVelocity.y=0;\r\n        this.angularVelocity.z=0;*/\n\n\n        break;\n\n      case BODY_DYNAMIC:\n        if (this.isKinematic) {\n          this.linearVelocity.set(0, 0, 0);\n          this.angularVelocity.set(0, 0, 0);\n        }\n\n        if (this.controlPos) {\n          this.linearVelocity.subVectors(this.newPosition, this.position).multiplyScalar(1 / timeStep);\n          this.controlPos = false;\n        }\n\n        if (this.controlRot) {\n          this.angularVelocity.copy(this.getAxis());\n          this.orientation.copy(this.newOrientation);\n          this.controlRot = false;\n        }\n\n        this.position.addScaledVector(this.linearVelocity, timeStep);\n        this.orientation.addTime(this.angularVelocity, timeStep);\n        this.updateMesh();\n        break;\n\n      default:\n        printError(\"RigidBody\", \"Invalid type.\");\n    }\n\n    this.syncShapes();\n    this.updateMesh();\n  },\n  getAxis: function () {\n    return new Vec3(0, 1, 0).applyMatrix3(this.inverseLocalInertia, true).normalize();\n  },\n  rotateInertia: function (rot, inertia, out) {\n    this.tmpInertia.multiplyMatrices(rot, inertia);\n    out.multiplyMatrices(this.tmpInertia, rot, true);\n  },\n  syncShapes: function () {\n    this.rotation.setQuat(this.orientation);\n    this.rotateInertia(this.rotation, this.inverseLocalInertia, this.inverseInertia);\n\n    for (var shape = this.shapes; shape != null; shape = shape.next) {\n      shape.position.copy(shape.relativePosition).applyMatrix3(this.rotation, true).add(this.position); // add by QuaziKb\n\n      shape.rotation.multiplyMatrices(this.rotation, shape.relativeRotation);\n      shape.updateProxy();\n    }\n  },\n  //---------------------------------------------\n  // APPLY IMPULSE FORCE\n  //---------------------------------------------\n  applyImpulse: function (position, force) {\n    this.linearVelocity.addScaledVector(force, this.inverseMass);\n    var rel = new Vec3().copy(position).sub(this.position).cross(force).applyMatrix3(this.inverseInertia, true);\n    this.angularVelocity.add(rel);\n  },\n  //---------------------------------------------\n  // SET DYNAMIQUE POSITION AND ROTATION\n  //---------------------------------------------\n  setPosition: function (pos) {\n    this.newPosition.copy(pos).multiplyScalar(this.invScale);\n    this.controlPos = true;\n    if (!this.isKinematic) this.isKinematic = true;\n  },\n  setQuaternion: function (q) {\n    this.newOrientation.set(q.x, q.y, q.z, q.w);\n    this.controlRot = true;\n    if (!this.isKinematic) this.isKinematic = true;\n  },\n  setRotation: function (rot) {\n    this.newOrientation = new Quat().setFromEuler(rot.x * _Math.degtorad, rot.y * _Math.degtorad, rot.y * _Math.degtorad); //this.rotationVectToQuad( rot );\n\n    this.controlRot = true;\n  },\n  //---------------------------------------------\n  // RESET DYNAMIQUE POSITION AND ROTATION\n  //---------------------------------------------\n  resetPosition: function (x, y, z) {\n    this.linearVelocity.set(0, 0, 0);\n    this.angularVelocity.set(0, 0, 0);\n    this.position.set(x, y, z).multiplyScalar(this.invScale); //this.position.set( x*OIMO.WorldScale.invScale, y*OIMO.WorldScale.invScale, z*OIMO.WorldScale.invScale );\n\n    this.awake();\n  },\n  resetQuaternion: function (q) {\n    this.angularVelocity.set(0, 0, 0);\n    this.orientation = new Quat(q.x, q.y, q.z, q.w);\n    this.awake();\n  },\n  resetRotation: function (x, y, z) {\n    this.angularVelocity.set(0, 0, 0);\n    this.orientation = new Quat().setFromEuler(x * _Math.degtorad, y * _Math.degtorad, z * _Math.degtorad); //this.rotationVectToQuad( new Vec3(x,y,z) );\n\n    this.awake();\n  },\n  //---------------------------------------------\n  // GET POSITION AND ROTATION\n  //---------------------------------------------\n  getPosition: function () {\n    return this.pos;\n  },\n  getQuaternion: function () {\n    return this.quaternion;\n  },\n  //---------------------------------------------\n  // AUTO UPDATE THREE MESH\n  //---------------------------------------------\n  connectMesh: function (mesh) {\n    this.mesh = mesh;\n    this.updateMesh();\n  },\n  updateMesh: function () {\n    this.pos.scale(this.position, this.scale);\n    this.quaternion.copy(this.orientation);\n    if (this.mesh === null) return;\n    this.mesh.position.copy(this.getPosition());\n    this.mesh.quaternion.copy(this.getQuaternion());\n  }\n});\n/**\r\n* A pair of shapes that may collide.\r\n* @author saharan\r\n*/\n\nfunction Pair(s1, s2) {\n  // The first shape.\n  this.shape1 = s1 || null; // The second shape.\n\n  this.shape2 = s2 || null;\n}\n/**\r\n* The broad-phase is used for collecting all possible pairs for collision.\r\n*/\n\n\nfunction BroadPhase() {\n  this.types = BR_NULL;\n  this.numPairChecks = 0;\n  this.numPairs = 0;\n  this.pairs = [];\n}\n\nObject.assign(BroadPhase.prototype, {\n  BroadPhase: true,\n  // Create a new proxy.\n  createProxy: function (shape) {\n    printError(\"BroadPhase\", \"Inheritance error.\");\n  },\n  // Add the proxy into the broad-phase.\n  addProxy: function (proxy) {\n    printError(\"BroadPhase\", \"Inheritance error.\");\n  },\n  // Remove the proxy from the broad-phase.\n  removeProxy: function (proxy) {\n    printError(\"BroadPhase\", \"Inheritance error.\");\n  },\n  // Returns whether the pair is available or not.\n  isAvailablePair: function (s1, s2) {\n    var b1 = s1.parent;\n    var b2 = s2.parent;\n\n    if (b1 == b2 || // same parents\n    !b1.isDynamic && !b2.isDynamic || // static or kinematic object\n    (s1.belongsTo & s2.collidesWith) == 0 || (s2.belongsTo & s1.collidesWith) == 0 // collision filtering\n    ) {\n        return false;\n      }\n\n    var js;\n    if (b1.numJoints < b2.numJoints) js = b1.jointLink;else js = b2.jointLink;\n\n    while (js !== null) {\n      var joint = js.joint;\n\n      if (!joint.allowCollision && (joint.body1 == b1 && joint.body2 == b2 || joint.body1 == b2 && joint.body2 == b1)) {\n        return false;\n      }\n\n      js = js.next;\n    }\n\n    return true;\n  },\n  // Detect overlapping pairs.\n  detectPairs: function () {\n    // clear old\n    this.pairs = [];\n    this.numPairs = 0;\n    this.numPairChecks = 0;\n    this.collectPairs();\n  },\n  collectPairs: function () {\n    Error(\"BroadPhase\", \"Inheritance error.\");\n  },\n  addPair: function (s1, s2) {\n    var pair = new Pair(s1, s2);\n    this.pairs.push(pair);\n    this.numPairs++;\n  }\n});\nvar count$1 = 0;\n\nfunction ProxyIdCount() {\n  return count$1++;\n}\n/**\r\n * A proxy is used for broad-phase collecting pairs that can be colliding.\r\n *\r\n * @author lo-th\r\n */\n\n\nfunction Proxy(shape) {\n  //The parent shape.\n  this.shape = shape; //The axis-aligned bounding box.\n\n  this.aabb = shape.aabb;\n}\n\nObject.assign(Proxy.prototype, {\n  Proxy: true,\n  // Update the proxy. Must be inherited by a child.\n  update: function () {\n    printError(\"Proxy\", \"Inheritance error.\");\n  }\n});\n/**\r\n* A basic implementation of proxies.\r\n*\r\n* @author saharan\r\n*/\n\nfunction BasicProxy(shape) {\n  Proxy.call(this, shape);\n  this.id = ProxyIdCount();\n}\n\nBasicProxy.prototype = Object.assign(Object.create(Proxy.prototype), {\n  constructor: BasicProxy,\n  update: function () {}\n});\n/**\r\n* A broad-phase algorithm with brute-force search.\r\n* This always checks for all possible pairs.\r\n*/\n\nfunction BruteForceBroadPhase() {\n  BroadPhase.call(this);\n  this.types = BR_BRUTE_FORCE; //this.numProxies=0;\n  ///this.maxProxies = 256;\n\n  this.proxies = []; //this.proxies.length = 256;\n}\n\nBruteForceBroadPhase.prototype = Object.assign(Object.create(BroadPhase.prototype), {\n  constructor: BruteForceBroadPhase,\n  createProxy: function (shape) {\n    return new BasicProxy(shape);\n  },\n  addProxy: function (proxy) {\n    /*if(this.numProxies==this.maxProxies){\r\n        //this.maxProxies<<=1;\r\n        this.maxProxies*=2;\r\n        var newProxies=[];\r\n        newProxies.length = this.maxProxies;\r\n        var i = this.numProxies;\r\n        while(i--){\r\n        //for(var i=0, l=this.numProxies;i<l;i++){\r\n            newProxies[i]=this.proxies[i];\r\n        }\r\n        this.proxies=newProxies;\r\n    }*/\n    //this.proxies[this.numProxies++] = proxy;\n    this.proxies.push(proxy); //this.numProxies++;\n  },\n  removeProxy: function (proxy) {\n    var n = this.proxies.indexOf(proxy);\n\n    if (n > -1) {\n      this.proxies.splice(n, 1); //this.numProxies--;\n    }\n    /*var i = this.numProxies;\r\n    while(i--){\r\n    //for(var i=0, l=this.numProxies;i<l;i++){\r\n        if(this.proxies[i] == proxy){\r\n            this.proxies[i] = this.proxies[--this.numProxies];\r\n            this.proxies[this.numProxies] = null;\r\n            return;\r\n        }\r\n    }*/\n\n  },\n  collectPairs: function () {\n    var i = 0,\n        j,\n        p1,\n        p2;\n    var px = this.proxies;\n    var l = px.length; //this.numProxies;\n    //var ar1 = [];\n    //var ar2 = [];\n    //for( i = px.length ; i-- ; ar1[ i ] = px[ i ] ){};\n    //for( i = px.length ; i-- ; ar2[ i ] = px[ i ] ){};\n    //var ar1 = JSON.parse(JSON.stringify(this.proxies))\n    //var ar2 = JSON.parse(JSON.stringify(this.proxies))\n\n    this.numPairChecks = l * (l - 1) >> 1; //this.numPairChecks=this.numProxies*(this.numProxies-1)*0.5;\n\n    while (i < l) {\n      p1 = px[i++];\n      j = i + 1;\n\n      while (j < l) {\n        p2 = px[j++];\n        if (p1.aabb.intersectTest(p2.aabb) || !this.isAvailablePair(p1.shape, p2.shape)) continue;\n        this.addPair(p1.shape, p2.shape);\n      }\n    }\n  }\n});\n/**\r\n * A projection axis for sweep and prune broad-phase.\r\n * @author saharan\r\n */\n\nfunction SAPAxis() {\n  this.numElements = 0;\n  this.bufferSize = 256;\n  this.elements = [];\n  this.elements.length = this.bufferSize;\n  this.stack = new Float32Array(64);\n}\n\nObject.assign(SAPAxis.prototype, {\n  SAPAxis: true,\n  addElements: function (min, max) {\n    if (this.numElements + 2 >= this.bufferSize) {\n      //this.bufferSize<<=1;\n      this.bufferSize *= 2;\n      var newElements = [];\n      var i = this.numElements;\n\n      while (i--) {\n        //for(var i=0, l=this.numElements; i<l; i++){\n        newElements[i] = this.elements[i];\n      }\n    }\n\n    this.elements[this.numElements++] = min;\n    this.elements[this.numElements++] = max;\n  },\n  removeElements: function (min, max) {\n    var minIndex = -1;\n    var maxIndex = -1;\n\n    for (var i = 0, l = this.numElements; i < l; i++) {\n      var e = this.elements[i];\n\n      if (e == min || e == max) {\n        if (minIndex == -1) {\n          minIndex = i;\n        } else {\n          maxIndex = i;\n          break;\n        }\n      }\n    }\n\n    for (i = minIndex + 1, l = maxIndex; i < l; i++) {\n      this.elements[i - 1] = this.elements[i];\n    }\n\n    for (i = maxIndex + 1, l = this.numElements; i < l; i++) {\n      this.elements[i - 2] = this.elements[i];\n    }\n\n    this.elements[--this.numElements] = null;\n    this.elements[--this.numElements] = null;\n  },\n  sort: function () {\n    var count = 0;\n    var threshold = 1;\n\n    while (this.numElements >> threshold != 0) threshold++;\n\n    threshold = threshold * this.numElements >> 2;\n    count = 0;\n    var giveup = false;\n    var elements = this.elements;\n\n    for (var i = 1, l = this.numElements; i < l; i++) {\n      // try insertion sort\n      var tmp = elements[i];\n      var pivot = tmp.value;\n      var tmp2 = elements[i - 1];\n\n      if (tmp2.value > pivot) {\n        var j = i;\n\n        do {\n          elements[j] = tmp2;\n          if (--j == 0) break;\n          tmp2 = elements[j - 1];\n        } while (tmp2.value > pivot);\n\n        elements[j] = tmp;\n        count += i - j;\n\n        if (count > threshold) {\n          giveup = true; // stop and use quick sort\n\n          break;\n        }\n      }\n    }\n\n    if (!giveup) return;\n    count = 2;\n    var stack = this.stack;\n    stack[0] = 0;\n    stack[1] = this.numElements - 1;\n\n    while (count > 0) {\n      var right = stack[--count];\n      var left = stack[--count];\n      var diff = right - left;\n\n      if (diff > 16) {\n        // quick sort\n        //var mid=left+(diff>>1);\n        var mid = left + _Math.floor(diff * 0.5);\n\n        tmp = elements[mid];\n        elements[mid] = elements[right];\n        elements[right] = tmp;\n        pivot = tmp.value;\n        i = left - 1;\n        j = right;\n\n        while (true) {\n          var ei;\n          var ej;\n\n          do {\n            ei = elements[++i];\n          } while (ei.value < pivot);\n\n          do {\n            ej = elements[--j];\n          } while (pivot < ej.value && j != left);\n\n          if (i >= j) break;\n          elements[i] = ej;\n          elements[j] = ei;\n        }\n\n        elements[right] = elements[i];\n        elements[i] = tmp;\n\n        if (i - left > right - i) {\n          stack[count++] = left;\n          stack[count++] = i - 1;\n          stack[count++] = i + 1;\n          stack[count++] = right;\n        } else {\n          stack[count++] = i + 1;\n          stack[count++] = right;\n          stack[count++] = left;\n          stack[count++] = i - 1;\n        }\n      } else {\n        for (i = left + 1; i <= right; i++) {\n          tmp = elements[i];\n          pivot = tmp.value;\n          tmp2 = elements[i - 1];\n\n          if (tmp2.value > pivot) {\n            j = i;\n\n            do {\n              elements[j] = tmp2;\n              if (--j == 0) break;\n              tmp2 = elements[j - 1];\n            } while (tmp2.value > pivot);\n\n            elements[j] = tmp;\n          }\n        }\n      }\n    }\n  },\n  calculateTestCount: function () {\n    var num = 1;\n    var sum = 0;\n\n    for (var i = 1, l = this.numElements; i < l; i++) {\n      if (this.elements[i].max) {\n        num--;\n      } else {\n        sum += num;\n        num++;\n      }\n    }\n\n    return sum;\n  }\n});\n/**\r\n * An element of proxies.\r\n * @author saharan\r\n */\n\nfunction SAPElement(proxy, max) {\n  // The parent proxy\n  this.proxy = proxy; // The pair element.\n\n  this.pair = null; // The minimum element on other axis.\n\n  this.min1 = null; // The maximum element on other axis.\n\n  this.max1 = null; // The minimum element on other axis.\n\n  this.min2 = null; // The maximum element on other axis.\n\n  this.max2 = null; // Whether the element has maximum value or not.\n\n  this.max = max; // The value of the element.\n\n  this.value = 0;\n}\n/**\r\n * A proxy for sweep and prune broad-phase.\r\n * @author saharan\r\n * @author lo-th\r\n */\n\n\nfunction SAPProxy(sap, shape) {\n  Proxy.call(this, shape); // Type of the axis to which the proxy belongs to. [0:none, 1:dynamic, 2:static]\n\n  this.belongsTo = 0; // The maximum elements on each axis.\n\n  this.max = []; // The minimum elements on each axis.\n\n  this.min = [];\n  this.sap = sap;\n  this.min[0] = new SAPElement(this, false);\n  this.max[0] = new SAPElement(this, true);\n  this.min[1] = new SAPElement(this, false);\n  this.max[1] = new SAPElement(this, true);\n  this.min[2] = new SAPElement(this, false);\n  this.max[2] = new SAPElement(this, true);\n  this.max[0].pair = this.min[0];\n  this.max[1].pair = this.min[1];\n  this.max[2].pair = this.min[2];\n  this.min[0].min1 = this.min[1];\n  this.min[0].max1 = this.max[1];\n  this.min[0].min2 = this.min[2];\n  this.min[0].max2 = this.max[2];\n  this.min[1].min1 = this.min[0];\n  this.min[1].max1 = this.max[0];\n  this.min[1].min2 = this.min[2];\n  this.min[1].max2 = this.max[2];\n  this.min[2].min1 = this.min[0];\n  this.min[2].max1 = this.max[0];\n  this.min[2].min2 = this.min[1];\n  this.min[2].max2 = this.max[1];\n}\n\nSAPProxy.prototype = Object.assign(Object.create(Proxy.prototype), {\n  constructor: SAPProxy,\n  // Returns whether the proxy is dynamic or not.\n  isDynamic: function () {\n    var body = this.shape.parent;\n    return body.isDynamic && !body.sleeping;\n  },\n  update: function () {\n    var te = this.aabb.elements;\n    this.min[0].value = te[0];\n    this.min[1].value = te[1];\n    this.min[2].value = te[2];\n    this.max[0].value = te[3];\n    this.max[1].value = te[4];\n    this.max[2].value = te[5];\n\n    if (this.belongsTo == 1 && !this.isDynamic() || this.belongsTo == 2 && this.isDynamic()) {\n      this.sap.removeProxy(this);\n      this.sap.addProxy(this);\n    }\n  }\n});\n/**\r\n * A broad-phase collision detection algorithm using sweep and prune.\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction SAPBroadPhase() {\n  BroadPhase.call(this);\n  this.types = BR_SWEEP_AND_PRUNE;\n  this.numElementsD = 0;\n  this.numElementsS = 0; // dynamic proxies\n\n  this.axesD = [new SAPAxis(), new SAPAxis(), new SAPAxis()]; // static or sleeping proxies\n\n  this.axesS = [new SAPAxis(), new SAPAxis(), new SAPAxis()];\n  this.index1 = 0;\n  this.index2 = 1;\n}\n\nSAPBroadPhase.prototype = Object.assign(Object.create(BroadPhase.prototype), {\n  constructor: SAPBroadPhase,\n  createProxy: function (shape) {\n    return new SAPProxy(this, shape);\n  },\n  addProxy: function (proxy) {\n    var p = proxy;\n\n    if (p.isDynamic()) {\n      this.axesD[0].addElements(p.min[0], p.max[0]);\n      this.axesD[1].addElements(p.min[1], p.max[1]);\n      this.axesD[2].addElements(p.min[2], p.max[2]);\n      p.belongsTo = 1;\n      this.numElementsD += 2;\n    } else {\n      this.axesS[0].addElements(p.min[0], p.max[0]);\n      this.axesS[1].addElements(p.min[1], p.max[1]);\n      this.axesS[2].addElements(p.min[2], p.max[2]);\n      p.belongsTo = 2;\n      this.numElementsS += 2;\n    }\n  },\n  removeProxy: function (proxy) {\n    var p = proxy;\n    if (p.belongsTo == 0) return;\n    /*else if ( p.belongsTo == 1 ) {\r\n        this.axesD[0].removeElements( p.min[0], p.max[0] );\r\n        this.axesD[1].removeElements( p.min[1], p.max[1] );\r\n        this.axesD[2].removeElements( p.min[2], p.max[2] );\r\n        this.numElementsD -= 2;\r\n    } else if ( p.belongsTo == 2 ) {\r\n        this.axesS[0].removeElements( p.min[0], p.max[0] );\r\n        this.axesS[1].removeElements( p.min[1], p.max[1] );\r\n        this.axesS[2].removeElements( p.min[2], p.max[2] );\r\n        this.numElementsS -= 2;\r\n    }*/\n\n    switch (p.belongsTo) {\n      case 1:\n        this.axesD[0].removeElements(p.min[0], p.max[0]);\n        this.axesD[1].removeElements(p.min[1], p.max[1]);\n        this.axesD[2].removeElements(p.min[2], p.max[2]);\n        this.numElementsD -= 2;\n        break;\n\n      case 2:\n        this.axesS[0].removeElements(p.min[0], p.max[0]);\n        this.axesS[1].removeElements(p.min[1], p.max[1]);\n        this.axesS[2].removeElements(p.min[2], p.max[2]);\n        this.numElementsS -= 2;\n        break;\n    }\n\n    p.belongsTo = 0;\n  },\n  collectPairs: function () {\n    if (this.numElementsD == 0) return;\n    var axis1 = this.axesD[this.index1];\n    var axis2 = this.axesD[this.index2];\n    axis1.sort();\n    axis2.sort();\n    var count1 = axis1.calculateTestCount();\n    var count2 = axis2.calculateTestCount();\n    var elementsD;\n    var elementsS;\n\n    if (count1 <= count2) {\n      // select the best axis\n      axis2 = this.axesS[this.index1];\n      axis2.sort();\n      elementsD = axis1.elements;\n      elementsS = axis2.elements;\n    } else {\n      axis1 = this.axesS[this.index2];\n      axis1.sort();\n      elementsD = axis2.elements;\n      elementsS = axis1.elements;\n      this.index1 ^= this.index2;\n      this.index2 ^= this.index1;\n      this.index1 ^= this.index2;\n    }\n\n    var activeD;\n    var activeS;\n    var p = 0;\n    var q = 0;\n\n    while (p < this.numElementsD) {\n      var e1;\n      var dyn;\n\n      if (q == this.numElementsS) {\n        e1 = elementsD[p];\n        dyn = true;\n        p++;\n      } else {\n        var d = elementsD[p];\n        var s = elementsS[q];\n\n        if (d.value < s.value) {\n          e1 = d;\n          dyn = true;\n          p++;\n        } else {\n          e1 = s;\n          dyn = false;\n          q++;\n        }\n      }\n\n      if (!e1.max) {\n        var s1 = e1.proxy.shape;\n        var min1 = e1.min1.value;\n        var max1 = e1.max1.value;\n        var min2 = e1.min2.value;\n        var max2 = e1.max2.value;\n\n        for (var e2 = activeD; e2 != null; e2 = e2.pair) {\n          // test for dynamic\n          var s2 = e2.proxy.shape;\n          this.numPairChecks++;\n          if (min1 > e2.max1.value || max1 < e2.min1.value || min2 > e2.max2.value || max2 < e2.min2.value || !this.isAvailablePair(s1, s2)) continue;\n          this.addPair(s1, s2);\n        }\n\n        if (dyn) {\n          for (e2 = activeS; e2 != null; e2 = e2.pair) {\n            // test for static\n            s2 = e2.proxy.shape;\n            this.numPairChecks++;\n            if (min1 > e2.max1.value || max1 < e2.min1.value || min2 > e2.max2.value || max2 < e2.min2.value || !this.isAvailablePair(s1, s2)) continue;\n            this.addPair(s1, s2);\n          }\n\n          e1.pair = activeD;\n          activeD = e1;\n        } else {\n          e1.pair = activeS;\n          activeS = e1;\n        }\n      } else {\n        var min = e1.pair;\n\n        if (dyn) {\n          if (min == activeD) {\n            activeD = activeD.pair;\n            continue;\n          } else {\n            e1 = activeD;\n          }\n        } else {\n          if (min == activeS) {\n            activeS = activeS.pair;\n            continue;\n          } else {\n            e1 = activeS;\n          }\n        }\n\n        do {\n          e2 = e1.pair;\n\n          if (e2 == min) {\n            e1.pair = e2.pair;\n            break;\n          }\n\n          e1 = e2;\n        } while (e1 != null);\n      }\n    }\n\n    this.index2 = (this.index1 | this.index2) ^ 3;\n  }\n});\n/**\r\n* A node of the dynamic bounding volume tree.\r\n* @author saharan\r\n*/\n\nfunction DBVTNode() {\n  // The first child node of this node.\n  this.child1 = null; // The second child node of this node.\n\n  this.child2 = null; //  The parent node of this tree.\n\n  this.parent = null; // The proxy of this node. This has no value if this node is not leaf.\n\n  this.proxy = null; // The maximum distance from leaf nodes.\n\n  this.height = 0; // The AABB of this node.\n\n  this.aabb = new AABB();\n}\n/**\r\n * A dynamic bounding volume tree for the broad-phase algorithm.\r\n *\r\n * @author saharan\r\n * @author lo-th\r\n */\n\n\nfunction DBVT() {\n  // The root of the tree.\n  this.root = null;\n  this.freeNodes = [];\n  this.freeNodes.length = 16384;\n  this.numFreeNodes = 0;\n  this.aabb = new AABB();\n}\n\nObject.assign(DBVT.prototype, {\n  DBVT: true,\n  moveLeaf: function (leaf) {\n    this.deleteLeaf(leaf);\n    this.insertLeaf(leaf);\n  },\n  insertLeaf: function (leaf) {\n    if (this.root == null) {\n      this.root = leaf;\n      return;\n    }\n\n    var lb = leaf.aabb;\n    var sibling = this.root;\n    var oldArea;\n    var newArea;\n\n    while (sibling.proxy == null) {\n      // descend the node to search the best pair\n      var c1 = sibling.child1;\n      var c2 = sibling.child2;\n      var b = sibling.aabb;\n      var c1b = c1.aabb;\n      var c2b = c2.aabb;\n      oldArea = b.surfaceArea();\n      this.aabb.combine(lb, b);\n      newArea = this.aabb.surfaceArea();\n      var creatingCost = newArea * 2;\n      var incrementalCost = (newArea - oldArea) * 2; // cost of creating a new pair with the node\n\n      var discendingCost1 = incrementalCost;\n      this.aabb.combine(lb, c1b);\n\n      if (c1.proxy != null) {\n        // leaf cost = area(combined aabb)\n        discendingCost1 += this.aabb.surfaceArea();\n      } else {\n        // node cost = area(combined aabb) - area(old aabb)\n        discendingCost1 += this.aabb.surfaceArea() - c1b.surfaceArea();\n      }\n\n      var discendingCost2 = incrementalCost;\n      this.aabb.combine(lb, c2b);\n\n      if (c2.proxy != null) {\n        // leaf cost = area(combined aabb)\n        discendingCost2 += this.aabb.surfaceArea();\n      } else {\n        // node cost = area(combined aabb) - area(old aabb)\n        discendingCost2 += this.aabb.surfaceArea() - c2b.surfaceArea();\n      }\n\n      if (discendingCost1 < discendingCost2) {\n        if (creatingCost < discendingCost1) {\n          break; // stop descending\n        } else {\n          sibling = c1; // descend into first child\n        }\n      } else {\n        if (creatingCost < discendingCost2) {\n          break; // stop descending\n        } else {\n          sibling = c2; // descend into second child\n        }\n      }\n    }\n\n    var oldParent = sibling.parent;\n    var newParent;\n\n    if (this.numFreeNodes > 0) {\n      newParent = this.freeNodes[--this.numFreeNodes];\n    } else {\n      newParent = new DBVTNode();\n    }\n\n    newParent.parent = oldParent;\n    newParent.child1 = leaf;\n    newParent.child2 = sibling;\n    newParent.aabb.combine(leaf.aabb, sibling.aabb);\n    newParent.height = sibling.height + 1;\n    sibling.parent = newParent;\n    leaf.parent = newParent;\n\n    if (sibling == this.root) {\n      // replace root\n      this.root = newParent;\n    } else {\n      // replace child\n      if (oldParent.child1 == sibling) {\n        oldParent.child1 = newParent;\n      } else {\n        oldParent.child2 = newParent;\n      }\n    } // update whole tree\n\n\n    do {\n      newParent = this.balance(newParent);\n      this.fix(newParent);\n      newParent = newParent.parent;\n    } while (newParent != null);\n  },\n  getBalance: function (node) {\n    if (node.proxy != null) return 0;\n    return node.child1.height - node.child2.height;\n  },\n  deleteLeaf: function (leaf) {\n    if (leaf == this.root) {\n      this.root = null;\n      return;\n    }\n\n    var parent = leaf.parent;\n    var sibling;\n\n    if (parent.child1 == leaf) {\n      sibling = parent.child2;\n    } else {\n      sibling = parent.child1;\n    }\n\n    if (parent == this.root) {\n      this.root = sibling;\n      sibling.parent = null;\n      return;\n    }\n\n    var grandParent = parent.parent;\n    sibling.parent = grandParent;\n\n    if (grandParent.child1 == parent) {\n      grandParent.child1 = sibling;\n    } else {\n      grandParent.child2 = sibling;\n    }\n\n    if (this.numFreeNodes < 16384) {\n      this.freeNodes[this.numFreeNodes++] = parent;\n    }\n\n    do {\n      grandParent = this.balance(grandParent);\n      this.fix(grandParent);\n      grandParent = grandParent.parent;\n    } while (grandParent != null);\n  },\n  balance: function (node) {\n    var nh = node.height;\n\n    if (nh < 2) {\n      return node;\n    }\n\n    var p = node.parent;\n    var l = node.child1;\n    var r = node.child2;\n    var lh = l.height;\n    var rh = r.height;\n    var balance = lh - rh;\n    var t; // for bit operation\n    //          [ N ]\n    //         /     \\\n    //    [ L ]       [ R ]\n    //     / \\         / \\\n    // [L-L] [L-R] [R-L] [R-R]\n    // Is the tree balanced?\n\n    if (balance > 1) {\n      var ll = l.child1;\n      var lr = l.child2;\n      var llh = ll.height;\n      var lrh = lr.height; // Is L-L higher than L-R?\n\n      if (llh > lrh) {\n        // set N to L-R\n        l.child2 = node;\n        node.parent = l; //          [ L ]\n        //         /     \\\n        //    [L-L]       [ N ]\n        //     / \\         / \\\n        // [...] [...] [ L ] [ R ]\n        // set L-R\n\n        node.child1 = lr;\n        lr.parent = node; //          [ L ]\n        //         /     \\\n        //    [L-L]       [ N ]\n        //     / \\         / \\\n        // [...] [...] [L-R] [ R ]\n        // fix bounds and heights\n\n        node.aabb.combine(lr.aabb, r.aabb);\n        t = lrh - rh;\n        node.height = lrh - (t & t >> 31) + 1;\n        l.aabb.combine(ll.aabb, node.aabb);\n        t = llh - nh;\n        l.height = llh - (t & t >> 31) + 1;\n      } else {\n        // set N to L-L\n        l.child1 = node;\n        node.parent = l; //          [ L ]\n        //         /     \\\n        //    [ N ]       [L-R]\n        //     / \\         / \\\n        // [ L ] [ R ] [...] [...]\n        // set L-L\n\n        node.child1 = ll;\n        ll.parent = node; //          [ L ]\n        //         /     \\\n        //    [ N ]       [L-R]\n        //     / \\         / \\\n        // [L-L] [ R ] [...] [...]\n        // fix bounds and heights\n\n        node.aabb.combine(ll.aabb, r.aabb);\n        t = llh - rh;\n        node.height = llh - (t & t >> 31) + 1;\n        l.aabb.combine(node.aabb, lr.aabb);\n        t = nh - lrh;\n        l.height = nh - (t & t >> 31) + 1;\n      } // set new parent of L\n\n\n      if (p != null) {\n        if (p.child1 == node) {\n          p.child1 = l;\n        } else {\n          p.child2 = l;\n        }\n      } else {\n        this.root = l;\n      }\n\n      l.parent = p;\n      return l;\n    } else if (balance < -1) {\n      var rl = r.child1;\n      var rr = r.child2;\n      var rlh = rl.height;\n      var rrh = rr.height; // Is R-L higher than R-R?\n\n      if (rlh > rrh) {\n        // set N to R-R\n        r.child2 = node;\n        node.parent = r; //          [ R ]\n        //         /     \\\n        //    [R-L]       [ N ]\n        //     / \\         / \\\n        // [...] [...] [ L ] [ R ]\n        // set R-R\n\n        node.child2 = rr;\n        rr.parent = node; //          [ R ]\n        //         /     \\\n        //    [R-L]       [ N ]\n        //     / \\         / \\\n        // [...] [...] [ L ] [R-R]\n        // fix bounds and heights\n\n        node.aabb.combine(l.aabb, rr.aabb);\n        t = lh - rrh;\n        node.height = lh - (t & t >> 31) + 1;\n        r.aabb.combine(rl.aabb, node.aabb);\n        t = rlh - nh;\n        r.height = rlh - (t & t >> 31) + 1;\n      } else {\n        // set N to R-L\n        r.child1 = node;\n        node.parent = r; //          [ R ]\n        //         /     \\\n        //    [ N ]       [R-R]\n        //     / \\         / \\\n        // [ L ] [ R ] [...] [...]\n        // set R-L\n\n        node.child2 = rl;\n        rl.parent = node; //          [ R ]\n        //         /     \\\n        //    [ N ]       [R-R]\n        //     / \\         / \\\n        // [ L ] [R-L] [...] [...]\n        // fix bounds and heights\n\n        node.aabb.combine(l.aabb, rl.aabb);\n        t = lh - rlh;\n        node.height = lh - (t & t >> 31) + 1;\n        r.aabb.combine(node.aabb, rr.aabb);\n        t = nh - rrh;\n        r.height = nh - (t & t >> 31) + 1;\n      } // set new parent of R\n\n\n      if (p != null) {\n        if (p.child1 == node) {\n          p.child1 = r;\n        } else {\n          p.child2 = r;\n        }\n      } else {\n        this.root = r;\n      }\n\n      r.parent = p;\n      return r;\n    }\n\n    return node;\n  },\n  fix: function (node) {\n    var c1 = node.child1;\n    var c2 = node.child2;\n    node.aabb.combine(c1.aabb, c2.aabb);\n    node.height = c1.height < c2.height ? c2.height + 1 : c1.height + 1;\n  }\n});\n/**\r\n* A proxy for dynamic bounding volume tree broad-phase.\r\n* @author saharan\r\n*/\n\nfunction DBVTProxy(shape) {\n  Proxy.call(this, shape); // The leaf of the proxy.\n\n  this.leaf = new DBVTNode();\n  this.leaf.proxy = this;\n}\n\nDBVTProxy.prototype = Object.assign(Object.create(Proxy.prototype), {\n  constructor: DBVTProxy,\n  update: function () {}\n});\n/**\r\n * A broad-phase algorithm using dynamic bounding volume tree.\r\n *\r\n * @author saharan\r\n * @author lo-th\r\n */\n\nfunction DBVTBroadPhase() {\n  BroadPhase.call(this);\n  this.types = BR_BOUNDING_VOLUME_TREE;\n  this.tree = new DBVT();\n  this.stack = [];\n  this.leaves = [];\n  this.numLeaves = 0;\n}\n\nDBVTBroadPhase.prototype = Object.assign(Object.create(BroadPhase.prototype), {\n  constructor: DBVTBroadPhase,\n  createProxy: function (shape) {\n    return new DBVTProxy(shape);\n  },\n  addProxy: function (proxy) {\n    this.tree.insertLeaf(proxy.leaf);\n    this.leaves.push(proxy.leaf);\n    this.numLeaves++;\n  },\n  removeProxy: function (proxy) {\n    this.tree.deleteLeaf(proxy.leaf);\n    var n = this.leaves.indexOf(proxy.leaf);\n\n    if (n > -1) {\n      this.leaves.splice(n, 1);\n      this.numLeaves--;\n    }\n  },\n  collectPairs: function () {\n    if (this.numLeaves < 2) return;\n    var leaf,\n        margin = 0.1,\n        i = this.numLeaves;\n\n    while (i--) {\n      leaf = this.leaves[i];\n\n      if (leaf.proxy.aabb.intersectTestTwo(leaf.aabb)) {\n        leaf.aabb.copy(leaf.proxy.aabb, margin);\n        this.tree.deleteLeaf(leaf);\n        this.tree.insertLeaf(leaf);\n        this.collide(leaf, this.tree.root);\n      }\n    }\n  },\n  collide: function (node1, node2) {\n    var stackCount = 2;\n    var s1, s2, n1, n2, l1, l2;\n    this.stack[0] = node1;\n    this.stack[1] = node2;\n\n    while (stackCount > 0) {\n      n1 = this.stack[--stackCount];\n      n2 = this.stack[--stackCount];\n      l1 = n1.proxy != null;\n      l2 = n2.proxy != null;\n      this.numPairChecks++;\n\n      if (l1 && l2) {\n        s1 = n1.proxy.shape;\n        s2 = n2.proxy.shape;\n        if (s1 == s2 || s1.aabb.intersectTest(s2.aabb) || !this.isAvailablePair(s1, s2)) continue;\n        this.addPair(s1, s2);\n      } else {\n        if (n1.aabb.intersectTest(n2.aabb)) continue;\n        /*if(stackCount+4>=this.maxStack){// expand the stack\r\n            //this.maxStack<<=1;\r\n            this.maxStack*=2;\r\n            var newStack = [];// vector\r\n            newStack.length = this.maxStack;\r\n            for(var i=0;i<stackCount;i++){\r\n                newStack[i] = this.stack[i];\r\n            }\r\n            this.stack = newStack;\r\n        }*/\n\n        if (l2 || !l1 && n1.aabb.surfaceArea() > n2.aabb.surfaceArea()) {\n          this.stack[stackCount++] = n1.child1;\n          this.stack[stackCount++] = n2;\n          this.stack[stackCount++] = n1.child2;\n          this.stack[stackCount++] = n2;\n        } else {\n          this.stack[stackCount++] = n1;\n          this.stack[stackCount++] = n2.child1;\n          this.stack[stackCount++] = n1;\n          this.stack[stackCount++] = n2.child2;\n        }\n      }\n    }\n  }\n});\n\nfunction CollisionDetector() {\n  this.flip = false;\n}\n\nObject.assign(CollisionDetector.prototype, {\n  CollisionDetector: true,\n  detectCollision: function (shape1, shape2, manifold) {\n    printError(\"CollisionDetector\", \"Inheritance error.\");\n  }\n});\n/**\r\n * A collision detector which detects collisions between two boxes.\r\n * @author saharan\r\n */\n\nfunction BoxBoxCollisionDetector() {\n  CollisionDetector.call(this);\n  this.clipVertices1 = new Float32Array(24); // 8 vertices x,y,z\n\n  this.clipVertices2 = new Float32Array(24);\n  this.used = new Float32Array(8);\n  this.INF = 1 / 0;\n}\n\nBoxBoxCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: BoxBoxCollisionDetector,\n  detectCollision: function (shape1, shape2, manifold) {\n    // What you are doing \n    //  I to prepare a separate axis of the fifteen \n    //-Six in each of three normal vectors of the xyz direction of the box both \n    //  Remaining nine 3x3 a vector perpendicular to the side of the box 2 and the side of the box 1 \n    //  Calculate the depth to the separation axis \n    // Calculates the distance using the inner product and put the amount of embedment \n    //  However a vertical separation axis and side to weight a little to avoid vibration \n    // And end when there is a separate axis that is remote even one \n    //  I look for separation axis with little to dent most \n    // Men and if separation axis of the first six - end collision \n    // Heng If it separate axis of nine other - side collision \n    // Heng - case of a side collision \n    //  Find points of two sides on which you made the separation axis \n    // Calculates the point of closest approach of a straight line consisting of separate axis points obtained, and the collision point \n    //-Surface - the case of the plane crash \n    //-Box A, box B and the other a box of better made a separate axis \n    //  The surface A and the plane that made the separation axis of the box A, and B to the surface the face of the box B close in the opposite direction to the most isolated axis \n    // When viewed from the front surface A, and the cut part exceeding the area of the surface A is a surface B \n    //-Plane B becomes the 3-8 triangle, I a candidate for the collision point the vertex of surface B \n    //  If more than one candidate 5 exists, scraping up to four \n    // For potential collision points of all, to examine the distance between the surface A \n    //  If you were on the inside surface of A, and the collision point\n    var b1;\n    var b2;\n\n    if (shape1.id < shape2.id) {\n      b1 = shape1;\n      b2 = shape2;\n    } else {\n      b1 = shape2;\n      b2 = shape1;\n    }\n\n    var V1 = b1.elements;\n    var V2 = b2.elements;\n    var D1 = b1.dimentions;\n    var D2 = b2.dimentions;\n    var p1 = b1.position;\n    var p2 = b2.position;\n    var p1x = p1.x;\n    var p1y = p1.y;\n    var p1z = p1.z;\n    var p2x = p2.x;\n    var p2y = p2.y;\n    var p2z = p2.z; // diff\n\n    var dx = p2x - p1x;\n    var dy = p2y - p1y;\n    var dz = p2z - p1z; // distance\n\n    var w1 = b1.halfWidth;\n    var h1 = b1.halfHeight;\n    var d1 = b1.halfDepth;\n    var w2 = b2.halfWidth;\n    var h2 = b2.halfHeight;\n    var d2 = b2.halfDepth; // direction\n    // ----------------------------\n    // 15 separating axes\n    // 1~6: face\n    // 7~f: edge\n    // http://marupeke296.com/COL_3D_No13_OBBvsOBB.html\n    // ----------------------------\n\n    var a1x = D1[0];\n    var a1y = D1[1];\n    var a1z = D1[2];\n    var a2x = D1[3];\n    var a2y = D1[4];\n    var a2z = D1[5];\n    var a3x = D1[6];\n    var a3y = D1[7];\n    var a3z = D1[8];\n    var d1x = D1[9];\n    var d1y = D1[10];\n    var d1z = D1[11];\n    var d2x = D1[12];\n    var d2y = D1[13];\n    var d2z = D1[14];\n    var d3x = D1[15];\n    var d3y = D1[16];\n    var d3z = D1[17];\n    var a4x = D2[0];\n    var a4y = D2[1];\n    var a4z = D2[2];\n    var a5x = D2[3];\n    var a5y = D2[4];\n    var a5z = D2[5];\n    var a6x = D2[6];\n    var a6y = D2[7];\n    var a6z = D2[8];\n    var d4x = D2[9];\n    var d4y = D2[10];\n    var d4z = D2[11];\n    var d5x = D2[12];\n    var d5y = D2[13];\n    var d5z = D2[14];\n    var d6x = D2[15];\n    var d6y = D2[16];\n    var d6z = D2[17];\n    var a7x = a1y * a4z - a1z * a4y;\n    var a7y = a1z * a4x - a1x * a4z;\n    var a7z = a1x * a4y - a1y * a4x;\n    var a8x = a1y * a5z - a1z * a5y;\n    var a8y = a1z * a5x - a1x * a5z;\n    var a8z = a1x * a5y - a1y * a5x;\n    var a9x = a1y * a6z - a1z * a6y;\n    var a9y = a1z * a6x - a1x * a6z;\n    var a9z = a1x * a6y - a1y * a6x;\n    var aax = a2y * a4z - a2z * a4y;\n    var aay = a2z * a4x - a2x * a4z;\n    var aaz = a2x * a4y - a2y * a4x;\n    var abx = a2y * a5z - a2z * a5y;\n    var aby = a2z * a5x - a2x * a5z;\n    var abz = a2x * a5y - a2y * a5x;\n    var acx = a2y * a6z - a2z * a6y;\n    var acy = a2z * a6x - a2x * a6z;\n    var acz = a2x * a6y - a2y * a6x;\n    var adx = a3y * a4z - a3z * a4y;\n    var ady = a3z * a4x - a3x * a4z;\n    var adz = a3x * a4y - a3y * a4x;\n    var aex = a3y * a5z - a3z * a5y;\n    var aey = a3z * a5x - a3x * a5z;\n    var aez = a3x * a5y - a3y * a5x;\n    var afx = a3y * a6z - a3z * a6y;\n    var afy = a3z * a6x - a3x * a6z;\n    var afz = a3x * a6y - a3y * a6x; // right or left flags\n\n    var right1;\n    var right2;\n    var right3;\n    var right4;\n    var right5;\n    var right6;\n    var right7;\n    var right8;\n    var right9;\n    var righta;\n    var rightb;\n    var rightc;\n    var rightd;\n    var righte;\n    var rightf; // overlapping distances\n\n    var overlap1;\n    var overlap2;\n    var overlap3;\n    var overlap4;\n    var overlap5;\n    var overlap6;\n    var overlap7;\n    var overlap8;\n    var overlap9;\n    var overlapa;\n    var overlapb;\n    var overlapc;\n    var overlapd;\n    var overlape;\n    var overlapf; // invalid flags\n\n    var invalid7 = false;\n    var invalid8 = false;\n    var invalid9 = false;\n    var invalida = false;\n    var invalidb = false;\n    var invalidc = false;\n    var invalidd = false;\n    var invalide = false;\n    var invalidf = false; // temporary variables\n\n    var len;\n    var len1;\n    var len2;\n    var dot1;\n    var dot2;\n    var dot3; // try axis 1\n\n    len = a1x * dx + a1y * dy + a1z * dz;\n    right1 = len > 0;\n    if (!right1) len = -len;\n    len1 = w1;\n    dot1 = a1x * a4x + a1y * a4y + a1z * a4z;\n    dot2 = a1x * a5x + a1y * a5y + a1z * a5z;\n    dot3 = a1x * a6x + a1y * a6y + a1z * a6z;\n    if (dot1 < 0) dot1 = -dot1;\n    if (dot2 < 0) dot2 = -dot2;\n    if (dot3 < 0) dot3 = -dot3;\n    len2 = dot1 * w2 + dot2 * h2 + dot3 * d2;\n    overlap1 = len - len1 - len2;\n    if (overlap1 > 0) return; // try axis 2\n\n    len = a2x * dx + a2y * dy + a2z * dz;\n    right2 = len > 0;\n    if (!right2) len = -len;\n    len1 = h1;\n    dot1 = a2x * a4x + a2y * a4y + a2z * a4z;\n    dot2 = a2x * a5x + a2y * a5y + a2z * a5z;\n    dot3 = a2x * a6x + a2y * a6y + a2z * a6z;\n    if (dot1 < 0) dot1 = -dot1;\n    if (dot2 < 0) dot2 = -dot2;\n    if (dot3 < 0) dot3 = -dot3;\n    len2 = dot1 * w2 + dot2 * h2 + dot3 * d2;\n    overlap2 = len - len1 - len2;\n    if (overlap2 > 0) return; // try axis 3\n\n    len = a3x * dx + a3y * dy + a3z * dz;\n    right3 = len > 0;\n    if (!right3) len = -len;\n    len1 = d1;\n    dot1 = a3x * a4x + a3y * a4y + a3z * a4z;\n    dot2 = a3x * a5x + a3y * a5y + a3z * a5z;\n    dot3 = a3x * a6x + a3y * a6y + a3z * a6z;\n    if (dot1 < 0) dot1 = -dot1;\n    if (dot2 < 0) dot2 = -dot2;\n    if (dot3 < 0) dot3 = -dot3;\n    len2 = dot1 * w2 + dot2 * h2 + dot3 * d2;\n    overlap3 = len - len1 - len2;\n    if (overlap3 > 0) return; // try axis 4\n\n    len = a4x * dx + a4y * dy + a4z * dz;\n    right4 = len > 0;\n    if (!right4) len = -len;\n    dot1 = a4x * a1x + a4y * a1y + a4z * a1z;\n    dot2 = a4x * a2x + a4y * a2y + a4z * a2z;\n    dot3 = a4x * a3x + a4y * a3y + a4z * a3z;\n    if (dot1 < 0) dot1 = -dot1;\n    if (dot2 < 0) dot2 = -dot2;\n    if (dot3 < 0) dot3 = -dot3;\n    len1 = dot1 * w1 + dot2 * h1 + dot3 * d1;\n    len2 = w2;\n    overlap4 = (len - len1 - len2) * 1.0;\n    if (overlap4 > 0) return; // try axis 5\n\n    len = a5x * dx + a5y * dy + a5z * dz;\n    right5 = len > 0;\n    if (!right5) len = -len;\n    dot1 = a5x * a1x + a5y * a1y + a5z * a1z;\n    dot2 = a5x * a2x + a5y * a2y + a5z * a2z;\n    dot3 = a5x * a3x + a5y * a3y + a5z * a3z;\n    if (dot1 < 0) dot1 = -dot1;\n    if (dot2 < 0) dot2 = -dot2;\n    if (dot3 < 0) dot3 = -dot3;\n    len1 = dot1 * w1 + dot2 * h1 + dot3 * d1;\n    len2 = h2;\n    overlap5 = (len - len1 - len2) * 1.0;\n    if (overlap5 > 0) return; // try axis 6\n\n    len = a6x * dx + a6y * dy + a6z * dz;\n    right6 = len > 0;\n    if (!right6) len = -len;\n    dot1 = a6x * a1x + a6y * a1y + a6z * a1z;\n    dot2 = a6x * a2x + a6y * a2y + a6z * a2z;\n    dot3 = a6x * a3x + a6y * a3y + a6z * a3z;\n    if (dot1 < 0) dot1 = -dot1;\n    if (dot2 < 0) dot2 = -dot2;\n    if (dot3 < 0) dot3 = -dot3;\n    len1 = dot1 * w1 + dot2 * h1 + dot3 * d1;\n    len2 = d2;\n    overlap6 = (len - len1 - len2) * 1.0;\n    if (overlap6 > 0) return; // try axis 7\n\n    len = a7x * a7x + a7y * a7y + a7z * a7z;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      a7x *= len;\n      a7y *= len;\n      a7z *= len;\n      len = a7x * dx + a7y * dy + a7z * dz;\n      right7 = len > 0;\n      if (!right7) len = -len;\n      dot1 = a7x * a2x + a7y * a2y + a7z * a2z;\n      dot2 = a7x * a3x + a7y * a3y + a7z * a3z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * h1 + dot2 * d1;\n      dot1 = a7x * a5x + a7y * a5y + a7z * a5z;\n      dot2 = a7x * a6x + a7y * a6y + a7z * a6z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * h2 + dot2 * d2;\n      overlap7 = len - len1 - len2;\n      if (overlap7 > 0) return;\n    } else {\n      right7 = false;\n      overlap7 = 0;\n      invalid7 = true;\n    } // try axis 8\n\n\n    len = a8x * a8x + a8y * a8y + a8z * a8z;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      a8x *= len;\n      a8y *= len;\n      a8z *= len;\n      len = a8x * dx + a8y * dy + a8z * dz;\n      right8 = len > 0;\n      if (!right8) len = -len;\n      dot1 = a8x * a2x + a8y * a2y + a8z * a2z;\n      dot2 = a8x * a3x + a8y * a3y + a8z * a3z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * h1 + dot2 * d1;\n      dot1 = a8x * a4x + a8y * a4y + a8z * a4z;\n      dot2 = a8x * a6x + a8y * a6y + a8z * a6z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * w2 + dot2 * d2;\n      overlap8 = len - len1 - len2;\n      if (overlap8 > 0) return;\n    } else {\n      right8 = false;\n      overlap8 = 0;\n      invalid8 = true;\n    } // try axis 9\n\n\n    len = a9x * a9x + a9y * a9y + a9z * a9z;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      a9x *= len;\n      a9y *= len;\n      a9z *= len;\n      len = a9x * dx + a9y * dy + a9z * dz;\n      right9 = len > 0;\n      if (!right9) len = -len;\n      dot1 = a9x * a2x + a9y * a2y + a9z * a2z;\n      dot2 = a9x * a3x + a9y * a3y + a9z * a3z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * h1 + dot2 * d1;\n      dot1 = a9x * a4x + a9y * a4y + a9z * a4z;\n      dot2 = a9x * a5x + a9y * a5y + a9z * a5z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * w2 + dot2 * h2;\n      overlap9 = len - len1 - len2;\n      if (overlap9 > 0) return;\n    } else {\n      right9 = false;\n      overlap9 = 0;\n      invalid9 = true;\n    } // try axis 10\n\n\n    len = aax * aax + aay * aay + aaz * aaz;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      aax *= len;\n      aay *= len;\n      aaz *= len;\n      len = aax * dx + aay * dy + aaz * dz;\n      righta = len > 0;\n      if (!righta) len = -len;\n      dot1 = aax * a1x + aay * a1y + aaz * a1z;\n      dot2 = aax * a3x + aay * a3y + aaz * a3z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * w1 + dot2 * d1;\n      dot1 = aax * a5x + aay * a5y + aaz * a5z;\n      dot2 = aax * a6x + aay * a6y + aaz * a6z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * h2 + dot2 * d2;\n      overlapa = len - len1 - len2;\n      if (overlapa > 0) return;\n    } else {\n      righta = false;\n      overlapa = 0;\n      invalida = true;\n    } // try axis 11\n\n\n    len = abx * abx + aby * aby + abz * abz;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      abx *= len;\n      aby *= len;\n      abz *= len;\n      len = abx * dx + aby * dy + abz * dz;\n      rightb = len > 0;\n      if (!rightb) len = -len;\n      dot1 = abx * a1x + aby * a1y + abz * a1z;\n      dot2 = abx * a3x + aby * a3y + abz * a3z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * w1 + dot2 * d1;\n      dot1 = abx * a4x + aby * a4y + abz * a4z;\n      dot2 = abx * a6x + aby * a6y + abz * a6z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * w2 + dot2 * d2;\n      overlapb = len - len1 - len2;\n      if (overlapb > 0) return;\n    } else {\n      rightb = false;\n      overlapb = 0;\n      invalidb = true;\n    } // try axis 12\n\n\n    len = acx * acx + acy * acy + acz * acz;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      acx *= len;\n      acy *= len;\n      acz *= len;\n      len = acx * dx + acy * dy + acz * dz;\n      rightc = len > 0;\n      if (!rightc) len = -len;\n      dot1 = acx * a1x + acy * a1y + acz * a1z;\n      dot2 = acx * a3x + acy * a3y + acz * a3z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * w1 + dot2 * d1;\n      dot1 = acx * a4x + acy * a4y + acz * a4z;\n      dot2 = acx * a5x + acy * a5y + acz * a5z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * w2 + dot2 * h2;\n      overlapc = len - len1 - len2;\n      if (overlapc > 0) return;\n    } else {\n      rightc = false;\n      overlapc = 0;\n      invalidc = true;\n    } // try axis 13\n\n\n    len = adx * adx + ady * ady + adz * adz;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      adx *= len;\n      ady *= len;\n      adz *= len;\n      len = adx * dx + ady * dy + adz * dz;\n      rightd = len > 0;\n      if (!rightd) len = -len;\n      dot1 = adx * a1x + ady * a1y + adz * a1z;\n      dot2 = adx * a2x + ady * a2y + adz * a2z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * w1 + dot2 * h1;\n      dot1 = adx * a5x + ady * a5y + adz * a5z;\n      dot2 = adx * a6x + ady * a6y + adz * a6z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * h2 + dot2 * d2;\n      overlapd = len - len1 - len2;\n      if (overlapd > 0) return;\n    } else {\n      rightd = false;\n      overlapd = 0;\n      invalidd = true;\n    } // try axis 14\n\n\n    len = aex * aex + aey * aey + aez * aez;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      aex *= len;\n      aey *= len;\n      aez *= len;\n      len = aex * dx + aey * dy + aez * dz;\n      righte = len > 0;\n      if (!righte) len = -len;\n      dot1 = aex * a1x + aey * a1y + aez * a1z;\n      dot2 = aex * a2x + aey * a2y + aez * a2z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * w1 + dot2 * h1;\n      dot1 = aex * a4x + aey * a4y + aez * a4z;\n      dot2 = aex * a6x + aey * a6y + aez * a6z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * w2 + dot2 * d2;\n      overlape = len - len1 - len2;\n      if (overlape > 0) return;\n    } else {\n      righte = false;\n      overlape = 0;\n      invalide = true;\n    } // try axis 15\n\n\n    len = afx * afx + afy * afy + afz * afz;\n\n    if (len > 1e-5) {\n      len = 1 / _Math.sqrt(len);\n      afx *= len;\n      afy *= len;\n      afz *= len;\n      len = afx * dx + afy * dy + afz * dz;\n      rightf = len > 0;\n      if (!rightf) len = -len;\n      dot1 = afx * a1x + afy * a1y + afz * a1z;\n      dot2 = afx * a2x + afy * a2y + afz * a2z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len1 = dot1 * w1 + dot2 * h1;\n      dot1 = afx * a4x + afy * a4y + afz * a4z;\n      dot2 = afx * a5x + afy * a5y + afz * a5z;\n      if (dot1 < 0) dot1 = -dot1;\n      if (dot2 < 0) dot2 = -dot2;\n      len2 = dot1 * w2 + dot2 * h2;\n      overlapf = len - len1 - len2;\n      if (overlapf > 0) return;\n    } else {\n      rightf = false;\n      overlapf = 0;\n      invalidf = true;\n    } // boxes are overlapping\n\n\n    var depth = overlap1;\n    var depth2 = overlap1;\n    var minIndex = 0;\n    var right = right1;\n\n    if (overlap2 > depth2) {\n      depth = overlap2;\n      depth2 = overlap2;\n      minIndex = 1;\n      right = right2;\n    }\n\n    if (overlap3 > depth2) {\n      depth = overlap3;\n      depth2 = overlap3;\n      minIndex = 2;\n      right = right3;\n    }\n\n    if (overlap4 > depth2) {\n      depth = overlap4;\n      depth2 = overlap4;\n      minIndex = 3;\n      right = right4;\n    }\n\n    if (overlap5 > depth2) {\n      depth = overlap5;\n      depth2 = overlap5;\n      minIndex = 4;\n      right = right5;\n    }\n\n    if (overlap6 > depth2) {\n      depth = overlap6;\n      depth2 = overlap6;\n      minIndex = 5;\n      right = right6;\n    }\n\n    if (overlap7 - 0.01 > depth2 && !invalid7) {\n      depth = overlap7;\n      depth2 = overlap7 - 0.01;\n      minIndex = 6;\n      right = right7;\n    }\n\n    if (overlap8 - 0.01 > depth2 && !invalid8) {\n      depth = overlap8;\n      depth2 = overlap8 - 0.01;\n      minIndex = 7;\n      right = right8;\n    }\n\n    if (overlap9 - 0.01 > depth2 && !invalid9) {\n      depth = overlap9;\n      depth2 = overlap9 - 0.01;\n      minIndex = 8;\n      right = right9;\n    }\n\n    if (overlapa - 0.01 > depth2 && !invalida) {\n      depth = overlapa;\n      depth2 = overlapa - 0.01;\n      minIndex = 9;\n      right = righta;\n    }\n\n    if (overlapb - 0.01 > depth2 && !invalidb) {\n      depth = overlapb;\n      depth2 = overlapb - 0.01;\n      minIndex = 10;\n      right = rightb;\n    }\n\n    if (overlapc - 0.01 > depth2 && !invalidc) {\n      depth = overlapc;\n      depth2 = overlapc - 0.01;\n      minIndex = 11;\n      right = rightc;\n    }\n\n    if (overlapd - 0.01 > depth2 && !invalidd) {\n      depth = overlapd;\n      depth2 = overlapd - 0.01;\n      minIndex = 12;\n      right = rightd;\n    }\n\n    if (overlape - 0.01 > depth2 && !invalide) {\n      depth = overlape;\n      depth2 = overlape - 0.01;\n      minIndex = 13;\n      right = righte;\n    }\n\n    if (overlapf - 0.01 > depth2 && !invalidf) {\n      depth = overlapf;\n      minIndex = 14;\n      right = rightf;\n    } // normal\n\n\n    var nx = 0;\n    var ny = 0;\n    var nz = 0; // edge line or face side normal\n\n    var n1x = 0;\n    var n1y = 0;\n    var n1z = 0;\n    var n2x = 0;\n    var n2y = 0;\n    var n2z = 0; // center of current face\n\n    var cx = 0;\n    var cy = 0;\n    var cz = 0; // face side\n\n    var s1x = 0;\n    var s1y = 0;\n    var s1z = 0;\n    var s2x = 0;\n    var s2y = 0;\n    var s2z = 0; // swap b1 b2\n\n    var swap = false; //_______________________________________\n\n    if (minIndex == 0) {\n      // b1.x * b2\n      if (right) {\n        cx = p1x + d1x;\n        cy = p1y + d1y;\n        cz = p1z + d1z;\n        nx = a1x;\n        ny = a1y;\n        nz = a1z;\n      } else {\n        cx = p1x - d1x;\n        cy = p1y - d1y;\n        cz = p1z - d1z;\n        nx = -a1x;\n        ny = -a1y;\n        nz = -a1z;\n      }\n\n      s1x = d2x;\n      s1y = d2y;\n      s1z = d2z;\n      n1x = -a2x;\n      n1y = -a2y;\n      n1z = -a2z;\n      s2x = d3x;\n      s2y = d3y;\n      s2z = d3z;\n      n2x = -a3x;\n      n2y = -a3y;\n      n2z = -a3z;\n    } else if (minIndex == 1) {\n      // b1.y * b2\n      if (right) {\n        cx = p1x + d2x;\n        cy = p1y + d2y;\n        cz = p1z + d2z;\n        nx = a2x;\n        ny = a2y;\n        nz = a2z;\n      } else {\n        cx = p1x - d2x;\n        cy = p1y - d2y;\n        cz = p1z - d2z;\n        nx = -a2x;\n        ny = -a2y;\n        nz = -a2z;\n      }\n\n      s1x = d1x;\n      s1y = d1y;\n      s1z = d1z;\n      n1x = -a1x;\n      n1y = -a1y;\n      n1z = -a1z;\n      s2x = d3x;\n      s2y = d3y;\n      s2z = d3z;\n      n2x = -a3x;\n      n2y = -a3y;\n      n2z = -a3z;\n    } else if (minIndex == 2) {\n      // b1.z * b2\n      if (right) {\n        cx = p1x + d3x;\n        cy = p1y + d3y;\n        cz = p1z + d3z;\n        nx = a3x;\n        ny = a3y;\n        nz = a3z;\n      } else {\n        cx = p1x - d3x;\n        cy = p1y - d3y;\n        cz = p1z - d3z;\n        nx = -a3x;\n        ny = -a3y;\n        nz = -a3z;\n      }\n\n      s1x = d1x;\n      s1y = d1y;\n      s1z = d1z;\n      n1x = -a1x;\n      n1y = -a1y;\n      n1z = -a1z;\n      s2x = d2x;\n      s2y = d2y;\n      s2z = d2z;\n      n2x = -a2x;\n      n2y = -a2y;\n      n2z = -a2z;\n    } else if (minIndex == 3) {\n      // b2.x * b1\n      swap = true;\n\n      if (!right) {\n        cx = p2x + d4x;\n        cy = p2y + d4y;\n        cz = p2z + d4z;\n        nx = a4x;\n        ny = a4y;\n        nz = a4z;\n      } else {\n        cx = p2x - d4x;\n        cy = p2y - d4y;\n        cz = p2z - d4z;\n        nx = -a4x;\n        ny = -a4y;\n        nz = -a4z;\n      }\n\n      s1x = d5x;\n      s1y = d5y;\n      s1z = d5z;\n      n1x = -a5x;\n      n1y = -a5y;\n      n1z = -a5z;\n      s2x = d6x;\n      s2y = d6y;\n      s2z = d6z;\n      n2x = -a6x;\n      n2y = -a6y;\n      n2z = -a6z;\n    } else if (minIndex == 4) {\n      // b2.y * b1\n      swap = true;\n\n      if (!right) {\n        cx = p2x + d5x;\n        cy = p2y + d5y;\n        cz = p2z + d5z;\n        nx = a5x;\n        ny = a5y;\n        nz = a5z;\n      } else {\n        cx = p2x - d5x;\n        cy = p2y - d5y;\n        cz = p2z - d5z;\n        nx = -a5x;\n        ny = -a5y;\n        nz = -a5z;\n      }\n\n      s1x = d4x;\n      s1y = d4y;\n      s1z = d4z;\n      n1x = -a4x;\n      n1y = -a4y;\n      n1z = -a4z;\n      s2x = d6x;\n      s2y = d6y;\n      s2z = d6z;\n      n2x = -a6x;\n      n2y = -a6y;\n      n2z = -a6z;\n    } else if (minIndex == 5) {\n      // b2.z * b1\n      swap = true;\n\n      if (!right) {\n        cx = p2x + d6x;\n        cy = p2y + d6y;\n        cz = p2z + d6z;\n        nx = a6x;\n        ny = a6y;\n        nz = a6z;\n      } else {\n        cx = p2x - d6x;\n        cy = p2y - d6y;\n        cz = p2z - d6z;\n        nx = -a6x;\n        ny = -a6y;\n        nz = -a6z;\n      }\n\n      s1x = d4x;\n      s1y = d4y;\n      s1z = d4z;\n      n1x = -a4x;\n      n1y = -a4y;\n      n1z = -a4z;\n      s2x = d5x;\n      s2y = d5y;\n      s2z = d5z;\n      n2x = -a5x;\n      n2y = -a5y;\n      n2z = -a5z;\n    } else if (minIndex == 6) {\n      // b1.x * b2.x\n      nx = a7x;\n      ny = a7y;\n      nz = a7z;\n      n1x = a1x;\n      n1y = a1y;\n      n1z = a1z;\n      n2x = a4x;\n      n2y = a4y;\n      n2z = a4z;\n    } else if (minIndex == 7) {\n      // b1.x * b2.y\n      nx = a8x;\n      ny = a8y;\n      nz = a8z;\n      n1x = a1x;\n      n1y = a1y;\n      n1z = a1z;\n      n2x = a5x;\n      n2y = a5y;\n      n2z = a5z;\n    } else if (minIndex == 8) {\n      // b1.x * b2.z\n      nx = a9x;\n      ny = a9y;\n      nz = a9z;\n      n1x = a1x;\n      n1y = a1y;\n      n1z = a1z;\n      n2x = a6x;\n      n2y = a6y;\n      n2z = a6z;\n    } else if (minIndex == 9) {\n      // b1.y * b2.x\n      nx = aax;\n      ny = aay;\n      nz = aaz;\n      n1x = a2x;\n      n1y = a2y;\n      n1z = a2z;\n      n2x = a4x;\n      n2y = a4y;\n      n2z = a4z;\n    } else if (minIndex == 10) {\n      // b1.y * b2.y\n      nx = abx;\n      ny = aby;\n      nz = abz;\n      n1x = a2x;\n      n1y = a2y;\n      n1z = a2z;\n      n2x = a5x;\n      n2y = a5y;\n      n2z = a5z;\n    } else if (minIndex == 11) {\n      // b1.y * b2.z\n      nx = acx;\n      ny = acy;\n      nz = acz;\n      n1x = a2x;\n      n1y = a2y;\n      n1z = a2z;\n      n2x = a6x;\n      n2y = a6y;\n      n2z = a6z;\n    } else if (minIndex == 12) {\n      // b1.z * b2.x\n      nx = adx;\n      ny = ady;\n      nz = adz;\n      n1x = a3x;\n      n1y = a3y;\n      n1z = a3z;\n      n2x = a4x;\n      n2y = a4y;\n      n2z = a4z;\n    } else if (minIndex == 13) {\n      // b1.z * b2.y\n      nx = aex;\n      ny = aey;\n      nz = aez;\n      n1x = a3x;\n      n1y = a3y;\n      n1z = a3z;\n      n2x = a5x;\n      n2y = a5y;\n      n2z = a5z;\n    } else if (minIndex == 14) {\n      // b1.z * b2.z\n      nx = afx;\n      ny = afy;\n      nz = afz;\n      n1x = a3x;\n      n1y = a3y;\n      n1z = a3z;\n      n2x = a6x;\n      n2y = a6y;\n      n2z = a6z;\n    } //__________________________________________\n    //var v;\n\n\n    if (minIndex > 5) {\n      if (!right) {\n        nx = -nx;\n        ny = -ny;\n        nz = -nz;\n      }\n\n      var distance;\n      var maxDistance;\n      var vx;\n      var vy;\n      var vz;\n      var v1x;\n      var v1y;\n      var v1z;\n      var v2x;\n      var v2y;\n      var v2z; //vertex1;\n\n      v1x = V1[0];\n      v1y = V1[1];\n      v1z = V1[2];\n      maxDistance = nx * v1x + ny * v1y + nz * v1z; //vertex2;\n\n      vx = V1[3];\n      vy = V1[4];\n      vz = V1[5];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        v1x = vx;\n        v1y = vy;\n        v1z = vz;\n      } //vertex3;\n\n\n      vx = V1[6];\n      vy = V1[7];\n      vz = V1[8];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        v1x = vx;\n        v1y = vy;\n        v1z = vz;\n      } //vertex4;\n\n\n      vx = V1[9];\n      vy = V1[10];\n      vz = V1[11];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        v1x = vx;\n        v1y = vy;\n        v1z = vz;\n      } //vertex5;\n\n\n      vx = V1[12];\n      vy = V1[13];\n      vz = V1[14];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        v1x = vx;\n        v1y = vy;\n        v1z = vz;\n      } //vertex6;\n\n\n      vx = V1[15];\n      vy = V1[16];\n      vz = V1[17];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        v1x = vx;\n        v1y = vy;\n        v1z = vz;\n      } //vertex7;\n\n\n      vx = V1[18];\n      vy = V1[19];\n      vz = V1[20];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        v1x = vx;\n        v1y = vy;\n        v1z = vz;\n      } //vertex8;\n\n\n      vx = V1[21];\n      vy = V1[22];\n      vz = V1[23];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        v1x = vx;\n        v1y = vy;\n        v1z = vz;\n      } //vertex1;\n\n\n      v2x = V2[0];\n      v2y = V2[1];\n      v2z = V2[2];\n      maxDistance = nx * v2x + ny * v2y + nz * v2z; //vertex2;\n\n      vx = V2[3];\n      vy = V2[4];\n      vz = V2[5];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        v2x = vx;\n        v2y = vy;\n        v2z = vz;\n      } //vertex3;\n\n\n      vx = V2[6];\n      vy = V2[7];\n      vz = V2[8];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        v2x = vx;\n        v2y = vy;\n        v2z = vz;\n      } //vertex4;\n\n\n      vx = V2[9];\n      vy = V2[10];\n      vz = V2[11];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        v2x = vx;\n        v2y = vy;\n        v2z = vz;\n      } //vertex5;\n\n\n      vx = V2[12];\n      vy = V2[13];\n      vz = V2[14];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        v2x = vx;\n        v2y = vy;\n        v2z = vz;\n      } //vertex6;\n\n\n      vx = V2[15];\n      vy = V2[16];\n      vz = V2[17];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        v2x = vx;\n        v2y = vy;\n        v2z = vz;\n      } //vertex7;\n\n\n      vx = V2[18];\n      vy = V2[19];\n      vz = V2[20];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        v2x = vx;\n        v2y = vy;\n        v2z = vz;\n      } //vertex8;\n\n\n      vx = V2[21];\n      vy = V2[22];\n      vz = V2[23];\n      distance = nx * vx + ny * vy + nz * vz;\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        v2x = vx;\n        v2y = vy;\n        v2z = vz;\n      }\n\n      vx = v2x - v1x;\n      vy = v2y - v1y;\n      vz = v2z - v1z;\n      dot1 = n1x * n2x + n1y * n2y + n1z * n2z;\n      var t = (vx * (n1x - n2x * dot1) + vy * (n1y - n2y * dot1) + vz * (n1z - n2z * dot1)) / (1 - dot1 * dot1);\n      manifold.addPoint(v1x + n1x * t + nx * depth * 0.5, v1y + n1y * t + ny * depth * 0.5, v1z + n1z * t + nz * depth * 0.5, nx, ny, nz, depth, false);\n      return;\n    } // now detect face-face collision...\n    // target quad\n\n\n    var q1x;\n    var q1y;\n    var q1z;\n    var q2x;\n    var q2y;\n    var q2z;\n    var q3x;\n    var q3y;\n    var q3z;\n    var q4x;\n    var q4y;\n    var q4z; // search support face and vertex\n\n    var minDot = 1;\n    var dot = 0;\n    var minDotIndex = 0;\n\n    if (swap) {\n      dot = a1x * nx + a1y * ny + a1z * nz;\n\n      if (dot < minDot) {\n        minDot = dot;\n        minDotIndex = 0;\n      }\n\n      if (-dot < minDot) {\n        minDot = -dot;\n        minDotIndex = 1;\n      }\n\n      dot = a2x * nx + a2y * ny + a2z * nz;\n\n      if (dot < minDot) {\n        minDot = dot;\n        minDotIndex = 2;\n      }\n\n      if (-dot < minDot) {\n        minDot = -dot;\n        minDotIndex = 3;\n      }\n\n      dot = a3x * nx + a3y * ny + a3z * nz;\n\n      if (dot < minDot) {\n        minDot = dot;\n        minDotIndex = 4;\n      }\n\n      if (-dot < minDot) {\n        minDot = -dot;\n        minDotIndex = 5;\n      }\n\n      if (minDotIndex == 0) {\n        // x+ face\n        q1x = V1[0];\n        q1y = V1[1];\n        q1z = V1[2]; //vertex1\n\n        q2x = V1[6];\n        q2y = V1[7];\n        q2z = V1[8]; //vertex3\n\n        q3x = V1[9];\n        q3y = V1[10];\n        q3z = V1[11]; //vertex4\n\n        q4x = V1[3];\n        q4y = V1[4];\n        q4z = V1[5]; //vertex2\n      } else if (minDotIndex == 1) {\n        // x- face\n        q1x = V1[15];\n        q1y = V1[16];\n        q1z = V1[17]; //vertex6\n\n        q2x = V1[21];\n        q2y = V1[22];\n        q2z = V1[23]; //vertex8\n\n        q3x = V1[18];\n        q3y = V1[19];\n        q3z = V1[20]; //vertex7\n\n        q4x = V1[12];\n        q4y = V1[13];\n        q4z = V1[14]; //vertex5\n      } else if (minDotIndex == 2) {\n        // y+ face\n        q1x = V1[12];\n        q1y = V1[13];\n        q1z = V1[14]; //vertex5\n\n        q2x = V1[0];\n        q2y = V1[1];\n        q2z = V1[2]; //vertex1\n\n        q3x = V1[3];\n        q3y = V1[4];\n        q3z = V1[5]; //vertex2\n\n        q4x = V1[15];\n        q4y = V1[16];\n        q4z = V1[17]; //vertex6\n      } else if (minDotIndex == 3) {\n        // y- face\n        q1x = V1[21];\n        q1y = V1[22];\n        q1z = V1[23]; //vertex8\n\n        q2x = V1[9];\n        q2y = V1[10];\n        q2z = V1[11]; //vertex4\n\n        q3x = V1[6];\n        q3y = V1[7];\n        q3z = V1[8]; //vertex3\n\n        q4x = V1[18];\n        q4y = V1[19];\n        q4z = V1[20]; //vertex7\n      } else if (minDotIndex == 4) {\n        // z+ face\n        q1x = V1[12];\n        q1y = V1[13];\n        q1z = V1[14]; //vertex5\n\n        q2x = V1[18];\n        q2y = V1[19];\n        q2z = V1[20]; //vertex7\n\n        q3x = V1[6];\n        q3y = V1[7];\n        q3z = V1[8]; //vertex3\n\n        q4x = V1[0];\n        q4y = V1[1];\n        q4z = V1[2]; //vertex1\n      } else if (minDotIndex == 5) {\n        // z- face\n        q1x = V1[3];\n        q1y = V1[4];\n        q1z = V1[5]; //vertex2\n        //2x=V1[6]; q2y=V1[7]; q2z=V1[8];//vertex4 !!!\n\n        q2x = V2[9];\n        q2y = V2[10];\n        q2z = V2[11]; //vertex4\n\n        q3x = V1[21];\n        q3y = V1[22];\n        q3z = V1[23]; //vertex8\n\n        q4x = V1[15];\n        q4y = V1[16];\n        q4z = V1[17]; //vertex6\n      }\n    } else {\n      dot = a4x * nx + a4y * ny + a4z * nz;\n\n      if (dot < minDot) {\n        minDot = dot;\n        minDotIndex = 0;\n      }\n\n      if (-dot < minDot) {\n        minDot = -dot;\n        minDotIndex = 1;\n      }\n\n      dot = a5x * nx + a5y * ny + a5z * nz;\n\n      if (dot < minDot) {\n        minDot = dot;\n        minDotIndex = 2;\n      }\n\n      if (-dot < minDot) {\n        minDot = -dot;\n        minDotIndex = 3;\n      }\n\n      dot = a6x * nx + a6y * ny + a6z * nz;\n\n      if (dot < minDot) {\n        minDot = dot;\n        minDotIndex = 4;\n      }\n\n      if (-dot < minDot) {\n        minDot = -dot;\n        minDotIndex = 5;\n      } //______________________________________________________\n\n\n      if (minDotIndex == 0) {\n        // x+ face\n        q1x = V2[0];\n        q1y = V2[1];\n        q1z = V2[2]; //vertex1\n\n        q2x = V2[6];\n        q2y = V2[7];\n        q2z = V2[8]; //vertex3\n\n        q3x = V2[9];\n        q3y = V2[10];\n        q3z = V2[11]; //vertex4\n\n        q4x = V2[3];\n        q4y = V2[4];\n        q4z = V2[5]; //vertex2\n      } else if (minDotIndex == 1) {\n        // x- face\n        q1x = V2[15];\n        q1y = V2[16];\n        q1z = V2[17]; //vertex6\n\n        q2x = V2[21];\n        q2y = V2[22];\n        q2z = V2[23]; //vertex8\n\n        q3x = V2[18];\n        q3y = V2[19];\n        q3z = V2[20]; //vertex7\n\n        q4x = V2[12];\n        q4y = V2[13];\n        q4z = V2[14]; //vertex5\n      } else if (minDotIndex == 2) {\n        // y+ face\n        q1x = V2[12];\n        q1y = V2[13];\n        q1z = V2[14]; //vertex5\n\n        q2x = V2[0];\n        q2y = V2[1];\n        q2z = V2[2]; //vertex1\n\n        q3x = V2[3];\n        q3y = V2[4];\n        q3z = V2[5]; //vertex2\n\n        q4x = V2[15];\n        q4y = V2[16];\n        q4z = V2[17]; //vertex6\n      } else if (minDotIndex == 3) {\n        // y- face\n        q1x = V2[21];\n        q1y = V2[22];\n        q1z = V2[23]; //vertex8\n\n        q2x = V2[9];\n        q2y = V2[10];\n        q2z = V2[11]; //vertex4\n\n        q3x = V2[6];\n        q3y = V2[7];\n        q3z = V2[8]; //vertex3\n\n        q4x = V2[18];\n        q4y = V2[19];\n        q4z = V2[20]; //vertex7\n      } else if (minDotIndex == 4) {\n        // z+ face\n        q1x = V2[12];\n        q1y = V2[13];\n        q1z = V2[14]; //vertex5\n\n        q2x = V2[18];\n        q2y = V2[19];\n        q2z = V2[20]; //vertex7\n\n        q3x = V2[6];\n        q3y = V2[7];\n        q3z = V2[8]; //vertex3\n\n        q4x = V2[0];\n        q4y = V2[1];\n        q4z = V2[2]; //vertex1\n      } else if (minDotIndex == 5) {\n        // z- face\n        q1x = V2[3];\n        q1y = V2[4];\n        q1z = V2[5]; //vertex2\n\n        q2x = V2[9];\n        q2y = V2[10];\n        q2z = V2[11]; //vertex4\n\n        q3x = V2[21];\n        q3y = V2[22];\n        q3z = V2[23]; //vertex8\n\n        q4x = V2[15];\n        q4y = V2[16];\n        q4z = V2[17]; //vertex6\n      }\n    } // clip vertices\n\n\n    var numClipVertices;\n    var numAddedClipVertices;\n    var index;\n    var x1;\n    var y1;\n    var z1;\n    var x2;\n    var y2;\n    var z2;\n    this.clipVertices1[0] = q1x;\n    this.clipVertices1[1] = q1y;\n    this.clipVertices1[2] = q1z;\n    this.clipVertices1[3] = q2x;\n    this.clipVertices1[4] = q2y;\n    this.clipVertices1[5] = q2z;\n    this.clipVertices1[6] = q3x;\n    this.clipVertices1[7] = q3y;\n    this.clipVertices1[8] = q3z;\n    this.clipVertices1[9] = q4x;\n    this.clipVertices1[10] = q4y;\n    this.clipVertices1[11] = q4z;\n    numAddedClipVertices = 0;\n    x1 = this.clipVertices1[9];\n    y1 = this.clipVertices1[10];\n    z1 = this.clipVertices1[11];\n    dot1 = (x1 - cx - s1x) * n1x + (y1 - cy - s1y) * n1y + (z1 - cz - s1z) * n1z; //var i = 4;\n    //while(i--){\n\n    for (var i = 0; i < 4; i++) {\n      index = i * 3;\n      x2 = this.clipVertices1[index];\n      y2 = this.clipVertices1[index + 1];\n      z2 = this.clipVertices1[index + 2];\n      dot2 = (x2 - cx - s1x) * n1x + (y2 - cy - s1y) * n1y + (z2 - cz - s1z) * n1z;\n\n      if (dot1 > 0) {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices2[index] = x2;\n          this.clipVertices2[index + 1] = y2;\n          this.clipVertices2[index + 2] = z2;\n        } else {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices2[index] = x1 + (x2 - x1) * t;\n          this.clipVertices2[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices2[index + 2] = z1 + (z2 - z1) * t;\n        }\n      } else {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices2[index] = x1 + (x2 - x1) * t;\n          this.clipVertices2[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices2[index + 2] = z1 + (z2 - z1) * t;\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices2[index] = x2;\n          this.clipVertices2[index + 1] = y2;\n          this.clipVertices2[index + 2] = z2;\n        }\n      }\n\n      x1 = x2;\n      y1 = y2;\n      z1 = z2;\n      dot1 = dot2;\n    }\n\n    numClipVertices = numAddedClipVertices;\n    if (numClipVertices == 0) return;\n    numAddedClipVertices = 0;\n    index = (numClipVertices - 1) * 3;\n    x1 = this.clipVertices2[index];\n    y1 = this.clipVertices2[index + 1];\n    z1 = this.clipVertices2[index + 2];\n    dot1 = (x1 - cx - s2x) * n2x + (y1 - cy - s2y) * n2y + (z1 - cz - s2z) * n2z; //i = numClipVertices;\n    //while(i--){\n\n    for (i = 0; i < numClipVertices; i++) {\n      index = i * 3;\n      x2 = this.clipVertices2[index];\n      y2 = this.clipVertices2[index + 1];\n      z2 = this.clipVertices2[index + 2];\n      dot2 = (x2 - cx - s2x) * n2x + (y2 - cy - s2y) * n2y + (z2 - cz - s2z) * n2z;\n\n      if (dot1 > 0) {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices1[index] = x2;\n          this.clipVertices1[index + 1] = y2;\n          this.clipVertices1[index + 2] = z2;\n        } else {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices1[index] = x1 + (x2 - x1) * t;\n          this.clipVertices1[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices1[index + 2] = z1 + (z2 - z1) * t;\n        }\n      } else {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices1[index] = x1 + (x2 - x1) * t;\n          this.clipVertices1[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices1[index + 2] = z1 + (z2 - z1) * t;\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices1[index] = x2;\n          this.clipVertices1[index + 1] = y2;\n          this.clipVertices1[index + 2] = z2;\n        }\n      }\n\n      x1 = x2;\n      y1 = y2;\n      z1 = z2;\n      dot1 = dot2;\n    }\n\n    numClipVertices = numAddedClipVertices;\n    if (numClipVertices == 0) return;\n    numAddedClipVertices = 0;\n    index = (numClipVertices - 1) * 3;\n    x1 = this.clipVertices1[index];\n    y1 = this.clipVertices1[index + 1];\n    z1 = this.clipVertices1[index + 2];\n    dot1 = (x1 - cx + s1x) * -n1x + (y1 - cy + s1y) * -n1y + (z1 - cz + s1z) * -n1z; //i = numClipVertices;\n    //while(i--){\n\n    for (i = 0; i < numClipVertices; i++) {\n      index = i * 3;\n      x2 = this.clipVertices1[index];\n      y2 = this.clipVertices1[index + 1];\n      z2 = this.clipVertices1[index + 2];\n      dot2 = (x2 - cx + s1x) * -n1x + (y2 - cy + s1y) * -n1y + (z2 - cz + s1z) * -n1z;\n\n      if (dot1 > 0) {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices2[index] = x2;\n          this.clipVertices2[index + 1] = y2;\n          this.clipVertices2[index + 2] = z2;\n        } else {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices2[index] = x1 + (x2 - x1) * t;\n          this.clipVertices2[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices2[index + 2] = z1 + (z2 - z1) * t;\n        }\n      } else {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices2[index] = x1 + (x2 - x1) * t;\n          this.clipVertices2[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices2[index + 2] = z1 + (z2 - z1) * t;\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices2[index] = x2;\n          this.clipVertices2[index + 1] = y2;\n          this.clipVertices2[index + 2] = z2;\n        }\n      }\n\n      x1 = x2;\n      y1 = y2;\n      z1 = z2;\n      dot1 = dot2;\n    }\n\n    numClipVertices = numAddedClipVertices;\n    if (numClipVertices == 0) return;\n    numAddedClipVertices = 0;\n    index = (numClipVertices - 1) * 3;\n    x1 = this.clipVertices2[index];\n    y1 = this.clipVertices2[index + 1];\n    z1 = this.clipVertices2[index + 2];\n    dot1 = (x1 - cx + s2x) * -n2x + (y1 - cy + s2y) * -n2y + (z1 - cz + s2z) * -n2z; //i = numClipVertices;\n    //while(i--){\n\n    for (i = 0; i < numClipVertices; i++) {\n      index = i * 3;\n      x2 = this.clipVertices2[index];\n      y2 = this.clipVertices2[index + 1];\n      z2 = this.clipVertices2[index + 2];\n      dot2 = (x2 - cx + s2x) * -n2x + (y2 - cy + s2y) * -n2y + (z2 - cz + s2z) * -n2z;\n\n      if (dot1 > 0) {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices1[index] = x2;\n          this.clipVertices1[index + 1] = y2;\n          this.clipVertices1[index + 2] = z2;\n        } else {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices1[index] = x1 + (x2 - x1) * t;\n          this.clipVertices1[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices1[index + 2] = z1 + (z2 - z1) * t;\n        }\n      } else {\n        if (dot2 > 0) {\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          t = dot1 / (dot1 - dot2);\n          this.clipVertices1[index] = x1 + (x2 - x1) * t;\n          this.clipVertices1[index + 1] = y1 + (y2 - y1) * t;\n          this.clipVertices1[index + 2] = z1 + (z2 - z1) * t;\n          index = numAddedClipVertices * 3;\n          numAddedClipVertices++;\n          this.clipVertices1[index] = x2;\n          this.clipVertices1[index + 1] = y2;\n          this.clipVertices1[index + 2] = z2;\n        }\n      }\n\n      x1 = x2;\n      y1 = y2;\n      z1 = z2;\n      dot1 = dot2;\n    }\n\n    numClipVertices = numAddedClipVertices;\n\n    if (swap) {\n      var tb = b1;\n      b1 = b2;\n      b2 = tb;\n    }\n\n    if (numClipVertices == 0) return;\n    var flipped = b1 != shape1;\n\n    if (numClipVertices > 4) {\n      x1 = (q1x + q2x + q3x + q4x) * 0.25;\n      y1 = (q1y + q2y + q3y + q4y) * 0.25;\n      z1 = (q1z + q2z + q3z + q4z) * 0.25;\n      n1x = q1x - x1;\n      n1y = q1y - y1;\n      n1z = q1z - z1;\n      n2x = q2x - x1;\n      n2y = q2y - y1;\n      n2z = q2z - z1;\n      var index1 = 0;\n      var index2 = 0;\n      var index3 = 0;\n      var index4 = 0;\n      var maxDot = -this.INF;\n      minDot = this.INF; //i = numClipVertices;\n      //while(i--){\n\n      for (i = 0; i < numClipVertices; i++) {\n        this.used[i] = false;\n        index = i * 3;\n        x1 = this.clipVertices1[index];\n        y1 = this.clipVertices1[index + 1];\n        z1 = this.clipVertices1[index + 2];\n        dot = x1 * n1x + y1 * n1y + z1 * n1z;\n\n        if (dot < minDot) {\n          minDot = dot;\n          index1 = i;\n        }\n\n        if (dot > maxDot) {\n          maxDot = dot;\n          index3 = i;\n        }\n      }\n\n      this.used[index1] = true;\n      this.used[index3] = true;\n      maxDot = -this.INF;\n      minDot = this.INF; //i = numClipVertices;\n      //while(i--){\n\n      for (i = 0; i < numClipVertices; i++) {\n        if (this.used[i]) continue;\n        index = i * 3;\n        x1 = this.clipVertices1[index];\n        y1 = this.clipVertices1[index + 1];\n        z1 = this.clipVertices1[index + 2];\n        dot = x1 * n2x + y1 * n2y + z1 * n2z;\n\n        if (dot < minDot) {\n          minDot = dot;\n          index2 = i;\n        }\n\n        if (dot > maxDot) {\n          maxDot = dot;\n          index4 = i;\n        }\n      }\n\n      index = index1 * 3;\n      x1 = this.clipVertices1[index];\n      y1 = this.clipVertices1[index + 1];\n      z1 = this.clipVertices1[index + 2];\n      dot = (x1 - cx) * nx + (y1 - cy) * ny + (z1 - cz) * nz;\n      if (dot < 0) manifold.addPoint(x1, y1, z1, nx, ny, nz, dot, flipped);\n      index = index2 * 3;\n      x1 = this.clipVertices1[index];\n      y1 = this.clipVertices1[index + 1];\n      z1 = this.clipVertices1[index + 2];\n      dot = (x1 - cx) * nx + (y1 - cy) * ny + (z1 - cz) * nz;\n      if (dot < 0) manifold.addPoint(x1, y1, z1, nx, ny, nz, dot, flipped);\n      index = index3 * 3;\n      x1 = this.clipVertices1[index];\n      y1 = this.clipVertices1[index + 1];\n      z1 = this.clipVertices1[index + 2];\n      dot = (x1 - cx) * nx + (y1 - cy) * ny + (z1 - cz) * nz;\n      if (dot < 0) manifold.addPoint(x1, y1, z1, nx, ny, nz, dot, flipped);\n      index = index4 * 3;\n      x1 = this.clipVertices1[index];\n      y1 = this.clipVertices1[index + 1];\n      z1 = this.clipVertices1[index + 2];\n      dot = (x1 - cx) * nx + (y1 - cy) * ny + (z1 - cz) * nz;\n      if (dot < 0) manifold.addPoint(x1, y1, z1, nx, ny, nz, dot, flipped);\n    } else {\n      //i = numClipVertices;\n      //while(i--){\n      for (i = 0; i < numClipVertices; i++) {\n        index = i * 3;\n        x1 = this.clipVertices1[index];\n        y1 = this.clipVertices1[index + 1];\n        z1 = this.clipVertices1[index + 2];\n        dot = (x1 - cx) * nx + (y1 - cy) * ny + (z1 - cz) * nz;\n        if (dot < 0) manifold.addPoint(x1, y1, z1, nx, ny, nz, dot, flipped);\n      }\n    }\n  }\n});\n\nfunction BoxCylinderCollisionDetector(flip) {\n  CollisionDetector.call(this);\n  this.flip = flip;\n}\n\nBoxCylinderCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: BoxCylinderCollisionDetector,\n  getSep: function (c1, c2, sep, pos, dep) {\n    var t1x;\n    var t1y;\n    var t1z;\n    var t2x;\n    var t2y;\n    var t2z;\n    var sup = new Vec3();\n    var len;\n    var p1x;\n    var p1y;\n    var p1z;\n    var p2x;\n    var p2y;\n    var p2z;\n    var v01x = c1.position.x;\n    var v01y = c1.position.y;\n    var v01z = c1.position.z;\n    var v02x = c2.position.x;\n    var v02y = c2.position.y;\n    var v02z = c2.position.z;\n    var v0x = v02x - v01x;\n    var v0y = v02y - v01y;\n    var v0z = v02z - v01z;\n    if (v0x * v0x + v0y * v0y + v0z * v0z == 0) v0y = 0.001;\n    var nx = -v0x;\n    var ny = -v0y;\n    var nz = -v0z;\n    this.supportPointB(c1, -nx, -ny, -nz, sup);\n    var v11x = sup.x;\n    var v11y = sup.y;\n    var v11z = sup.z;\n    this.supportPointC(c2, nx, ny, nz, sup);\n    var v12x = sup.x;\n    var v12y = sup.y;\n    var v12z = sup.z;\n    var v1x = v12x - v11x;\n    var v1y = v12y - v11y;\n    var v1z = v12z - v11z;\n\n    if (v1x * nx + v1y * ny + v1z * nz <= 0) {\n      return false;\n    }\n\n    nx = v1y * v0z - v1z * v0y;\n    ny = v1z * v0x - v1x * v0z;\n    nz = v1x * v0y - v1y * v0x;\n\n    if (nx * nx + ny * ny + nz * nz == 0) {\n      sep.set(v1x - v0x, v1y - v0y, v1z - v0z).normalize();\n      pos.set((v11x + v12x) * 0.5, (v11y + v12y) * 0.5, (v11z + v12z) * 0.5);\n      return true;\n    }\n\n    this.supportPointB(c1, -nx, -ny, -nz, sup);\n    var v21x = sup.x;\n    var v21y = sup.y;\n    var v21z = sup.z;\n    this.supportPointC(c2, nx, ny, nz, sup);\n    var v22x = sup.x;\n    var v22y = sup.y;\n    var v22z = sup.z;\n    var v2x = v22x - v21x;\n    var v2y = v22y - v21y;\n    var v2z = v22z - v21z;\n\n    if (v2x * nx + v2y * ny + v2z * nz <= 0) {\n      return false;\n    }\n\n    t1x = v1x - v0x;\n    t1y = v1y - v0y;\n    t1z = v1z - v0z;\n    t2x = v2x - v0x;\n    t2y = v2y - v0y;\n    t2z = v2z - v0z;\n    nx = t1y * t2z - t1z * t2y;\n    ny = t1z * t2x - t1x * t2z;\n    nz = t1x * t2y - t1y * t2x;\n\n    if (nx * v0x + ny * v0y + nz * v0z > 0) {\n      t1x = v1x;\n      t1y = v1y;\n      t1z = v1z;\n      v1x = v2x;\n      v1y = v2y;\n      v1z = v2z;\n      v2x = t1x;\n      v2y = t1y;\n      v2z = t1z;\n      t1x = v11x;\n      t1y = v11y;\n      t1z = v11z;\n      v11x = v21x;\n      v11y = v21y;\n      v11z = v21z;\n      v21x = t1x;\n      v21y = t1y;\n      v21z = t1z;\n      t1x = v12x;\n      t1y = v12y;\n      t1z = v12z;\n      v12x = v22x;\n      v12y = v22y;\n      v12z = v22z;\n      v22x = t1x;\n      v22y = t1y;\n      v22z = t1z;\n      nx = -nx;\n      ny = -ny;\n      nz = -nz;\n    }\n\n    var iterations = 0;\n\n    while (true) {\n      if (++iterations > 100) {\n        return false;\n      }\n\n      this.supportPointB(c1, -nx, -ny, -nz, sup);\n      var v31x = sup.x;\n      var v31y = sup.y;\n      var v31z = sup.z;\n      this.supportPointC(c2, nx, ny, nz, sup);\n      var v32x = sup.x;\n      var v32y = sup.y;\n      var v32z = sup.z;\n      var v3x = v32x - v31x;\n      var v3y = v32y - v31y;\n      var v3z = v32z - v31z;\n\n      if (v3x * nx + v3y * ny + v3z * nz <= 0) {\n        return false;\n      }\n\n      if ((v1y * v3z - v1z * v3y) * v0x + (v1z * v3x - v1x * v3z) * v0y + (v1x * v3y - v1y * v3x) * v0z < 0) {\n        v2x = v3x;\n        v2y = v3y;\n        v2z = v3z;\n        v21x = v31x;\n        v21y = v31y;\n        v21z = v31z;\n        v22x = v32x;\n        v22y = v32y;\n        v22z = v32z;\n        t1x = v1x - v0x;\n        t1y = v1y - v0y;\n        t1z = v1z - v0z;\n        t2x = v3x - v0x;\n        t2y = v3y - v0y;\n        t2z = v3z - v0z;\n        nx = t1y * t2z - t1z * t2y;\n        ny = t1z * t2x - t1x * t2z;\n        nz = t1x * t2y - t1y * t2x;\n        continue;\n      }\n\n      if ((v3y * v2z - v3z * v2y) * v0x + (v3z * v2x - v3x * v2z) * v0y + (v3x * v2y - v3y * v2x) * v0z < 0) {\n        v1x = v3x;\n        v1y = v3y;\n        v1z = v3z;\n        v11x = v31x;\n        v11y = v31y;\n        v11z = v31z;\n        v12x = v32x;\n        v12y = v32y;\n        v12z = v32z;\n        t1x = v3x - v0x;\n        t1y = v3y - v0y;\n        t1z = v3z - v0z;\n        t2x = v2x - v0x;\n        t2y = v2y - v0y;\n        t2z = v2z - v0z;\n        nx = t1y * t2z - t1z * t2y;\n        ny = t1z * t2x - t1x * t2z;\n        nz = t1x * t2y - t1y * t2x;\n        continue;\n      }\n\n      var hit = false;\n\n      while (true) {\n        t1x = v2x - v1x;\n        t1y = v2y - v1y;\n        t1z = v2z - v1z;\n        t2x = v3x - v1x;\n        t2y = v3y - v1y;\n        t2z = v3z - v1z;\n        nx = t1y * t2z - t1z * t2y;\n        ny = t1z * t2x - t1x * t2z;\n        nz = t1x * t2y - t1y * t2x;\n        len = 1 / _Math.sqrt(nx * nx + ny * ny + nz * nz);\n        nx *= len;\n        ny *= len;\n        nz *= len;\n\n        if (nx * v1x + ny * v1y + nz * v1z >= 0 && !hit) {\n          var b0 = (v1y * v2z - v1z * v2y) * v3x + (v1z * v2x - v1x * v2z) * v3y + (v1x * v2y - v1y * v2x) * v3z;\n          var b1 = (v3y * v2z - v3z * v2y) * v0x + (v3z * v2x - v3x * v2z) * v0y + (v3x * v2y - v3y * v2x) * v0z;\n          var b2 = (v0y * v1z - v0z * v1y) * v3x + (v0z * v1x - v0x * v1z) * v3y + (v0x * v1y - v0y * v1x) * v3z;\n          var b3 = (v2y * v1z - v2z * v1y) * v0x + (v2z * v1x - v2x * v1z) * v0y + (v2x * v1y - v2y * v1x) * v0z;\n          var sum = b0 + b1 + b2 + b3;\n\n          if (sum <= 0) {\n            b0 = 0;\n            b1 = (v2y * v3z - v2z * v3y) * nx + (v2z * v3x - v2x * v3z) * ny + (v2x * v3y - v2y * v3x) * nz;\n            b2 = (v3y * v2z - v3z * v2y) * nx + (v3z * v2x - v3x * v2z) * ny + (v3x * v2y - v3y * v2x) * nz;\n            b3 = (v1y * v2z - v1z * v2y) * nx + (v1z * v2x - v1x * v2z) * ny + (v1x * v2y - v1y * v2x) * nz;\n            sum = b1 + b2 + b3;\n          }\n\n          var inv = 1 / sum;\n          p1x = (v01x * b0 + v11x * b1 + v21x * b2 + v31x * b3) * inv;\n          p1y = (v01y * b0 + v11y * b1 + v21y * b2 + v31y * b3) * inv;\n          p1z = (v01z * b0 + v11z * b1 + v21z * b2 + v31z * b3) * inv;\n          p2x = (v02x * b0 + v12x * b1 + v22x * b2 + v32x * b3) * inv;\n          p2y = (v02y * b0 + v12y * b1 + v22y * b2 + v32y * b3) * inv;\n          p2z = (v02z * b0 + v12z * b1 + v22z * b2 + v32z * b3) * inv;\n          hit = true;\n        }\n\n        this.supportPointB(c1, -nx, -ny, -nz, sup);\n        var v41x = sup.x;\n        var v41y = sup.y;\n        var v41z = sup.z;\n        this.supportPointC(c2, nx, ny, nz, sup);\n        var v42x = sup.x;\n        var v42y = sup.y;\n        var v42z = sup.z;\n        var v4x = v42x - v41x;\n        var v4y = v42y - v41y;\n        var v4z = v42z - v41z;\n        var separation = -(v4x * nx + v4y * ny + v4z * nz);\n\n        if ((v4x - v3x) * nx + (v4y - v3y) * ny + (v4z - v3z) * nz <= 0.01 || separation >= 0) {\n          if (hit) {\n            sep.set(-nx, -ny, -nz);\n            pos.set((p1x + p2x) * 0.5, (p1y + p2y) * 0.5, (p1z + p2z) * 0.5);\n            dep.x = separation;\n            return true;\n          }\n\n          return false;\n        }\n\n        if ((v4y * v1z - v4z * v1y) * v0x + (v4z * v1x - v4x * v1z) * v0y + (v4x * v1y - v4y * v1x) * v0z < 0) {\n          if ((v4y * v2z - v4z * v2y) * v0x + (v4z * v2x - v4x * v2z) * v0y + (v4x * v2y - v4y * v2x) * v0z < 0) {\n            v1x = v4x;\n            v1y = v4y;\n            v1z = v4z;\n            v11x = v41x;\n            v11y = v41y;\n            v11z = v41z;\n            v12x = v42x;\n            v12y = v42y;\n            v12z = v42z;\n          } else {\n            v3x = v4x;\n            v3y = v4y;\n            v3z = v4z;\n            v31x = v41x;\n            v31y = v41y;\n            v31z = v41z;\n            v32x = v42x;\n            v32y = v42y;\n            v32z = v42z;\n          }\n        } else {\n          if ((v4y * v3z - v4z * v3y) * v0x + (v4z * v3x - v4x * v3z) * v0y + (v4x * v3y - v4y * v3x) * v0z < 0) {\n            v2x = v4x;\n            v2y = v4y;\n            v2z = v4z;\n            v21x = v41x;\n            v21y = v41y;\n            v21z = v41z;\n            v22x = v42x;\n            v22y = v42y;\n            v22z = v42z;\n          } else {\n            v1x = v4x;\n            v1y = v4y;\n            v1z = v4z;\n            v11x = v41x;\n            v11y = v41y;\n            v11z = v41z;\n            v12x = v42x;\n            v12y = v42y;\n            v12z = v42z;\n          }\n        }\n      }\n    } //return false;\n\n  },\n  supportPointB: function (c, dx, dy, dz, out) {\n    var rot = c.rotation.elements;\n    var ldx = rot[0] * dx + rot[3] * dy + rot[6] * dz;\n    var ldy = rot[1] * dx + rot[4] * dy + rot[7] * dz;\n    var ldz = rot[2] * dx + rot[5] * dy + rot[8] * dz;\n    var w = c.halfWidth;\n    var h = c.halfHeight;\n    var d = c.halfDepth;\n    var ox;\n    var oy;\n    var oz;\n    if (ldx < 0) ox = -w;else ox = w;\n    if (ldy < 0) oy = -h;else oy = h;\n    if (ldz < 0) oz = -d;else oz = d;\n    ldx = rot[0] * ox + rot[1] * oy + rot[2] * oz + c.position.x;\n    ldy = rot[3] * ox + rot[4] * oy + rot[5] * oz + c.position.y;\n    ldz = rot[6] * ox + rot[7] * oy + rot[8] * oz + c.position.z;\n    out.set(ldx, ldy, ldz);\n  },\n  supportPointC: function (c, dx, dy, dz, out) {\n    var rot = c.rotation.elements;\n    var ldx = rot[0] * dx + rot[3] * dy + rot[6] * dz;\n    var ldy = rot[1] * dx + rot[4] * dy + rot[7] * dz;\n    var ldz = rot[2] * dx + rot[5] * dy + rot[8] * dz;\n    var radx = ldx;\n    var radz = ldz;\n    var len = radx * radx + radz * radz;\n    var rad = c.radius;\n    var hh = c.halfHeight;\n    var ox;\n    var oy;\n    var oz;\n\n    if (len == 0) {\n      if (ldy < 0) {\n        ox = rad;\n        oy = -hh;\n        oz = 0;\n      } else {\n        ox = rad;\n        oy = hh;\n        oz = 0;\n      }\n    } else {\n      len = c.radius / _Math.sqrt(len);\n\n      if (ldy < 0) {\n        ox = radx * len;\n        oy = -hh;\n        oz = radz * len;\n      } else {\n        ox = radx * len;\n        oy = hh;\n        oz = radz * len;\n      }\n    }\n\n    ldx = rot[0] * ox + rot[1] * oy + rot[2] * oz + c.position.x;\n    ldy = rot[3] * ox + rot[4] * oy + rot[5] * oz + c.position.y;\n    ldz = rot[6] * ox + rot[7] * oy + rot[8] * oz + c.position.z;\n    out.set(ldx, ldy, ldz);\n  },\n  detectCollision: function (shape1, shape2, manifold) {\n    var b;\n    var c;\n\n    if (this.flip) {\n      b = shape2;\n      c = shape1;\n    } else {\n      b = shape1;\n      c = shape2;\n    }\n\n    var sep = new Vec3();\n    var pos = new Vec3();\n    var dep = new Vec3();\n    if (!this.getSep(b, c, sep, pos, dep)) return;\n    var pbx = b.position.x;\n    var pby = b.position.y;\n    var pbz = b.position.z;\n    var pcx = c.position.x;\n    var pcy = c.position.y;\n    var pcz = c.position.z;\n    var bw = b.halfWidth;\n    var bh = b.halfHeight;\n    var bd = b.halfDepth;\n    var ch = c.halfHeight;\n    var r = c.radius;\n    var D = b.dimentions;\n    var nwx = D[0]; //b.normalDirectionWidth.x;\n\n    var nwy = D[1]; //b.normalDirectionWidth.y;\n\n    var nwz = D[2]; //b.normalDirectionWidth.z;\n\n    var nhx = D[3]; //b.normalDirectionHeight.x;\n\n    var nhy = D[4]; //b.normalDirectionHeight.y;\n\n    var nhz = D[5]; //b.normalDirectionHeight.z;\n\n    var ndx = D[6]; //b.normalDirectionDepth.x;\n\n    var ndy = D[7]; //b.normalDirectionDepth.y;\n\n    var ndz = D[8]; //b.normalDirectionDepth.z;\n\n    var dwx = D[9]; //b.halfDirectionWidth.x;\n\n    var dwy = D[10]; //b.halfDirectionWidth.y;\n\n    var dwz = D[11]; //b.halfDirectionWidth.z;\n\n    var dhx = D[12]; //b.halfDirectionHeight.x;\n\n    var dhy = D[13]; //b.halfDirectionHeight.y;\n\n    var dhz = D[14]; //b.halfDirectionHeight.z;\n\n    var ddx = D[15]; //b.halfDirectionDepth.x;\n\n    var ddy = D[16]; //b.halfDirectionDepth.y;\n\n    var ddz = D[17]; //b.halfDirectionDepth.z;\n\n    var ncx = c.normalDirection.x;\n    var ncy = c.normalDirection.y;\n    var ncz = c.normalDirection.z;\n    var dcx = c.halfDirection.x;\n    var dcy = c.halfDirection.y;\n    var dcz = c.halfDirection.z;\n    var nx = sep.x;\n    var ny = sep.y;\n    var nz = sep.z;\n    var dotw = nx * nwx + ny * nwy + nz * nwz;\n    var doth = nx * nhx + ny * nhy + nz * nhz;\n    var dotd = nx * ndx + ny * ndy + nz * ndz;\n    var dotc = nx * ncx + ny * ncy + nz * ncz;\n    var right1 = dotw > 0;\n    var right2 = doth > 0;\n    var right3 = dotd > 0;\n    var right4 = dotc > 0;\n    if (!right1) dotw = -dotw;\n    if (!right2) doth = -doth;\n    if (!right3) dotd = -dotd;\n    if (!right4) dotc = -dotc;\n    var state = 0;\n\n    if (dotc > 0.999) {\n      if (dotw > 0.999) {\n        if (dotw > dotc) state = 1;else state = 4;\n      } else if (doth > 0.999) {\n        if (doth > dotc) state = 2;else state = 4;\n      } else if (dotd > 0.999) {\n        if (dotd > dotc) state = 3;else state = 4;\n      } else state = 4;\n    } else {\n      if (dotw > 0.999) state = 1;else if (doth > 0.999) state = 2;else if (dotd > 0.999) state = 3;\n    }\n\n    var cbx;\n    var cby;\n    var cbz;\n    var ccx;\n    var ccy;\n    var ccz;\n    var r00;\n    var r01;\n    var r02;\n    var r10;\n    var r11;\n    var r12;\n    var r20;\n    var r21;\n    var r22;\n    var px;\n    var py;\n    var pz;\n    var pd;\n    var dot;\n    var len;\n    var tx;\n    var ty;\n    var tz;\n    var td;\n    var dx;\n    var dy;\n    var dz;\n    var d1x;\n    var d1y;\n    var d1z;\n    var d2x;\n    var d2y;\n    var d2z;\n    var sx;\n    var sy;\n    var sz;\n    var sd;\n    var ex;\n    var ey;\n    var ez;\n    var ed;\n    var dot1;\n    var dot2;\n    var t1;\n    var dir1x;\n    var dir1y;\n    var dir1z;\n    var dir2x;\n    var dir2y;\n    var dir2z;\n    var dir1l;\n    var dir2l;\n\n    if (state == 0) {\n      //manifold.addPoint(pos.x,pos.y,pos.z,nx,ny,nz,dep.x,b,c,0,0,false);\n      manifold.addPoint(pos.x, pos.y, pos.z, nx, ny, nz, dep.x, this.flip);\n    } else if (state == 4) {\n      if (right4) {\n        ccx = pcx - dcx;\n        ccy = pcy - dcy;\n        ccz = pcz - dcz;\n        nx = -ncx;\n        ny = -ncy;\n        nz = -ncz;\n      } else {\n        ccx = pcx + dcx;\n        ccy = pcy + dcy;\n        ccz = pcz + dcz;\n        nx = ncx;\n        ny = ncy;\n        nz = ncz;\n      }\n\n      var v1x;\n      var v1y;\n      var v1z;\n      var v2x;\n      var v2y;\n      var v2z;\n      var v3x;\n      var v3y;\n      var v3z;\n      var v4x;\n      var v4y;\n      var v4z;\n      dot = 1;\n      state = 0;\n      dot1 = nwx * nx + nwy * ny + nwz * nz;\n\n      if (dot1 < dot) {\n        dot = dot1;\n        state = 0;\n      }\n\n      if (-dot1 < dot) {\n        dot = -dot1;\n        state = 1;\n      }\n\n      dot1 = nhx * nx + nhy * ny + nhz * nz;\n\n      if (dot1 < dot) {\n        dot = dot1;\n        state = 2;\n      }\n\n      if (-dot1 < dot) {\n        dot = -dot1;\n        state = 3;\n      }\n\n      dot1 = ndx * nx + ndy * ny + ndz * nz;\n\n      if (dot1 < dot) {\n        dot = dot1;\n        state = 4;\n      }\n\n      if (-dot1 < dot) {\n        dot = -dot1;\n        state = 5;\n      }\n\n      var v = b.elements;\n\n      switch (state) {\n        case 0:\n          //v=b.vertex1;\n          v1x = v[0]; //v.x;\n\n          v1y = v[1]; //v.y;\n\n          v1z = v[2]; //v.z;\n          //v=b.vertex3;\n\n          v2x = v[6]; //v.x;\n\n          v2y = v[7]; //v.y;\n\n          v2z = v[8]; //v.z;\n          //v=b.vertex4;\n\n          v3x = v[9]; //v.x;\n\n          v3y = v[10]; //v.y;\n\n          v3z = v[11]; //v.z;\n          //v=b.vertex2;\n\n          v4x = v[3]; //v.x;\n\n          v4y = v[4]; //v.y;\n\n          v4z = v[5]; //v.z;\n\n          break;\n\n        case 1:\n          //v=b.vertex6;\n          v1x = v[15]; //v.x;\n\n          v1y = v[16]; //v.y;\n\n          v1z = v[17]; //v.z;\n          //v=b.vertex8;\n\n          v2x = v[21]; //v.x;\n\n          v2y = v[22]; //v.y;\n\n          v2z = v[23]; //v.z;\n          //v=b.vertex7;\n\n          v3x = v[18]; //v.x;\n\n          v3y = v[19]; //v.y;\n\n          v3z = v[20]; //v.z;\n          //v=b.vertex5;\n\n          v4x = v[12]; //v.x;\n\n          v4y = v[13]; //v.y;\n\n          v4z = v[14]; //v.z;\n\n          break;\n\n        case 2:\n          //v=b.vertex5;\n          v1x = v[12]; //v.x;\n\n          v1y = v[13]; //v.y;\n\n          v1z = v[14]; //v.z;\n          //v=b.vertex1;\n\n          v2x = v[0]; //v.x;\n\n          v2y = v[1]; //v.y;\n\n          v2z = v[2]; //v.z;\n          //v=b.vertex2;\n\n          v3x = v[3]; //v.x;\n\n          v3y = v[4]; //v.y;\n\n          v3z = v[5]; //v.z;\n          //v=b.vertex6;\n\n          v4x = v[15]; //v.x;\n\n          v4y = v[16]; //v.y;\n\n          v4z = v[17]; //v.z;\n\n          break;\n\n        case 3:\n          //v=b.vertex8;\n          v1x = v[21]; //v.x;\n\n          v1y = v[22]; //v.y;\n\n          v1z = v[23]; //v.z;\n          //v=b.vertex4;\n\n          v2x = v[9]; //v.x;\n\n          v2y = v[10]; //v.y;\n\n          v2z = v[11]; //v.z;\n          //v=b.vertex3;\n\n          v3x = v[6]; //v.x;\n\n          v3y = v[7]; //v.y;\n\n          v3z = v[8]; //v.z;\n          //v=b.vertex7;\n\n          v4x = v[18]; //v.x;\n\n          v4y = v[19]; //v.y;\n\n          v4z = v[20]; //v.z;\n\n          break;\n\n        case 4:\n          //v=b.vertex5;\n          v1x = v[12]; //v.x;\n\n          v1y = v[13]; //v.y;\n\n          v1z = v[14]; //v.z;\n          //v=b.vertex7;\n\n          v2x = v[18]; //v.x;\n\n          v2y = v[19]; //v.y;\n\n          v2z = v[20]; //v.z;\n          //v=b.vertex3;\n\n          v3x = v[6]; //v.x;\n\n          v3y = v[7]; //v.y;\n\n          v3z = v[8]; //v.z;\n          //v=b.vertex1;\n\n          v4x = v[0]; //v.x;\n\n          v4y = v[1]; //v.y;\n\n          v4z = v[2]; //v.z;\n\n          break;\n\n        case 5:\n          //v=b.vertex2;\n          v1x = v[3]; //v.x;\n\n          v1y = v[4]; //v.y;\n\n          v1z = v[5]; //v.z;\n          //v=b.vertex4;\n\n          v2x = v[9]; //v.x;\n\n          v2y = v[10]; //v.y;\n\n          v2z = v[11]; //v.z;\n          //v=b.vertex8;\n\n          v3x = v[21]; //v.x;\n\n          v3y = v[22]; //v.y;\n\n          v3z = v[23]; //v.z;\n          //v=b.vertex6;\n\n          v4x = v[15]; //v.x;\n\n          v4y = v[16]; //v.y;\n\n          v4z = v[17]; //v.z;\n\n          break;\n      }\n\n      pd = nx * (v1x - ccx) + ny * (v1y - ccy) + nz * (v1z - ccz);\n      if (pd <= 0) manifold.addPoint(v1x, v1y, v1z, -nx, -ny, -nz, pd, this.flip);\n      pd = nx * (v2x - ccx) + ny * (v2y - ccy) + nz * (v2z - ccz);\n      if (pd <= 0) manifold.addPoint(v2x, v2y, v2z, -nx, -ny, -nz, pd, this.flip);\n      pd = nx * (v3x - ccx) + ny * (v3y - ccy) + nz * (v3z - ccz);\n      if (pd <= 0) manifold.addPoint(v3x, v3y, v3z, -nx, -ny, -nz, pd, this.flip);\n      pd = nx * (v4x - ccx) + ny * (v4y - ccy) + nz * (v4z - ccz);\n      if (pd <= 0) manifold.addPoint(v4x, v4y, v4z, -nx, -ny, -nz, pd, this.flip);\n    } else {\n      switch (state) {\n        case 1:\n          if (right1) {\n            cbx = pbx + dwx;\n            cby = pby + dwy;\n            cbz = pbz + dwz;\n            nx = nwx;\n            ny = nwy;\n            nz = nwz;\n          } else {\n            cbx = pbx - dwx;\n            cby = pby - dwy;\n            cbz = pbz - dwz;\n            nx = -nwx;\n            ny = -nwy;\n            nz = -nwz;\n          }\n\n          dir1x = nhx;\n          dir1y = nhy;\n          dir1z = nhz;\n          dir1l = bh;\n          dir2x = ndx;\n          dir2y = ndy;\n          dir2z = ndz;\n          dir2l = bd;\n          break;\n\n        case 2:\n          if (right2) {\n            cbx = pbx + dhx;\n            cby = pby + dhy;\n            cbz = pbz + dhz;\n            nx = nhx;\n            ny = nhy;\n            nz = nhz;\n          } else {\n            cbx = pbx - dhx;\n            cby = pby - dhy;\n            cbz = pbz - dhz;\n            nx = -nhx;\n            ny = -nhy;\n            nz = -nhz;\n          }\n\n          dir1x = nwx;\n          dir1y = nwy;\n          dir1z = nwz;\n          dir1l = bw;\n          dir2x = ndx;\n          dir2y = ndy;\n          dir2z = ndz;\n          dir2l = bd;\n          break;\n\n        case 3:\n          if (right3) {\n            cbx = pbx + ddx;\n            cby = pby + ddy;\n            cbz = pbz + ddz;\n            nx = ndx;\n            ny = ndy;\n            nz = ndz;\n          } else {\n            cbx = pbx - ddx;\n            cby = pby - ddy;\n            cbz = pbz - ddz;\n            nx = -ndx;\n            ny = -ndy;\n            nz = -ndz;\n          }\n\n          dir1x = nwx;\n          dir1y = nwy;\n          dir1z = nwz;\n          dir1l = bw;\n          dir2x = nhx;\n          dir2y = nhy;\n          dir2z = nhz;\n          dir2l = bh;\n          break;\n      }\n\n      dot = nx * ncx + ny * ncy + nz * ncz;\n      if (dot < 0) len = ch;else len = -ch;\n      ccx = pcx + len * ncx;\n      ccy = pcy + len * ncy;\n      ccz = pcz + len * ncz;\n\n      if (dotc >= 0.999999) {\n        tx = -ny;\n        ty = nz;\n        tz = nx;\n      } else {\n        tx = nx;\n        ty = ny;\n        tz = nz;\n      }\n\n      len = tx * ncx + ty * ncy + tz * ncz;\n      dx = len * ncx - tx;\n      dy = len * ncy - ty;\n      dz = len * ncz - tz;\n      len = _Math.sqrt(dx * dx + dy * dy + dz * dz);\n      if (len == 0) return;\n      len = r / len;\n      dx *= len;\n      dy *= len;\n      dz *= len;\n      tx = ccx + dx;\n      ty = ccy + dy;\n      tz = ccz + dz;\n\n      if (dot < -0.96 || dot > 0.96) {\n        r00 = ncx * ncx * 1.5 - 0.5;\n        r01 = ncx * ncy * 1.5 - ncz * 0.866025403;\n        r02 = ncx * ncz * 1.5 + ncy * 0.866025403;\n        r10 = ncy * ncx * 1.5 + ncz * 0.866025403;\n        r11 = ncy * ncy * 1.5 - 0.5;\n        r12 = ncy * ncz * 1.5 - ncx * 0.866025403;\n        r20 = ncz * ncx * 1.5 - ncy * 0.866025403;\n        r21 = ncz * ncy * 1.5 + ncx * 0.866025403;\n        r22 = ncz * ncz * 1.5 - 0.5;\n        px = tx;\n        py = ty;\n        pz = tz;\n        pd = nx * (px - cbx) + ny * (py - cby) + nz * (pz - cbz);\n        tx = px - pd * nx - cbx;\n        ty = py - pd * ny - cby;\n        tz = pz - pd * nz - cbz;\n        sd = dir1x * tx + dir1y * ty + dir1z * tz;\n        ed = dir2x * tx + dir2y * ty + dir2z * tz;\n        if (sd < -dir1l) sd = -dir1l;else if (sd > dir1l) sd = dir1l;\n        if (ed < -dir2l) ed = -dir2l;else if (ed > dir2l) ed = dir2l;\n        tx = sd * dir1x + ed * dir2x;\n        ty = sd * dir1y + ed * dir2y;\n        tz = sd * dir1z + ed * dir2z;\n        px = cbx + tx;\n        py = cby + ty;\n        pz = cbz + tz;\n        manifold.addPoint(px, py, pz, nx, ny, nz, pd, this.flip);\n        px = dx * r00 + dy * r01 + dz * r02;\n        py = dx * r10 + dy * r11 + dz * r12;\n        pz = dx * r20 + dy * r21 + dz * r22;\n        px = (dx = px) + ccx;\n        py = (dy = py) + ccy;\n        pz = (dz = pz) + ccz;\n        pd = nx * (px - cbx) + ny * (py - cby) + nz * (pz - cbz);\n\n        if (pd <= 0) {\n          tx = px - pd * nx - cbx;\n          ty = py - pd * ny - cby;\n          tz = pz - pd * nz - cbz;\n          sd = dir1x * tx + dir1y * ty + dir1z * tz;\n          ed = dir2x * tx + dir2y * ty + dir2z * tz;\n          if (sd < -dir1l) sd = -dir1l;else if (sd > dir1l) sd = dir1l;\n          if (ed < -dir2l) ed = -dir2l;else if (ed > dir2l) ed = dir2l;\n          tx = sd * dir1x + ed * dir2x;\n          ty = sd * dir1y + ed * dir2y;\n          tz = sd * dir1z + ed * dir2z;\n          px = cbx + tx;\n          py = cby + ty;\n          pz = cbz + tz; //manifold.addPoint(px,py,pz,nx,ny,nz,pd,b,c,2,0,false);\n\n          manifold.addPoint(px, py, pz, nx, ny, nz, pd, this.flip);\n        }\n\n        px = dx * r00 + dy * r01 + dz * r02;\n        py = dx * r10 + dy * r11 + dz * r12;\n        pz = dx * r20 + dy * r21 + dz * r22;\n        px = (dx = px) + ccx;\n        py = (dy = py) + ccy;\n        pz = (dz = pz) + ccz;\n        pd = nx * (px - cbx) + ny * (py - cby) + nz * (pz - cbz);\n\n        if (pd <= 0) {\n          tx = px - pd * nx - cbx;\n          ty = py - pd * ny - cby;\n          tz = pz - pd * nz - cbz;\n          sd = dir1x * tx + dir1y * ty + dir1z * tz;\n          ed = dir2x * tx + dir2y * ty + dir2z * tz;\n          if (sd < -dir1l) sd = -dir1l;else if (sd > dir1l) sd = dir1l;\n          if (ed < -dir2l) ed = -dir2l;else if (ed > dir2l) ed = dir2l;\n          tx = sd * dir1x + ed * dir2x;\n          ty = sd * dir1y + ed * dir2y;\n          tz = sd * dir1z + ed * dir2z;\n          px = cbx + tx;\n          py = cby + ty;\n          pz = cbz + tz; //manifold.addPoint(px,py,pz,nx,ny,nz,pd,b,c,3,0,false);\n\n          manifold.addPoint(px, py, pz, nx, ny, nz, pd, this.flip);\n        }\n      } else {\n        sx = tx;\n        sy = ty;\n        sz = tz;\n        sd = nx * (sx - cbx) + ny * (sy - cby) + nz * (sz - cbz);\n        sx -= sd * nx;\n        sy -= sd * ny;\n        sz -= sd * nz;\n\n        if (dot > 0) {\n          ex = tx + dcx * 2;\n          ey = ty + dcy * 2;\n          ez = tz + dcz * 2;\n        } else {\n          ex = tx - dcx * 2;\n          ey = ty - dcy * 2;\n          ez = tz - dcz * 2;\n        }\n\n        ed = nx * (ex - cbx) + ny * (ey - cby) + nz * (ez - cbz);\n        ex -= ed * nx;\n        ey -= ed * ny;\n        ez -= ed * nz;\n        d1x = sx - cbx;\n        d1y = sy - cby;\n        d1z = sz - cbz;\n        d2x = ex - cbx;\n        d2y = ey - cby;\n        d2z = ez - cbz;\n        tx = ex - sx;\n        ty = ey - sy;\n        tz = ez - sz;\n        td = ed - sd;\n        dotw = d1x * dir1x + d1y * dir1y + d1z * dir1z;\n        doth = d2x * dir1x + d2y * dir1y + d2z * dir1z;\n        dot1 = dotw - dir1l;\n        dot2 = doth - dir1l;\n\n        if (dot1 > 0) {\n          if (dot2 > 0) return;\n          t1 = dot1 / (dot1 - dot2);\n          sx = sx + tx * t1;\n          sy = sy + ty * t1;\n          sz = sz + tz * t1;\n          sd = sd + td * t1;\n          d1x = sx - cbx;\n          d1y = sy - cby;\n          d1z = sz - cbz;\n          dotw = d1x * dir1x + d1y * dir1y + d1z * dir1z;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          td = ed - sd;\n        } else if (dot2 > 0) {\n          t1 = dot1 / (dot1 - dot2);\n          ex = sx + tx * t1;\n          ey = sy + ty * t1;\n          ez = sz + tz * t1;\n          ed = sd + td * t1;\n          d2x = ex - cbx;\n          d2y = ey - cby;\n          d2z = ez - cbz;\n          doth = d2x * dir1x + d2y * dir1y + d2z * dir1z;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          td = ed - sd;\n        }\n\n        dot1 = dotw + dir1l;\n        dot2 = doth + dir1l;\n\n        if (dot1 < 0) {\n          if (dot2 < 0) return;\n          t1 = dot1 / (dot1 - dot2);\n          sx = sx + tx * t1;\n          sy = sy + ty * t1;\n          sz = sz + tz * t1;\n          sd = sd + td * t1;\n          d1x = sx - cbx;\n          d1y = sy - cby;\n          d1z = sz - cbz;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          td = ed - sd;\n        } else if (dot2 < 0) {\n          t1 = dot1 / (dot1 - dot2);\n          ex = sx + tx * t1;\n          ey = sy + ty * t1;\n          ez = sz + tz * t1;\n          ed = sd + td * t1;\n          d2x = ex - cbx;\n          d2y = ey - cby;\n          d2z = ez - cbz;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          td = ed - sd;\n        }\n\n        dotw = d1x * dir2x + d1y * dir2y + d1z * dir2z;\n        doth = d2x * dir2x + d2y * dir2y + d2z * dir2z;\n        dot1 = dotw - dir2l;\n        dot2 = doth - dir2l;\n\n        if (dot1 > 0) {\n          if (dot2 > 0) return;\n          t1 = dot1 / (dot1 - dot2);\n          sx = sx + tx * t1;\n          sy = sy + ty * t1;\n          sz = sz + tz * t1;\n          sd = sd + td * t1;\n          d1x = sx - cbx;\n          d1y = sy - cby;\n          d1z = sz - cbz;\n          dotw = d1x * dir2x + d1y * dir2y + d1z * dir2z;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          td = ed - sd;\n        } else if (dot2 > 0) {\n          t1 = dot1 / (dot1 - dot2);\n          ex = sx + tx * t1;\n          ey = sy + ty * t1;\n          ez = sz + tz * t1;\n          ed = sd + td * t1;\n          d2x = ex - cbx;\n          d2y = ey - cby;\n          d2z = ez - cbz;\n          doth = d2x * dir2x + d2y * dir2y + d2z * dir2z;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          td = ed - sd;\n        }\n\n        dot1 = dotw + dir2l;\n        dot2 = doth + dir2l;\n\n        if (dot1 < 0) {\n          if (dot2 < 0) return;\n          t1 = dot1 / (dot1 - dot2);\n          sx = sx + tx * t1;\n          sy = sy + ty * t1;\n          sz = sz + tz * t1;\n          sd = sd + td * t1;\n        } else if (dot2 < 0) {\n          t1 = dot1 / (dot1 - dot2);\n          ex = sx + tx * t1;\n          ey = sy + ty * t1;\n          ez = sz + tz * t1;\n          ed = sd + td * t1;\n        }\n\n        if (sd < 0) {\n          //manifold.addPoint(sx,sy,sz,nx,ny,nz,sd,b,c,1,0,false);\n          manifold.addPoint(sx, sy, sz, nx, ny, nz, sd, this.flip);\n        }\n\n        if (ed < 0) {\n          //manifold.addPoint(ex,ey,ez,nx,ny,nz,ed,b,c,4,0,false);\n          manifold.addPoint(ex, ey, ez, nx, ny, nz, ed, this.flip);\n        }\n      }\n    }\n  }\n});\n\nfunction CylinderCylinderCollisionDetector() {\n  CollisionDetector.call(this);\n}\n\nCylinderCylinderCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: CylinderCylinderCollisionDetector,\n  getSep: function (c1, c2, sep, pos, dep) {\n    var t1x;\n    var t1y;\n    var t1z;\n    var t2x;\n    var t2y;\n    var t2z;\n    var sup = new Vec3();\n    var len;\n    var p1x;\n    var p1y;\n    var p1z;\n    var p2x;\n    var p2y;\n    var p2z;\n    var v01x = c1.position.x;\n    var v01y = c1.position.y;\n    var v01z = c1.position.z;\n    var v02x = c2.position.x;\n    var v02y = c2.position.y;\n    var v02z = c2.position.z;\n    var v0x = v02x - v01x;\n    var v0y = v02y - v01y;\n    var v0z = v02z - v01z;\n    if (v0x * v0x + v0y * v0y + v0z * v0z == 0) v0y = 0.001;\n    var nx = -v0x;\n    var ny = -v0y;\n    var nz = -v0z;\n    this.supportPoint(c1, -nx, -ny, -nz, sup);\n    var v11x = sup.x;\n    var v11y = sup.y;\n    var v11z = sup.z;\n    this.supportPoint(c2, nx, ny, nz, sup);\n    var v12x = sup.x;\n    var v12y = sup.y;\n    var v12z = sup.z;\n    var v1x = v12x - v11x;\n    var v1y = v12y - v11y;\n    var v1z = v12z - v11z;\n\n    if (v1x * nx + v1y * ny + v1z * nz <= 0) {\n      return false;\n    }\n\n    nx = v1y * v0z - v1z * v0y;\n    ny = v1z * v0x - v1x * v0z;\n    nz = v1x * v0y - v1y * v0x;\n\n    if (nx * nx + ny * ny + nz * nz == 0) {\n      sep.set(v1x - v0x, v1y - v0y, v1z - v0z).normalize();\n      pos.set((v11x + v12x) * 0.5, (v11y + v12y) * 0.5, (v11z + v12z) * 0.5);\n      return true;\n    }\n\n    this.supportPoint(c1, -nx, -ny, -nz, sup);\n    var v21x = sup.x;\n    var v21y = sup.y;\n    var v21z = sup.z;\n    this.supportPoint(c2, nx, ny, nz, sup);\n    var v22x = sup.x;\n    var v22y = sup.y;\n    var v22z = sup.z;\n    var v2x = v22x - v21x;\n    var v2y = v22y - v21y;\n    var v2z = v22z - v21z;\n\n    if (v2x * nx + v2y * ny + v2z * nz <= 0) {\n      return false;\n    }\n\n    t1x = v1x - v0x;\n    t1y = v1y - v0y;\n    t1z = v1z - v0z;\n    t2x = v2x - v0x;\n    t2y = v2y - v0y;\n    t2z = v2z - v0z;\n    nx = t1y * t2z - t1z * t2y;\n    ny = t1z * t2x - t1x * t2z;\n    nz = t1x * t2y - t1y * t2x;\n\n    if (nx * v0x + ny * v0y + nz * v0z > 0) {\n      t1x = v1x;\n      t1y = v1y;\n      t1z = v1z;\n      v1x = v2x;\n      v1y = v2y;\n      v1z = v2z;\n      v2x = t1x;\n      v2y = t1y;\n      v2z = t1z;\n      t1x = v11x;\n      t1y = v11y;\n      t1z = v11z;\n      v11x = v21x;\n      v11y = v21y;\n      v11z = v21z;\n      v21x = t1x;\n      v21y = t1y;\n      v21z = t1z;\n      t1x = v12x;\n      t1y = v12y;\n      t1z = v12z;\n      v12x = v22x;\n      v12y = v22y;\n      v12z = v22z;\n      v22x = t1x;\n      v22y = t1y;\n      v22z = t1z;\n      nx = -nx;\n      ny = -ny;\n      nz = -nz;\n    }\n\n    var iterations = 0;\n\n    while (true) {\n      if (++iterations > 100) {\n        return false;\n      }\n\n      this.supportPoint(c1, -nx, -ny, -nz, sup);\n      var v31x = sup.x;\n      var v31y = sup.y;\n      var v31z = sup.z;\n      this.supportPoint(c2, nx, ny, nz, sup);\n      var v32x = sup.x;\n      var v32y = sup.y;\n      var v32z = sup.z;\n      var v3x = v32x - v31x;\n      var v3y = v32y - v31y;\n      var v3z = v32z - v31z;\n\n      if (v3x * nx + v3y * ny + v3z * nz <= 0) {\n        return false;\n      }\n\n      if ((v1y * v3z - v1z * v3y) * v0x + (v1z * v3x - v1x * v3z) * v0y + (v1x * v3y - v1y * v3x) * v0z < 0) {\n        v2x = v3x;\n        v2y = v3y;\n        v2z = v3z;\n        v21x = v31x;\n        v21y = v31y;\n        v21z = v31z;\n        v22x = v32x;\n        v22y = v32y;\n        v22z = v32z;\n        t1x = v1x - v0x;\n        t1y = v1y - v0y;\n        t1z = v1z - v0z;\n        t2x = v3x - v0x;\n        t2y = v3y - v0y;\n        t2z = v3z - v0z;\n        nx = t1y * t2z - t1z * t2y;\n        ny = t1z * t2x - t1x * t2z;\n        nz = t1x * t2y - t1y * t2x;\n        continue;\n      }\n\n      if ((v3y * v2z - v3z * v2y) * v0x + (v3z * v2x - v3x * v2z) * v0y + (v3x * v2y - v3y * v2x) * v0z < 0) {\n        v1x = v3x;\n        v1y = v3y;\n        v1z = v3z;\n        v11x = v31x;\n        v11y = v31y;\n        v11z = v31z;\n        v12x = v32x;\n        v12y = v32y;\n        v12z = v32z;\n        t1x = v3x - v0x;\n        t1y = v3y - v0y;\n        t1z = v3z - v0z;\n        t2x = v2x - v0x;\n        t2y = v2y - v0y;\n        t2z = v2z - v0z;\n        nx = t1y * t2z - t1z * t2y;\n        ny = t1z * t2x - t1x * t2z;\n        nz = t1x * t2y - t1y * t2x;\n        continue;\n      }\n\n      var hit = false;\n\n      while (true) {\n        t1x = v2x - v1x;\n        t1y = v2y - v1y;\n        t1z = v2z - v1z;\n        t2x = v3x - v1x;\n        t2y = v3y - v1y;\n        t2z = v3z - v1z;\n        nx = t1y * t2z - t1z * t2y;\n        ny = t1z * t2x - t1x * t2z;\n        nz = t1x * t2y - t1y * t2x;\n        len = 1 / _Math.sqrt(nx * nx + ny * ny + nz * nz);\n        nx *= len;\n        ny *= len;\n        nz *= len;\n\n        if (nx * v1x + ny * v1y + nz * v1z >= 0 && !hit) {\n          var b0 = (v1y * v2z - v1z * v2y) * v3x + (v1z * v2x - v1x * v2z) * v3y + (v1x * v2y - v1y * v2x) * v3z;\n          var b1 = (v3y * v2z - v3z * v2y) * v0x + (v3z * v2x - v3x * v2z) * v0y + (v3x * v2y - v3y * v2x) * v0z;\n          var b2 = (v0y * v1z - v0z * v1y) * v3x + (v0z * v1x - v0x * v1z) * v3y + (v0x * v1y - v0y * v1x) * v3z;\n          var b3 = (v2y * v1z - v2z * v1y) * v0x + (v2z * v1x - v2x * v1z) * v0y + (v2x * v1y - v2y * v1x) * v0z;\n          var sum = b0 + b1 + b2 + b3;\n\n          if (sum <= 0) {\n            b0 = 0;\n            b1 = (v2y * v3z - v2z * v3y) * nx + (v2z * v3x - v2x * v3z) * ny + (v2x * v3y - v2y * v3x) * nz;\n            b2 = (v3y * v2z - v3z * v2y) * nx + (v3z * v2x - v3x * v2z) * ny + (v3x * v2y - v3y * v2x) * nz;\n            b3 = (v1y * v2z - v1z * v2y) * nx + (v1z * v2x - v1x * v2z) * ny + (v1x * v2y - v1y * v2x) * nz;\n            sum = b1 + b2 + b3;\n          }\n\n          var inv = 1 / sum;\n          p1x = (v01x * b0 + v11x * b1 + v21x * b2 + v31x * b3) * inv;\n          p1y = (v01y * b0 + v11y * b1 + v21y * b2 + v31y * b3) * inv;\n          p1z = (v01z * b0 + v11z * b1 + v21z * b2 + v31z * b3) * inv;\n          p2x = (v02x * b0 + v12x * b1 + v22x * b2 + v32x * b3) * inv;\n          p2y = (v02y * b0 + v12y * b1 + v22y * b2 + v32y * b3) * inv;\n          p2z = (v02z * b0 + v12z * b1 + v22z * b2 + v32z * b3) * inv;\n          hit = true;\n        }\n\n        this.supportPoint(c1, -nx, -ny, -nz, sup);\n        var v41x = sup.x;\n        var v41y = sup.y;\n        var v41z = sup.z;\n        this.supportPoint(c2, nx, ny, nz, sup);\n        var v42x = sup.x;\n        var v42y = sup.y;\n        var v42z = sup.z;\n        var v4x = v42x - v41x;\n        var v4y = v42y - v41y;\n        var v4z = v42z - v41z;\n        var separation = -(v4x * nx + v4y * ny + v4z * nz);\n\n        if ((v4x - v3x) * nx + (v4y - v3y) * ny + (v4z - v3z) * nz <= 0.01 || separation >= 0) {\n          if (hit) {\n            sep.set(-nx, -ny, -nz);\n            pos.set((p1x + p2x) * 0.5, (p1y + p2y) * 0.5, (p1z + p2z) * 0.5);\n            dep.x = separation;\n            return true;\n          }\n\n          return false;\n        }\n\n        if ((v4y * v1z - v4z * v1y) * v0x + (v4z * v1x - v4x * v1z) * v0y + (v4x * v1y - v4y * v1x) * v0z < 0) {\n          if ((v4y * v2z - v4z * v2y) * v0x + (v4z * v2x - v4x * v2z) * v0y + (v4x * v2y - v4y * v2x) * v0z < 0) {\n            v1x = v4x;\n            v1y = v4y;\n            v1z = v4z;\n            v11x = v41x;\n            v11y = v41y;\n            v11z = v41z;\n            v12x = v42x;\n            v12y = v42y;\n            v12z = v42z;\n          } else {\n            v3x = v4x;\n            v3y = v4y;\n            v3z = v4z;\n            v31x = v41x;\n            v31y = v41y;\n            v31z = v41z;\n            v32x = v42x;\n            v32y = v42y;\n            v32z = v42z;\n          }\n        } else {\n          if ((v4y * v3z - v4z * v3y) * v0x + (v4z * v3x - v4x * v3z) * v0y + (v4x * v3y - v4y * v3x) * v0z < 0) {\n            v2x = v4x;\n            v2y = v4y;\n            v2z = v4z;\n            v21x = v41x;\n            v21y = v41y;\n            v21z = v41z;\n            v22x = v42x;\n            v22y = v42y;\n            v22z = v42z;\n          } else {\n            v1x = v4x;\n            v1y = v4y;\n            v1z = v4z;\n            v11x = v41x;\n            v11y = v41y;\n            v11z = v41z;\n            v12x = v42x;\n            v12y = v42y;\n            v12z = v42z;\n          }\n        }\n      }\n    } //return false;\n\n  },\n  supportPoint: function (c, dx, dy, dz, out) {\n    var rot = c.rotation.elements;\n    var ldx = rot[0] * dx + rot[3] * dy + rot[6] * dz;\n    var ldy = rot[1] * dx + rot[4] * dy + rot[7] * dz;\n    var ldz = rot[2] * dx + rot[5] * dy + rot[8] * dz;\n    var radx = ldx;\n    var radz = ldz;\n    var len = radx * radx + radz * radz;\n    var rad = c.radius;\n    var hh = c.halfHeight;\n    var ox;\n    var oy;\n    var oz;\n\n    if (len == 0) {\n      if (ldy < 0) {\n        ox = rad;\n        oy = -hh;\n        oz = 0;\n      } else {\n        ox = rad;\n        oy = hh;\n        oz = 0;\n      }\n    } else {\n      len = c.radius / _Math.sqrt(len);\n\n      if (ldy < 0) {\n        ox = radx * len;\n        oy = -hh;\n        oz = radz * len;\n      } else {\n        ox = radx * len;\n        oy = hh;\n        oz = radz * len;\n      }\n    }\n\n    ldx = rot[0] * ox + rot[1] * oy + rot[2] * oz + c.position.x;\n    ldy = rot[3] * ox + rot[4] * oy + rot[5] * oz + c.position.y;\n    ldz = rot[6] * ox + rot[7] * oy + rot[8] * oz + c.position.z;\n    out.set(ldx, ldy, ldz);\n  },\n  detectCollision: function (shape1, shape2, manifold) {\n    var c1;\n    var c2;\n\n    if (shape1.id < shape2.id) {\n      c1 = shape1;\n      c2 = shape2;\n    } else {\n      c1 = shape2;\n      c2 = shape1;\n    }\n\n    var p1 = c1.position;\n    var p2 = c2.position;\n    var p1x = p1.x;\n    var p1y = p1.y;\n    var p1z = p1.z;\n    var p2x = p2.x;\n    var p2y = p2.y;\n    var p2z = p2.z;\n    var h1 = c1.halfHeight;\n    var h2 = c2.halfHeight;\n    var n1 = c1.normalDirection;\n    var n2 = c2.normalDirection;\n    var d1 = c1.halfDirection;\n    var d2 = c2.halfDirection;\n    var r1 = c1.radius;\n    var r2 = c2.radius;\n    var n1x = n1.x;\n    var n1y = n1.y;\n    var n1z = n1.z;\n    var n2x = n2.x;\n    var n2y = n2.y;\n    var n2z = n2.z;\n    var d1x = d1.x;\n    var d1y = d1.y;\n    var d1z = d1.z;\n    var d2x = d2.x;\n    var d2y = d2.y;\n    var d2z = d2.z;\n    var dx = p1x - p2x;\n    var dy = p1y - p2y;\n    var dz = p1z - p2z;\n    var len;\n    var c1x;\n    var c1y;\n    var c1z;\n    var c2x;\n    var c2y;\n    var c2z;\n    var tx;\n    var ty;\n    var tz;\n    var sx;\n    var sy;\n    var sz;\n    var ex;\n    var ey;\n    var ez;\n    var depth1;\n    var depth2;\n    var dot;\n    var t1;\n    var t2;\n    var sep = new Vec3();\n    var pos = new Vec3();\n    var dep = new Vec3();\n    if (!this.getSep(c1, c2, sep, pos, dep)) return;\n    var dot1 = sep.x * n1x + sep.y * n1y + sep.z * n1z;\n    var dot2 = sep.x * n2x + sep.y * n2y + sep.z * n2z;\n    var right1 = dot1 > 0;\n    var right2 = dot2 > 0;\n    if (!right1) dot1 = -dot1;\n    if (!right2) dot2 = -dot2;\n    var state = 0;\n\n    if (dot1 > 0.999 || dot2 > 0.999) {\n      if (dot1 > dot2) state = 1;else state = 2;\n    }\n\n    var nx;\n    var ny;\n    var nz;\n    var depth = dep.x;\n    var r00;\n    var r01;\n    var r02;\n    var r10;\n    var r11;\n    var r12;\n    var r20;\n    var r21;\n    var r22;\n    var px;\n    var py;\n    var pz;\n    var pd;\n    var a;\n    var b;\n    var e;\n    var f;\n    nx = sep.x;\n    ny = sep.y;\n    nz = sep.z;\n\n    switch (state) {\n      case 0:\n        manifold.addPoint(pos.x, pos.y, pos.z, nx, ny, nz, depth, false);\n        break;\n\n      case 1:\n        if (right1) {\n          c1x = p1x + d1x;\n          c1y = p1y + d1y;\n          c1z = p1z + d1z;\n          nx = n1x;\n          ny = n1y;\n          nz = n1z;\n        } else {\n          c1x = p1x - d1x;\n          c1y = p1y - d1y;\n          c1z = p1z - d1z;\n          nx = -n1x;\n          ny = -n1y;\n          nz = -n1z;\n        }\n\n        dot = nx * n2x + ny * n2y + nz * n2z;\n        if (dot < 0) len = h2;else len = -h2;\n        c2x = p2x + len * n2x;\n        c2y = p2y + len * n2y;\n        c2z = p2z + len * n2z;\n\n        if (dot2 >= 0.999999) {\n          tx = -ny;\n          ty = nz;\n          tz = nx;\n        } else {\n          tx = nx;\n          ty = ny;\n          tz = nz;\n        }\n\n        len = tx * n2x + ty * n2y + tz * n2z;\n        dx = len * n2x - tx;\n        dy = len * n2y - ty;\n        dz = len * n2z - tz;\n        len = _Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (len == 0) break;\n        len = r2 / len;\n        dx *= len;\n        dy *= len;\n        dz *= len;\n        tx = c2x + dx;\n        ty = c2y + dy;\n        tz = c2z + dz;\n\n        if (dot < -0.96 || dot > 0.96) {\n          r00 = n2x * n2x * 1.5 - 0.5;\n          r01 = n2x * n2y * 1.5 - n2z * 0.866025403;\n          r02 = n2x * n2z * 1.5 + n2y * 0.866025403;\n          r10 = n2y * n2x * 1.5 + n2z * 0.866025403;\n          r11 = n2y * n2y * 1.5 - 0.5;\n          r12 = n2y * n2z * 1.5 - n2x * 0.866025403;\n          r20 = n2z * n2x * 1.5 - n2y * 0.866025403;\n          r21 = n2z * n2y * 1.5 + n2x * 0.866025403;\n          r22 = n2z * n2z * 1.5 - 0.5;\n          px = tx;\n          py = ty;\n          pz = tz;\n          pd = nx * (px - c1x) + ny * (py - c1y) + nz * (pz - c1z);\n          tx = px - pd * nx - c1x;\n          ty = py - pd * ny - c1y;\n          tz = pz - pd * nz - c1z;\n          len = tx * tx + ty * ty + tz * tz;\n\n          if (len > r1 * r1) {\n            len = r1 / _Math.sqrt(len);\n            tx *= len;\n            ty *= len;\n            tz *= len;\n          }\n\n          px = c1x + tx;\n          py = c1y + ty;\n          pz = c1z + tz;\n          manifold.addPoint(px, py, pz, nx, ny, nz, pd, false);\n          px = dx * r00 + dy * r01 + dz * r02;\n          py = dx * r10 + dy * r11 + dz * r12;\n          pz = dx * r20 + dy * r21 + dz * r22;\n          px = (dx = px) + c2x;\n          py = (dy = py) + c2y;\n          pz = (dz = pz) + c2z;\n          pd = nx * (px - c1x) + ny * (py - c1y) + nz * (pz - c1z);\n\n          if (pd <= 0) {\n            tx = px - pd * nx - c1x;\n            ty = py - pd * ny - c1y;\n            tz = pz - pd * nz - c1z;\n            len = tx * tx + ty * ty + tz * tz;\n\n            if (len > r1 * r1) {\n              len = r1 / _Math.sqrt(len);\n              tx *= len;\n              ty *= len;\n              tz *= len;\n            }\n\n            px = c1x + tx;\n            py = c1y + ty;\n            pz = c1z + tz;\n            manifold.addPoint(px, py, pz, nx, ny, nz, pd, false);\n          }\n\n          px = dx * r00 + dy * r01 + dz * r02;\n          py = dx * r10 + dy * r11 + dz * r12;\n          pz = dx * r20 + dy * r21 + dz * r22;\n          px = (dx = px) + c2x;\n          py = (dy = py) + c2y;\n          pz = (dz = pz) + c2z;\n          pd = nx * (px - c1x) + ny * (py - c1y) + nz * (pz - c1z);\n\n          if (pd <= 0) {\n            tx = px - pd * nx - c1x;\n            ty = py - pd * ny - c1y;\n            tz = pz - pd * nz - c1z;\n            len = tx * tx + ty * ty + tz * tz;\n\n            if (len > r1 * r1) {\n              len = r1 / _Math.sqrt(len);\n              tx *= len;\n              ty *= len;\n              tz *= len;\n            }\n\n            px = c1x + tx;\n            py = c1y + ty;\n            pz = c1z + tz;\n            manifold.addPoint(px, py, pz, nx, ny, nz, pd, false);\n          }\n        } else {\n          sx = tx;\n          sy = ty;\n          sz = tz;\n          depth1 = nx * (sx - c1x) + ny * (sy - c1y) + nz * (sz - c1z);\n          sx -= depth1 * nx;\n          sy -= depth1 * ny;\n          sz -= depth1 * nz;\n\n          if (dot > 0) {\n            ex = tx + n2x * h2 * 2;\n            ey = ty + n2y * h2 * 2;\n            ez = tz + n2z * h2 * 2;\n          } else {\n            ex = tx - n2x * h2 * 2;\n            ey = ty - n2y * h2 * 2;\n            ez = tz - n2z * h2 * 2;\n          }\n\n          depth2 = nx * (ex - c1x) + ny * (ey - c1y) + nz * (ez - c1z);\n          ex -= depth2 * nx;\n          ey -= depth2 * ny;\n          ez -= depth2 * nz;\n          dx = c1x - sx;\n          dy = c1y - sy;\n          dz = c1z - sz;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          a = dx * dx + dy * dy + dz * dz;\n          b = dx * tx + dy * ty + dz * tz;\n          e = tx * tx + ty * ty + tz * tz;\n          f = b * b - e * (a - r1 * r1);\n          if (f < 0) break;\n          f = _Math.sqrt(f);\n          t1 = (b + f) / e;\n          t2 = (b - f) / e;\n\n          if (t2 < t1) {\n            len = t1;\n            t1 = t2;\n            t2 = len;\n          }\n\n          if (t2 > 1) t2 = 1;\n          if (t1 < 0) t1 = 0;\n          tx = sx + (ex - sx) * t1;\n          ty = sy + (ey - sy) * t1;\n          tz = sz + (ez - sz) * t1;\n          ex = sx + (ex - sx) * t2;\n          ey = sy + (ey - sy) * t2;\n          ez = sz + (ez - sz) * t2;\n          sx = tx;\n          sy = ty;\n          sz = tz;\n          len = depth1 + (depth2 - depth1) * t1;\n          depth2 = depth1 + (depth2 - depth1) * t2;\n          depth1 = len;\n          if (depth1 < 0) manifold.addPoint(sx, sy, sz, nx, ny, nz, pd, false);\n          if (depth2 < 0) manifold.addPoint(ex, ey, ez, nx, ny, nz, pd, false);\n        }\n\n        break;\n\n      case 2:\n        if (right2) {\n          c2x = p2x - d2x;\n          c2y = p2y - d2y;\n          c2z = p2z - d2z;\n          nx = -n2x;\n          ny = -n2y;\n          nz = -n2z;\n        } else {\n          c2x = p2x + d2x;\n          c2y = p2y + d2y;\n          c2z = p2z + d2z;\n          nx = n2x;\n          ny = n2y;\n          nz = n2z;\n        }\n\n        dot = nx * n1x + ny * n1y + nz * n1z;\n        if (dot < 0) len = h1;else len = -h1;\n        c1x = p1x + len * n1x;\n        c1y = p1y + len * n1y;\n        c1z = p1z + len * n1z;\n\n        if (dot1 >= 0.999999) {\n          tx = -ny;\n          ty = nz;\n          tz = nx;\n        } else {\n          tx = nx;\n          ty = ny;\n          tz = nz;\n        }\n\n        len = tx * n1x + ty * n1y + tz * n1z;\n        dx = len * n1x - tx;\n        dy = len * n1y - ty;\n        dz = len * n1z - tz;\n        len = _Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (len == 0) break;\n        len = r1 / len;\n        dx *= len;\n        dy *= len;\n        dz *= len;\n        tx = c1x + dx;\n        ty = c1y + dy;\n        tz = c1z + dz;\n\n        if (dot < -0.96 || dot > 0.96) {\n          r00 = n1x * n1x * 1.5 - 0.5;\n          r01 = n1x * n1y * 1.5 - n1z * 0.866025403;\n          r02 = n1x * n1z * 1.5 + n1y * 0.866025403;\n          r10 = n1y * n1x * 1.5 + n1z * 0.866025403;\n          r11 = n1y * n1y * 1.5 - 0.5;\n          r12 = n1y * n1z * 1.5 - n1x * 0.866025403;\n          r20 = n1z * n1x * 1.5 - n1y * 0.866025403;\n          r21 = n1z * n1y * 1.5 + n1x * 0.866025403;\n          r22 = n1z * n1z * 1.5 - 0.5;\n          px = tx;\n          py = ty;\n          pz = tz;\n          pd = nx * (px - c2x) + ny * (py - c2y) + nz * (pz - c2z);\n          tx = px - pd * nx - c2x;\n          ty = py - pd * ny - c2y;\n          tz = pz - pd * nz - c2z;\n          len = tx * tx + ty * ty + tz * tz;\n\n          if (len > r2 * r2) {\n            len = r2 / _Math.sqrt(len);\n            tx *= len;\n            ty *= len;\n            tz *= len;\n          }\n\n          px = c2x + tx;\n          py = c2y + ty;\n          pz = c2z + tz;\n          manifold.addPoint(px, py, pz, -nx, -ny, -nz, pd, false);\n          px = dx * r00 + dy * r01 + dz * r02;\n          py = dx * r10 + dy * r11 + dz * r12;\n          pz = dx * r20 + dy * r21 + dz * r22;\n          px = (dx = px) + c1x;\n          py = (dy = py) + c1y;\n          pz = (dz = pz) + c1z;\n          pd = nx * (px - c2x) + ny * (py - c2y) + nz * (pz - c2z);\n\n          if (pd <= 0) {\n            tx = px - pd * nx - c2x;\n            ty = py - pd * ny - c2y;\n            tz = pz - pd * nz - c2z;\n            len = tx * tx + ty * ty + tz * tz;\n\n            if (len > r2 * r2) {\n              len = r2 / _Math.sqrt(len);\n              tx *= len;\n              ty *= len;\n              tz *= len;\n            }\n\n            px = c2x + tx;\n            py = c2y + ty;\n            pz = c2z + tz;\n            manifold.addPoint(px, py, pz, -nx, -ny, -nz, pd, false);\n          }\n\n          px = dx * r00 + dy * r01 + dz * r02;\n          py = dx * r10 + dy * r11 + dz * r12;\n          pz = dx * r20 + dy * r21 + dz * r22;\n          px = (dx = px) + c1x;\n          py = (dy = py) + c1y;\n          pz = (dz = pz) + c1z;\n          pd = nx * (px - c2x) + ny * (py - c2y) + nz * (pz - c2z);\n\n          if (pd <= 0) {\n            tx = px - pd * nx - c2x;\n            ty = py - pd * ny - c2y;\n            tz = pz - pd * nz - c2z;\n            len = tx * tx + ty * ty + tz * tz;\n\n            if (len > r2 * r2) {\n              len = r2 / _Math.sqrt(len);\n              tx *= len;\n              ty *= len;\n              tz *= len;\n            }\n\n            px = c2x + tx;\n            py = c2y + ty;\n            pz = c2z + tz;\n            manifold.addPoint(px, py, pz, -nx, -ny, -nz, pd, false);\n          }\n        } else {\n          sx = tx;\n          sy = ty;\n          sz = tz;\n          depth1 = nx * (sx - c2x) + ny * (sy - c2y) + nz * (sz - c2z);\n          sx -= depth1 * nx;\n          sy -= depth1 * ny;\n          sz -= depth1 * nz;\n\n          if (dot > 0) {\n            ex = tx + n1x * h1 * 2;\n            ey = ty + n1y * h1 * 2;\n            ez = tz + n1z * h1 * 2;\n          } else {\n            ex = tx - n1x * h1 * 2;\n            ey = ty - n1y * h1 * 2;\n            ez = tz - n1z * h1 * 2;\n          }\n\n          depth2 = nx * (ex - c2x) + ny * (ey - c2y) + nz * (ez - c2z);\n          ex -= depth2 * nx;\n          ey -= depth2 * ny;\n          ez -= depth2 * nz;\n          dx = c2x - sx;\n          dy = c2y - sy;\n          dz = c2z - sz;\n          tx = ex - sx;\n          ty = ey - sy;\n          tz = ez - sz;\n          a = dx * dx + dy * dy + dz * dz;\n          b = dx * tx + dy * ty + dz * tz;\n          e = tx * tx + ty * ty + tz * tz;\n          f = b * b - e * (a - r2 * r2);\n          if (f < 0) break;\n          f = _Math.sqrt(f);\n          t1 = (b + f) / e;\n          t2 = (b - f) / e;\n\n          if (t2 < t1) {\n            len = t1;\n            t1 = t2;\n            t2 = len;\n          }\n\n          if (t2 > 1) t2 = 1;\n          if (t1 < 0) t1 = 0;\n          tx = sx + (ex - sx) * t1;\n          ty = sy + (ey - sy) * t1;\n          tz = sz + (ez - sz) * t1;\n          ex = sx + (ex - sx) * t2;\n          ey = sy + (ey - sy) * t2;\n          ez = sz + (ez - sz) * t2;\n          sx = tx;\n          sy = ty;\n          sz = tz;\n          len = depth1 + (depth2 - depth1) * t1;\n          depth2 = depth1 + (depth2 - depth1) * t2;\n          depth1 = len;\n\n          if (depth1 < 0) {\n            manifold.addPoint(sx, sy, sz, -nx, -ny, -nz, depth1, false);\n          }\n\n          if (depth2 < 0) {\n            manifold.addPoint(ex, ey, ez, -nx, -ny, -nz, depth2, false);\n          }\n        }\n\n        break;\n    }\n  }\n});\n/**\n * A collision detector which detects collisions between sphere and box.\n * @author saharan\n */\n\nfunction SphereBoxCollisionDetector(flip) {\n  CollisionDetector.call(this);\n  this.flip = flip;\n}\n\nSphereBoxCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: SphereBoxCollisionDetector,\n  detectCollision: function (shape1, shape2, manifold) {\n    var s;\n    var b;\n\n    if (this.flip) {\n      s = shape2;\n      b = shape1;\n    } else {\n      s = shape1;\n      b = shape2;\n    }\n\n    var D = b.dimentions;\n    var ps = s.position;\n    var psx = ps.x;\n    var psy = ps.y;\n    var psz = ps.z;\n    var pb = b.position;\n    var pbx = pb.x;\n    var pby = pb.y;\n    var pbz = pb.z;\n    var rad = s.radius;\n    var hw = b.halfWidth;\n    var hh = b.halfHeight;\n    var hd = b.halfDepth;\n    var dx = psx - pbx;\n    var dy = psy - pby;\n    var dz = psz - pbz;\n    var sx = D[0] * dx + D[1] * dy + D[2] * dz;\n    var sy = D[3] * dx + D[4] * dy + D[5] * dz;\n    var sz = D[6] * dx + D[7] * dy + D[8] * dz;\n    var cx;\n    var cy;\n    var cz;\n    var len;\n    var invLen;\n    var overlap = 0;\n\n    if (sx > hw) {\n      sx = hw;\n    } else if (sx < -hw) {\n      sx = -hw;\n    } else {\n      overlap = 1;\n    }\n\n    if (sy > hh) {\n      sy = hh;\n    } else if (sy < -hh) {\n      sy = -hh;\n    } else {\n      overlap |= 2;\n    }\n\n    if (sz > hd) {\n      sz = hd;\n    } else if (sz < -hd) {\n      sz = -hd;\n    } else {\n      overlap |= 4;\n    }\n\n    if (overlap == 7) {\n      // center of sphere is in the box\n      if (sx < 0) {\n        dx = hw + sx;\n      } else {\n        dx = hw - sx;\n      }\n\n      if (sy < 0) {\n        dy = hh + sy;\n      } else {\n        dy = hh - sy;\n      }\n\n      if (sz < 0) {\n        dz = hd + sz;\n      } else {\n        dz = hd - sz;\n      }\n\n      if (dx < dy) {\n        if (dx < dz) {\n          len = dx - hw;\n\n          if (sx < 0) {\n            sx = -hw;\n            dx = D[0];\n            dy = D[1];\n            dz = D[2];\n          } else {\n            sx = hw;\n            dx = -D[0];\n            dy = -D[1];\n            dz = -D[2];\n          }\n        } else {\n          len = dz - hd;\n\n          if (sz < 0) {\n            sz = -hd;\n            dx = D[6];\n            dy = D[7];\n            dz = D[8];\n          } else {\n            sz = hd;\n            dx = -D[6];\n            dy = -D[7];\n            dz = -D[8];\n          }\n        }\n      } else {\n        if (dy < dz) {\n          len = dy - hh;\n\n          if (sy < 0) {\n            sy = -hh;\n            dx = D[3];\n            dy = D[4];\n            dz = D[5];\n          } else {\n            sy = hh;\n            dx = -D[3];\n            dy = -D[4];\n            dz = -D[5];\n          }\n        } else {\n          len = dz - hd;\n\n          if (sz < 0) {\n            sz = -hd;\n            dx = D[6];\n            dy = D[7];\n            dz = D[8];\n          } else {\n            sz = hd;\n            dx = -D[6];\n            dy = -D[7];\n            dz = -D[8];\n          }\n        }\n      }\n\n      cx = pbx + sx * D[0] + sy * D[3] + sz * D[6];\n      cy = pby + sx * D[1] + sy * D[4] + sz * D[7];\n      cz = pbz + sx * D[2] + sy * D[5] + sz * D[8];\n      manifold.addPoint(psx + rad * dx, psy + rad * dy, psz + rad * dz, dx, dy, dz, len - rad, this.flip);\n    } else {\n      cx = pbx + sx * D[0] + sy * D[3] + sz * D[6];\n      cy = pby + sx * D[1] + sy * D[4] + sz * D[7];\n      cz = pbz + sx * D[2] + sy * D[5] + sz * D[8];\n      dx = cx - ps.x;\n      dy = cy - ps.y;\n      dz = cz - ps.z;\n      len = dx * dx + dy * dy + dz * dz;\n\n      if (len > 0 && len < rad * rad) {\n        len = _Math.sqrt(len);\n        invLen = 1 / len;\n        dx *= invLen;\n        dy *= invLen;\n        dz *= invLen;\n        manifold.addPoint(psx + rad * dx, psy + rad * dy, psz + rad * dz, dx, dy, dz, len - rad, this.flip);\n      }\n    }\n  }\n});\n\nfunction SphereCylinderCollisionDetector(flip) {\n  CollisionDetector.call(this);\n  this.flip = flip;\n}\n\nSphereCylinderCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: SphereCylinderCollisionDetector,\n  detectCollision: function (shape1, shape2, manifold) {\n    var s;\n    var c;\n\n    if (this.flip) {\n      s = shape2;\n      c = shape1;\n    } else {\n      s = shape1;\n      c = shape2;\n    }\n\n    var ps = s.position;\n    var psx = ps.x;\n    var psy = ps.y;\n    var psz = ps.z;\n    var pc = c.position;\n    var pcx = pc.x;\n    var pcy = pc.y;\n    var pcz = pc.z;\n    var dirx = c.normalDirection.x;\n    var diry = c.normalDirection.y;\n    var dirz = c.normalDirection.z;\n    var rads = s.radius;\n    var radc = c.radius;\n    var rad2 = rads + radc;\n    var halfh = c.halfHeight;\n    var dx = psx - pcx;\n    var dy = psy - pcy;\n    var dz = psz - pcz;\n    var dot = dx * dirx + dy * diry + dz * dirz;\n    if (dot < -halfh - rads || dot > halfh + rads) return;\n    var cx = pcx + dot * dirx;\n    var cy = pcy + dot * diry;\n    var cz = pcz + dot * dirz;\n    var d2x = psx - cx;\n    var d2y = psy - cy;\n    var d2z = psz - cz;\n    var len = d2x * d2x + d2y * d2y + d2z * d2z;\n    if (len > rad2 * rad2) return;\n\n    if (len > radc * radc) {\n      len = radc / _Math.sqrt(len);\n      d2x *= len;\n      d2y *= len;\n      d2z *= len;\n    }\n\n    if (dot < -halfh) dot = -halfh;else if (dot > halfh) dot = halfh;\n    cx = pcx + dot * dirx + d2x;\n    cy = pcy + dot * diry + d2y;\n    cz = pcz + dot * dirz + d2z;\n    dx = cx - psx;\n    dy = cy - psy;\n    dz = cz - psz;\n    len = dx * dx + dy * dy + dz * dz;\n    var invLen;\n\n    if (len > 0 && len < rads * rads) {\n      len = _Math.sqrt(len);\n      invLen = 1 / len;\n      dx *= invLen;\n      dy *= invLen;\n      dz *= invLen; ///result.addContactInfo(psx+dx*rads,psy+dy*rads,psz+dz*rads,dx,dy,dz,len-rads,s,c,0,0,false);\n\n      manifold.addPoint(psx + dx * rads, psy + dy * rads, psz + dz * rads, dx, dy, dz, len - rads, this.flip);\n    }\n  }\n});\n/**\n * A collision detector which detects collisions between two spheres.\n * @author saharan\n */\n\nfunction SphereSphereCollisionDetector() {\n  CollisionDetector.call(this);\n}\n\nSphereSphereCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: SphereSphereCollisionDetector,\n  detectCollision: function (shape1, shape2, manifold) {\n    var s1 = shape1;\n    var s2 = shape2;\n    var p1 = s1.position;\n    var p2 = s2.position;\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n    var dz = p2.z - p1.z;\n    var len = dx * dx + dy * dy + dz * dz;\n    var r1 = s1.radius;\n    var r2 = s2.radius;\n    var rad = r1 + r2;\n\n    if (len > 0 && len < rad * rad) {\n      len = _Math.sqrt(len);\n      var invLen = 1 / len;\n      dx *= invLen;\n      dy *= invLen;\n      dz *= invLen;\n      manifold.addPoint(p1.x + dx * r1, p1.y + dy * r1, p1.z + dz * r1, dx, dy, dz, len - rad, false);\n    }\n  }\n});\n/**\r\n * A collision detector which detects collisions between two spheres.\r\n * @author saharan \r\n * @author lo-th\r\n */\n\nfunction SpherePlaneCollisionDetector(flip) {\n  CollisionDetector.call(this);\n  this.flip = flip;\n  this.n = new Vec3();\n  this.p = new Vec3();\n}\n\nSpherePlaneCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: SpherePlaneCollisionDetector,\n  detectCollision: function (shape1, shape2, manifold) {\n    var n = this.n;\n    var p = this.p;\n    var s = this.flip ? shape2 : shape1;\n    var pn = this.flip ? shape1 : shape2;\n    var rad = s.radius;\n    var len;\n    n.sub(s.position, pn.position); //var h = _Math.dotVectors( pn.normal, n );\n\n    n.x *= pn.normal.x; //+ rad;\n\n    n.y *= pn.normal.y;\n    n.z *= pn.normal.z; //+ rad;\n\n    var len = n.lengthSq();\n\n    if (len > 0 && len < rad * rad) {\n      //&& h > rad*rad ){\n      len = _Math.sqrt(len); //len = _Math.sqrt( h );\n\n      n.copy(pn.normal).negate(); //n.scaleEqual( 1/len );\n      //(0, -1, 0)\n      //n.normalize();\n\n      p.copy(s.position).addScaledVector(n, rad);\n      manifold.addPointVec(p, n, len - rad, this.flip);\n    }\n  }\n});\n/**\r\n * A collision detector which detects collisions between two spheres.\r\n * @author saharan \r\n * @author lo-th\r\n */\n\nfunction BoxPlaneCollisionDetector(flip) {\n  CollisionDetector.call(this);\n  this.flip = flip;\n  this.n = new Vec3();\n  this.p = new Vec3();\n  this.dix = new Vec3();\n  this.diy = new Vec3();\n  this.diz = new Vec3();\n  this.cc = new Vec3();\n  this.cc2 = new Vec3();\n}\n\nBoxPlaneCollisionDetector.prototype = Object.assign(Object.create(CollisionDetector.prototype), {\n  constructor: BoxPlaneCollisionDetector,\n  detectCollision: function (shape1, shape2, manifold) {\n    var n = this.n;\n    var p = this.p;\n    var cc = this.cc;\n    var b = this.flip ? shape2 : shape1;\n    var pn = this.flip ? shape1 : shape2;\n    var D = b.dimentions;\n    var hw = b.halfWidth;\n    var hh = b.halfHeight;\n    var hd = b.halfDepth;\n    var len;\n    var overlap = 0;\n    this.dix.set(D[0], D[1], D[2]);\n    this.diy.set(D[3], D[4], D[5]);\n    this.diz.set(D[6], D[7], D[8]);\n    n.sub(b.position, pn.position);\n    n.x *= pn.normal.x; //+ rad;\n\n    n.y *= pn.normal.y;\n    n.z *= pn.normal.z; //+ rad;\n\n    cc.set(_Math.dotVectors(this.dix, n), _Math.dotVectors(this.diy, n), _Math.dotVectors(this.diz, n));\n    if (cc.x > hw) cc.x = hw;else if (cc.x < -hw) cc.x = -hw;else overlap = 1;\n    if (cc.y > hh) cc.y = hh;else if (cc.y < -hh) cc.y = -hh;else overlap |= 2;\n    if (cc.z > hd) cc.z = hd;else if (cc.z < -hd) cc.z = -hd;else overlap |= 4;\n\n    if (overlap === 7) {\n      // center of sphere is in the box\n      n.set(cc.x < 0 ? hw + cc.x : hw - cc.x, cc.y < 0 ? hh + cc.y : hh - cc.y, cc.z < 0 ? hd + cc.z : hd - cc.z);\n\n      if (n.x < n.y) {\n        if (n.x < n.z) {\n          len = n.x - hw;\n\n          if (cc.x < 0) {\n            cc.x = -hw;\n            n.copy(this.dix);\n          } else {\n            cc.x = hw;\n            n.subEqual(this.dix);\n          }\n        } else {\n          len = n.z - hd;\n\n          if (cc.z < 0) {\n            cc.z = -hd;\n            n.copy(this.diz);\n          } else {\n            cc.z = hd;\n            n.subEqual(this.diz);\n          }\n        }\n      } else {\n        if (n.y < n.z) {\n          len = n.y - hh;\n\n          if (cc.y < 0) {\n            cc.y = -hh;\n            n.copy(this.diy);\n          } else {\n            cc.y = hh;\n            n.subEqual(this.diy);\n          }\n        } else {\n          len = n.z - hd;\n\n          if (cc.z < 0) {\n            cc.z = -hd;\n            n.copy(this.diz);\n          } else {\n            cc.z = hd;\n            n.subEqual(this.diz);\n          }\n        }\n      }\n\n      p.copy(pn.position).addScaledVector(n, 1);\n      manifold.addPointVec(p, n, len, this.flip);\n    }\n  }\n}); //import { TetraShape } from '../collision/shape/TetraShape';\n\n/**\r\n * The class of physical computing world.\r\n * You must be added to the world physical all computing objects\r\n *\r\n * @author saharan\r\n * @author lo-th\r\n */\n// timestep, broadphase, iterations, worldscale, random, stat\n\nfunction World(o) {\n  if (!(o instanceof Object)) o = {}; // this world scale defaut is 0.1 to 10 meters max for dynamique body\n\n  this.scale = o.worldscale || 1;\n  this.invScale = 1 / this.scale; // The time between each step\n\n  this.timeStep = o.timestep || 0.01666; // 1/60;\n\n  this.timerate = this.timeStep * 1000;\n  this.timer = null;\n  this.preLoop = null; //function(){};\n\n  this.postLoop = null; //function(){};\n  // The number of iterations for constraint solvers.\n\n  this.numIterations = o.iterations || 8; // It is a wide-area collision judgment that is used in order to reduce as much as possible a detailed collision judgment.\n\n  switch (o.broadphase || 2) {\n    case 1:\n      this.broadPhase = new BruteForceBroadPhase();\n      break;\n\n    case 2:\n    default:\n      this.broadPhase = new SAPBroadPhase();\n      break;\n\n    case 3:\n      this.broadPhase = new DBVTBroadPhase();\n      break;\n  }\n\n  this.Btypes = ['None', 'BruteForce', 'Sweep & Prune', 'Bounding Volume Tree'];\n  this.broadPhaseType = this.Btypes[o.broadphase || 2]; // This is the detailed information of the performance.\n\n  this.performance = null;\n  this.isStat = o.info === undefined ? false : o.info;\n  if (this.isStat) this.performance = new InfoDisplay(this);\n  /**\r\n   * Whether the constraints randomizer is enabled or not.\r\n   *\r\n   * @property enableRandomizer\r\n   * @type {Boolean}\r\n   */\n\n  this.enableRandomizer = o.random !== undefined ? o.random : true; // The rigid body list\n\n  this.rigidBodies = null; // number of rigid body\n\n  this.numRigidBodies = 0; // The contact list\n\n  this.contacts = null;\n  this.unusedContacts = null; // The number of contact\n\n  this.numContacts = 0; // The number of contact points\n\n  this.numContactPoints = 0; //  The joint list\n\n  this.joints = null; // The number of joints.\n\n  this.numJoints = 0; // The number of simulation islands.\n\n  this.numIslands = 0; // The gravity in the world.\n\n  this.gravity = new Vec3(0, -9.8, 0);\n  if (o.gravity !== undefined) this.gravity.fromArray(o.gravity);\n  var numShapeTypes = 5; //4;//3;\n\n  this.detectors = [];\n  this.detectors.length = numShapeTypes;\n  var i = numShapeTypes;\n\n  while (i--) {\n    this.detectors[i] = [];\n    this.detectors[i].length = numShapeTypes;\n  }\n\n  this.detectors[SHAPE_SPHERE][SHAPE_SPHERE] = new SphereSphereCollisionDetector();\n  this.detectors[SHAPE_SPHERE][SHAPE_BOX] = new SphereBoxCollisionDetector(false);\n  this.detectors[SHAPE_BOX][SHAPE_SPHERE] = new SphereBoxCollisionDetector(true);\n  this.detectors[SHAPE_BOX][SHAPE_BOX] = new BoxBoxCollisionDetector(); // CYLINDER add\n\n  this.detectors[SHAPE_CYLINDER][SHAPE_CYLINDER] = new CylinderCylinderCollisionDetector();\n  this.detectors[SHAPE_CYLINDER][SHAPE_BOX] = new BoxCylinderCollisionDetector(true);\n  this.detectors[SHAPE_BOX][SHAPE_CYLINDER] = new BoxCylinderCollisionDetector(false);\n  this.detectors[SHAPE_CYLINDER][SHAPE_SPHERE] = new SphereCylinderCollisionDetector(true);\n  this.detectors[SHAPE_SPHERE][SHAPE_CYLINDER] = new SphereCylinderCollisionDetector(false); // PLANE add\n\n  this.detectors[SHAPE_PLANE][SHAPE_SPHERE] = new SpherePlaneCollisionDetector(true);\n  this.detectors[SHAPE_SPHERE][SHAPE_PLANE] = new SpherePlaneCollisionDetector(false);\n  this.detectors[SHAPE_PLANE][SHAPE_BOX] = new BoxPlaneCollisionDetector(true);\n  this.detectors[SHAPE_BOX][SHAPE_PLANE] = new BoxPlaneCollisionDetector(false); // TETRA add\n  //this.detectors[SHAPE_TETRA][SHAPE_TETRA] = new TetraTetraCollisionDetector();\n\n  this.randX = 65535;\n  this.randA = 98765;\n  this.randB = 123456789;\n  this.islandRigidBodies = [];\n  this.islandStack = [];\n  this.islandConstraints = [];\n}\n\nObject.assign(World.prototype, {\n  World: true,\n  play: function () {\n    if (this.timer !== null) return;\n\n    var _this = this;\n\n    this.timer = setInterval(function () {\n      _this.step();\n    }, this.timerate); //this.timer = setInterval( this.loop.bind(this) , this.timerate );\n  },\n  stop: function () {\n    if (this.timer === null) return;\n    clearInterval(this.timer);\n    this.timer = null;\n  },\n  setGravity: function (ar) {\n    this.gravity.fromArray(ar);\n  },\n  getInfo: function () {\n    return this.isStat ? this.performance.show() : '';\n  },\n  // Reset the world and remove all rigid bodies, shapes, joints and any object from the world.\n  clear: function () {\n    this.stop();\n    this.preLoop = null;\n    this.postLoop = null;\n    this.randX = 65535;\n\n    while (this.joints !== null) {\n      this.removeJoint(this.joints);\n    }\n\n    while (this.contacts !== null) {\n      this.removeContact(this.contacts);\n    }\n\n    while (this.rigidBodies !== null) {\n      this.removeRigidBody(this.rigidBodies);\n    }\n  },\n\n  /**\r\n  * I'll add a rigid body to the world.\r\n  * Rigid body that has been added will be the operands of each step.\r\n  * @param  rigidBody  Rigid body that you want to add\r\n  */\n  addRigidBody: function (rigidBody) {\n    if (rigidBody.parent) {\n      printError(\"World\", \"It is not possible to be added to more than one world one of the rigid body\");\n    }\n\n    rigidBody.setParent(this); //rigidBody.awake();\n\n    for (var shape = rigidBody.shapes; shape !== null; shape = shape.next) {\n      this.addShape(shape);\n    }\n\n    if (this.rigidBodies !== null) (this.rigidBodies.prev = rigidBody).next = this.rigidBodies;\n    this.rigidBodies = rigidBody;\n    this.numRigidBodies++;\n  },\n\n  /**\r\n  * I will remove the rigid body from the world.\r\n  * Rigid body that has been deleted is excluded from the calculation on a step-by-step basis.\r\n  * @param  rigidBody  Rigid body to be removed\r\n  */\n  removeRigidBody: function (rigidBody) {\n    var remove = rigidBody;\n    if (remove.parent !== this) return;\n    remove.awake();\n    var js = remove.jointLink;\n\n    while (js != null) {\n      var joint = js.joint;\n      js = js.next;\n      this.removeJoint(joint);\n    }\n\n    for (var shape = rigidBody.shapes; shape !== null; shape = shape.next) {\n      this.removeShape(shape);\n    }\n\n    var prev = remove.prev;\n    var next = remove.next;\n    if (prev !== null) prev.next = next;\n    if (next !== null) next.prev = prev;\n    if (this.rigidBodies == remove) this.rigidBodies = next;\n    remove.prev = null;\n    remove.next = null;\n    remove.parent = null;\n    this.numRigidBodies--;\n  },\n  getByName: function (name) {\n    var body = this.rigidBodies;\n\n    while (body !== null) {\n      if (body.name === name) return body;\n      body = body.next;\n    }\n\n    var joint = this.joints;\n\n    while (joint !== null) {\n      if (joint.name === name) return joint;\n      joint = joint.next;\n    }\n\n    return null;\n  },\n\n  /**\r\n  * I'll add a shape to the world..\r\n  * Add to the rigid world, and if you add a shape to a rigid body that has been added to the world,\r\n  * Shape will be added to the world automatically, please do not call from outside this method.\r\n  * @param  shape  Shape you want to add\r\n  */\n  addShape: function (shape) {\n    if (!shape.parent || !shape.parent.parent) {\n      printError(\"World\", \"It is not possible to be added alone to shape world\");\n    }\n\n    shape.proxy = this.broadPhase.createProxy(shape);\n    shape.updateProxy();\n    this.broadPhase.addProxy(shape.proxy);\n  },\n\n  /**\r\n  * I will remove the shape from the world.\r\n  * Add to the rigid world, and if you add a shape to a rigid body that has been added to the world,\r\n  * Shape will be added to the world automatically, please do not call from outside this method.\r\n  * @param  shape  Shape you want to delete\r\n  */\n  removeShape: function (shape) {\n    this.broadPhase.removeProxy(shape.proxy);\n    shape.proxy = null;\n  },\n\n  /**\r\n  * I'll add a joint to the world.\r\n  * Joint that has been added will be the operands of each step.\r\n  * @param  shape Joint to be added\r\n  */\n  addJoint: function (joint) {\n    if (joint.parent) {\n      printError(\"World\", \"It is not possible to be added to more than one world one of the joint\");\n    }\n\n    if (this.joints != null) (this.joints.prev = joint).next = this.joints;\n    this.joints = joint;\n    joint.setParent(this);\n    this.numJoints++;\n    joint.awake();\n    joint.attach();\n  },\n\n  /**\r\n  * I will remove the joint from the world.\r\n  * Joint that has been added will be the operands of each step.\r\n  * @param  shape Joint to be deleted\r\n  */\n  removeJoint: function (joint) {\n    var remove = joint;\n    var prev = remove.prev;\n    var next = remove.next;\n    if (prev !== null) prev.next = next;\n    if (next !== null) next.prev = prev;\n    if (this.joints == remove) this.joints = next;\n    remove.prev = null;\n    remove.next = null;\n    this.numJoints--;\n    remove.awake();\n    remove.detach();\n    remove.parent = null;\n  },\n  addContact: function (s1, s2) {\n    var newContact;\n\n    if (this.unusedContacts !== null) {\n      newContact = this.unusedContacts;\n      this.unusedContacts = this.unusedContacts.next;\n    } else {\n      newContact = new Contact();\n    }\n\n    newContact.attach(s1, s2);\n    newContact.detector = this.detectors[s1.type][s2.type];\n    if (this.contacts) (this.contacts.prev = newContact).next = this.contacts;\n    this.contacts = newContact;\n    this.numContacts++;\n  },\n  removeContact: function (contact) {\n    var prev = contact.prev;\n    var next = contact.next;\n    if (next) next.prev = prev;\n    if (prev) prev.next = next;\n    if (this.contacts == contact) this.contacts = next;\n    contact.prev = null;\n    contact.next = null;\n    contact.detach();\n    contact.next = this.unusedContacts;\n    this.unusedContacts = contact;\n    this.numContacts--;\n  },\n  getContact: function (b1, b2) {\n    b1 = b1.constructor === RigidBody ? b1.name : b1;\n    b2 = b2.constructor === RigidBody ? b2.name : b2;\n    var n1, n2;\n    var contact = this.contacts;\n\n    while (contact !== null) {\n      n1 = contact.body1.name;\n      n2 = contact.body2.name;\n\n      if (n1 === b1 && n2 === b2 || n2 === b1 && n1 === b2) {\n        if (contact.touching) return contact;else return null;\n      } else contact = contact.next;\n    }\n\n    return null;\n  },\n  checkContact: function (name1, name2) {\n    var n1, n2;\n    var contact = this.contacts;\n\n    while (contact !== null) {\n      n1 = contact.body1.name || ' ';\n      n2 = contact.body2.name || ' ';\n\n      if (n1 == name1 && n2 == name2 || n2 == name1 && n1 == name2) {\n        if (contact.touching) return true;else return false;\n      } else contact = contact.next;\n    } //return false;\n\n  },\n  callSleep: function (body) {\n    if (!body.allowSleep) return false;\n    if (body.linearVelocity.lengthSq() > 0.04) return false;\n    if (body.angularVelocity.lengthSq() > 0.25) return false;\n    return true;\n  },\n\n  /**\r\n  * I will proceed only time step seconds time of World.\r\n  */\n  step: function () {\n    var stat = this.isStat;\n    if (stat) this.performance.setTime(0);\n    var body = this.rigidBodies;\n\n    while (body !== null) {\n      body.addedToIsland = false;\n      if (body.sleeping) body.testWakeUp();\n      body = body.next;\n    } //------------------------------------------------------\n    //   UPDATE BROADPHASE CONTACT\n    //------------------------------------------------------\n\n\n    if (stat) this.performance.setTime(1);\n    this.broadPhase.detectPairs();\n    var pairs = this.broadPhase.pairs;\n    var i = this.broadPhase.numPairs; //do{\n\n    while (i--) {\n      //for(var i=0, l=numPairs; i<l; i++){\n      var pair = pairs[i];\n      var s1;\n      var s2;\n\n      if (pair.shape1.id < pair.shape2.id) {\n        s1 = pair.shape1;\n        s2 = pair.shape2;\n      } else {\n        s1 = pair.shape2;\n        s2 = pair.shape1;\n      }\n\n      var link;\n      if (s1.numContacts < s2.numContacts) link = s1.contactLink;else link = s2.contactLink;\n      var exists = false;\n\n      while (link) {\n        var contact = link.contact;\n\n        if (contact.shape1 == s1 && contact.shape2 == s2) {\n          contact.persisting = true;\n          exists = true; // contact already exists\n\n          break;\n        }\n\n        link = link.next;\n      }\n\n      if (!exists) {\n        this.addContact(s1, s2);\n      }\n    } // while(i-- >0);\n\n\n    if (stat) this.performance.calcBroadPhase(); //------------------------------------------------------\n    //   UPDATE NARROWPHASE CONTACT\n    //------------------------------------------------------\n    // update & narrow phase\n\n    this.numContactPoints = 0;\n    contact = this.contacts;\n\n    while (contact !== null) {\n      if (!contact.persisting) {\n        if (contact.shape1.aabb.intersectTest(contact.shape2.aabb)) {\n          /*var aabb1=contact.shape1.aabb;\r\n          var aabb2=contact.shape2.aabb;\r\n          if(\r\n           aabb1.minX>aabb2.maxX || aabb1.maxX<aabb2.minX ||\r\n           aabb1.minY>aabb2.maxY || aabb1.maxY<aabb2.minY ||\r\n           aabb1.minZ>aabb2.maxZ || aabb1.maxZ<aabb2.minZ\r\n          ){*/\n          var next = contact.next;\n          this.removeContact(contact);\n          contact = next;\n          continue;\n        }\n      }\n\n      var b1 = contact.body1;\n      var b2 = contact.body2;\n      if (b1.isDynamic && !b1.sleeping || b2.isDynamic && !b2.sleeping) contact.updateManifold();\n      this.numContactPoints += contact.manifold.numPoints;\n      contact.persisting = false;\n      contact.constraint.addedToIsland = false;\n      contact = contact.next;\n    }\n\n    if (stat) this.performance.calcNarrowPhase(); //------------------------------------------------------\n    //   SOLVE ISLANDS\n    //------------------------------------------------------\n\n    var invTimeStep = 1 / this.timeStep;\n    var joint;\n    var constraint;\n\n    for (joint = this.joints; joint !== null; joint = joint.next) {\n      joint.addedToIsland = false;\n    } // clear old island array\n\n\n    this.islandRigidBodies = [];\n    this.islandConstraints = [];\n    this.islandStack = [];\n    if (stat) this.performance.setTime(1);\n    this.numIslands = 0; // build and solve simulation islands\n\n    for (var base = this.rigidBodies; base !== null; base = base.next) {\n      if (base.addedToIsland || base.isStatic || base.sleeping) continue; // ignore\n\n      if (base.isLonely()) {\n        // update single body\n        if (base.isDynamic) {\n          base.linearVelocity.addScaledVector(this.gravity, this.timeStep);\n          /*base.linearVelocity.x+=this.gravity.x*this.timeStep;\r\n          base.linearVelocity.y+=this.gravity.y*this.timeStep;\r\n          base.linearVelocity.z+=this.gravity.z*this.timeStep;*/\n        }\n\n        if (this.callSleep(base)) {\n          base.sleepTime += this.timeStep;\n          if (base.sleepTime > 0.5) base.sleep();else base.updatePosition(this.timeStep);\n        } else {\n          base.sleepTime = 0;\n          base.updatePosition(this.timeStep);\n        }\n\n        this.numIslands++;\n        continue;\n      }\n\n      var islandNumRigidBodies = 0;\n      var islandNumConstraints = 0;\n      var stackCount = 1; // add rigid body to stack\n\n      this.islandStack[0] = base;\n      base.addedToIsland = true; // build an island\n\n      do {\n        // get rigid body from stack\n        body = this.islandStack[--stackCount];\n        this.islandStack[stackCount] = null;\n        body.sleeping = false; // add rigid body to the island\n\n        this.islandRigidBodies[islandNumRigidBodies++] = body;\n        if (body.isStatic) continue; // search connections\n\n        for (var cs = body.contactLink; cs !== null; cs = cs.next) {\n          var contact = cs.contact;\n          constraint = contact.constraint;\n          if (constraint.addedToIsland || !contact.touching) continue; // ignore\n          // add constraint to the island\n\n          this.islandConstraints[islandNumConstraints++] = constraint;\n          constraint.addedToIsland = true;\n          var next = cs.body;\n          if (next.addedToIsland) continue; // add rigid body to stack\n\n          this.islandStack[stackCount++] = next;\n          next.addedToIsland = true;\n        }\n\n        for (var js = body.jointLink; js !== null; js = js.next) {\n          constraint = js.joint;\n          if (constraint.addedToIsland) continue; // ignore\n          // add constraint to the island\n\n          this.islandConstraints[islandNumConstraints++] = constraint;\n          constraint.addedToIsland = true;\n          next = js.body;\n          if (next.addedToIsland || !next.isDynamic) continue; // add rigid body to stack\n\n          this.islandStack[stackCount++] = next;\n          next.addedToIsland = true;\n        }\n      } while (stackCount != 0); // update velocities\n\n\n      var gVel = new Vec3().addScaledVector(this.gravity, this.timeStep);\n      /*var gx=this.gravity.x*this.timeStep;\r\n      var gy=this.gravity.y*this.timeStep;\r\n      var gz=this.gravity.z*this.timeStep;*/\n\n      var j = islandNumRigidBodies;\n\n      while (j--) {\n        //or(var j=0, l=islandNumRigidBodies; j<l; j++){\n        body = this.islandRigidBodies[j];\n\n        if (body.isDynamic) {\n          body.linearVelocity.addEqual(gVel);\n          /*body.linearVelocity.x+=gx;\r\n          body.linearVelocity.y+=gy;\r\n          body.linearVelocity.z+=gz;*/\n        }\n      } // randomizing order\n\n\n      if (this.enableRandomizer) {\n        //for(var j=1, l=islandNumConstraints; j<l; j++){\n        j = islandNumConstraints;\n\n        while (j--) {\n          if (j !== 0) {\n            var swap = (this.randX = this.randX * this.randA + this.randB & 0x7fffffff) / 2147483648.0 * j | 0;\n            constraint = this.islandConstraints[j];\n            this.islandConstraints[j] = this.islandConstraints[swap];\n            this.islandConstraints[swap] = constraint;\n          }\n        }\n      } // solve contraints\n\n\n      j = islandNumConstraints;\n\n      while (j--) {\n        //for(j=0, l=islandNumConstraints; j<l; j++){\n        this.islandConstraints[j].preSolve(this.timeStep, invTimeStep); // pre-solve\n      }\n\n      var k = this.numIterations;\n\n      while (k--) {\n        //for(var k=0, l=this.numIterations; k<l; k++){\n        j = islandNumConstraints;\n\n        while (j--) {\n          //for(j=0, m=islandNumConstraints; j<m; j++){\n          this.islandConstraints[j].solve(); // main-solve\n        }\n      }\n\n      j = islandNumConstraints;\n\n      while (j--) {\n        //for(j=0, l=islandNumConstraints; j<l; j++){\n        this.islandConstraints[j].postSolve(); // post-solve\n\n        this.islandConstraints[j] = null; // gc\n      } // sleeping check\n\n\n      var sleepTime = 10;\n      j = islandNumRigidBodies;\n\n      while (j--) {\n        //for(j=0, l=islandNumRigidBodies;j<l;j++){\n        body = this.islandRigidBodies[j];\n\n        if (this.callSleep(body)) {\n          body.sleepTime += this.timeStep;\n          if (body.sleepTime < sleepTime) sleepTime = body.sleepTime;\n        } else {\n          body.sleepTime = 0;\n          sleepTime = 0;\n          continue;\n        }\n      }\n\n      if (sleepTime > 0.5) {\n        // sleep the island\n        j = islandNumRigidBodies;\n\n        while (j--) {\n          //for(j=0, l=islandNumRigidBodies;j<l;j++){\n          this.islandRigidBodies[j].sleep();\n          this.islandRigidBodies[j] = null; // gc\n        }\n      } else {\n        // update positions\n        j = islandNumRigidBodies;\n\n        while (j--) {\n          //for(j=0, l=islandNumRigidBodies;j<l;j++){\n          this.islandRigidBodies[j].updatePosition(this.timeStep);\n          this.islandRigidBodies[j] = null; // gc\n        }\n      }\n\n      this.numIslands++;\n    } //------------------------------------------------------\n    //   END SIMULATION\n    //------------------------------------------------------\n\n\n    if (stat) this.performance.calcEnd();\n    if (this.postLoop !== null) this.postLoop();\n  },\n  // remove someting to world\n  remove: function (obj) {},\n  // add someting to world\n  add: function (o) {\n    o = o || {};\n    var type = o.type || \"box\";\n    if (type.constructor === String) type = [type];\n    var isJoint = type[0].substring(0, 5) === 'joint' ? true : false;\n    if (isJoint) return this.initJoint(type[0], o);else return this.initBody(type, o);\n  },\n  initBody: function (type, o) {\n    var invScale = this.invScale; // body dynamic or static\n\n    var move = o.move || false;\n    var kinematic = o.kinematic || false; // POSITION\n    // body position\n\n    var p = o.pos || [0, 0, 0];\n    p = p.map(function (x) {\n      return x * invScale;\n    }); // shape position\n\n    var p2 = o.posShape || [0, 0, 0];\n    p2 = p2.map(function (x) {\n      return x * invScale;\n    }); // ROTATION\n    // body rotation in degree\n\n    var r = o.rot || [0, 0, 0];\n    r = r.map(function (x) {\n      return x * _Math.degtorad;\n    }); // shape rotation in degree\n\n    var r2 = o.rotShape || [0, 0, 0];\n    r2 = r.map(function (x) {\n      return x * _Math.degtorad;\n    }); // SIZE\n    // shape size\n\n    var s = o.size === undefined ? [1, 1, 1] : o.size;\n\n    if (s.length === 1) {\n      s[1] = s[0];\n    }\n\n    if (s.length === 2) {\n      s[2] = s[0];\n    }\n\n    s = s.map(function (x) {\n      return x * invScale;\n    }); // body physics settings\n\n    var sc = new ShapeConfig(); // The density of the shape.\n\n    if (o.density !== undefined) sc.density = o.density; // The coefficient of friction of the shape.\n\n    if (o.friction !== undefined) sc.friction = o.friction; // The coefficient of restitution of the shape.\n\n    if (o.restitution !== undefined) sc.restitution = o.restitution; // The bits of the collision groups to which the shape belongs.\n\n    if (o.belongsTo !== undefined) sc.belongsTo = o.belongsTo; // The bits of the collision groups with which the shape collides.\n\n    if (o.collidesWith !== undefined) sc.collidesWith = o.collidesWith;\n\n    if (o.config !== undefined) {\n      if (o.config[0] !== undefined) sc.density = o.config[0];\n      if (o.config[1] !== undefined) sc.friction = o.config[1];\n      if (o.config[2] !== undefined) sc.restitution = o.config[2];\n      if (o.config[3] !== undefined) sc.belongsTo = o.config[3];\n      if (o.config[4] !== undefined) sc.collidesWith = o.config[4];\n    }\n    /* if(o.massPos){\r\n         o.massPos = o.massPos.map(function(x) { return x * invScale; });\r\n         sc.relativePosition.set( o.massPos[0], o.massPos[1], o.massPos[2] );\r\n     }\r\n     if(o.massRot){\r\n         o.massRot = o.massRot.map(function(x) { return x * _Math.degtorad; });\r\n         var q = new Quat().setFromEuler( o.massRot[0], o.massRot[1], o.massRot[2] );\r\n         sc.relativeRotation = new Mat33().setQuat( q );//_Math.EulerToMatrix( o.massRot[0], o.massRot[1], o.massRot[2] );\r\n     }*/\n\n\n    var position = new Vec3(p[0], p[1], p[2]);\n    var rotation = new Quat().setFromEuler(r[0], r[1], r[2]); // rigidbody\n\n    var body = new RigidBody(position, rotation); //var body = new RigidBody( p[0], p[1], p[2], r[0], r[1], r[2], r[3], this.scale, this.invScale );\n    // SHAPES\n\n    var shape, n;\n\n    for (var i = 0; i < type.length; i++) {\n      n = i * 3;\n      if (p2[n] !== undefined) sc.relativePosition.set(p2[n], p2[n + 1], p2[n + 2]);\n      if (r2[n] !== undefined) sc.relativeRotation.setQuat(new Quat().setFromEuler(r2[n], r2[n + 1], r2[n + 2]));\n\n      switch (type[i]) {\n        case \"sphere\":\n          shape = new Sphere(sc, s[n]);\n          break;\n\n        case \"cylinder\":\n          shape = new Cylinder(sc, s[n], s[n + 1]);\n          break;\n\n        case \"box\":\n          shape = new Box(sc, s[n], s[n + 1], s[n + 2]);\n          break;\n\n        case \"plane\":\n          shape = new Plane(sc);\n          break;\n      }\n\n      body.addShape(shape);\n    } // body can sleep or not\n\n\n    if (o.neverSleep || kinematic) body.allowSleep = false;else body.allowSleep = true;\n    body.isKinematic = kinematic; // body static or dynamic\n\n    if (move) {\n      if (o.massPos || o.massRot) body.setupMass(BODY_DYNAMIC, false);else body.setupMass(BODY_DYNAMIC, true); // body can sleep or not\n      //if( o.neverSleep ) body.allowSleep = false;\n      //else body.allowSleep = true;\n    } else {\n      body.setupMass(BODY_STATIC);\n    }\n\n    if (o.name !== undefined) body.name = o.name; //else if( move ) body.name = this.numRigidBodies;\n    // finaly add to physics world\n\n    this.addRigidBody(body); // force sleep on not\n\n    if (move) {\n      if (o.sleep) body.sleep();else body.awake();\n    }\n\n    return body;\n  },\n  initJoint: function (type, o) {\n    //var type = type;\n    var invScale = this.invScale;\n    var axe1 = o.axe1 || [1, 0, 0];\n    var axe2 = o.axe2 || [1, 0, 0];\n    var pos1 = o.pos1 || [0, 0, 0];\n    var pos2 = o.pos2 || [0, 0, 0];\n    pos1 = pos1.map(function (x) {\n      return x * invScale;\n    });\n    pos2 = pos2.map(function (x) {\n      return x * invScale;\n    });\n    var min, max;\n\n    if (type === \"jointDistance\") {\n      min = o.min || 0;\n      max = o.max || 10;\n      min = min * invScale;\n      max = max * invScale;\n    } else {\n      min = o.min || 57.29578;\n      max = o.max || 0;\n      min = min * _Math.degtorad;\n      max = max * _Math.degtorad;\n    }\n\n    var limit = o.limit || null;\n    var spring = o.spring || null;\n    var motor = o.motor || null; // joint setting\n\n    var jc = new JointConfig();\n    jc.scale = this.scale;\n    jc.invScale = this.invScale;\n    jc.allowCollision = o.collision || false;\n    jc.localAxis1.set(axe1[0], axe1[1], axe1[2]);\n    jc.localAxis2.set(axe2[0], axe2[1], axe2[2]);\n    jc.localAnchorPoint1.set(pos1[0], pos1[1], pos1[2]);\n    jc.localAnchorPoint2.set(pos2[0], pos2[1], pos2[2]);\n    var b1 = null;\n    var b2 = null;\n    if (o.body1 === undefined || o.body2 === undefined) return printError('World', \"Can't add joint if attach rigidbodys not define !\");\n\n    if (o.body1.constructor === String) {\n      b1 = this.getByName(o.body1);\n    } else if (o.body1.constructor === Number) {\n      b1 = this.getByName(o.body1);\n    } else if (o.body1.constructor === RigidBody) {\n      b1 = o.body1;\n    }\n\n    if (o.body2.constructor === String) {\n      b2 = this.getByName(o.body2);\n    } else if (o.body2.constructor === Number) {\n      b2 = this.getByName(o.body2);\n    } else if (o.body2.constructor === RigidBody) {\n      b2 = o.body2;\n    }\n\n    if (b1 === null || b2 === null) return printError('World', \"Can't add joint attach rigidbodys not find !\");\n    jc.body1 = b1;\n    jc.body2 = b2;\n    var joint;\n\n    switch (type) {\n      case \"jointDistance\":\n        joint = new DistanceJoint(jc, min, max);\n        if (spring !== null) joint.limitMotor.setSpring(spring[0], spring[1]);\n        if (motor !== null) joint.limitMotor.setMotor(motor[0], motor[1]);\n        break;\n\n      case \"jointHinge\":\n      case \"joint\":\n        joint = new HingeJoint(jc, min, max);\n        if (spring !== null) joint.limitMotor.setSpring(spring[0], spring[1]); // soften the joint ex: 100, 0.2\n\n        if (motor !== null) joint.limitMotor.setMotor(motor[0], motor[1]);\n        break;\n\n      case \"jointPrisme\":\n        joint = new PrismaticJoint(jc, min, max);\n        break;\n\n      case \"jointSlide\":\n        joint = new SliderJoint(jc, min, max);\n        break;\n\n      case \"jointBall\":\n        joint = new BallAndSocketJoint(jc);\n        break;\n\n      case \"jointWheel\":\n        joint = new WheelJoint(jc);\n        if (limit !== null) joint.rotationalLimitMotor1.setLimit(limit[0], limit[1]);\n        if (spring !== null) joint.rotationalLimitMotor1.setSpring(spring[0], spring[1]);\n        if (motor !== null) joint.rotationalLimitMotor1.setMotor(motor[0], motor[1]);\n        break;\n    }\n\n    joint.name = o.name || ''; // finaly add to physics world\n\n    this.addJoint(joint);\n    return joint;\n  }\n}); // test version\n//export { RigidBody } from './core/RigidBody_X.js';\n//export { World } from './core/World_X.js';\n\nexport { _Math as Math, Vec3, Quat, Mat33, Shape, Box, Sphere, Cylinder, Plane, Particle, ShapeConfig, LimitMotor, HingeJoint, BallAndSocketJoint, DistanceJoint, PrismaticJoint, SliderJoint, WheelJoint, JointConfig, RigidBody, World, REVISION, BR_NULL, BR_BRUTE_FORCE, BR_SWEEP_AND_PRUNE, BR_BOUNDING_VOLUME_TREE, BODY_NULL, BODY_DYNAMIC, BODY_STATIC, BODY_KINEMATIC, BODY_GHOST, SHAPE_NULL, SHAPE_SPHERE, SHAPE_BOX, SHAPE_CYLINDER, SHAPE_PLANE, SHAPE_PARTICLE, SHAPE_TETRA, JOINT_NULL, JOINT_DISTANCE, JOINT_BALL_AND_SOCKET, JOINT_HINGE, JOINT_WHEEL, JOINT_SLIDER, JOINT_PRISMATIC, AABB_PROX, printError, InfoDisplay };","map":null,"metadata":{},"sourceType":"module"}