{"ast":null,"code":"!function (e, t) {\n  var n = [],\n      r = e.BABYLON || this.BABYLON;\n  \"object\" == typeof exports && \"object\" == typeof module ? (r = r || require(\"babylonjs\"), module.exports = t(r)) : \"function\" == typeof define && define.amd ? (n.push(\"babylonjs\"), define(\"babylonjs-loaders\", n, t)) : \"object\" == typeof exports ? (r = r || require(\"babylonjs\"), exports[\"babylonjs-loaders\"] = t(r)) : e.BABYLON = t(r);\n}(this, function (e) {\n  e = e || this.BABYLON;\n  this && this.__decorate;\n\n  var r,\n      y,\n      t,\n      n,\n      o,\n      a,\n      i,\n      s,\n      l,\n      u,\n      c,\n      d,\n      f,\n      W,\n      h,\n      p,\n      m,\n      _,\n      A,\n      g,\n      v,\n      b,\n      T,\n      E,\n      L,\n      x,\n      O,\n      M,\n      w,\n      S,\n      N,\n      F,\n      P,\n      C,\n      I,\n      R,\n      D,\n      B,\n      G,\n      V,\n      U,\n      k,\n      j,\n      H,\n      K,\n      Z,\n      Q,\n      Y,\n      J,\n      q,\n      X,\n      z,\n      $,\n      ee,\n      te,\n      ne,\n      re,\n      oe,\n      ae,\n      ie,\n      se,\n      le,\n      ue,\n      ce,\n      de,\n      fe,\n      he,\n      pe,\n      me,\n      ye,\n      _e,\n      Ae,\n      ge,\n      ve,\n      be,\n      Te,\n      Ee,\n      Le,\n      xe,\n      Oe,\n      Me,\n      we,\n      Se,\n      Ne,\n      Fe = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n\n    r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  });\n\n  return y = e || (e = {}), t = function () {\n    function e() {\n      this.solidPattern = /solid (\\S*)([\\S\\s]*)endsolid[ ]*(\\S*)/g, this.facetsPattern = /facet([\\s\\S]*?)endfacet/g, this.normalPattern = /normal[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g, this.vertexPattern = /vertex[\\s]+([\\-+]?[0-9]+\\.?[0-9]*([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+[\\s]+([\\-+]?[0-9]*\\.?[0-9]+([eE][\\-+]?[0-9]+)?)+/g, this.name = \"stl\", this.extensions = {\n        \".stl\": {\n          isBinary: !0\n        }\n      };\n    }\n\n    return e.prototype.importMesh = function (e, t, n, r, o, a, i) {\n      var s;\n\n      if (\"string\" != typeof n) {\n        if (this.isBinary(n)) {\n          var l = new y.Mesh(\"stlmesh\", t);\n          return this.parseBinary(l, n), o && o.push(l), !0;\n        }\n\n        for (var u = new Uint8Array(n), c = \"\", d = 0; d < n.byteLength; d++) c += String.fromCharCode(u[d]);\n\n        n = c;\n      }\n\n      for (; s = this.solidPattern.exec(n);) {\n        var f = s[1];\n        if (f != s[3]) return y.Tools.Error(\"Error in STL, solid name != endsolid name\"), !1;\n        if (e && f) if (e instanceof Array) {\n          if (!e.indexOf(f)) continue;\n        } else if (f !== e) continue;\n        f = f || \"stlmesh\";\n        l = new y.Mesh(f, t);\n        this.parseASCII(l, s[2]), o && o.push(l);\n      }\n\n      return !0;\n    }, e.prototype.load = function (e, t, n) {\n      var r = this.importMesh(null, e, t, n, null, null, null);\n      return r && e.createDefaultCameraOrLight(), r;\n    }, e.prototype.loadAssetContainer = function (e, t, n, r) {\n      var o = new y.AssetContainer(e);\n      return this.importMesh(null, e, t, n, o.meshes, null, null), o.removeAllFromScene(), o;\n    }, e.prototype.isBinary = function (e) {\n      var t;\n      if (84 + 50 * (t = new DataView(e)).getUint32(80, !0) === t.byteLength) return !0;\n\n      for (var n = t.byteLength, r = 0; r < n; r++) if (127 < t.getUint8(r)) return !0;\n\n      return !1;\n    }, e.prototype.parseBinary = function (e, t) {\n      for (var n = new DataView(t), r = n.getUint32(80, !0), o = 0, a = new Float32Array(3 * r * 3), i = new Float32Array(3 * r * 3), s = new Uint32Array(3 * r), l = 0, u = 0; u < r; u++) {\n        for (var c = 84 + 50 * u, d = n.getFloat32(c, !0), f = n.getFloat32(c + 4, !0), h = n.getFloat32(c + 8, !0), p = 1; p <= 3; p++) {\n          var m = c + 12 * p;\n          a[o] = n.getFloat32(m, !0), a[o + 2] = n.getFloat32(m + 4, !0), a[o + 1] = n.getFloat32(m + 8, !0), i[o] = d, i[o + 2] = f, i[o + 1] = h, o += 3;\n        }\n\n        s[l] = l++, s[l] = l++, s[l] = l++;\n      }\n\n      e.setVerticesData(y.VertexBuffer.PositionKind, a), e.setVerticesData(y.VertexBuffer.NormalKind, i), e.setIndices(s), e.computeWorldMatrix(!0);\n    }, e.prototype.parseASCII = function (e, t) {\n      for (var n, r = [], o = [], a = [], i = 0; n = this.facetsPattern.exec(t);) {\n        var s = n[1],\n            l = this.normalPattern.exec(s);\n\n        if (this.normalPattern.lastIndex = 0, l) {\n          for (var u, c = [Number(l[1]), Number(l[5]), Number(l[3])]; u = this.vertexPattern.exec(s);) r.push(Number(u[1]), Number(u[5]), Number(u[3])), o.push(c[0], c[1], c[2]);\n\n          a.push(i++, i++, i++), this.vertexPattern.lastIndex = 0;\n        }\n      }\n\n      this.facetsPattern.lastIndex = 0, e.setVerticesData(y.VertexBuffer.PositionKind, r), e.setVerticesData(y.VertexBuffer.NormalKind, o), e.setIndices(a), e.computeWorldMatrix(!0);\n    }, e;\n  }(), y.STLFileLoader = t, y.SceneLoader && y.SceneLoader.RegisterPlugin(new t()), function (Q) {\n    var Y = function () {\n      function f() {\n        this.materials = [];\n      }\n\n      return f.prototype.parseMTL = function (e, t, n) {\n        if (!(t instanceof ArrayBuffer)) {\n          for (var r, o = t.split(\"\\n\"), a = /\\s+/, i = null, s = 0; s < o.length; s++) {\n            var l = o[s].trim();\n\n            if (0 !== l.length && \"#\" !== l.charAt(0)) {\n              var u = l.indexOf(\" \"),\n                  c = 0 <= u ? l.substring(0, u) : l;\n              c = c.toLowerCase();\n              var d = 0 <= u ? l.substring(u + 1).trim() : \"\";\n              \"newmtl\" === c ? (i && this.materials.push(i), i = new Q.StandardMaterial(d, e)) : \"kd\" === c && i ? (r = d.split(a, 3).map(parseFloat), i.diffuseColor = Q.Color3.FromArray(r)) : \"ka\" === c && i ? (r = d.split(a, 3).map(parseFloat), i.ambientColor = Q.Color3.FromArray(r)) : \"ks\" === c && i ? (r = d.split(a, 3).map(parseFloat), i.specularColor = Q.Color3.FromArray(r)) : \"ke\" === c && i ? (r = d.split(a, 3).map(parseFloat), i.emissiveColor = Q.Color3.FromArray(r)) : \"ns\" === c && i ? i.specularPower = parseFloat(d) : \"d\" === c && i ? i.alpha = parseFloat(d) : \"map_ka\" === c && i ? i.ambientTexture = f._getTexture(n, d, e) : \"map_kd\" === c && i ? i.diffuseTexture = f._getTexture(n, d, e) : \"map_ks\" === c && i ? i.specularTexture = f._getTexture(n, d, e) : \"map_ns\" === c || (\"map_bump\" === c && i ? i.bumpTexture = f._getTexture(n, d, e) : \"map_d\" === c && i && (i.opacityTexture = f._getTexture(n, d, e)));\n            }\n          }\n\n          i && this.materials.push(i);\n        }\n      }, f._getTexture = function (e, t, n) {\n        if (!t) return null;\n        var r = e;\n\n        if (\"file:\" === e) {\n          var o = t.lastIndexOf(\"\\\\\");\n          -1 === o && (o = t.lastIndexOf(\"/\")), r += -1 < o ? t.substr(o + 1) : t;\n        } else r += t;\n\n        return new Q.Texture(r, n);\n      }, f;\n    }();\n\n    Q.MTLFileLoader = Y;\n\n    var e = function () {\n      function Z() {\n        this.name = \"obj\", this.extensions = \".obj\", this.obj = /^o/, this.group = /^g/, this.mtllib = /^mtllib /, this.usemtl = /^usemtl /, this.smooth = /^s /, this.vertexPattern = /v( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/, this.normalPattern = /vn( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/, this.uvPattern = /vt( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/, this.facePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/, this.facePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/, this.facePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/, this.facePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/, this.facePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n      }\n\n      return Z.prototype._loadMTL = function (e, t, n) {\n        var r = Q.Tools.BaseUrl + t + e;\n        Q.Tools.LoadFile(r, n, void 0, void 0, !1, function () {\n          console.warn(\"Error - Unable to load \" + r);\n        });\n      }, Z.prototype.importMeshAsync = function (e, t, n, r, o, a) {\n        return this._parseSolid(e, t, n, r).then(function (e) {\n          return {\n            meshes: e,\n            particleSystems: [],\n            skeletons: [],\n            animationGroups: []\n          };\n        });\n      }, Z.prototype.loadAsync = function (e, t, n, r, o) {\n        return this.importMeshAsync(null, e, t, n, r).then(function () {});\n      }, Z.prototype.loadAssetContainerAsync = function (n, e, t, r, o) {\n        return this.importMeshAsync(null, n, e, t).then(function (e) {\n          var t = new Q.AssetContainer(n);\n          return e.meshes.forEach(function (e) {\n            return t.meshes.push(e);\n          }), t.removeAllFromScene(), t;\n        });\n      }, Z.prototype._parseSolid = function (e, l, t, u) {\n        for (var n, r = this, s = [], c = [], d = [], o = [], f = [], h = [], p = [], m = [], y = [], _ = 0, a = !1, i = [], A = [], g = [], v = [], b = \"\", T = \"\", E = new Y(), L = 1, x = !0, O = function (e, t, n, r, o, a) {\n          var i;\n          -1 == (i = Z.OPTIMIZE_WITH_UV ? function (e, t) {\n            e[t[0]] || (e[t[0]] = {\n              normals: [],\n              idx: [],\n              uv: []\n            });\n            var n = e[t[0]].normals.indexOf(t[1]);\n            return 1 != n && t[2] == e[t[0]].uv[n] ? e[t[0]].idx[n] : -1;\n          }(y, [e, n, t]) : function (e, t) {\n            e[t[0]] || (e[t[0]] = {\n              normals: [],\n              idx: []\n            });\n            var n = e[t[0]].normals.indexOf(t[1]);\n            return -1 === n ? -1 : e[t[0]].idx[n];\n          }(y, [e, n])) ? (f.push(h.length), h.push(r), p.push(o), m.push(a), y[e].normals.push(n), y[e].idx.push(_++), Z.OPTIMIZE_WITH_UV && y[e].uv.push(t)) : f.push(i);\n        }, M = function () {\n          for (var e = 0; e < h.length; e++) i.push(h[e].x, h[e].y, h[e].z), A.push(m[e].x, m[e].y, m[e].z), g.push(p[e].x, p[e].y);\n\n          h = [], m = [], p = [], y = [], _ = 0;\n        }, w = function (e, t) {\n          t + 1 < e.length && (v.push(e[0], e[t], e[t + 1]), w(e, t += 1));\n        }, S = function (e, t) {\n          w(e, t);\n\n          for (var n = 0; n < v.length; n++) {\n            var r = parseInt(v[n]) - 1;\n            O(r, 0, 0, s[r], Q.Vector2.Zero(), Q.Vector3.Up());\n          }\n\n          v = [];\n        }, N = function (e, t) {\n          w(e, t);\n\n          for (var n = 0; n < v.length; n++) {\n            var r = v[n].split(\"/\"),\n                o = parseInt(r[0]) - 1,\n                a = parseInt(r[1]) - 1;\n            O(o, a, 0, s[o], d[a], Q.Vector3.Up());\n          }\n\n          v = [];\n        }, F = function (e, t) {\n          w(e, t);\n\n          for (var n = 0; n < v.length; n++) {\n            var r = v[n].split(\"/\"),\n                o = parseInt(r[0]) - 1,\n                a = parseInt(r[1]) - 1,\n                i = parseInt(r[2]) - 1;\n            O(o, a, i, s[o], d[a], c[i]);\n          }\n\n          v = [];\n        }, P = function (e, t) {\n          w(e, t);\n\n          for (var n = 0; n < v.length; n++) {\n            var r = v[n].split(\"//\"),\n                o = parseInt(r[0]) - 1,\n                a = parseInt(r[1]) - 1;\n            O(o, 1, a, s[o], Q.Vector2.Zero(), c[a]);\n          }\n\n          v = [];\n        }, C = function (e, t) {\n          w(e, t);\n\n          for (var n = 0; n < v.length; n++) {\n            var r = v[n].split(\"/\"),\n                o = s.length + parseInt(r[0]),\n                a = d.length + parseInt(r[1]),\n                i = c.length + parseInt(r[2]);\n            O(o, a, i, s[o], d[a], c[i]);\n          }\n\n          v = [];\n        }, I = function () {\n          0 < o.length && (n = o[o.length - 1], M(), f.reverse(), n.indices = f.slice(), n.positions = i.slice(), n.normals = A.slice(), n.uvs = g.slice(), f = [], i = [], A = [], g = []);\n        }, R = t.split(\"\\n\"), D = 0; D < R.length; D++) {\n          var B,\n              G = R[D].trim();\n          if (0 !== G.length && \"#\" !== G.charAt(0)) if (null !== (B = this.vertexPattern.exec(G))) s.push(new Q.Vector3(parseFloat(B[1]), parseFloat(B[2]), parseFloat(B[3])));else if (null !== (B = this.normalPattern.exec(G))) c.push(new Q.Vector3(parseFloat(B[1]), parseFloat(B[2]), parseFloat(B[3])));else if (null !== (B = this.uvPattern.exec(G))) d.push(new Q.Vector2(parseFloat(B[1]), parseFloat(B[2])));else if (null !== (B = this.facePattern3.exec(G))) F(B[1].trim().split(\" \"), 1);else if (null !== (B = this.facePattern4.exec(G))) P(B[1].trim().split(\" \"), 1);else if (null !== (B = this.facePattern5.exec(G))) C(B[1].trim().split(\" \"), 1);else if (null !== (B = this.facePattern2.exec(G))) N(B[1].trim().split(\" \"), 1);else if (null !== (B = this.facePattern1.exec(G))) S(B[1].trim().split(\" \"), 1);else if (this.group.test(G) || this.obj.test(G)) {\n            var V = {\n              name: G.substring(2).trim(),\n              indices: void 0,\n              positions: void 0,\n              normals: void 0,\n              uvs: void 0,\n              materialName: \"\"\n            };\n            I(), o.push(V), x = a = !0, L = 1;\n          } else if (this.usemtl.test(G)) {\n            if (b = G.substring(7).trim(), !x) {\n              I();\n              V = {\n                name: \"_mm\" + L.toString(),\n                indices: void 0,\n                positions: void 0,\n                normals: void 0,\n                uvs: void 0,\n                materialName: b\n              };\n              L++, o.push(V);\n            }\n\n            a && x && (o[o.length - 1].materialName = b, x = !1);\n          } else this.mtllib.test(G) ? T = G.substring(7).trim() : this.smooth.test(G) || console.log(\"Unhandled expression at line : \" + G);\n        }\n\n        a && (n = o[o.length - 1], f.reverse(), M(), n.indices = f, n.positions = i, n.normals = A, n.uvs = g), a || (f.reverse(), M(), o.push({\n          name: Q.Geometry.RandomId(),\n          indices: f,\n          positions: i,\n          normals: A,\n          uvs: g,\n          materialName: b\n        }));\n\n        for (var U = [], k = new Array(), j = 0; j < o.length; j++) {\n          if (e && o[j].name) if (e instanceof Array) {\n            if (-1 == e.indexOf(o[j].name)) continue;\n          } else if (o[j].name !== e) continue;\n          n = o[j];\n          var H = new Q.Mesh(o[j].name, l);\n          k.push(o[j].materialName);\n          var W = new Q.VertexData();\n          W.positions = n.positions, W.normals = n.normals, W.uvs = n.uvs, W.indices = n.indices, W.applyToMesh(H), Z.INVERT_Y && (H.scaling.y *= -1), U.push(H);\n        }\n\n        var K = [];\n        return \"\" !== T && K.push(new Promise(function (i, s) {\n          r._loadMTL(T, u, function (e) {\n            try {\n              E.parseMTL(l, e, u);\n\n              for (var t = 0; t < E.materials.length; t++) {\n                for (var n, r = 0, o = []; -1 < (n = k.indexOf(E.materials[t].name, r));) o.push(n), r = n + 1;\n\n                if (-1 == n && 0 == o.length) E.materials[t].dispose();else for (var a = 0; a < o.length; a++) U[o[a]].material = E.materials[t];\n              }\n\n              i();\n            } catch (e) {\n              s(e);\n            }\n          });\n        })), Promise.all(K).then(function () {\n          return U;\n        });\n      }, Z.OPTIMIZE_WITH_UV = !1, Z.INVERT_Y = !1, Z;\n    }();\n\n    Q.OBJFileLoader = e, Q.SceneLoader && Q.SceneLoader.RegisterPlugin(new e());\n  }(e || (e = {})), function (i) {\n    var e, t, n, r, o;\n    (t = e = i.GLTFLoaderCoordinateSystemMode || (i.GLTFLoaderCoordinateSystemMode = {}))[t.AUTO = 0] = \"AUTO\", t[t.FORCE_RIGHT_HANDED = 1] = \"FORCE_RIGHT_HANDED\", (r = n = i.GLTFLoaderAnimationStartMode || (i.GLTFLoaderAnimationStartMode = {}))[r.NONE = 0] = \"NONE\", r[r.FIRST = 1] = \"FIRST\", r[r.ALL = 2] = \"ALL\", (o = i.GLTFLoaderState || (i.GLTFLoaderState = {}))[o.LOADING = 0] = \"LOADING\", o[o.READY = 1] = \"READY\", o[o.COMPLETE = 2] = \"COMPLETE\";\n\n    var a = function () {\n      function l() {\n        this.onParsedObservable = new i.Observable(), this.coordinateSystemMode = e.AUTO, this.animationStartMode = n.FIRST, this.compileMaterials = !1, this.useClipPlane = !1, this.compileShadowGenerators = !1, this.transparencyAsCoverage = !1, this.preprocessUrlAsync = function (e) {\n          return Promise.resolve(e);\n        }, this.onMeshLoadedObservable = new i.Observable(), this.onTextureLoadedObservable = new i.Observable(), this.onMaterialLoadedObservable = new i.Observable(), this.onCameraLoadedObservable = new i.Observable(), this.onCompleteObservable = new i.Observable(), this.onErrorObservable = new i.Observable(), this.onDisposeObservable = new i.Observable(), this.onExtensionLoadedObservable = new i.Observable(), this.validate = !1, this.onValidatedObservable = new i.Observable(), this._loader = null, this.name = \"gltf\", this.extensions = {\n          \".gltf\": {\n            isBinary: !1\n          },\n          \".glb\": {\n            isBinary: !0\n          }\n        }, this._logIndentLevel = 0, this._loggingEnabled = !1, this._log = this._logDisabled, this._capturePerformanceCounters = !1, this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled;\n      }\n\n      return Object.defineProperty(l.prototype, \"onParsed\", {\n        set: function (e) {\n          this._onParsedObserver && this.onParsedObservable.remove(this._onParsedObserver), this._onParsedObserver = this.onParsedObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onMeshLoaded\", {\n        set: function (e) {\n          this._onMeshLoadedObserver && this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver), this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onTextureLoaded\", {\n        set: function (e) {\n          this._onTextureLoadedObserver && this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver), this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onMaterialLoaded\", {\n        set: function (e) {\n          this._onMaterialLoadedObserver && this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver), this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onCameraLoaded\", {\n        set: function (e) {\n          this._onCameraLoadedObserver && this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver), this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onComplete\", {\n        set: function (e) {\n          this._onCompleteObserver && this.onCompleteObservable.remove(this._onCompleteObserver), this._onCompleteObserver = this.onCompleteObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onError\", {\n        set: function (e) {\n          this._onErrorObserver && this.onErrorObservable.remove(this._onErrorObserver), this._onErrorObserver = this.onErrorObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onDispose\", {\n        set: function (e) {\n          this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onExtensionLoaded\", {\n        set: function (e) {\n          this._onExtensionLoadedObserver && this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver), this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"loggingEnabled\", {\n        get: function () {\n          return this._loggingEnabled;\n        },\n        set: function (e) {\n          this._loggingEnabled !== e && (this._loggingEnabled = e, this._loggingEnabled ? this._log = this._logEnabled : this._log = this._logDisabled);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"capturePerformanceCounters\", {\n        get: function () {\n          return this._capturePerformanceCounters;\n        },\n        set: function (e) {\n          this._capturePerformanceCounters !== e && (this._capturePerformanceCounters = e, this._capturePerformanceCounters ? (this._startPerformanceCounter = this._startPerformanceCounterEnabled, this._endPerformanceCounter = this._endPerformanceCounterEnabled) : (this._startPerformanceCounter = this._startPerformanceCounterDisabled, this._endPerformanceCounter = this._endPerformanceCounterDisabled));\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(l.prototype, \"onValidated\", {\n        set: function (e) {\n          this._onValidatedObserver && this.onValidatedObservable.remove(this._onValidatedObserver), this._onValidatedObserver = this.onValidatedObservable.add(e);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), l.prototype.dispose = function () {\n        this._loader && (this._loader.dispose(), this._loader = null), this._clear(), this.onDisposeObservable.notifyObservers(void 0), this.onDisposeObservable.clear();\n      }, l.prototype._clear = function () {\n        this.preprocessUrlAsync = function (e) {\n          return Promise.resolve(e);\n        }, this.onMeshLoadedObservable.clear(), this.onTextureLoadedObservable.clear(), this.onMaterialLoadedObservable.clear(), this.onCameraLoadedObservable.clear(), this.onCompleteObservable.clear(), this.onExtensionLoadedObservable.clear();\n      }, l.prototype.importMeshAsync = function (t, n, e, r, o, a) {\n        var i = this;\n        return this._parseAsync(n, e, r, a).then(function (e) {\n          return i._log(\"Loading \" + (a || \"\")), i._loader = i._getLoader(e), i._loader.importMeshAsync(t, n, e, r, o, a);\n        });\n      }, l.prototype.loadAsync = function (t, e, n, r, o) {\n        var a = this;\n        return this._parseAsync(t, e, n, o).then(function (e) {\n          return a._log(\"Loading \" + (o || \"\")), a._loader = a._getLoader(e), a._loader.loadAsync(t, e, n, r, o);\n        });\n      }, l.prototype.loadAssetContainerAsync = function (n, e, t, r, o) {\n        var a = this;\n        return this._parseAsync(n, e, t, o).then(function (e) {\n          return a._log(\"Loading \" + (o || \"\")), a._loader = a._getLoader(e), a._loader.importMeshAsync(null, n, e, t, r, o).then(function (e) {\n            var t = new i.AssetContainer(n);\n            return Array.prototype.push.apply(t.meshes, e.meshes), Array.prototype.push.apply(t.particleSystems, e.particleSystems), Array.prototype.push.apply(t.skeletons, e.skeletons), Array.prototype.push.apply(t.animationGroups, e.animationGroups), t.removeAllFromScene(), t;\n          });\n        });\n      }, l.prototype.canDirectLoad = function (e) {\n        return -1 !== e.indexOf(\"scene\") && -1 !== e.indexOf(\"node\");\n      }, l.prototype.createPlugin = function () {\n        return new l();\n      }, Object.defineProperty(l.prototype, \"loaderState\", {\n        get: function () {\n          return this._loader ? this._loader.state : null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), l.prototype.whenCompleteAsync = function () {\n        var n = this;\n        return new Promise(function (e, t) {\n          n.onCompleteObservable.addOnce(function () {\n            e();\n          }), n.onErrorObservable.addOnce(function (e) {\n            t(e);\n          });\n        });\n      }, l.prototype._parseAsync = function (e, n, r, o) {\n        var a = this;\n        return Promise.resolve().then(function () {\n          var t = n instanceof ArrayBuffer ? a._unpackBinary(n) : {\n            json: n,\n            bin: null\n          };\n          return a._validateAsync(e, t.json, r, o).then(function () {\n            a._startPerformanceCounter(\"Parse JSON\"), a._log(\"JSON length: \" + t.json.length);\n            var e = {\n              json: JSON.parse(t.json),\n              bin: t.bin\n            };\n            return a._endPerformanceCounter(\"Parse JSON\"), a.onParsedObservable.notifyObservers(e), a.onParsedObservable.clear(), e;\n          });\n        });\n      }, l.prototype._validateAsync = function (t, e, n, r) {\n        var o = this;\n        if (!this.validate || \"undefined\" == typeof GLTFValidator) return Promise.resolve();\n\n        this._startPerformanceCounter(\"Validate JSON\");\n\n        var a = {\n          externalResourceFunction: function (e) {\n            return o.preprocessUrlAsync(n + e).then(function (e) {\n              return t._loadFileAsync(e, !0, !0);\n            }).then(function (e) {\n              return new Uint8Array(e);\n            });\n          }\n        };\n        return r && \"data:\" !== r.substr(0, 5) && (a.uri = \"file:\" === n ? r : \"\" + n + r), GLTFValidator.validateString(e, a).then(function (e) {\n          o._endPerformanceCounter(\"Validate JSON\"), o.onValidatedObservable.notifyObservers(e), o.onValidatedObservable.clear();\n        });\n      }, l.prototype._getLoader = function (e) {\n        var t = e.json.asset || {};\n        this._log(\"Asset version: \" + t.version), t.minVersion && this._log(\"Asset minimum version: \" + t.minVersion), t.generator && this._log(\"Asset generator: \" + t.generator);\n\n        var n = l._parseVersion(t.version);\n\n        if (!n) throw new Error(\"Invalid version: \" + t.version);\n\n        if (void 0 !== t.minVersion) {\n          var r = l._parseVersion(t.minVersion);\n\n          if (!r) throw new Error(\"Invalid minimum version: \" + t.minVersion);\n          if (0 < l._compareVersion(r, {\n            major: 2,\n            minor: 0\n          })) throw new Error(\"Incompatible minimum version: \" + t.minVersion);\n        }\n\n        var o = {\n          1: l._CreateGLTFLoaderV1,\n          2: l._CreateGLTFLoaderV2\n        }[n.major];\n        if (!o) throw new Error(\"Unsupported version: \" + t.version);\n        return o(this);\n      }, l.prototype._unpackBinary = function (e) {\n        this._startPerformanceCounter(\"Unpack binary\"), this._log(\"Binary length: \" + e.byteLength);\n        var t = new s(e),\n            n = t.readUint32();\n        if (1179937895 !== n) throw new Error(\"Unexpected magic: \" + n);\n        var r,\n            o = t.readUint32();\n\n        switch (this.loggingEnabled && this._log(\"Binary version: \" + o), o) {\n          case 1:\n            r = this._unpackBinaryV1(t);\n            break;\n\n          case 2:\n            r = this._unpackBinaryV2(t);\n            break;\n\n          default:\n            throw new Error(\"Unsupported version: \" + o);\n        }\n\n        return this._endPerformanceCounter(\"Unpack binary\"), r;\n      }, l.prototype._unpackBinaryV1 = function (e) {\n        var t = e.readUint32();\n        if (t != e.getLength()) throw new Error(\"Length in header does not match actual data length: \" + t + \" != \" + e.getLength());\n        var n,\n            r = e.readUint32(),\n            o = e.readUint32();\n\n        switch (o) {\n          case 0:\n            n = l._decodeBufferToText(e.readUint8Array(r));\n            break;\n\n          default:\n            throw new Error(\"Unexpected content format: \" + o);\n        }\n\n        var a = e.getLength() - e.getPosition();\n        return {\n          json: n,\n          bin: e.readUint8Array(a)\n        };\n      }, l.prototype._unpackBinaryV2 = function (e) {\n        var t = 1313821514,\n            n = 5130562,\n            r = e.readUint32();\n        if (r !== e.getLength()) throw new Error(\"Length in header does not match actual data length: \" + r + \" != \" + e.getLength());\n        var o = e.readUint32();\n        if (e.readUint32() !== t) throw new Error(\"First chunk format is not JSON\");\n\n        for (var a = l._decodeBufferToText(e.readUint8Array(o)), i = null; e.getPosition() < e.getLength();) {\n          var s = e.readUint32();\n\n          switch (e.readUint32()) {\n            case t:\n              throw new Error(\"Unexpected JSON chunk\");\n\n            case n:\n              i = e.readUint8Array(s);\n              break;\n\n            default:\n              e.skipBytes(s);\n          }\n        }\n\n        return {\n          json: a,\n          bin: i\n        };\n      }, l._parseVersion = function (e) {\n        if (\"1.0\" === e || \"1.0.1\" === e) return {\n          major: 1,\n          minor: 0\n        };\n        var t = (e + \"\").match(/^(\\d+)\\.(\\d+)/);\n        return t ? {\n          major: parseInt(t[1]),\n          minor: parseInt(t[2])\n        } : null;\n      }, l._compareVersion = function (e, t) {\n        return e.major > t.major ? 1 : e.major < t.major ? -1 : e.minor > t.minor ? 1 : e.minor < t.minor ? -1 : 0;\n      }, l._decodeBufferToText = function (e) {\n        for (var t = \"\", n = e.byteLength, r = 0; r < n; r++) t += String.fromCharCode(e[r]);\n\n        return t;\n      }, l.prototype._logOpen = function (e) {\n        this._log(e), this._logIndentLevel++;\n      }, l.prototype._logClose = function () {\n        --this._logIndentLevel;\n      }, l.prototype._logEnabled = function (e) {\n        var t = l._logSpaces.substr(0, 2 * this._logIndentLevel);\n\n        i.Tools.Log(\"\" + t + e);\n      }, l.prototype._logDisabled = function (e) {}, l.prototype._startPerformanceCounterEnabled = function (e) {\n        i.Tools.StartPerformanceCounter(e);\n      }, l.prototype._startPerformanceCounterDisabled = function (e) {}, l.prototype._endPerformanceCounterEnabled = function (e) {\n        i.Tools.EndPerformanceCounter(e);\n      }, l.prototype._endPerformanceCounterDisabled = function (e) {}, l.IncrementalLoading = !0, l.HomogeneousCoordinates = !1, l._logSpaces = \"                                \", l;\n    }();\n\n    i.GLTFFileLoader = a;\n\n    var s = function () {\n      function e(e) {\n        this._arrayBuffer = e, this._dataView = new DataView(e), this._byteOffset = 0;\n      }\n\n      return e.prototype.getPosition = function () {\n        return this._byteOffset;\n      }, e.prototype.getLength = function () {\n        return this._arrayBuffer.byteLength;\n      }, e.prototype.readUint32 = function () {\n        var e = this._dataView.getUint32(this._byteOffset, !0);\n\n        return this._byteOffset += 4, e;\n      }, e.prototype.readUint8Array = function (e) {\n        var t = new Uint8Array(this._arrayBuffer, this._byteOffset, e);\n        return this._byteOffset += e, t;\n      }, e.prototype.skipBytes = function (e) {\n        this._byteOffset += e;\n      }, e;\n    }();\n\n    i.SceneLoader && i.SceneLoader.RegisterPlugin(new a());\n  }(e || (e = {})), n = e || (e = {}), o = n.GLTF1 || (n.GLTF1 = {}), (a = o.EComponentType || (o.EComponentType = {}))[a.BYTE = 5120] = \"BYTE\", a[a.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", a[a.SHORT = 5122] = \"SHORT\", a[a.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", a[a.FLOAT = 5126] = \"FLOAT\", (i = o.EShaderType || (o.EShaderType = {}))[i.FRAGMENT = 35632] = \"FRAGMENT\", i[i.VERTEX = 35633] = \"VERTEX\", (s = o.EParameterType || (o.EParameterType = {}))[s.BYTE = 5120] = \"BYTE\", s[s.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", s[s.SHORT = 5122] = \"SHORT\", s[s.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", s[s.INT = 5124] = \"INT\", s[s.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", s[s.FLOAT = 5126] = \"FLOAT\", s[s.FLOAT_VEC2 = 35664] = \"FLOAT_VEC2\", s[s.FLOAT_VEC3 = 35665] = \"FLOAT_VEC3\", s[s.FLOAT_VEC4 = 35666] = \"FLOAT_VEC4\", s[s.INT_VEC2 = 35667] = \"INT_VEC2\", s[s.INT_VEC3 = 35668] = \"INT_VEC3\", s[s.INT_VEC4 = 35669] = \"INT_VEC4\", s[s.BOOL = 35670] = \"BOOL\", s[s.BOOL_VEC2 = 35671] = \"BOOL_VEC2\", s[s.BOOL_VEC3 = 35672] = \"BOOL_VEC3\", s[s.BOOL_VEC4 = 35673] = \"BOOL_VEC4\", s[s.FLOAT_MAT2 = 35674] = \"FLOAT_MAT2\", s[s.FLOAT_MAT3 = 35675] = \"FLOAT_MAT3\", s[s.FLOAT_MAT4 = 35676] = \"FLOAT_MAT4\", s[s.SAMPLER_2D = 35678] = \"SAMPLER_2D\", (l = o.ETextureWrapMode || (o.ETextureWrapMode = {}))[l.CLAMP_TO_EDGE = 33071] = \"CLAMP_TO_EDGE\", l[l.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\", l[l.REPEAT = 10497] = \"REPEAT\", (u = o.ETextureFilterType || (o.ETextureFilterType = {}))[u.NEAREST = 9728] = \"NEAREST\", u[u.LINEAR = 9728] = \"LINEAR\", u[u.NEAREST_MIPMAP_NEAREST = 9984] = \"NEAREST_MIPMAP_NEAREST\", u[u.LINEAR_MIPMAP_NEAREST = 9985] = \"LINEAR_MIPMAP_NEAREST\", u[u.NEAREST_MIPMAP_LINEAR = 9986] = \"NEAREST_MIPMAP_LINEAR\", u[u.LINEAR_MIPMAP_LINEAR = 9987] = \"LINEAR_MIPMAP_LINEAR\", (c = o.ETextureFormat || (o.ETextureFormat = {}))[c.ALPHA = 6406] = \"ALPHA\", c[c.RGB = 6407] = \"RGB\", c[c.RGBA = 6408] = \"RGBA\", c[c.LUMINANCE = 6409] = \"LUMINANCE\", c[c.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", (d = o.ECullingType || (o.ECullingType = {}))[d.FRONT = 1028] = \"FRONT\", d[d.BACK = 1029] = \"BACK\", d[d.FRONT_AND_BACK = 1032] = \"FRONT_AND_BACK\", (f = o.EBlendingFunction || (o.EBlendingFunction = {}))[f.ZERO = 0] = \"ZERO\", f[f.ONE = 1] = \"ONE\", f[f.SRC_COLOR = 768] = \"SRC_COLOR\", f[f.ONE_MINUS_SRC_COLOR = 769] = \"ONE_MINUS_SRC_COLOR\", f[f.DST_COLOR = 774] = \"DST_COLOR\", f[f.ONE_MINUS_DST_COLOR = 775] = \"ONE_MINUS_DST_COLOR\", f[f.SRC_ALPHA = 770] = \"SRC_ALPHA\", f[f.ONE_MINUS_SRC_ALPHA = 771] = \"ONE_MINUS_SRC_ALPHA\", f[f.DST_ALPHA = 772] = \"DST_ALPHA\", f[f.ONE_MINUS_DST_ALPHA = 773] = \"ONE_MINUS_DST_ALPHA\", f[f.CONSTANT_COLOR = 32769] = \"CONSTANT_COLOR\", f[f.ONE_MINUS_CONSTANT_COLOR = 32770] = \"ONE_MINUS_CONSTANT_COLOR\", f[f.CONSTANT_ALPHA = 32771] = \"CONSTANT_ALPHA\", f[f.ONE_MINUS_CONSTANT_ALPHA = 32772] = \"ONE_MINUS_CONSTANT_ALPHA\", f[f.SRC_ALPHA_SATURATE = 776] = \"SRC_ALPHA_SATURATE\", function (D) {\n    var B, e;\n    (e = B || (B = {}))[e.IDENTIFIER = 1] = \"IDENTIFIER\", e[e.UNKNOWN = 2] = \"UNKNOWN\", e[e.END_OF_INPUT = 3] = \"END_OF_INPUT\";\n\n    var G = function () {\n      function e(e) {\n        this._pos = 0, this.currentToken = B.UNKNOWN, this.currentIdentifier = \"\", this.currentString = \"\", this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/, this._toParse = e, this._maxPos = e.length;\n      }\n\n      return e.prototype.getNextToken = function () {\n        if (this.isEnd()) return B.END_OF_INPUT;\n        if (this.currentString = this.read(), this.currentToken = B.UNKNOWN, \"_\" === this.currentString || this.isLetterOrDigitPattern.test(this.currentString)) for (this.currentToken = B.IDENTIFIER, this.currentIdentifier = this.currentString; !this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || \"_\" === this.currentString);) this.currentIdentifier += this.currentString, this.forward();\n        return this.currentToken;\n      }, e.prototype.peek = function () {\n        return this._toParse[this._pos];\n      }, e.prototype.read = function () {\n        return this._toParse[this._pos++];\n      }, e.prototype.forward = function () {\n        this._pos++;\n      }, e.prototype.isEnd = function () {\n        return this._pos >= this._maxPos;\n      }, e;\n    }(),\n        V = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"],\n        U = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"],\n        w = [\"translation\", \"rotation\", \"scale\"],\n        S = [\"position\", \"rotationQuaternion\", \"scaling\"],\n        o = function (e, t, n) {\n      for (var r in e) {\n        var o = e[r];\n        n[t][r] = o;\n      }\n    },\n        N = function (e) {\n      if (e) for (var t = 0; t < e.length / 2; t++) e[2 * t + 1] = 1 - e[2 * t + 1];\n    },\n        k = function (e) {\n      if (\"NORMAL\" === e.semantic) return \"normal\";\n      if (\"POSITION\" === e.semantic) return \"position\";\n      if (\"JOINT\" === e.semantic) return \"matricesIndices\";\n      if (\"WEIGHT\" === e.semantic) return \"matricesWeights\";\n      if (\"COLOR\" === e.semantic) return \"color\";\n\n      if (e.semantic && -1 !== e.semantic.indexOf(\"TEXCOORD_\")) {\n        var t = Number(e.semantic.split(\"_\")[1]);\n        return \"uv\" + (0 === t ? \"\" : t + 1);\n      }\n\n      return null;\n    },\n        v = function (e) {\n      var t = null;\n\n      if (e.translation || e.rotation || e.scale) {\n        var n = W.Vector3.FromArray(e.scale || [1, 1, 1]),\n            r = W.Quaternion.FromArray(e.rotation || [0, 0, 0, 1]),\n            o = W.Vector3.FromArray(e.translation || [0, 0, 0]);\n        t = W.Matrix.Compose(n, r, o);\n      } else t = W.Matrix.FromArray(e.matrix);\n\n      return t;\n    },\n        b = function (e, t, n, r) {\n      for (var o = 0; o < r.bones.length; o++) if (r.bones[o].name === n) return r.bones[o];\n\n      var a = e.nodes;\n\n      for (var i in a) {\n        var s = a[i];\n\n        if (s.jointName) {\n          var l = s.children;\n\n          for (o = 0; o < l.length; o++) {\n            var u = e.nodes[l[o]];\n\n            if (u.jointName && u.jointName === n) {\n              var c = v(s),\n                  d = new W.Bone(s.name || \"\", r, b(e, t, s.jointName, r), c);\n              return d.id = i, d;\n            }\n          }\n        }\n      }\n\n      return null;\n    },\n        T = function (e, t) {\n      for (var n = 0; n < e.length; n++) for (var r = e[n], o = 0; o < r.node.children.length; o++) if (r.node.children[o] === t) return r.bone;\n\n      return null;\n    },\n        E = function (e, t) {\n      var n = e.nodes,\n          r = n[t];\n      if (r) return {\n        node: r,\n        id: t\n      };\n\n      for (var o in n) if ((r = n[o]).jointName === t) return {\n        node: r,\n        id: o\n      };\n\n      return null;\n    },\n        L = function (e, t) {\n      for (var n = 0; n < e.jointNames.length; n++) if (e.jointNames[n] === t) return !0;\n\n      return !1;\n    },\n        x = function (e, t, n, r, o) {\n      if (r || (r = new W.Skeleton(t.name || \"\", \"\", e.scene)), !t.babylonSkeleton) return r;\n      var a = [],\n          i = [];\n      !function (e, t, n, r) {\n        for (var o in e.nodes) {\n          var a = e.nodes[o],\n              i = o;\n\n          if (a.jointName && !L(n, a.jointName)) {\n            var s = v(a),\n                l = new W.Bone(a.name || \"\", t, null, s);\n            l.id = i, r.push({\n              bone: l,\n              node: a,\n              id: i\n            });\n          }\n        }\n\n        for (var u = 0; u < r.length; u++) for (var c = r[u], d = c.node.children, f = 0; f < d.length; f++) {\n          for (var h = null, p = 0; p < r.length; p++) if (r[p].id === d[f]) {\n            h = r[p];\n            break;\n          }\n\n          h && (h.bone._parent = c.bone, c.bone.children.push(h.bone));\n        }\n      }(e, r, t, a), r.bones = [];\n\n      for (var s = 0; s < t.jointNames.length; s++) if (g = E(e, t.jointNames[s])) {\n        var l = g.node;\n\n        if (l) {\n          o = g.id;\n          var u = e.scene.getBoneByID(o);\n          if (u) r.bones.push(u);else {\n            for (var c = !1, d = null, f = 0; f < s; f++) {\n              var h = E(e, t.jointNames[f]);\n\n              if (h) {\n                var p = h.node;\n\n                if (p) {\n                  var m = p.children;\n\n                  if (m) {\n                    c = !1;\n\n                    for (var y = 0; y < m.length; y++) if (m[y] === o) {\n                      d = b(e, t, t.jointNames[f], r), c = !0;\n                      break;\n                    }\n\n                    if (c) break;\n                  }\n                } else W.Tools.Warn(\"Joint named \" + t.jointNames[f] + \" does not exist when looking for parent\");\n              }\n            }\n\n            var _ = v(l);\n\n            !d && 0 < a.length && (d = T(a, o)) && -1 === i.indexOf(d) && i.push(d), new W.Bone(l.jointName || \"\", r, d, _).id = o;\n          }\n        } else W.Tools.Warn(\"Joint named \" + t.jointNames[s] + \" does not exist\");\n      }\n\n      var A = r.bones;\n\n      for (r.bones = [], s = 0; s < t.jointNames.length; s++) {\n        var g;\n        if (g = E(e, t.jointNames[s])) for (f = 0; f < A.length; f++) if (A[f].id === g.id) {\n          r.bones.push(A[f]);\n          break;\n        }\n      }\n\n      for (r.prepare(), s = 0; s < i.length; s++) r.bones.push(i[s]);\n\n      return r;\n    },\n        O = function (e, t, n, r, o) {\n      if (o || ((o = new W.Mesh(t.name || \"\", e.scene)).id = r), !t.babylonNode) return o;\n\n      for (var a, i = [], s = null, l = new Array(), u = new Array(), c = new Array(), d = new Array(), f = 0; f < n.length; f++) {\n        var h = n[f];\n        if (w = e.meshes[h]) for (var p = 0; p < w.primitives.length; p++) {\n          var m = new W.VertexData(),\n              y = w.primitives[p];\n          y.mode;\n          var _ = y.attributes,\n              A = null,\n              g = null;\n\n          for (var v in _) if (A = e.accessors[_[v]], g = D.GLTFUtils.GetBufferFromAccessor(e, A), \"NORMAL\" === v) m.normals = new Float32Array(g.length), m.normals.set(g);else if (\"POSITION\" === v) {\n            if (W.GLTFFileLoader.HomogeneousCoordinates) {\n              m.positions = new Float32Array(g.length - g.length / 4);\n\n              for (var b = 0; b < g.length; b += 4) m.positions[b] = g[b], m.positions[b + 1] = g[b + 1], m.positions[b + 2] = g[b + 2];\n            } else m.positions = new Float32Array(g.length), m.positions.set(g);\n\n            u.push(m.positions.length);\n          } else if (-1 !== v.indexOf(\"TEXCOORD_\")) {\n            var T = Number(v.split(\"_\")[1]),\n                E = W.VertexBuffer.UVKind + (0 === T ? \"\" : T + 1),\n                L = new Float32Array(g.length);\n            L.set(g), N(L), m.set(L, E);\n          } else \"JOINT\" === v ? (m.matricesIndices = new Float32Array(g.length), m.matricesIndices.set(g)) : \"WEIGHT\" === v ? (m.matricesWeights = new Float32Array(g.length), m.matricesWeights.set(g)) : \"COLOR\" === v && (m.colors = new Float32Array(g.length), m.colors.set(g));\n\n          if (A = e.accessors[y.indices]) g = D.GLTFUtils.GetBufferFromAccessor(e, A), m.indices = new Int32Array(g.length), m.indices.set(g), d.push(m.indices.length);else {\n            var x = [];\n\n            for (b = 0; b < m.positions.length / 3; b++) x.push(b);\n\n            m.indices = new Int32Array(x), d.push(m.indices.length);\n          }\n          s ? s.merge(m) : s = m;\n          var O = e.scene.getMaterialByID(y.material);\n          i.push(null === O ? D.GLTFUtils.GetDefaultMaterial(e.scene) : O), l.push(0 === l.length ? 0 : l[l.length - 1] + u[u.length - 2]), c.push(0 === c.length ? 0 : c[c.length - 1] + d[d.length - 2]);\n        }\n      }\n\n      1 < i.length ? (a = new W.MultiMaterial(\"multimat\" + r, e.scene)).subMaterials = i : a = new W.StandardMaterial(\"multimat\" + r, e.scene), 1 === i.length && (a = i[0]), o.material || (o.material = a), new W.Geometry(r, e.scene, s, !1, o), o.computeWorldMatrix(!0), o.subMeshes = [];\n      var M = 0;\n\n      for (f = 0; f < n.length; f++) {\n        var w;\n        if (h = n[f], w = e.meshes[h]) for (p = 0; p < w.primitives.length; p++) w.primitives[p].mode, W.SubMesh.AddToMesh(M, l[M], u[M], c[M], d[M], o, o, !0), M++;\n      }\n\n      return o;\n    },\n        M = function (e, t, n, r) {\n      e.position && (e.position = t), (e.rotationQuaternion || e.rotation) && (e.rotationQuaternion = n), e.scaling && (e.scaling = r);\n    },\n        s = function (e, t, n, r) {\n      var o = null;\n      if (e.importOnlyMeshes && (t.skin || t.meshes) && e.importMeshesNames && 0 < e.importMeshesNames.length && -1 === e.importMeshesNames.indexOf(t.name || \"\")) return null;\n\n      if (t.skin) {\n        if (t.meshes) {\n          var a = e.skins[t.skin];\n          (i = O(e, t, t.meshes, n, t.babylonNode)).skeleton = e.scene.getLastSkeletonByID(t.skin), null === i.skeleton && (i.skeleton = x(e, a, 0, a.babylonSkeleton, t.skin), a.babylonSkeleton || (a.babylonSkeleton = i.skeleton)), o = i;\n        }\n      } else if (t.meshes) {\n        var i;\n        o = i = O(e, t, t.mesh ? [t.mesh] : t.meshes, n, t.babylonNode);\n      } else if (!t.light || t.babylonNode || e.importOnlyMeshes) {\n        if (t.camera && !t.babylonNode && !e.importOnlyMeshes) {\n          var s = e.cameras[t.camera];\n          if (s) if (\"orthographic\" === s.type) {\n            var l = new W.FreeCamera(t.camera, W.Vector3.Zero(), e.scene, !1);\n            l.name = t.name || \"\", l.mode = W.Camera.ORTHOGRAPHIC_CAMERA, l.attachControl(e.scene.getEngine().getRenderingCanvas()), o = l;\n          } else if (\"perspective\" === s.type) {\n            var u = s[s.type],\n                c = new W.FreeCamera(t.camera, W.Vector3.Zero(), e.scene, !1);\n            c.name = t.name || \"\", c.attachControl(e.scene.getEngine().getRenderingCanvas()), u.aspectRatio || (u.aspectRatio = e.scene.getEngine().getRenderWidth() / e.scene.getEngine().getRenderHeight()), u.znear && u.zfar && (c.maxZ = u.zfar, c.minZ = u.znear), o = c;\n          }\n        }\n      } else {\n        var d = e.lights[t.light];\n        if (d) if (\"ambient\" === d.type) {\n          var f = d[d.type],\n              h = new W.HemisphericLight(t.light, W.Vector3.Zero(), e.scene);\n          h.name = t.name || \"\", f.color && (h.diffuse = W.Color3.FromArray(f.color)), o = h;\n        } else if (\"directional\" === d.type) {\n          var p = d[d.type],\n              m = new W.DirectionalLight(t.light, W.Vector3.Zero(), e.scene);\n          m.name = t.name || \"\", p.color && (m.diffuse = W.Color3.FromArray(p.color)), o = m;\n        } else if (\"point\" === d.type) {\n          var y = d[d.type],\n              _ = new W.PointLight(t.light, W.Vector3.Zero(), e.scene);\n\n          _.name = t.name || \"\", y.color && (_.diffuse = W.Color3.FromArray(y.color)), o = _;\n        } else if (\"spot\" === d.type) {\n          var A = d[d.type],\n              g = new W.SpotLight(t.light, W.Vector3.Zero(), W.Vector3.Zero(), 0, 0, e.scene);\n          g.name = t.name || \"\", A.color && (g.diffuse = W.Color3.FromArray(A.color)), A.fallOfAngle && (g.angle = A.fallOfAngle), A.fallOffExponent && (g.exponent = A.fallOffExponent), o = g;\n        }\n      }\n\n      if (!t.jointName) {\n        if (t.babylonNode) return t.babylonNode;\n\n        if (null === o) {\n          var v = new W.Mesh(t.name || \"\", e.scene);\n          o = t.babylonNode = v;\n        }\n      }\n\n      if (null !== o) {\n        if (t.matrix && o instanceof W.Mesh) !function (e, t, n) {\n          if (t.matrix) {\n            var r = new W.Vector3(0, 0, 0),\n                o = new W.Quaternion(),\n                a = new W.Vector3(0, 0, 0);\n            W.Matrix.FromArray(t.matrix).decompose(a, o, r), M(e, r, o, a);\n          } else t.translation && t.rotation && t.scale && M(e, W.Vector3.FromArray(t.translation), W.Quaternion.FromArray(t.rotation), W.Vector3.FromArray(t.scale));\n\n          e.computeWorldMatrix(!0);\n        }(o, t);else {\n          var b = t.translation || [0, 0, 0],\n              T = t.rotation || [0, 0, 0, 1],\n              E = t.scale || [1, 1, 1];\n          M(o, W.Vector3.FromArray(b), W.Quaternion.FromArray(T), W.Vector3.FromArray(E));\n        }\n        o.updateCache(!0), t.babylonNode = o;\n      }\n\n      return o;\n    },\n        l = function (e, t, n, r) {\n      void 0 === r && (r = !1);\n      var o = e.nodes[t],\n          a = null;\n      if (r = !(e.importOnlyMeshes && !r && e.importMeshesNames) || -1 !== e.importMeshesNames.indexOf(o.name || \"\") || 0 === e.importMeshesNames.length, !o.jointName && r && null !== (a = s(e, o, t)) && (a.id = t, a.parent = n), o.children) for (var i = 0; i < o.children.length; i++) l(e, o.children[i], a, r);\n    },\n        d = function (e) {\n      var t = e.currentScene;\n      if (t) for (var n = 0; n < t.nodes.length; n++) l(e, t.nodes[n], null);else for (var r in e.scenes) for (t = e.scenes[r], n = 0; n < t.nodes.length; n++) l(e, t.nodes[n], null);\n\n      for (function (e) {\n        for (var t in e.animations) {\n          var n = e.animations[t];\n          if (n.channels && n.samplers) for (var r = null, o = 0; o < n.channels.length; o++) {\n            var a = n.channels[o],\n                i = n.samplers[a.sampler];\n\n            if (i) {\n              var s = null,\n                  l = null;\n              n.parameters ? (s = n.parameters[i.input], l = n.parameters[i.output]) : (s = i.input, l = i.output);\n              var u = D.GLTFUtils.GetBufferFromAccessor(e, e.accessors[s]),\n                  c = D.GLTFUtils.GetBufferFromAccessor(e, e.accessors[l]),\n                  d = a.target.id,\n                  f = e.scene.getNodeByID(d);\n\n              if (null === f && (f = e.scene.getNodeByName(d)), null !== f) {\n                var h = f instanceof W.Bone,\n                    p = a.target.path,\n                    m = w.indexOf(p);\n                -1 !== m && (p = S[m]);\n                var y = W.Animation.ANIMATIONTYPE_MATRIX;\n                h || (\"rotationQuaternion\" === p ? (y = W.Animation.ANIMATIONTYPE_QUATERNION, f.rotationQuaternion = new W.Quaternion()) : y = W.Animation.ANIMATIONTYPE_VECTOR3);\n                var _ = null,\n                    A = [],\n                    g = 0,\n                    v = !1;\n                h && r && r.getKeys().length === u.length && (_ = r, v = !0), v || (_ = new W.Animation(t, h ? \"_matrix\" : p, 1, y, W.Animation.ANIMATIONLOOPMODE_CYCLE));\n\n                for (var b = 0; b < u.length; b++) {\n                  var T = null;\n\n                  if (\"rotationQuaternion\" === p ? (T = W.Quaternion.FromArray([c[g], c[g + 1], c[g + 2], c[g + 3]]), g += 4) : (T = W.Vector3.FromArray([c[g], c[g + 1], c[g + 2]]), g += 3), h) {\n                    var E = f,\n                        L = W.Vector3.Zero(),\n                        x = new W.Quaternion(),\n                        O = W.Vector3.Zero(),\n                        M = E.getBaseMatrix();\n                    v && r && (M = r.getKeys()[b].value), M.decompose(O, x, L), \"position\" === p ? L = T : \"rotationQuaternion\" === p ? x = T : O = T, T = W.Matrix.Compose(O, x, L);\n                  }\n\n                  v ? r && (r.getKeys()[b].value = T) : A.push({\n                    frame: u[b],\n                    value: T\n                  });\n                }\n\n                !v && _ && (_.setKeys(A), f.animations.push(_)), r = _, e.scene.stopAnimation(f), e.scene.beginAnimation(f, 0, u[u.length - 1], !0, 1);\n              } else W.Tools.Warn(\"Creating animation named \" + t + \". But cannot find node named \" + d + \" to attach to\");\n            }\n          }\n        }\n      }(e), n = 0; n < e.scene.skeletons.length; n++) {\n        var o = e.scene.skeletons[n];\n        e.scene.beginAnimation(o, 0, Number.MAX_VALUE, !0, 1);\n      }\n    },\n        j = function (t, n, r, o, a, i) {\n      return function (e) {\n        !function (e, n, t, r, o) {\n          var a = r.values || t.parameters,\n              i = t.uniforms;\n\n          for (var s in o) {\n            var l = o[s],\n                u = l.type,\n                c = a[i[s]];\n\n            if (void 0 === c && (c = l.value), c) {\n              var d = function (t) {\n                return function (e) {\n                  l.value && t && (n.setTexture(t, e), delete o[t]);\n                };\n              };\n\n              u === D.EParameterType.SAMPLER_2D ? D.GLTFLoaderExtension.LoadTextureAsync(e, r.values ? c : l.value, d(s), function () {\n                return d(null);\n              }) : l.value && D.GLTFUtils.SetUniform(n, s, r.values ? c : l.value, u) && delete o[s];\n            }\n          }\n        }(t, n, r, o, a), n.onBind = function (e) {\n          !function (e, t, n, r, o, a, i) {\n            var s = a.values || o.parameters;\n\n            for (var l in n) {\n              var u = n[l],\n                  c = u.type;\n              if (c === D.EParameterType.FLOAT_MAT2 || c === D.EParameterType.FLOAT_MAT3 || c === D.EParameterType.FLOAT_MAT4) {\n                if (!u.semantic || u.source || u.node) {\n                  if (u.semantic && (u.source || u.node)) {\n                    var d = t.scene.getNodeByName(u.source || u.node || \"\");\n                    if (null === d && (d = t.scene.getNodeByID(u.source || u.node || \"\")), null === d) continue;\n                    D.GLTFUtils.SetMatrix(t.scene, d, u, l, r.getEffect());\n                  }\n                } else D.GLTFUtils.SetMatrix(t.scene, e, u, l, r.getEffect());\n              } else {\n                var f = s[o.uniforms[l]];\n                if (!f) continue;\n\n                if (c === D.EParameterType.SAMPLER_2D) {\n                  var h = t.textures[a.values ? f : u.value].babylonTexture;\n                  if (null == h) continue;\n                  r.getEffect().setTexture(l, h);\n                } else D.GLTFUtils.SetUniform(r.getEffect(), l, f, c);\n              }\n            }\n\n            i(r);\n          }(e, t, a, n, r, o, i);\n        };\n      };\n    },\n        H = function (e, t, n) {\n      for (var r in t.uniforms) {\n        var o = t.uniforms[r],\n            a = t.parameters[o];\n\n        if (e.currentIdentifier === r && a.semantic && !a.source && !a.node) {\n          var i = V.indexOf(a.semantic);\n          if (-1 !== i) return delete n[r], U[i];\n        }\n      }\n\n      return e.currentIdentifier;\n    },\n        f = function (e) {\n      for (var t in e.materials) D.GLTFLoaderExtension.LoadMaterialAsync(e, t, function (e) {}, function () {});\n    },\n        t = function () {\n      function e() {}\n\n      return e.CreateRuntime = function (e, t, n) {\n        var r = {\n          extensions: {},\n          accessors: {},\n          buffers: {},\n          bufferViews: {},\n          meshes: {},\n          lights: {},\n          cameras: {},\n          nodes: {},\n          images: {},\n          textures: {},\n          shaders: {},\n          programs: {},\n          samplers: {},\n          techniques: {},\n          materials: {},\n          animations: {},\n          skins: {},\n          extensionsUsed: [],\n          scenes: {},\n          buffersCount: 0,\n          shaderscount: 0,\n          scene: t,\n          rootUrl: n,\n          loadedBufferCount: 0,\n          loadedBufferViews: {},\n          loadedShaderCount: 0,\n          importOnlyMeshes: !1,\n          dummyNodes: []\n        };\n        return e.extensions && o(e.extensions, \"extensions\", r), e.extensionsUsed && o(e.extensionsUsed, \"extensionsUsed\", r), e.buffers && function (e, t) {\n          for (var n in e) {\n            var r = e[n];\n            t.buffers[n] = r, t.buffersCount++;\n          }\n        }(e.buffers, r), e.bufferViews && o(e.bufferViews, \"bufferViews\", r), e.accessors && o(e.accessors, \"accessors\", r), e.meshes && o(e.meshes, \"meshes\", r), e.lights && o(e.lights, \"lights\", r), e.cameras && o(e.cameras, \"cameras\", r), e.nodes && o(e.nodes, \"nodes\", r), e.images && o(e.images, \"images\", r), e.textures && o(e.textures, \"textures\", r), e.shaders && function (e, t) {\n          for (var n in e) {\n            var r = e[n];\n            t.shaders[n] = r, t.shaderscount++;\n          }\n        }(e.shaders, r), e.programs && o(e.programs, \"programs\", r), e.samplers && o(e.samplers, \"samplers\", r), e.techniques && o(e.techniques, \"techniques\", r), e.materials && o(e.materials, \"materials\", r), e.animations && o(e.animations, \"animations\", r), e.skins && o(e.skins, \"skins\", r), e.scenes && (r.scenes = e.scenes), e.scene && e.scenes && (r.currentScene = e.scenes[e.scene]), r;\n      }, e.LoadBufferAsync = function (e, t, n, r, o) {\n        var a = e.buffers[t];\n        W.Tools.IsBase64(a.uri) ? setTimeout(function () {\n          return n(new Uint8Array(W.Tools.DecodeBase64(a.uri)));\n        }) : W.Tools.LoadFile(e.rootUrl + a.uri, function (e) {\n          return n(new Uint8Array(e));\n        }, o, void 0, !0, function (e) {\n          e && r(e.status + \" \" + e.statusText);\n        });\n      }, e.LoadTextureBufferAsync = function (e, t, n, r) {\n        var o = e.textures[t];\n        if (o && o.source) {\n          if (o.babylonTexture) n(null);else {\n            var a = e.images[o.source];\n            W.Tools.IsBase64(a.uri) ? setTimeout(function () {\n              return n(new Uint8Array(W.Tools.DecodeBase64(a.uri)));\n            }) : W.Tools.LoadFile(e.rootUrl + a.uri, function (e) {\n              return n(new Uint8Array(e));\n            }, void 0, void 0, !0, function (e) {\n              e && r(e.status + \" \" + e.statusText);\n            });\n          }\n        } else r(\"\");\n      }, e.CreateTextureAsync = function (e, t, n, r, o) {\n        var a = e.textures[t];\n        if (a.babylonTexture) r(a.babylonTexture);else {\n          var i = e.samplers[a.sampler],\n              s = i.minFilter === D.ETextureFilterType.NEAREST_MIPMAP_NEAREST || i.minFilter === D.ETextureFilterType.NEAREST_MIPMAP_LINEAR || i.minFilter === D.ETextureFilterType.LINEAR_MIPMAP_NEAREST || i.minFilter === D.ETextureFilterType.LINEAR_MIPMAP_LINEAR,\n              l = W.Texture.BILINEAR_SAMPLINGMODE,\n              u = null == n ? new Blob() : new Blob([n]),\n              c = URL.createObjectURL(u),\n              d = function () {\n            return URL.revokeObjectURL(c);\n          },\n              f = new W.Texture(c, e.scene, !s, !0, l, d, d);\n\n          void 0 !== i.wrapS && (f.wrapU = D.GLTFUtils.GetWrapMode(i.wrapS)), void 0 !== i.wrapT && (f.wrapV = D.GLTFUtils.GetWrapMode(i.wrapT)), f.name = t, r(a.babylonTexture = f);\n        }\n      }, e.LoadShaderStringAsync = function (e, t, n, r) {\n        var o = e.shaders[t];\n\n        if (W.Tools.IsBase64(o.uri)) {\n          var a = atob(o.uri.split(\",\")[1]);\n          n && n(a);\n        } else W.Tools.LoadFile(e.rootUrl + o.uri, n, void 0, void 0, !1, function (e) {\n          e && r && r(e.status + \" \" + e.statusText);\n        });\n      }, e.LoadMaterialAsync = function (e, t, n, r) {\n        var o = e.materials[t];\n\n        if (o.technique) {\n          var a = e.techniques[o.technique];\n\n          if (!a) {\n            var i = new W.StandardMaterial(t, e.scene);\n            return i.diffuseColor = new W.Color3(.5, .5, .5), i.sideOrientation = W.Material.CounterClockWiseSideOrientation, void n(i);\n          }\n\n          var s = e.programs[a.program],\n              l = a.states,\n              u = W.Effect.ShadersStore[s.vertexShader + \"VertexShader\"],\n              c = W.Effect.ShadersStore[s.fragmentShader + \"PixelShader\"],\n              d = \"\",\n              f = \"\",\n              h = new G(u),\n              p = new G(c),\n              m = {},\n              y = [],\n              _ = [],\n              A = [];\n\n          for (var g in a.uniforms) {\n            var v = a.uniforms[g],\n                b = a.parameters[v];\n            if (!(m[g] = b).semantic || b.node || b.source) b.type === D.EParameterType.SAMPLER_2D ? A.push(g) : y.push(g);else {\n              var T = V.indexOf(b.semantic);\n              -1 !== T ? (y.push(U[T]), delete m[g]) : y.push(g);\n            }\n          }\n\n          for (var E in a.attributes) {\n            var L = a.attributes[E];\n\n            if ((M = a.parameters[L]).semantic) {\n              var x = k(M);\n              x && _.push(x);\n            }\n          }\n\n          for (; !h.isEnd() && h.getNextToken();) if (h.currentToken === B.IDENTIFIER) {\n            var O = !1;\n\n            for (var E in a.attributes) {\n              L = a.attributes[E];\n              var M = a.parameters[L];\n\n              if (h.currentIdentifier === E && M.semantic) {\n                d += k(M), O = !0;\n                break;\n              }\n            }\n\n            O || (d += H(h, a, m));\n          } else d += h.currentString;\n\n          for (; !p.isEnd() && p.getNextToken();) p.currentToken === B.IDENTIFIER ? f += H(p, a, m) : f += p.currentString;\n\n          var w = {\n            vertex: s.vertexShader + t,\n            fragment: s.fragmentShader + t\n          },\n              S = {\n            attributes: _,\n            uniforms: y,\n            samplers: A,\n            needAlphaBlending: l && l.enable && -1 !== l.enable.indexOf(3042)\n          };\n          W.Effect.ShadersStore[s.vertexShader + t + \"VertexShader\"] = d, W.Effect.ShadersStore[s.fragmentShader + t + \"PixelShader\"] = f;\n          var N,\n              F,\n              P,\n              C = new W.ShaderMaterial(t, e.scene, w, S);\n\n          if (C.onError = (N = s, F = C, P = r, function (e, t) {\n            F.dispose(!0), P(\"Cannot compile program named \" + N.name + \". Error: \" + t + \". Default material will be applied\");\n          }), C.onCompiled = j(e, C, a, o, m, n), C.sideOrientation = W.Material.CounterClockWiseSideOrientation, l && l.functions) {\n            var I = l.functions;\n            I.cullFace && I.cullFace[0] !== D.ECullingType.BACK && (C.backFaceCulling = !1);\n            var R = I.blendFuncSeparate;\n            R && (R[0] === D.EBlendingFunction.SRC_ALPHA && R[1] === D.EBlendingFunction.ONE_MINUS_SRC_ALPHA && R[2] === D.EBlendingFunction.ONE && R[3] === D.EBlendingFunction.ONE ? C.alphaMode = W.Engine.ALPHA_COMBINE : R[0] === D.EBlendingFunction.ONE && R[1] === D.EBlendingFunction.ONE && R[2] === D.EBlendingFunction.ZERO && R[3] === D.EBlendingFunction.ONE ? C.alphaMode = W.Engine.ALPHA_ONEONE : R[0] === D.EBlendingFunction.SRC_ALPHA && R[1] === D.EBlendingFunction.ONE && R[2] === D.EBlendingFunction.ZERO && R[3] === D.EBlendingFunction.ONE ? C.alphaMode = W.Engine.ALPHA_ADD : R[0] === D.EBlendingFunction.ZERO && R[1] === D.EBlendingFunction.ONE_MINUS_SRC_COLOR && R[2] === D.EBlendingFunction.ONE && R[3] === D.EBlendingFunction.ONE ? C.alphaMode = W.Engine.ALPHA_SUBTRACT : R[0] === D.EBlendingFunction.DST_COLOR && R[1] === D.EBlendingFunction.ZERO && R[2] === D.EBlendingFunction.ONE && R[3] === D.EBlendingFunction.ONE ? C.alphaMode = W.Engine.ALPHA_MULTIPLY : R[0] === D.EBlendingFunction.SRC_ALPHA && R[1] === D.EBlendingFunction.ONE_MINUS_SRC_COLOR && R[2] === D.EBlendingFunction.ONE && R[3] === D.EBlendingFunction.ONE && (C.alphaMode = W.Engine.ALPHA_MAXIMIZED));\n          }\n        } else r && r(\"No technique found.\");\n      }, e;\n    }();\n\n    D.GLTFLoaderBase = t;\n\n    var n = function () {\n      function t() {\n        this.state = null;\n      }\n\n      return t.RegisterExtension = function (e) {\n        t.Extensions[e.name] ? W.Tools.Error('Tool with the same name \"' + e.name + '\" already exists') : t.Extensions[e.name] = e;\n      }, t.prototype.dispose = function () {}, t.prototype._importMeshAsync = function (s, e, t, n, l, u, r) {\n        var c = this;\n        return e.useRightHandedSystem = !0, D.GLTFLoaderExtension.LoadRuntimeAsync(e, t, n, function (e) {\n          e.importOnlyMeshes = !0, \"\" === s ? e.importMeshesNames = [] : \"string\" == typeof s ? e.importMeshesNames = [s] : !s || s instanceof Array ? (e.importMeshesNames = [], W.Tools.Warn(\"Argument meshesNames must be of type string or string[]\")) : e.importMeshesNames = [s], c._createNodes(e);\n          var t = new Array(),\n              n = new Array();\n\n          for (var r in e.nodes) {\n            var o = e.nodes[r];\n            o.babylonNode instanceof W.AbstractMesh && t.push(o.babylonNode);\n          }\n\n          for (var a in e.skins) {\n            var i = e.skins[a];\n            i.babylonSkeleton instanceof W.Skeleton && n.push(i.babylonSkeleton);\n          }\n\n          c._loadBuffersAsync(e, function () {\n            c._loadShadersAsync(e, function () {\n              f(e), d(e), !W.GLTFFileLoader.IncrementalLoading && l && l(t, n);\n            });\n          }, u), W.GLTFFileLoader.IncrementalLoading && l && l(t, n);\n        }, r), !0;\n      }, t.prototype.importMeshAsync = function (e, r, o, a, i) {\n        var s = this;\n        return new Promise(function (n, t) {\n          s._importMeshAsync(e, r, o, a, function (e, t) {\n            n({\n              meshes: e,\n              particleSystems: [],\n              skeletons: t,\n              animationGroups: []\n            });\n          }, i, function (e) {\n            t(new Error(e));\n          });\n        });\n      }, t.prototype._loadAsync = function (e, t, n, r, o, a) {\n        var i = this;\n        e.useRightHandedSystem = !0, D.GLTFLoaderExtension.LoadRuntimeAsync(e, t, n, function (e) {\n          D.GLTFLoaderExtension.LoadRuntimeExtensionsAsync(e, function () {\n            i._createNodes(e), i._loadBuffersAsync(e, function () {\n              i._loadShadersAsync(e, function () {\n                f(e), d(e), W.GLTFFileLoader.IncrementalLoading || r();\n              });\n            }), W.GLTFFileLoader.IncrementalLoading && r();\n          }, a);\n        }, a);\n      }, t.prototype.loadAsync = function (n, r, o, a) {\n        var i = this;\n        return new Promise(function (e, t) {\n          i._loadAsync(n, r, o, function () {\n            e();\n          }, a, function (e) {\n            t(new Error(e));\n          });\n        });\n      }, t.prototype._loadShadersAsync = function (r, o) {\n        var e = !1,\n            t = function (t, n) {\n          D.GLTFLoaderExtension.LoadShaderStringAsync(r, t, function (e) {\n            e instanceof ArrayBuffer || (r.loadedShaderCount++, e && (W.Effect.ShadersStore[t + (n.type === D.EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = e), r.loadedShaderCount === r.shaderscount && o());\n          }, function () {\n            W.Tools.Error(\"Error when loading shader program named \" + t + \" located at \" + n.uri);\n          });\n        };\n\n        for (var n in r.shaders) {\n          e = !0;\n          var a = r.shaders[n];\n          a ? t.bind(this, n, a)() : W.Tools.Error(\"No shader named: \" + n);\n        }\n\n        e || o();\n      }, t.prototype._loadBuffersAsync = function (r, o, e) {\n        var t = !1,\n            n = function (t, n) {\n          D.GLTFLoaderExtension.LoadBufferAsync(r, t, function (e) {\n            r.loadedBufferCount++, e && (e.byteLength != r.buffers[t].byteLength && W.Tools.Error(\"Buffer named \" + t + \" is length \" + e.byteLength + \". Expected: \" + n.byteLength), r.loadedBufferViews[t] = e), r.loadedBufferCount === r.buffersCount && o();\n          }, function () {\n            W.Tools.Error(\"Error when loading buffer named \" + t + \" located at \" + n.uri);\n          });\n        };\n\n        for (var a in r.buffers) {\n          t = !0;\n          var i = r.buffers[a];\n          i ? n.bind(this, a, i)() : W.Tools.Error(\"No buffer named: \" + a);\n        }\n\n        t || o();\n      }, t.prototype._createNodes = function (e) {\n        var t = e.currentScene;\n        if (t) for (var n = 0; n < t.nodes.length; n++) l(e, t.nodes[n], null);else for (var r in e.scenes) for (t = e.scenes[r], n = 0; n < t.nodes.length; n++) l(e, t.nodes[n], null);\n      }, t.Extensions = {}, t;\n    }();\n\n    D.GLTFLoader = n, W.GLTFFileLoader._CreateGLTFLoaderV1 = function () {\n      return new n();\n    };\n  }((W = e || (e = {})).GLTF1 || (W.GLTF1 = {})), h = e || (e = {}), p = h.GLTF1 || (h.GLTF1 = {}), m = function () {\n    function o() {}\n\n    return o.SetMatrix = function (e, t, n, r, o) {\n      var a = null;\n      if (\"MODEL\" === n.semantic ? a = t.getWorldMatrix() : \"PROJECTION\" === n.semantic ? a = e.getProjectionMatrix() : \"VIEW\" === n.semantic ? a = e.getViewMatrix() : \"MODELVIEWINVERSETRANSPOSE\" === n.semantic ? a = h.Matrix.Transpose(t.getWorldMatrix().multiply(e.getViewMatrix()).invert()) : \"MODELVIEW\" === n.semantic ? a = t.getWorldMatrix().multiply(e.getViewMatrix()) : \"MODELVIEWPROJECTION\" === n.semantic ? a = t.getWorldMatrix().multiply(e.getTransformMatrix()) : \"MODELINVERSE\" === n.semantic ? a = t.getWorldMatrix().invert() : \"VIEWINVERSE\" === n.semantic ? a = e.getViewMatrix().invert() : \"PROJECTIONINVERSE\" === n.semantic ? a = e.getProjectionMatrix().invert() : \"MODELVIEWINVERSE\" === n.semantic ? a = t.getWorldMatrix().multiply(e.getViewMatrix()).invert() : \"MODELVIEWPROJECTIONINVERSE\" === n.semantic ? a = t.getWorldMatrix().multiply(e.getTransformMatrix()).invert() : \"MODELINVERSETRANSPOSE\" === n.semantic && (a = h.Matrix.Transpose(t.getWorldMatrix().invert())), a) switch (n.type) {\n        case p.EParameterType.FLOAT_MAT2:\n          o.setMatrix2x2(r, h.Matrix.GetAsMatrix2x2(a));\n          break;\n\n        case p.EParameterType.FLOAT_MAT3:\n          o.setMatrix3x3(r, h.Matrix.GetAsMatrix3x3(a));\n          break;\n\n        case p.EParameterType.FLOAT_MAT4:\n          o.setMatrix(r, a);\n      }\n    }, o.SetUniform = function (e, t, n, r) {\n      switch (r) {\n        case p.EParameterType.FLOAT:\n          return e.setFloat(t, n), !0;\n\n        case p.EParameterType.FLOAT_VEC2:\n          return e.setVector2(t, h.Vector2.FromArray(n)), !0;\n\n        case p.EParameterType.FLOAT_VEC3:\n          return e.setVector3(t, h.Vector3.FromArray(n)), !0;\n\n        case p.EParameterType.FLOAT_VEC4:\n          return e.setVector4(t, h.Vector4.FromArray(n)), !0;\n\n        default:\n          return !1;\n      }\n    }, o.GetWrapMode = function (e) {\n      switch (e) {\n        case p.ETextureWrapMode.CLAMP_TO_EDGE:\n          return h.Texture.CLAMP_ADDRESSMODE;\n\n        case p.ETextureWrapMode.MIRRORED_REPEAT:\n          return h.Texture.MIRROR_ADDRESSMODE;\n\n        case p.ETextureWrapMode.REPEAT:\n        default:\n          return h.Texture.WRAP_ADDRESSMODE;\n      }\n    }, o.GetByteStrideFromType = function (e) {\n      switch (e.type) {\n        case \"VEC2\":\n          return 2;\n\n        case \"VEC3\":\n          return 3;\n\n        case \"VEC4\":\n        case \"MAT2\":\n          return 4;\n\n        case \"MAT3\":\n          return 9;\n\n        case \"MAT4\":\n          return 16;\n\n        default:\n          return 1;\n      }\n    }, o.GetTextureFilterMode = function (e) {\n      switch (e) {\n        case p.ETextureFilterType.LINEAR:\n        case p.ETextureFilterType.LINEAR_MIPMAP_NEAREST:\n        case p.ETextureFilterType.LINEAR_MIPMAP_LINEAR:\n          return h.Texture.TRILINEAR_SAMPLINGMODE;\n\n        case p.ETextureFilterType.NEAREST:\n        case p.ETextureFilterType.NEAREST_MIPMAP_NEAREST:\n          return h.Texture.NEAREST_SAMPLINGMODE;\n\n        default:\n          return h.Texture.BILINEAR_SAMPLINGMODE;\n      }\n    }, o.GetBufferFromBufferView = function (e, t, n, r, o) {\n      n = t.byteOffset + n;\n      var a = e.loadedBufferViews[t.buffer];\n      if (n + r > a.byteLength) throw new Error(\"Buffer access is out of range\");\n      var i = a.buffer;\n\n      switch (n += a.byteOffset, o) {\n        case p.EComponentType.BYTE:\n          return new Int8Array(i, n, r);\n\n        case p.EComponentType.UNSIGNED_BYTE:\n          return new Uint8Array(i, n, r);\n\n        case p.EComponentType.SHORT:\n          return new Int16Array(i, n, r);\n\n        case p.EComponentType.UNSIGNED_SHORT:\n          return new Uint16Array(i, n, r);\n\n        default:\n          return new Float32Array(i, n, r);\n      }\n    }, o.GetBufferFromAccessor = function (e, t) {\n      var n = e.bufferViews[t.bufferView],\n          r = t.count * o.GetByteStrideFromType(t);\n      return o.GetBufferFromBufferView(e, n, t.byteOffset, r, t.componentType);\n    }, o.DecodeBufferToText = function (e) {\n      for (var t = \"\", n = e.byteLength, r = 0; r < n; ++r) t += String.fromCharCode(e[r]);\n\n      return t;\n    }, o.GetDefaultMaterial = function (e) {\n      if (!o._DefaultMaterial) {\n        h.Effect.ShadersStore.GLTFDefaultMaterialVertexShader = [\"precision highp float;\", \"\", \"uniform mat4 worldView;\", \"uniform mat4 projection;\", \"\", \"attribute vec3 position;\", \"\", \"void main(void)\", \"{\", \"    gl_Position = projection * worldView * vec4(position, 1.0);\", \"}\"].join(\"\\n\"), h.Effect.ShadersStore.GLTFDefaultMaterialPixelShader = [\"precision highp float;\", \"\", \"uniform vec4 u_emission;\", \"\", \"void main(void)\", \"{\", \"    gl_FragColor = u_emission;\", \"}\"].join(\"\\n\");\n        var t = {\n          attributes: [\"position\"],\n          uniforms: [\"worldView\", \"projection\", \"u_emission\"],\n          samplers: new Array(),\n          needAlphaBlending: !1\n        };\n        (o._DefaultMaterial = new h.ShaderMaterial(\"GLTFDefaultMaterial\", e, {\n          vertex: \"GLTFDefaultMaterial\",\n          fragment: \"GLTFDefaultMaterial\"\n        }, t)).setColor4(\"u_emission\", new h.Color4(.5, .5, .5, 1));\n      }\n\n      return o._DefaultMaterial;\n    }, o._DefaultMaterial = null, o;\n  }(), p.GLTFUtils = m, _ = e || (e = {}), A = _.GLTF1 || (_.GLTF1 = {}), g = function () {\n    function i(e) {\n      this._name = e;\n    }\n\n    return Object.defineProperty(i.prototype, \"name\", {\n      get: function () {\n        return this._name;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), i.prototype.loadRuntimeAsync = function (e, t, n, r, o) {\n      return !1;\n    }, i.prototype.loadRuntimeExtensionsAsync = function (e, t, n) {\n      return !1;\n    }, i.prototype.loadBufferAsync = function (e, t, n, r, o) {\n      return !1;\n    }, i.prototype.loadTextureBufferAsync = function (e, t, n, r) {\n      return !1;\n    }, i.prototype.createTextureAsync = function (e, t, n, r, o) {\n      return !1;\n    }, i.prototype.loadShaderStringAsync = function (e, t, n, r) {\n      return !1;\n    }, i.prototype.loadMaterialAsync = function (e, t, n, r) {\n      return !1;\n    }, i.LoadRuntimeAsync = function (t, n, r, o, a) {\n      i.ApplyExtensions(function (e) {\n        return e.loadRuntimeAsync(t, n, r, o, a);\n      }, function () {\n        setTimeout(function () {\n          o && o(A.GLTFLoaderBase.CreateRuntime(n.json, t, r));\n        });\n      });\n    }, i.LoadRuntimeExtensionsAsync = function (t, n, r) {\n      i.ApplyExtensions(function (e) {\n        return e.loadRuntimeExtensionsAsync(t, n, r);\n      }, function () {\n        setTimeout(function () {\n          n();\n        });\n      });\n    }, i.LoadBufferAsync = function (t, n, r, o, a) {\n      i.ApplyExtensions(function (e) {\n        return e.loadBufferAsync(t, n, r, o, a);\n      }, function () {\n        A.GLTFLoaderBase.LoadBufferAsync(t, n, r, o, a);\n      });\n    }, i.LoadTextureAsync = function (t, n, r, o) {\n      i.LoadTextureBufferAsync(t, n, function (e) {\n        e && i.CreateTextureAsync(t, n, e, r, o);\n      }, o);\n    }, i.LoadShaderStringAsync = function (t, n, r, o) {\n      i.ApplyExtensions(function (e) {\n        return e.loadShaderStringAsync(t, n, r, o);\n      }, function () {\n        A.GLTFLoaderBase.LoadShaderStringAsync(t, n, r, o);\n      });\n    }, i.LoadMaterialAsync = function (t, n, r, o) {\n      i.ApplyExtensions(function (e) {\n        return e.loadMaterialAsync(t, n, r, o);\n      }, function () {\n        A.GLTFLoaderBase.LoadMaterialAsync(t, n, r, o);\n      });\n    }, i.LoadTextureBufferAsync = function (t, n, r, o) {\n      i.ApplyExtensions(function (e) {\n        return e.loadTextureBufferAsync(t, n, r, o);\n      }, function () {\n        A.GLTFLoaderBase.LoadTextureBufferAsync(t, n, r, o);\n      });\n    }, i.CreateTextureAsync = function (t, n, r, o, a) {\n      i.ApplyExtensions(function (e) {\n        return e.createTextureAsync(t, n, r, o, a);\n      }, function () {\n        A.GLTFLoaderBase.CreateTextureAsync(t, n, r, o, a);\n      });\n    }, i.ApplyExtensions = function (e, t) {\n      for (var n in A.GLTFLoader.Extensions) if (e(A.GLTFLoader.Extensions[n])) return;\n\n      t();\n    }, i;\n  }(), A.GLTFLoaderExtension = g, v = e || (e = {}), b = v.GLTF1 || (v.GLTF1 = {}), T = function (e) {\n    function t() {\n      return e.call(this, \"KHR_binary_glTF\") || this;\n    }\n\n    return Fe(t, e), t.prototype.loadRuntimeAsync = function (e, t, n, r, o) {\n      var a = t.json.extensionsUsed;\n      return !(!a || -1 === a.indexOf(this.name) || !t.bin || (this._bin = t.bin, r(b.GLTFLoaderBase.CreateRuntime(t.json, e, n)), 0));\n    }, t.prototype.loadBufferAsync = function (e, t, n, r) {\n      return -1 !== e.extensionsUsed.indexOf(this.name) && \"binary_glTF\" === t && (n(this._bin), !0);\n    }, t.prototype.loadTextureBufferAsync = function (e, t, n, r) {\n      var o = e.textures[t],\n          a = e.images[o.source];\n      if (!(a.extensions && this.name in a.extensions)) return !1;\n      var i = a.extensions[this.name],\n          s = e.bufferViews[i.bufferView];\n      return n(b.GLTFUtils.GetBufferFromBufferView(e, s, 0, s.byteLength, b.EComponentType.UNSIGNED_BYTE)), !0;\n    }, t.prototype.loadShaderStringAsync = function (e, t, n, r) {\n      var o = e.shaders[t];\n      if (!(o.extensions && this.name in o.extensions)) return !1;\n      var a = o.extensions[this.name],\n          i = e.bufferViews[a.bufferView],\n          s = b.GLTFUtils.GetBufferFromBufferView(e, i, 0, i.byteLength, b.EComponentType.UNSIGNED_BYTE);\n      return setTimeout(function () {\n        var e = b.GLTFUtils.DecodeBufferToText(s);\n        n(e);\n      }), !0;\n    }, t;\n  }(b.GLTFLoaderExtension), b.GLTFBinaryExtension = T, b.GLTFLoader.RegisterExtension(new T()), E = e || (e = {}), L = E.GLTF1 || (E.GLTF1 = {}), x = function (e) {\n    function t() {\n      return e.call(this, \"KHR_materials_common\") || this;\n    }\n\n    return Fe(t, e), t.prototype.loadRuntimeExtensionsAsync = function (e, t, n) {\n      if (!e.extensions) return !1;\n      var r = e.extensions[this.name];\n      if (!r) return !1;\n      var o = r.lights;\n      if (o) for (var a in o) {\n        var i = o[a];\n\n        switch (i.type) {\n          case \"ambient\":\n            var s = new E.HemisphericLight(i.name, new E.Vector3(0, 1, 0), e.scene),\n                l = i.ambient;\n            l && (s.diffuse = E.Color3.FromArray(l.color || [1, 1, 1]));\n            break;\n\n          case \"point\":\n            var u = new E.PointLight(i.name, new E.Vector3(10, 10, 10), e.scene),\n                c = i.point;\n            c && (u.diffuse = E.Color3.FromArray(c.color || [1, 1, 1]));\n            break;\n\n          case \"directional\":\n            var d = new E.DirectionalLight(i.name, new E.Vector3(0, -1, 0), e.scene),\n                f = i.directional;\n            f && (d.diffuse = E.Color3.FromArray(f.color || [1, 1, 1]));\n            break;\n\n          case \"spot\":\n            var h = i.spot;\n            h && (new E.SpotLight(i.name, new E.Vector3(0, 10, 0), new E.Vector3(0, -1, 0), h.fallOffAngle || Math.PI, h.fallOffExponent || 0, e.scene).diffuse = E.Color3.FromArray(h.color || [1, 1, 1]));\n            break;\n\n          default:\n            E.Tools.Warn('GLTF Material Common extension: light type \"' + i.type + \"” not supported\");\n        }\n      }\n      return !1;\n    }, t.prototype.loadMaterialAsync = function (e, t, n, r) {\n      var o = e.materials[t];\n      if (!o || !o.extensions) return !1;\n      var a = o.extensions[this.name];\n      if (!a) return !1;\n      var i = new E.StandardMaterial(t, e.scene);\n      return i.sideOrientation = E.Material.CounterClockWiseSideOrientation, \"CONSTANT\" === a.technique && (i.disableLighting = !0), i.backFaceCulling = void 0 !== a.doubleSided && !a.doubleSided, i.alpha = void 0 === a.values.transparency ? 1 : a.values.transparency, i.specularPower = void 0 === a.values.shininess ? 0 : a.values.shininess, \"string\" == typeof a.values.ambient ? this._loadTexture(e, a.values.ambient, i, \"ambientTexture\", r) : i.ambientColor = E.Color3.FromArray(a.values.ambient || [0, 0, 0]), \"string\" == typeof a.values.diffuse ? this._loadTexture(e, a.values.diffuse, i, \"diffuseTexture\", r) : i.diffuseColor = E.Color3.FromArray(a.values.diffuse || [0, 0, 0]), \"string\" == typeof a.values.emission ? this._loadTexture(e, a.values.emission, i, \"emissiveTexture\", r) : i.emissiveColor = E.Color3.FromArray(a.values.emission || [0, 0, 0]), \"string\" == typeof a.values.specular ? this._loadTexture(e, a.values.specular, i, \"specularTexture\", r) : i.specularColor = E.Color3.FromArray(a.values.specular || [0, 0, 0]), !0;\n    }, t.prototype._loadTexture = function (t, n, r, o, a) {\n      L.GLTFLoaderBase.LoadTextureBufferAsync(t, n, function (e) {\n        L.GLTFLoaderBase.CreateTextureAsync(t, n, e, function (e) {\n          return r[o] = e;\n        }, a);\n      }, a);\n    }, t;\n  }(L.GLTFLoaderExtension), L.GLTFMaterialsCommonExtension = x, L.GLTFLoader.RegisterExtension(new x()), function (e) {\n    var v = function () {\n      function e() {}\n\n      return e.Get = function (e, t, n) {\n        if (!t || null == n || !t[n]) throw new Error(e + \": Failed to find index (\" + n + \")\");\n        return t[n];\n      }, e.Assign = function (e) {\n        if (e) for (var t = 0; t < e.length; t++) e[t].index = t;\n      }, e;\n    }();\n\n    e.ArrayItem = v;\n\n    var t = function () {\n      function p(e) {\n        this._completePromises = new Array(), this._disposed = !1, this._state = null, this._extensions = {}, this._defaultBabylonMaterialData = {}, this._requests = new Array(), this._parent = e;\n      }\n\n      return p.RegisterExtension = function (e, t) {\n        p.UnregisterExtension(e) && O.Tools.Warn(\"Extension with the name '\" + e + \"' already exists\"), p._ExtensionFactories[e] = t, p._ExtensionNames.push(e);\n      }, p.UnregisterExtension = function (e) {\n        if (!p._ExtensionFactories[e]) return !1;\n        delete p._ExtensionFactories[e];\n\n        var t = p._ExtensionNames.indexOf(e);\n\n        return -1 !== t && p._ExtensionNames.splice(t, 1), !0;\n      }, Object.defineProperty(p.prototype, \"state\", {\n        get: function () {\n          return this._state;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), p.prototype.dispose = function () {\n        if (!this._disposed) {\n          this._disposed = !0;\n\n          for (var e = 0, t = this._requests; e < t.length; e++) t[e].abort();\n\n          for (var n in this._requests.length = 0, delete this.gltf, delete this.babylonScene, this._completePromises.length = 0, this._extensions) this._extensions[n].dispose && this._extensions[n].dispose();\n\n          this._extensions = {}, delete this._rootBabylonMesh, delete this._progressCallback, this._parent._clear();\n        }\n      }, p.prototype.importMeshAsync = function (a, i, s, l, u, c) {\n        var d = this;\n        return Promise.resolve().then(function () {\n          d.babylonScene = i, d._rootUrl = l, d._fileName = c || \"scene\", d._progressCallback = u, d._loadData(s);\n          var e = null;\n\n          if (a) {\n            var n = {};\n            if (d.gltf.nodes) for (var t = 0, r = d.gltf.nodes; t < r.length; t++) {\n              var o = r[t];\n              o.name && (n[o.name] = o.index);\n            }\n            e = (a instanceof Array ? a : [a]).map(function (e) {\n              var t = n[e];\n              if (void 0 === t) throw new Error(\"Failed to find node '\" + e + \"'\");\n              return t;\n            });\n          }\n\n          return d._loadAsync(e, function () {\n            return {\n              meshes: d._getMeshes(),\n              particleSystems: [],\n              skeletons: d._getSkeletons(),\n              animationGroups: d._getAnimationGroups()\n            };\n          });\n        });\n      }, p.prototype.loadAsync = function (e, t, n, r, o) {\n        var a = this;\n        return Promise.resolve().then(function () {\n          return a.babylonScene = e, a._rootUrl = n, a._fileName = o || \"scene\", a._progressCallback = r, a._loadData(t), a._loadAsync(null, function () {});\n        });\n      }, p.prototype._loadAsync = function (a, i) {\n        var s = this;\n        return Promise.resolve().then(function () {\n          s._uniqueRootUrl = -1 === s._rootUrl.indexOf(\"file:\") && s._fileName ? s._rootUrl : \"\" + s._rootUrl + Date.now() + \"/\", s._loadExtensions(), s._checkExtensions();\n          var e = O.GLTFLoaderState[O.GLTFLoaderState.LOADING] + \" => \" + O.GLTFLoaderState[O.GLTFLoaderState.READY],\n              t = O.GLTFLoaderState[O.GLTFLoaderState.LOADING] + \" => \" + O.GLTFLoaderState[O.GLTFLoaderState.COMPLETE];\n          s._parent._startPerformanceCounter(e), s._parent._startPerformanceCounter(t), s._setState(O.GLTFLoaderState.LOADING), s._extensionsOnLoading();\n          var n = new Array();\n          if (a) n.push(s.loadSceneAsync(\"#/nodes\", {\n            nodes: a,\n            index: -1\n          }));else {\n            var r = v.Get(\"#/scene\", s.gltf.scenes, s.gltf.scene || 0);\n            n.push(s.loadSceneAsync(\"#/scenes/\" + r.index, r));\n          }\n          s._parent.compileMaterials && n.push(s._compileMaterialsAsync()), s._parent.compileShadowGenerators && n.push(s._compileShadowGeneratorsAsync());\n          var o = Promise.all(n).then(function () {\n            return s._setState(O.GLTFLoaderState.READY), s._extensionsOnReady(), s._startAnimations(), i();\n          });\n          return o.then(function () {\n            s._parent._endPerformanceCounter(e), O.Tools.SetImmediate(function () {\n              s._disposed || Promise.all(s._completePromises).then(function () {\n                s._parent._endPerformanceCounter(t), s._setState(O.GLTFLoaderState.COMPLETE), s._parent.onCompleteObservable.notifyObservers(void 0), s._parent.onCompleteObservable.clear(), s.dispose();\n              }, function (e) {\n                s._parent.onErrorObservable.notifyObservers(e), s._parent.onErrorObservable.clear(), s.dispose();\n              });\n            });\n          }), o;\n        }, function (e) {\n          throw s._disposed || (s._parent.onErrorObservable.notifyObservers(e), s._parent.onErrorObservable.clear(), s.dispose()), e;\n        });\n      }, p.prototype._loadData = function (e) {\n        if (this.gltf = e.json, this._setupData(), e.bin) {\n          var t = this.gltf.buffers;\n\n          if (t && t[0] && !t[0].uri) {\n            var n = t[0];\n            (n.byteLength < e.bin.byteLength - 3 || n.byteLength > e.bin.byteLength) && O.Tools.Warn(\"Binary buffer length (\" + n.byteLength + \") from JSON does not match chunk length (\" + e.bin.byteLength + \")\"), n._data = Promise.resolve(e.bin);\n          } else O.Tools.Warn(\"Unexpected BIN chunk\");\n        }\n      }, p.prototype._setupData = function () {\n        if (v.Assign(this.gltf.accessors), v.Assign(this.gltf.animations), v.Assign(this.gltf.buffers), v.Assign(this.gltf.bufferViews), v.Assign(this.gltf.cameras), v.Assign(this.gltf.images), v.Assign(this.gltf.materials), v.Assign(this.gltf.meshes), v.Assign(this.gltf.nodes), v.Assign(this.gltf.samplers), v.Assign(this.gltf.scenes), v.Assign(this.gltf.skins), v.Assign(this.gltf.textures), this.gltf.nodes) {\n          for (var e = {}, t = 0, n = this.gltf.nodes; t < n.length; t++) if ((l = n[t]).children) for (var r = 0, o = l.children; r < o.length; r++) e[o[r]] = l.index;\n\n          for (var a = this._createRootNode(), i = 0, s = this.gltf.nodes; i < s.length; i++) {\n            var l,\n                u = e[(l = s[i]).index];\n            l.parent = void 0 === u ? a : this.gltf.nodes[u];\n          }\n        }\n      }, p.prototype._loadExtensions = function () {\n        for (var e = 0, t = p._ExtensionNames; e < t.length; e++) {\n          var n = t[e],\n              r = p._ExtensionFactories[n](this);\n\n          this._extensions[n] = r, this._parent.onExtensionLoadedObservable.notifyObservers(r);\n        }\n\n        this._parent.onExtensionLoadedObservable.clear();\n      }, p.prototype._checkExtensions = function () {\n        if (this.gltf.extensionsRequired) for (var e = 0, t = this.gltf.extensionsRequired; e < t.length; e++) {\n          var n = t[e],\n              r = this._extensions[n];\n          if (!r || !r.enabled) throw new Error(\"Require extension \" + n + \" is not available\");\n        }\n      }, p.prototype._setState = function (e) {\n        this._state = e, this.log(O.GLTFLoaderState[this._state]);\n      }, p.prototype._createRootNode = function () {\n        this._rootBabylonMesh = new O.Mesh(\"__root__\", this.babylonScene);\n        var e = {\n          _babylonMesh: this._rootBabylonMesh,\n          index: -1\n        };\n\n        switch (this._parent.coordinateSystemMode) {\n          case O.GLTFLoaderCoordinateSystemMode.AUTO:\n            this.babylonScene.useRightHandedSystem || (e.rotation = [0, 1, 0, 0], e.scale = [1, 1, -1], p._LoadTransform(e, this._rootBabylonMesh));\n            break;\n\n          case O.GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED:\n            this.babylonScene.useRightHandedSystem = !0;\n            break;\n\n          default:\n            throw new Error(\"Invalid coordinate system mode (\" + this._parent.coordinateSystemMode + \")\");\n        }\n\n        return this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh), e;\n      }, p.prototype.loadSceneAsync = function (e, t) {\n        var n = this,\n            r = this._extensionsLoadSceneAsync(e, t);\n\n        if (r) return r;\n        var o = new Array();\n        if (this.logOpen(e + \" \" + (t.name || \"\")), t.nodes) for (var a = 0, i = t.nodes; a < i.length; a++) {\n          var s = i[a],\n              l = v.Get(e + \"/nodes/\" + s, this.gltf.nodes, s);\n          o.push(this.loadNodeAsync(\"#/nodes/\" + l.index, l, function (e) {\n            e.parent = n._rootBabylonMesh;\n          }));\n        }\n        return o.push(this._loadAnimationsAsync()), this.logClose(), Promise.all(o).then(function () {});\n      }, p.prototype._forEachPrimitive = function (e, t) {\n        if (e._primitiveBabylonMeshes) for (var n = 0, r = e._primitiveBabylonMeshes; n < r.length; n++) t(r[n]);else t(e._babylonMesh);\n      }, p.prototype._getMeshes = function () {\n        var e = new Array();\n        e.push(this._rootBabylonMesh);\n        var t = this.gltf.nodes;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n          if (o._babylonMesh && e.push(o._babylonMesh), o._primitiveBabylonMeshes) for (var a = 0, i = o._primitiveBabylonMeshes; a < i.length; a++) {\n            var s = i[a];\n            e.push(s);\n          }\n        }\n        return e;\n      }, p.prototype._getSkeletons = function () {\n        var e = new Array(),\n            t = this.gltf.skins;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n          o._babylonSkeleton && e.push(o._babylonSkeleton);\n        }\n        return e;\n      }, p.prototype._getAnimationGroups = function () {\n        var e = new Array(),\n            t = this.gltf.animations;\n        if (t) for (var n = 0, r = t; n < r.length; n++) {\n          var o = r[n];\n          o._babylonAnimationGroup && e.push(o._babylonAnimationGroup);\n        }\n        return e;\n      }, p.prototype._startAnimations = function () {\n        switch (this._parent.animationStartMode) {\n          case O.GLTFLoaderAnimationStartMode.NONE:\n            break;\n\n          case O.GLTFLoaderAnimationStartMode.FIRST:\n            0 !== (e = this._getAnimationGroups()).length && e[0].start(!0);\n            break;\n\n          case O.GLTFLoaderAnimationStartMode.ALL:\n            for (var e, t = 0, n = e = this._getAnimationGroups(); t < n.length; t++) n[t].start(!0);\n\n            break;\n\n          default:\n            return void O.Tools.Error(\"Invalid animation start mode (\" + this._parent.animationStartMode + \")\");\n        }\n      }, p.prototype.loadNodeAsync = function (n, r, e) {\n        var o = this;\n        void 0 === e && (e = function () {});\n\n        var t = this._extensionsLoadNodeAsync(n, r, e);\n\n        if (t) return t;\n        if (r._babylonMesh) throw new Error(n + \": Invalid recursive node hierarchy\");\n        var a = new Array();\n        this.logOpen(n + \" \" + (r.name || \"\"));\n        var i = new O.Mesh(r.name || \"node\" + r.index, this.babylonScene);\n\n        if ((r._babylonMesh = i).setEnabled(!1), p._LoadTransform(r, i), null != r.mesh) {\n          var s = v.Get(n + \"/mesh\", this.gltf.meshes, r.mesh);\n          a.push(this._loadMeshAsync(\"#/meshes/\" + s.index, r, s, i));\n        }\n\n        if (null != r.camera) {\n          var l = v.Get(n + \"/camera\", this.gltf.cameras, r.camera);\n          a.push(this.loadCameraAsync(\"#/cameras/\" + l.index, l, function (e) {\n            e.parent = i;\n          }));\n        }\n\n        if (r.children) for (var u = function (e) {\n          var t = v.Get(n + \"/children/\" + e, c.gltf.nodes, e);\n          a.push(c.loadNodeAsync(\"#/nodes/\" + r.index, t, function (e) {\n            null == t.skin ? e.parent = i : e.parent = o._rootBabylonMesh;\n          }));\n        }, c = this, d = 0, f = r.children; d < f.length; d++) u(f[d]);\n        return e(i), this._parent.onMeshLoadedObservable.notifyObservers(i), this.logClose(), Promise.all(a).then(function () {\n          return i.setEnabled(!0), i;\n        });\n      }, p.prototype._loadMeshAsync = function (e, t, n, r) {\n        var o = this,\n            a = new Array();\n        this.logOpen(e + \" \" + (n.name || \"\"));\n        var i = n.primitives;\n        if (!i || 0 === i.length) throw new Error(e + \": Primitives are missing\");\n\n        if (v.Assign(i), 1 === i.length) {\n          var s = i[0];\n          a.push(this._loadMeshPrimitiveAsync(e + \"/primitives/\" + s.index, t, n, s, r));\n        } else {\n          t._primitiveBabylonMeshes = [];\n\n          for (var l = 0, u = i; l < u.length; l++) {\n            s = u[l];\n            var c = new O.Mesh((n.name || r.name) + \"_\" + s.index, this.babylonScene, r);\n            t._primitiveBabylonMeshes.push(c), a.push(this._loadMeshPrimitiveAsync(e + \"/primitives/\" + s.index, t, n, s, c)), this._parent.onMeshLoadedObservable.notifyObservers(r);\n          }\n        }\n\n        if (null != t.skin) {\n          var d = v.Get(e + \"/skin\", this.gltf.skins, t.skin);\n          a.push(this._loadSkinAsync(\"#/skins/\" + d.index, t, d));\n        }\n\n        return this.logClose(), Promise.all(a).then(function () {\n          o._forEachPrimitive(t, function (e) {\n            e._refreshBoundingInfo(!0);\n          });\n        });\n      }, p.prototype._loadMeshPrimitiveAsync = function (t, e, n, r, o) {\n        var a = this,\n            i = new Array();\n        this.logOpen(\"\" + t), this._createMorphTargets(t, e, n, r, o), i.push(this._loadVertexDataAsync(t, r, o).then(function (e) {\n          return a._loadMorphTargetsAsync(t, r, o, e).then(function () {\n            e.applyToMesh(o);\n          });\n        }));\n\n        var s = p._GetDrawMode(t, r.mode);\n\n        if (null == r.material) {\n          var l = this._defaultBabylonMaterialData[s];\n          l || (l = this._createDefaultMaterial(\"__gltf_default\", s), this._parent.onMaterialLoadedObservable.notifyObservers(l), this._defaultBabylonMaterialData[s] = l), o.material = l;\n        } else {\n          var u = v.Get(t + \"/material\", this.gltf.materials, r.material);\n          i.push(this._loadMaterialAsync(\"#/materials/\" + u.index, u, o, s, function (e) {\n            o.material = e;\n          }));\n        }\n\n        return this.logClose(), Promise.all(i).then(function () {});\n      }, p.prototype._loadVertexDataAsync = function (o, e, a) {\n        var i = this,\n            t = this._extensionsLoadVertexDataAsync(o, e, a);\n\n        if (t) return t;\n        var s = e.attributes;\n        if (!s) throw new Error(o + \": Attributes are missing\");\n        var l = new Array(),\n            u = new O.Geometry(a.name, this.babylonScene);\n        if (null == e.indices) a.isUnIndexed = !0;else {\n          var n = v.Get(o + \"/indices\", this.gltf.accessors, e.indices);\n          l.push(this._loadIndicesAccessorAsync(\"#/accessors/\" + n.index, n).then(function (e) {\n            u.setIndices(e);\n          }));\n        }\n\n        var r = function (e, t, n) {\n          if (null != s[e]) {\n            a._delayInfo = a._delayInfo || [], -1 === a._delayInfo.indexOf(t) && a._delayInfo.push(t);\n            var r = v.Get(o + \"/attributes/\" + e, i.gltf.accessors, s[e]);\n            l.push(i._loadVertexAccessorAsync(\"#/accessors/\" + r.index, r, t).then(function (e) {\n              u.setVerticesBuffer(e, r.count);\n            })), n && n(r);\n          }\n        };\n\n        return r(\"POSITION\", O.VertexBuffer.PositionKind), r(\"NORMAL\", O.VertexBuffer.NormalKind), r(\"TANGENT\", O.VertexBuffer.TangentKind), r(\"TEXCOORD_0\", O.VertexBuffer.UVKind), r(\"TEXCOORD_1\", O.VertexBuffer.UV2Kind), r(\"JOINTS_0\", O.VertexBuffer.MatricesIndicesKind), r(\"WEIGHTS_0\", O.VertexBuffer.MatricesWeightsKind), r(\"COLOR_0\", O.VertexBuffer.ColorKind, function (e) {\n          \"VEC4\" === e.type && (a.hasVertexAlpha = !0);\n        }), Promise.all(l).then(function () {\n          return u;\n        });\n      }, p.prototype._createMorphTargets = function (e, t, n, r, o) {\n        if (r.targets) {\n          if (null == t._numMorphTargets) t._numMorphTargets = r.targets.length;else if (r.targets.length !== t._numMorphTargets) throw new Error(e + \": Primitives do not have the same number of targets\");\n          o.morphTargetManager = new O.MorphTargetManager();\n\n          for (var a = 0; a < r.targets.length; a++) {\n            var i = t.weights ? t.weights[a] : n.weights ? n.weights[a] : 0;\n            o.morphTargetManager.addTarget(new O.MorphTarget(\"morphTarget\" + a, i));\n          }\n        }\n      }, p.prototype._loadMorphTargetsAsync = function (e, t, n, r) {\n        if (!t.targets) return Promise.resolve();\n\n        for (var o = new Array(), a = n.morphTargetManager, i = 0; i < a.numTargets; i++) {\n          var s = a.getTarget(i);\n          o.push(this._loadMorphTargetVertexDataAsync(e + \"/targets/\" + i, r, t.targets[i], s));\n        }\n\n        return Promise.all(o).then(function () {});\n      }, p.prototype._loadMorphTargetVertexDataAsync = function (a, i, s, t) {\n        var l = this,\n            u = new Array(),\n            e = function (e, t, n) {\n          if (null != s[e]) {\n            var r = i.getVertexBuffer(t);\n\n            if (r) {\n              var o = v.Get(a + \"/\" + e, l.gltf.accessors, s[e]);\n              u.push(l._loadFloatAccessorAsync(\"#/accessors/\" + o.index, o).then(function (e) {\n                n(r, e);\n              }));\n            }\n          }\n        };\n\n        return e(\"POSITION\", O.VertexBuffer.PositionKind, function (e, n) {\n          e.forEach(n.length, function (e, t) {\n            n[t] += e;\n          }), t.setPositions(n);\n        }), e(\"NORMAL\", O.VertexBuffer.NormalKind, function (e, n) {\n          e.forEach(n.length, function (e, t) {\n            n[t] += e;\n          }), t.setNormals(n);\n        }), e(\"TANGENT\", O.VertexBuffer.TangentKind, function (e, n) {\n          var r = 0;\n          e.forEach(n.length / 3 * 4, function (e, t) {\n            (t + 1) % 4 != 0 && (n[r++] += e);\n          }), t.setTangents(n);\n        }), Promise.all(u).then(function () {});\n      }, p._LoadTransform = function (e, t) {\n        var n = O.Vector3.Zero(),\n            r = O.Quaternion.Identity(),\n            o = O.Vector3.One();\n        e.matrix ? O.Matrix.FromArray(e.matrix).decompose(o, r, n) : (e.translation && (n = O.Vector3.FromArray(e.translation)), e.rotation && (r = O.Quaternion.FromArray(e.rotation)), e.scale && (o = O.Vector3.FromArray(e.scale))), t.position = n, t.rotationQuaternion = r, t.scaling = o;\n      }, p.prototype._loadSkinAsync = function (e, n, t) {\n        var r = this,\n            o = function (t) {\n          r._forEachPrimitive(n, function (e) {\n            e.skeleton = t;\n          }), n._babylonMesh.position = O.Vector3.Zero(), n._babylonMesh.rotationQuaternion = O.Quaternion.Identity(), n._babylonMesh.scaling = O.Vector3.One();\n        };\n\n        if (t._promise) return t._promise.then(function () {\n          o(t._babylonSkeleton);\n        });\n        var a = \"skeleton\" + t.index,\n            i = new O.Skeleton(t.name || a, a, this.babylonScene);\n        return t._babylonSkeleton = i, this._loadBones(e, t), o(i), t._promise = this._loadSkinInverseBindMatricesDataAsync(e, t).then(function (e) {\n          r._updateBoneMatrices(i, e);\n        });\n      }, p.prototype._loadBones = function (e, t) {\n        for (var n = {}, r = 0, o = t.joints; r < o.length; r++) {\n          var a = o[r],\n              i = v.Get(e + \"/joints/\" + a, this.gltf.nodes, a);\n\n          this._loadBone(i, t, n);\n        }\n      }, p.prototype._loadBone = function (e, t, n) {\n        var r = n[e.index];\n        if (r) return r;\n        var o = null;\n        e.parent && e.parent._babylonMesh !== this._rootBabylonMesh && (o = this._loadBone(e.parent, t, n));\n        var a = t.joints.indexOf(e.index);\n        return r = new O.Bone(e.name || \"joint\" + e.index, t._babylonSkeleton, o, this._getNodeMatrix(e), null, null, a), n[e.index] = r, e._babylonBones = e._babylonBones || [], e._babylonBones.push(r), r;\n      }, p.prototype._loadSkinInverseBindMatricesDataAsync = function (e, t) {\n        if (null == t.inverseBindMatrices) return Promise.resolve(null);\n        var n = v.Get(e + \"/inverseBindMatrices\", this.gltf.accessors, t.inverseBindMatrices);\n        return this._loadFloatAccessorAsync(\"#/accessors/\" + n.index, n);\n      }, p.prototype._updateBoneMatrices = function (e, t) {\n        for (var n = 0, r = e.bones; n < r.length; n++) {\n          var o = r[n],\n              a = O.Matrix.Identity(),\n              i = o._index;\n          t && -1 !== i && (O.Matrix.FromArrayToRef(t, 16 * i, a), a.invertToRef(a));\n          var s = o.getParent();\n          s && a.multiplyToRef(s.getInvertedAbsoluteTransform(), a), o.updateMatrix(a, !1, !1), o._updateDifferenceMatrix(void 0, !1);\n        }\n      }, p.prototype._getNodeMatrix = function (e) {\n        return e.matrix ? O.Matrix.FromArray(e.matrix) : O.Matrix.Compose(e.scale ? O.Vector3.FromArray(e.scale) : O.Vector3.One(), e.rotation ? O.Quaternion.FromArray(e.rotation) : O.Quaternion.Identity(), e.translation ? O.Vector3.FromArray(e.translation) : O.Vector3.Zero());\n      }, p.prototype.loadCameraAsync = function (e, t, n) {\n        void 0 === n && (n = function () {});\n\n        var r = this._extensionsLoadCameraAsync(e, t, n);\n\n        if (r) return r;\n        var o = new Array();\n        this.logOpen(e + \" \" + (t.name || \"\"));\n        var a = new O.FreeCamera(t.name || \"camera\" + t.index, O.Vector3.Zero(), this.babylonScene, !1);\n\n        switch (a.rotation = new O.Vector3(0, Math.PI, 0), t.type) {\n          case \"perspective\":\n            var i = t.perspective;\n            if (!i) throw new Error(e + \": Camera perspective properties are missing\");\n            a.fov = i.yfov, a.minZ = i.znear, a.maxZ = i.zfar || Number.MAX_VALUE;\n            break;\n\n          case \"orthographic\":\n            if (!t.orthographic) throw new Error(e + \": Camera orthographic properties are missing\");\n            a.mode = O.Camera.ORTHOGRAPHIC_CAMERA, a.orthoLeft = -t.orthographic.xmag, a.orthoRight = t.orthographic.xmag, a.orthoBottom = -t.orthographic.ymag, a.orthoTop = t.orthographic.ymag, a.minZ = t.orthographic.znear, a.maxZ = t.orthographic.zfar;\n            break;\n\n          default:\n            throw new Error(e + \": Invalid camera type (\" + t.type + \")\");\n        }\n\n        return n(a), this._parent.onCameraLoadedObservable.notifyObservers(a), Promise.all(o).then(function () {\n          return a;\n        });\n      }, p.prototype._loadAnimationsAsync = function () {\n        var e = this.gltf.animations;\n        if (!e) return Promise.resolve();\n\n        for (var t = new Array(), n = 0; n < e.length; n++) {\n          var r = e[n];\n          t.push(this.loadAnimationAsync(\"#/animations/\" + r.index, r));\n        }\n\n        return Promise.all(t).then(function () {});\n      }, p.prototype.loadAnimationAsync = function (e, t) {\n        var n = this._extensionsLoadAnimationAsync(e, t);\n\n        if (n) return n;\n        var r = new O.AnimationGroup(t.name || \"animation\" + t.index, this.babylonScene);\n        t._babylonAnimationGroup = r;\n        var o = new Array();\n        v.Assign(t.channels), v.Assign(t.samplers);\n\n        for (var a = 0, i = t.channels; a < i.length; a++) {\n          var s = i[a];\n          o.push(this._loadAnimationChannelAsync(e + \"/channels/\" + s.index, e, t, s, r));\n        }\n\n        return Promise.all(o).then(function () {\n          return r.normalize(0), r;\n        });\n      }, p.prototype._loadAnimationChannelAsync = function (m, e, t, y, _) {\n        var A = this,\n            g = v.Get(m + \"/target/node\", this.gltf.nodes, y.target.node);\n        if (\"weights\" === y.target.path && !g._numMorphTargets || \"weights\" !== y.target.path && !g._babylonMesh) return Promise.resolve();\n        if (null != g.skin && \"weights\" !== y.target.path) return Promise.resolve();\n        var n = v.Get(m + \"/sampler\", t.samplers, y.sampler);\n        return this._loadAnimationSamplerAsync(e + \"/samplers/\" + y.sampler, n).then(function (n) {\n          var t, a;\n\n          switch (y.target.path) {\n            case \"translation\":\n              t = \"position\", a = O.Animation.ANIMATIONTYPE_VECTOR3;\n              break;\n\n            case \"rotation\":\n              t = \"rotationQuaternion\", a = O.Animation.ANIMATIONTYPE_QUATERNION;\n              break;\n\n            case \"scale\":\n              t = \"scaling\", a = O.Animation.ANIMATIONTYPE_VECTOR3;\n              break;\n\n            case \"weights\":\n              t = \"influence\", a = O.Animation.ANIMATIONTYPE_FLOAT;\n              break;\n\n            default:\n              throw new Error(m + \"/target/path: Invalid value (\" + y.target.path + \")\");\n          }\n\n          var r,\n              e,\n              o = 0;\n\n          switch (t) {\n            case \"position\":\n              r = function () {\n                var e = O.Vector3.FromArray(n.output, o);\n                return o += 3, e;\n              };\n\n              break;\n\n            case \"rotationQuaternion\":\n              r = function () {\n                var e = O.Quaternion.FromArray(n.output, o);\n                return o += 4, e;\n              };\n\n              break;\n\n            case \"scaling\":\n              r = function () {\n                var e = O.Vector3.FromArray(n.output, o);\n                return o += 3, e;\n              };\n\n              break;\n\n            case \"influence\":\n              r = function () {\n                for (var e = new Array(g._numMorphTargets), t = 0; t < g._numMorphTargets; t++) e[t] = n.output[o++];\n\n                return e;\n              };\n\n          }\n\n          switch (n.interpolation) {\n            case \"STEP\":\n              e = function (e) {\n                return {\n                  frame: n.input[e],\n                  value: r(),\n                  interpolation: O.AnimationKeyInterpolation.STEP\n                };\n              };\n\n              break;\n\n            case \"LINEAR\":\n              e = function (e) {\n                return {\n                  frame: n.input[e],\n                  value: r()\n                };\n              };\n\n              break;\n\n            case \"CUBICSPLINE\":\n              e = function (e) {\n                return {\n                  frame: n.input[e],\n                  inTangent: r(),\n                  value: r(),\n                  outTangent: r()\n                };\n              };\n\n          }\n\n          for (var i = new Array(n.input.length), s = 0; s < n.input.length; s++) i[s] = e(s);\n\n          if (\"influence\" === t) for (var l = function (r) {\n            var e = _.name + \"_channel\" + _.targetedAnimations.length,\n                o = new O.Animation(e, t, 1, a);\n            o.setKeys(i.map(function (e) {\n              return {\n                frame: e.frame,\n                inTangent: e.inTangent ? e.inTangent[r] : void 0,\n                value: e.value[r],\n                outTangent: e.outTangent ? e.outTangent[r] : void 0\n              };\n            })), A._forEachPrimitive(g, function (e) {\n              var t = e.morphTargetManager.getTarget(r),\n                  n = o.clone();\n              t.animations.push(n), _.addTargetedAnimation(n, t);\n            });\n          }, u = 0; u < g._numMorphTargets; u++) l(u);else {\n            var c = _.name + \"_channel\" + _.targetedAnimations.length,\n                d = new O.Animation(c, t, 1, a);\n\n            if (d.setKeys(i), g._babylonBones) {\n              for (var f = [g._babylonMesh].concat(g._babylonBones), h = 0, p = f; h < p.length; h++) p[h].animations.push(d);\n\n              _.addTargetedAnimation(d, f);\n            } else g._babylonMesh.animations.push(d), _.addTargetedAnimation(d, g._babylonMesh);\n          }\n        });\n      }, p.prototype._loadAnimationSamplerAsync = function (e, t) {\n        if (t._data) return t._data;\n        var r = t.interpolation || \"LINEAR\";\n\n        switch (r) {\n          case \"STEP\":\n          case \"LINEAR\":\n          case \"CUBICSPLINE\":\n            break;\n\n          default:\n            throw new Error(e + \"/interpolation: Invalid value (\" + t.interpolation + \")\");\n        }\n\n        var n = v.Get(e + \"/input\", this.gltf.accessors, t.input),\n            o = v.Get(e + \"/output\", this.gltf.accessors, t.output);\n        return t._data = Promise.all([this._loadFloatAccessorAsync(\"#/accessors/\" + n.index, n), this._loadFloatAccessorAsync(\"#/accessors/\" + o.index, o)]).then(function (e) {\n          var t = e[0],\n              n = e[1];\n          return {\n            input: t,\n            interpolation: r,\n            output: n\n          };\n        }), t._data;\n      }, p.prototype._loadBufferAsync = function (e, t) {\n        if (t._data) return t._data;\n        if (!t.uri) throw new Error(e + \"/uri: Value is missing\");\n        return t._data = this.loadUriAsync(e + \"/uri\", t.uri), t._data;\n      }, p.prototype.loadBufferViewAsync = function (t, n) {\n        if (n._data) return n._data;\n        var e = v.Get(t + \"/buffer\", this.gltf.buffers, n.buffer);\n        return n._data = this._loadBufferAsync(\"#/buffers/\" + e.index, e).then(function (e) {\n          try {\n            return new Uint8Array(e.buffer, e.byteOffset + (n.byteOffset || 0), n.byteLength);\n          } catch (e) {\n            throw new Error(t + \": \" + e.message);\n          }\n        }), n._data;\n      }, p.prototype._loadIndicesAccessorAsync = function (t, n) {\n        if (\"SCALAR\" !== n.type) throw new Error(t + \"/type: Invalid value \" + n.type);\n        if (5121 !== n.componentType && 5123 !== n.componentType && 5125 !== n.componentType) throw new Error(t + \"/componentType: Invalid value \" + n.componentType);\n        if (n._data) return n._data;\n        var e = v.Get(t + \"/bufferView\", this.gltf.bufferViews, n.bufferView);\n        return n._data = this.loadBufferViewAsync(\"#/bufferViews/\" + e.index, e).then(function (e) {\n          return p._GetTypedArray(t, n.componentType, e, n.byteOffset, n.count);\n        }), n._data;\n      }, p.prototype._loadFloatAccessorAsync = function (c, d) {\n        var n = this;\n        if (5126 !== d.componentType) throw new Error(\"Invalid component type \" + d.componentType);\n        if (d._data) return d._data;\n\n        var f = p._GetNumComponents(c, d.type),\n            t = f * d.count;\n\n        if (null == d.bufferView) d._data = Promise.resolve(new Float32Array(t));else {\n          var e = v.Get(c + \"/bufferView\", this.gltf.bufferViews, d.bufferView);\n          d._data = this.loadBufferViewAsync(\"#/bufferViews/\" + e.index, e).then(function (e) {\n            return p._GetTypedArray(c, d.componentType, e, d.byteOffset, t);\n          });\n        }\n\n        if (d.sparse) {\n          var h = d.sparse;\n          d._data = d._data.then(function (u) {\n            var e = v.Get(c + \"/sparse/indices/bufferView\", n.gltf.bufferViews, h.indices.bufferView),\n                t = v.Get(c + \"/sparse/values/bufferView\", n.gltf.bufferViews, h.values.bufferView);\n            return Promise.all([n.loadBufferViewAsync(\"#/bufferViews/\" + e.index, e), n.loadBufferViewAsync(\"#/bufferViews/\" + t.index, t)]).then(function (e) {\n              for (var t = e[0], n = e[1], r = p._GetTypedArray(c + \"/sparse/indices\", h.indices.componentType, t, h.indices.byteOffset, h.count), o = p._GetTypedArray(c + \"/sparse/values\", d.componentType, n, h.values.byteOffset, f * h.count), a = 0, i = 0; i < r.length; i++) for (var s = r[i] * f, l = 0; l < f; l++) u[s++] = o[a++];\n\n              return u;\n            });\n          });\n        }\n\n        return d._data;\n      }, p.prototype._loadVertexBufferViewAsync = function (e, t) {\n        var n = this;\n        return e._babylonBuffer || (e._babylonBuffer = this.loadBufferViewAsync(\"#/bufferViews/\" + e.index, e).then(function (e) {\n          return new O.Buffer(n.babylonScene.getEngine(), e, !1);\n        })), e._babylonBuffer;\n      }, p.prototype._loadVertexAccessorAsync = function (n, r, o) {\n        var a = this;\n        if (r._babylonVertexBuffer) return r._babylonVertexBuffer;\n        if (r.sparse) r._babylonVertexBuffer = this._loadFloatAccessorAsync(\"#/accessors/\" + r.index, r).then(function (e) {\n          return new O.VertexBuffer(a.babylonScene.getEngine(), e, o, !1);\n        });else if (r.byteOffset && r.byteOffset % O.VertexBuffer.GetTypeByteLength(r.componentType) != 0) O.Tools.Warn(\"Accessor byte offset is not a multiple of component type byte length\"), r._babylonVertexBuffer = this._loadFloatAccessorAsync(\"#/accessors/\" + r.index, r).then(function (e) {\n          return new O.VertexBuffer(a.babylonScene.getEngine(), e, o, !1);\n        });else {\n          var i = v.Get(n + \"/bufferView\", this.gltf.bufferViews, r.bufferView);\n          r._babylonVertexBuffer = this._loadVertexBufferViewAsync(i, o).then(function (e) {\n            var t = p._GetNumComponents(n, r.type);\n\n            return new O.VertexBuffer(a.babylonScene.getEngine(), e, o, !1, !1, i.byteStride, !1, r.byteOffset, t, r.componentType, r.normalized, !0);\n          });\n        }\n        return r._babylonVertexBuffer;\n      }, p.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function (e, t, n) {\n        if (!(n instanceof O.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var r = new Array();\n        return t && (t.baseColorFactor ? (n.albedoColor = O.Color3.FromArray(t.baseColorFactor), n.alpha = t.baseColorFactor[3]) : n.albedoColor = O.Color3.White(), n.metallic = null == t.metallicFactor ? 1 : t.metallicFactor, n.roughness = null == t.roughnessFactor ? 1 : t.roughnessFactor, t.baseColorTexture && r.push(this.loadTextureInfoAsync(e + \"/baseColorTexture\", t.baseColorTexture, function (e) {\n          n.albedoTexture = e;\n        })), t.metallicRoughnessTexture && (r.push(this.loadTextureInfoAsync(e + \"/metallicRoughnessTexture\", t.metallicRoughnessTexture, function (e) {\n          n.metallicTexture = e;\n        })), n.useMetallnessFromMetallicTextureBlue = !0, n.useRoughnessFromMetallicTextureGreen = !0, n.useRoughnessFromMetallicTextureAlpha = !1)), Promise.all(r).then(function () {});\n      }, p.prototype._loadMaterialAsync = function (e, t, n, r, o) {\n        void 0 === o && (o = function () {});\n\n        var a = this._extensionsLoadMaterialAsync(e, t, n, r, o);\n\n        if (a) return a;\n        t._babylonData = t._babylonData || {};\n        var i = t._babylonData[r];\n\n        if (!i) {\n          this.logOpen(e + \" \" + (t.name || \"\"));\n          var s = this.createMaterial(e, t, r);\n          i = {\n            material: s,\n            meshes: [],\n            promise: this.loadMaterialPropertiesAsync(e, t, s)\n          }, t._babylonData[r] = i, this._parent.onMaterialLoadedObservable.notifyObservers(s), this.logClose();\n        }\n\n        return i.meshes.push(n), n.onDisposeObservable.addOnce(function () {\n          var e = i.meshes.indexOf(n);\n          -1 !== e && i.meshes.splice(e, 1);\n        }), o(i.material), i.promise.then(function () {\n          return i.material;\n        });\n      }, p.prototype._createDefaultMaterial = function (e, t) {\n        var n = new O.PBRMaterial(e, this.babylonScene);\n        return n.sideOrientation = this.babylonScene.useRightHandedSystem ? O.Material.CounterClockWiseSideOrientation : O.Material.ClockWiseSideOrientation, n.fillMode = t, n.enableSpecularAntiAliasing = !0, n.useRadianceOverAlpha = !this._parent.transparencyAsCoverage, n.useSpecularOverAlpha = !this._parent.transparencyAsCoverage, n.transparencyMode = O.PBRMaterial.PBRMATERIAL_OPAQUE, n.metallic = 1, n.roughness = 1, n;\n      }, p.prototype.createMaterial = function (e, t, n) {\n        var r = this._extensionsCreateMaterial(e, t, n);\n\n        if (r) return r;\n        var o = t.name || \"material\" + t.index;\n        return this._createDefaultMaterial(o, n);\n      }, p.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n        var r = this._extensionsLoadMaterialPropertiesAsync(e, t, n);\n\n        if (r) return r;\n        var o = new Array();\n        return o.push(this.loadMaterialBasePropertiesAsync(e, t, n)), t.pbrMetallicRoughness && o.push(this._loadMaterialMetallicRoughnessPropertiesAsync(e + \"/pbrMetallicRoughness\", t.pbrMetallicRoughness, n)), this.loadMaterialAlphaProperties(e, t, n), Promise.all(o).then(function () {});\n      }, p.prototype.loadMaterialBasePropertiesAsync = function (e, t, n) {\n        if (!(n instanceof O.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n        var r = new Array();\n        return n.emissiveColor = t.emissiveFactor ? O.Color3.FromArray(t.emissiveFactor) : new O.Color3(0, 0, 0), t.doubleSided && (n.backFaceCulling = !1, n.twoSidedLighting = !0), t.normalTexture && (r.push(this.loadTextureInfoAsync(e + \"/normalTexture\", t.normalTexture, function (e) {\n          n.bumpTexture = e;\n        })), n.invertNormalMapX = !this.babylonScene.useRightHandedSystem, n.invertNormalMapY = this.babylonScene.useRightHandedSystem, null != t.normalTexture.scale && (n.bumpTexture.level = t.normalTexture.scale)), t.occlusionTexture && (r.push(this.loadTextureInfoAsync(e + \"/occlusionTexture\", t.occlusionTexture, function (e) {\n          n.ambientTexture = e;\n        })), n.useAmbientInGrayScale = !0, null != t.occlusionTexture.strength && (n.ambientTextureStrength = t.occlusionTexture.strength)), t.emissiveTexture && r.push(this.loadTextureInfoAsync(e + \"/emissiveTexture\", t.emissiveTexture, function (e) {\n          n.emissiveTexture = e;\n        })), Promise.all(r).then(function () {});\n      }, p.prototype.loadMaterialAlphaProperties = function (e, t, n) {\n        if (!(n instanceof O.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n\n        switch (t.alphaMode || \"OPAQUE\") {\n          case \"OPAQUE\":\n            n.transparencyMode = O.PBRMaterial.PBRMATERIAL_OPAQUE;\n            break;\n\n          case \"MASK\":\n            n.transparencyMode = O.PBRMaterial.PBRMATERIAL_ALPHATEST, n.alphaCutOff = null == t.alphaCutoff ? .5 : t.alphaCutoff, n.albedoTexture && (n.albedoTexture.hasAlpha = !0);\n            break;\n\n          case \"BLEND\":\n            n.transparencyMode = O.PBRMaterial.PBRMATERIAL_ALPHABLEND, n.albedoTexture && (n.albedoTexture.hasAlpha = !0, n.useAlphaFromAlbedoTexture = !0);\n            break;\n\n          default:\n            throw new Error(e + \"/alphaMode: Invalid value (\" + t.alphaMode + \")\");\n        }\n      }, p.prototype.loadTextureInfoAsync = function (e, t, n) {\n        void 0 === n && (n = function () {});\n\n        var r = this._extensionsLoadTextureInfoAsync(e, t, n);\n\n        if (r) return r;\n        this.logOpen(\"\" + e);\n\n        var o = v.Get(e + \"/index\", this.gltf.textures, t.index),\n            a = this._loadTextureAsync(\"#/textures/\" + t.index, o, function (e) {\n          e.coordinatesIndex = t.texCoord || 0, n(e);\n        });\n\n        return this.logClose(), a;\n      }, p.prototype._loadTextureAsync = function (n, e, t) {\n        var r = this;\n        void 0 === t && (t = function () {});\n        var o = new Array();\n        this.logOpen(n + \" \" + (e.name || \"\"));\n\n        var a = null == e.sampler ? p._DefaultSampler : v.Get(n + \"/sampler\", this.gltf.samplers, e.sampler),\n            i = this._loadSampler(\"#/samplers/\" + a.index, a),\n            s = new O.Deferred(),\n            l = new O.Texture(null, this.babylonScene, i.noMipMaps, !1, i.samplingMode, function () {\n          r._disposed || s.resolve();\n        }, function (e, t) {\n          r._disposed || s.reject(new Error(n + \": \" + (t && t.message ? t.message : e || \"Failed to load texture\")));\n        });\n\n        o.push(s.promise), l.name = e.name || \"texture\" + e.index, l.wrapU = i.wrapU, l.wrapV = i.wrapV;\n        var u = v.Get(n + \"/source\", this.gltf.images, e.source);\n        return o.push(this.loadImageAsync(\"#/images/\" + u.index, u).then(function (e) {\n          var t = u.uri || r._fileName + \"#image\" + u.index,\n              n = \"data:\" + r._uniqueRootUrl + t;\n          l.updateURL(n, new Blob([e], {\n            type: u.mimeType\n          }));\n        })), t(l), this._parent.onTextureLoadedObservable.notifyObservers(l), this.logClose(), Promise.all(o).then(function () {\n          return l;\n        });\n      }, p.prototype._loadSampler = function (e, t) {\n        return t._data || (t._data = {\n          noMipMaps: 9728 === t.minFilter || 9729 === t.minFilter,\n          samplingMode: p._GetTextureSamplingMode(e, t),\n          wrapU: p._GetTextureWrapMode(e + \"/wrapS\", t.wrapS),\n          wrapV: p._GetTextureWrapMode(e + \"/wrapT\", t.wrapT)\n        }), t._data;\n      }, p.prototype.loadImageAsync = function (e, t) {\n        if (!t._data) {\n          if (this.logOpen(e + \" \" + (t.name || \"\")), t.uri) t._data = this.loadUriAsync(e + \"/uri\", t.uri);else {\n            var n = v.Get(e + \"/bufferView\", this.gltf.bufferViews, t.bufferView);\n            t._data = this.loadBufferViewAsync(\"#/bufferViews/\" + n.index, n);\n          }\n          this.logClose();\n        }\n\n        return t._data;\n      }, p.prototype.loadUriAsync = function (o, a) {\n        var i = this,\n            e = this._extensionsLoadUriAsync(o, a);\n\n        if (e) return e;\n        if (!p._ValidateUri(a)) throw new Error(o + \": '\" + a + \"' is invalid\");\n\n        if (O.Tools.IsBase64(a)) {\n          var t = new Uint8Array(O.Tools.DecodeBase64(a));\n          return this.log(\"Decoded \" + a.substr(0, 64) + \"... (\" + t.length + \" bytes)\"), Promise.resolve(t);\n        }\n\n        return this.log(\"Loading \" + a), this._parent.preprocessUrlAsync(this._rootUrl + a).then(function (e) {\n          return new Promise(function (n, r) {\n            if (!i._disposed) {\n              var t = O.Tools.LoadFile(e, function (e) {\n                if (!i._disposed) {\n                  var t = new Uint8Array(e);\n                  i.log(\"Loaded \" + a + \" (\" + t.length + \" bytes)\"), n(t);\n                }\n              }, function (e) {\n                if (!i._disposed && (t && (t._lengthComputable = e.lengthComputable, t._loaded = e.loaded, t._total = e.total), i._state === O.GLTFLoaderState.LOADING)) try {\n                  i._onProgress();\n                } catch (e) {\n                  r(e);\n                }\n              }, i.babylonScene.database, !0, function (e, t) {\n                i._disposed || r(new O.LoadFileError(o + \": Failed to load '\" + a + \"'\" + (e ? \": \" + e.status + \" \" + e.statusText : \"\"), e));\n              });\n\n              i._requests.push(t);\n            }\n          });\n        });\n      }, p.prototype._onProgress = function () {\n        if (this._progressCallback) {\n          for (var e = !0, t = 0, n = 0, r = 0, o = this._requests; r < o.length; r++) {\n            var a = o[r];\n            if (void 0 === a._lengthComputable || void 0 === a._loaded || void 0 === a._total) return;\n            e = e && a._lengthComputable, t += a._loaded, n += a._total;\n          }\n\n          this._progressCallback(new O.SceneLoaderProgressEvent(e, t, e ? n : 0));\n        }\n      }, p._GetTextureWrapMode = function (e, t) {\n        switch (t = null == t ? 10497 : t) {\n          case 33071:\n            return O.Texture.CLAMP_ADDRESSMODE;\n\n          case 33648:\n            return O.Texture.MIRROR_ADDRESSMODE;\n\n          case 10497:\n            return O.Texture.WRAP_ADDRESSMODE;\n\n          default:\n            return O.Tools.Warn(e + \": Invalid value (\" + t + \")\"), O.Texture.WRAP_ADDRESSMODE;\n        }\n      }, p._GetTextureSamplingMode = function (e, t) {\n        var n = null == t.magFilter ? 9729 : t.magFilter,\n            r = null == t.minFilter ? 9987 : t.minFilter;\n        if (9729 === n) switch (r) {\n          case 9728:\n            return O.Texture.LINEAR_NEAREST;\n\n          case 9729:\n            return O.Texture.LINEAR_LINEAR;\n\n          case 9984:\n            return O.Texture.LINEAR_NEAREST_MIPNEAREST;\n\n          case 9985:\n            return O.Texture.LINEAR_LINEAR_MIPNEAREST;\n\n          case 9986:\n            return O.Texture.LINEAR_NEAREST_MIPLINEAR;\n\n          case 9987:\n            return O.Texture.LINEAR_LINEAR_MIPLINEAR;\n\n          default:\n            return O.Tools.Warn(e + \"/minFilter: Invalid value (\" + r + \")\"), O.Texture.LINEAR_LINEAR_MIPLINEAR;\n        } else switch (9728 !== n && O.Tools.Warn(e + \"/magFilter: Invalid value (\" + n + \")\"), r) {\n          case 9728:\n            return O.Texture.NEAREST_NEAREST;\n\n          case 9729:\n            return O.Texture.NEAREST_LINEAR;\n\n          case 9984:\n            return O.Texture.NEAREST_NEAREST_MIPNEAREST;\n\n          case 9985:\n            return O.Texture.NEAREST_LINEAR_MIPNEAREST;\n\n          case 9986:\n            return O.Texture.NEAREST_NEAREST_MIPLINEAR;\n\n          case 9987:\n            return O.Texture.NEAREST_LINEAR_MIPLINEAR;\n\n          default:\n            return O.Tools.Warn(e + \"/minFilter: Invalid value (\" + r + \")\"), O.Texture.NEAREST_NEAREST_MIPNEAREST;\n        }\n      }, p._GetTypedArray = function (t, e, n, r, o) {\n        var a = n.buffer;\n        r = n.byteOffset + (r || 0);\n\n        try {\n          switch (e) {\n            case 5120:\n              return new Int8Array(a, r, o);\n\n            case 5121:\n              return new Uint8Array(a, r, o);\n\n            case 5122:\n              return new Int16Array(a, r, o);\n\n            case 5123:\n              return new Uint16Array(a, r, o);\n\n            case 5125:\n              return new Uint32Array(a, r, o);\n\n            case 5126:\n              return new Float32Array(a, r, o);\n\n            default:\n              throw new Error(\"Invalid component type \" + e);\n          }\n        } catch (e) {\n          throw new Error(t + \": \" + e);\n        }\n      }, p._GetNumComponents = function (e, t) {\n        switch (t) {\n          case \"SCALAR\":\n            return 1;\n\n          case \"VEC2\":\n            return 2;\n\n          case \"VEC3\":\n            return 3;\n\n          case \"VEC4\":\n          case \"MAT2\":\n            return 4;\n\n          case \"MAT3\":\n            return 9;\n\n          case \"MAT4\":\n            return 16;\n        }\n\n        throw new Error(e + \": Invalid type (\" + t + \")\");\n      }, p._ValidateUri = function (e) {\n        return O.Tools.IsBase64(e) || -1 === e.indexOf(\"..\");\n      }, p._GetDrawMode = function (e, t) {\n        switch (null == t && (t = 4), t) {\n          case 0:\n            return O.Material.PointListDrawMode;\n\n          case 1:\n            return O.Material.LineListDrawMode;\n\n          case 2:\n            return O.Material.LineLoopDrawMode;\n\n          case 3:\n            return O.Material.LineStripDrawMode;\n\n          case 4:\n            return O.Material.TriangleFillMode;\n\n          case 5:\n            return O.Material.TriangleStripDrawMode;\n\n          case 6:\n            return O.Material.TriangleFanDrawMode;\n        }\n\n        throw new Error(e + \": Invalid mesh primitive mode (\" + t + \")\");\n      }, p.prototype._compileMaterialsAsync = function () {\n        var e = this;\n\n        this._parent._startPerformanceCounter(\"Compile materials\");\n\n        var t = new Array();\n        if (this.gltf.materials) for (var n = 0, r = this.gltf.materials; n < r.length; n++) {\n          var o = r[n];\n          if (o._babylonData) for (var a in o._babylonData) for (var i = o._babylonData[a], s = 0, l = i.meshes; s < l.length; s++) {\n            var u = l[s];\n            u.computeWorldMatrix(!0);\n            var c = i.material;\n            t.push(c.forceCompilationAsync(u)), this._parent.useClipPlane && t.push(c.forceCompilationAsync(u, {\n              clipPlane: !0\n            }));\n          }\n        }\n        return Promise.all(t).then(function () {\n          e._parent._endPerformanceCounter(\"Compile materials\");\n        });\n      }, p.prototype._compileShadowGeneratorsAsync = function () {\n        var e = this;\n\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\n\n        for (var t = new Array(), n = 0, r = this.babylonScene.lights; n < r.length; n++) {\n          var o = r[n].getShadowGenerator();\n          o && t.push(o.forceCompilationAsync());\n        }\n\n        return Promise.all(t).then(function () {\n          e._parent._endPerformanceCounter(\"Compile shadow generators\");\n        });\n      }, p.prototype._forEachExtensions = function (e) {\n        for (var t = 0, n = p._ExtensionNames; t < n.length; t++) {\n          var r = n[t],\n              o = this._extensions[r];\n          o.enabled && e(o);\n        }\n      }, p.prototype._applyExtensions = function (e, t) {\n        for (var n = 0, r = p._ExtensionNames; n < r.length; n++) {\n          var o = r[n],\n              a = this._extensions[o];\n\n          if (a.enabled) {\n            var i = e;\n            i._activeLoaderExtensions = i._activeLoaderExtensions || {};\n            var s = i._activeLoaderExtensions;\n\n            if (!s[o]) {\n              s[o] = !0;\n\n              try {\n                var l = t(a);\n                if (l) return l;\n              } finally {\n                delete s[o];\n              }\n            }\n          }\n        }\n\n        return null;\n      }, p.prototype._extensionsOnLoading = function () {\n        this._forEachExtensions(function (e) {\n          return e.onLoading && e.onLoading();\n        });\n      }, p.prototype._extensionsOnReady = function () {\n        this._forEachExtensions(function (e) {\n          return e.onReady && e.onReady();\n        });\n      }, p.prototype._extensionsLoadSceneAsync = function (t, n) {\n        return this._applyExtensions(n, function (e) {\n          return e.loadSceneAsync && e.loadSceneAsync(t, n);\n        });\n      }, p.prototype._extensionsLoadNodeAsync = function (t, n, r) {\n        return this._applyExtensions(n, function (e) {\n          return e.loadNodeAsync && e.loadNodeAsync(t, n, r);\n        });\n      }, p.prototype._extensionsLoadCameraAsync = function (t, n, r) {\n        return this._applyExtensions(n, function (e) {\n          return e.loadCameraAsync && e.loadCameraAsync(t, n, r);\n        });\n      }, p.prototype._extensionsLoadVertexDataAsync = function (t, n, r) {\n        return this._applyExtensions(n, function (e) {\n          return e._loadVertexDataAsync && e._loadVertexDataAsync(t, n, r);\n        });\n      }, p.prototype._extensionsLoadMaterialAsync = function (t, n, r, o, a) {\n        return this._applyExtensions(n, function (e) {\n          return e._loadMaterialAsync && e._loadMaterialAsync(t, n, r, o, a);\n        });\n      }, p.prototype._extensionsCreateMaterial = function (t, n, r) {\n        return this._applyExtensions({}, function (e) {\n          return e.createMaterial && e.createMaterial(t, n, r);\n        });\n      }, p.prototype._extensionsLoadMaterialPropertiesAsync = function (t, n, r) {\n        return this._applyExtensions(n, function (e) {\n          return e.loadMaterialPropertiesAsync && e.loadMaterialPropertiesAsync(t, n, r);\n        });\n      }, p.prototype._extensionsLoadTextureInfoAsync = function (t, n, r) {\n        return this._applyExtensions(n, function (e) {\n          return e.loadTextureInfoAsync && e.loadTextureInfoAsync(t, n, r);\n        });\n      }, p.prototype._extensionsLoadAnimationAsync = function (t, n) {\n        return this._applyExtensions(n, function (e) {\n          return e.loadAnimationAsync && e.loadAnimationAsync(t, n);\n        });\n      }, p.prototype._extensionsLoadUriAsync = function (t, n) {\n        return this._applyExtensions({}, function (e) {\n          return e._loadUriAsync && e._loadUriAsync(t, n);\n        });\n      }, p.LoadExtensionAsync = function (e, t, n, r) {\n        if (!t.extensions) return null;\n        var o = t.extensions[n];\n        return o ? r(e + \"/extensions/\" + n, o) : null;\n      }, p.LoadExtraAsync = function (e, t, n, r) {\n        if (!t.extras) return null;\n        var o = t.extras[n];\n        return o ? r(e + \"/extras/\" + n, o) : null;\n      }, p.prototype.logOpen = function (e) {\n        this._parent._logOpen(e);\n      }, p.prototype.logClose = function () {\n        this._parent._logClose();\n      }, p.prototype.log = function (e) {\n        this._parent._log(e);\n      }, p.prototype.startPerformanceCounter = function (e) {\n        this._parent._startPerformanceCounter(e);\n      }, p.prototype.endPerformanceCounter = function (e) {\n        this._parent._endPerformanceCounter(e);\n      }, p._DefaultSampler = {\n        index: -1\n      }, p._ExtensionNames = new Array(), p._ExtensionFactories = {}, p;\n    }();\n\n    e.GLTFLoader = t, O.GLTFFileLoader._CreateGLTFLoaderV2 = function (e) {\n      return new t(e);\n    };\n  }((O = e || (e = {})).GLTF2 || (O.GLTF2 = {})), M = e || (e = {}), w = M.GLTF2 || (M.GLTF2 = {}), S = w.Loader || (w.Loader = {}), N = S.Extensions || (S.Extensions = {}), F = \"MSFT_lod\", P = function () {\n    function e(e) {\n      this.name = F, this.enabled = !0, this.maxLODsToLoad = Number.MAX_VALUE, this.onNodeLODsLoadedObservable = new M.Observable(), this.onMaterialLODsLoadedObservable = new M.Observable(), this._nodeIndexLOD = null, this._nodeSignalLODs = new Array(), this._nodePromiseLODs = new Array(), this._materialIndexLOD = null, this._materialSignalLODs = new Array(), this._materialPromiseLODs = new Array(), this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader, this._nodeIndexLOD = null, this._nodeSignalLODs.length = 0, this._nodePromiseLODs.length = 0, this._materialIndexLOD = null, this._materialSignalLODs.length = 0, this._materialPromiseLODs.length = 0, this.onMaterialLODsLoadedObservable.clear(), this.onNodeLODsLoadedObservable.clear();\n    }, e.prototype.onReady = function () {\n      for (var n = this, e = function (e) {\n        var t = Promise.all(r._nodePromiseLODs[e]).then(function () {\n          0 !== e && n._loader.endPerformanceCounter(\"Node LOD \" + e), n._loader.log(\"Loaded node LOD \" + e), n.onNodeLODsLoadedObservable.notifyObservers(e), e !== n._nodePromiseLODs.length - 1 && (n._loader.startPerformanceCounter(\"Node LOD \" + (e + 1)), n._nodeSignalLODs[e] && n._nodeSignalLODs[e].resolve());\n        });\n\n        r._loader._completePromises.push(t);\n      }, r = this, t = 0; t < this._nodePromiseLODs.length; t++) e(t);\n\n      var o = function (e) {\n        var t = Promise.all(a._materialPromiseLODs[e]).then(function () {\n          0 !== e && n._loader.endPerformanceCounter(\"Material LOD \" + e), n._loader.log(\"Loaded material LOD \" + e), n.onMaterialLODsLoadedObservable.notifyObservers(e), e !== n._materialPromiseLODs.length - 1 && (n._loader.startPerformanceCounter(\"Material LOD \" + (e + 1)), n._materialSignalLODs[e] && n._materialSignalLODs[e].resolve());\n        });\n\n        a._loader._completePromises.push(t);\n      },\n          a = this;\n\n      for (t = 0; t < this._materialPromiseLODs.length; t++) o(t);\n    }, e.prototype.loadNodeAsync = function (e, i, t) {\n      var s = this;\n      return w.GLTFLoader.LoadExtensionAsync(e, i, this.name, function (e, t) {\n        var r,\n            o = s._getLODs(e, i, s._loader.gltf.nodes, t.ids);\n\n        s._loader.logOpen(\"\" + e);\n\n        for (var n = function (n) {\n          var e = o[n];\n          0 !== n && (s._nodeIndexLOD = n, s._nodeSignalLODs[n] = s._nodeSignalLODs[n] || new M.Deferred());\n\n          var t = s._loader.loadNodeAsync(\"#/nodes/\" + e.index, e).then(function (e) {\n            if (0 !== n) {\n              var t = o[n - 1];\n              t._babylonMesh && (t._babylonMesh.dispose(), delete t._babylonMesh, s._disposeUnusedMaterials());\n            }\n\n            return e;\n          });\n\n          0 === n ? r = t : s._nodeIndexLOD = null, s._nodePromiseLODs[n] = s._nodePromiseLODs[n] || [], s._nodePromiseLODs[n].push(t);\n        }, a = 0; a < o.length; a++) n(a);\n\n        return s._loader.logClose(), r;\n      });\n    }, e.prototype._loadMaterialAsync = function (e, i, s, l, u) {\n      var c = this;\n      return this._nodeIndexLOD ? null : w.GLTFLoader.LoadExtensionAsync(e, i, this.name, function (e, t) {\n        var r,\n            o = c._getLODs(e, i, c._loader.gltf.materials, t.ids);\n\n        c._loader.logOpen(\"\" + e);\n\n        for (var n = function (n) {\n          var e = o[n];\n          0 !== n && (c._materialIndexLOD = n);\n\n          var t = c._loader._loadMaterialAsync(\"#/materials/\" + e.index, e, s, l, function (e) {\n            0 === n && u(e);\n          }).then(function (e) {\n            if (0 !== n) {\n              u(e);\n              var t = o[n - 1]._babylonData;\n              t[l] && (t[l].material.dispose(), delete t[l]);\n            }\n\n            return e;\n          });\n\n          0 === n ? r = t : c._materialIndexLOD = null, c._materialPromiseLODs[n] = c._materialPromiseLODs[n] || [], c._materialPromiseLODs[n].push(t);\n        }, a = 0; a < o.length; a++) n(a);\n\n        return c._loader.logClose(), r;\n      });\n    }, e.prototype._loadUriAsync = function (e, t) {\n      var n = this;\n\n      if (null !== this._materialIndexLOD) {\n        this._loader.log(\"deferred\");\n\n        var r = this._materialIndexLOD - 1;\n        return this._materialSignalLODs[r] = this._materialSignalLODs[r] || new M.Deferred(), this._materialSignalLODs[r].promise.then(function () {\n          return n._loader.loadUriAsync(e, t);\n        });\n      }\n\n      return null !== this._nodeIndexLOD ? (this._loader.log(\"deferred\"), r = this._nodeIndexLOD - 1, this._nodeSignalLODs[r] = this._nodeSignalLODs[r] || new M.Deferred(), this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function () {\n        return n._loader.loadUriAsync(e, t);\n      })) : null;\n    }, e.prototype._getLODs = function (e, t, n, r) {\n      if (this.maxLODsToLoad <= 0) throw new Error(\"maxLODsToLoad must be greater than zero\");\n\n      for (var o = new Array(), a = r.length - 1; 0 <= a; a--) if (o.push(w.ArrayItem.Get(e + \"/ids/\" + r[a], n, r[a])), o.length === this.maxLODsToLoad) return o;\n\n      return o.push(t), o;\n    }, e.prototype._disposeUnusedMaterials = function () {\n      var e = this._loader.gltf.materials;\n      if (e) for (var t = 0, n = e; t < n.length; t++) {\n        var r = n[t];\n        if (r._babylonData) for (var o in r._babylonData) {\n          var a = r._babylonData[o];\n          0 === a.meshes.length && (a.material.dispose(!1, !0), delete r._babylonData[o]);\n        }\n      }\n    }, e;\n  }(), N.MSFT_lod = P, w.GLTFLoader.RegisterExtension(F, function (e) {\n    return new P(e);\n  }), C = e || (e = {}), I = C.GLTF2 || (C.GLTF2 = {}), R = I.Loader || (I.Loader = {}), D = R.Extensions || (R.Extensions = {}), B = \"MSFT_minecraftMesh\", G = function () {\n    function e(e) {\n      this.name = B, this.enabled = !0, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader;\n    }, e.prototype.loadMaterialPropertiesAsync = function (r, o, a) {\n      var i = this;\n      return I.GLTFLoader.LoadExtraAsync(r, o, this.name, function (e, t) {\n        if (t) {\n          if (!(a instanceof C.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n\n          var n = i._loader.loadMaterialPropertiesAsync(r, o, a);\n\n          return a.needAlphaBlending() && (a.forceDepthWrite = !0, a.separateCullingPass = !0), a.backFaceCulling = a.forceDepthWrite, a.twoSidedLighting = !0, n;\n        }\n\n        return null;\n      });\n    }, e;\n  }(), D.MSFT_minecraftMesh = G, I.GLTFLoader.RegisterExtension(B, function (e) {\n    return new G(e);\n  }), V = e || (e = {}), U = V.GLTF2 || (V.GLTF2 = {}), k = U.Loader || (U.Loader = {}), j = k.Extensions || (k.Extensions = {}), H = \"MSFT_sRGBFactors\", K = function () {\n    function e(e) {\n      this.name = H, this.enabled = !0, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader;\n    }, e.prototype.loadMaterialPropertiesAsync = function (r, o, a) {\n      var i = this;\n      return U.GLTFLoader.LoadExtraAsync(r, o, this.name, function (e, t) {\n        if (t) {\n          if (!(a instanceof V.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n\n          var n = i._loader.loadMaterialPropertiesAsync(r, o, a);\n\n          return a.albedoTexture || a.albedoColor.toLinearSpaceToRef(a.albedoColor), a.reflectivityTexture || a.reflectivityColor.toLinearSpaceToRef(a.reflectivityColor), n;\n        }\n\n        return null;\n      });\n    }, e;\n  }(), j.MSFT_sRGBFactors = K, U.GLTFLoader.RegisterExtension(H, function (e) {\n    return new K(e);\n  }), Z = e || (e = {}), Q = Z.GLTF2 || (Z.GLTF2 = {}), Y = Q.Loader || (Q.Loader = {}), J = Y.Extensions || (Y.Extensions = {}), q = \"MSFT_audio_emitter\", X = function () {\n    function e(e) {\n      this.name = q, this.enabled = !0, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader, delete this._clips, delete this._emitters;\n    }, e.prototype.onLoading = function () {\n      var e = this._loader.gltf.extensions;\n\n      if (e && e[this.name]) {\n        var t = e[this.name];\n        this._clips = t.clips, this._emitters = t.emitters, Q.ArrayItem.Assign(this._clips), Q.ArrayItem.Assign(this._emitters);\n      }\n    }, e.prototype.loadSceneAsync = function (s, l) {\n      var u = this;\n      return Q.GLTFLoader.LoadExtensionAsync(s, l, this.name, function (e, t) {\n        var n = new Array();\n        n.push(u._loader.loadSceneAsync(s, l));\n\n        for (var r = 0, o = t.emitters; r < o.length; r++) {\n          var a = o[r],\n              i = Q.ArrayItem.Get(e + \"/emitters\", u._emitters, a);\n          if (null != i.refDistance || null != i.maxDistance || null != i.rolloffFactor || null != i.distanceModel || null != i.innerAngle || null != i.outerAngle) throw new Error(e + \": Direction or Distance properties are not allowed on emitters attached to a scene\");\n          n.push(u._loadEmitterAsync(e + \"/emitters/\" + i.index, i));\n        }\n\n        return Promise.all(n).then(function () {});\n      });\n    }, e.prototype.loadNodeAsync = function (e, t, s) {\n      var l = this;\n      return Q.GLTFLoader.LoadExtensionAsync(e, t, this.name, function (a, r) {\n        var i = new Array();\n        return l._loader.loadNodeAsync(a, t, function (o) {\n          for (var e = function (e) {\n            var r = Q.ArrayItem.Get(a + \"/emitters\", l._emitters, e);\n            i.push(l._loadEmitterAsync(a + \"/emitters/\" + r.index, r).then(function () {\n              for (var e = 0, t = r._babylonSounds; e < t.length; e++) {\n                var n = t[e];\n                n.attachToMesh(o), null == r.innerAngle && null == r.outerAngle || (n.setLocalDirectionToMesh(Z.Vector3.Forward()), n.setDirectionalCone(2 * Z.Tools.ToDegrees(null == r.innerAngle ? Math.PI : r.innerAngle), 2 * Z.Tools.ToDegrees(null == r.outerAngle ? Math.PI : r.outerAngle), 0));\n              }\n            }));\n          }, t = 0, n = r.emitters; t < n.length; t++) e(n[t]);\n\n          s(o);\n        }).then(function (e) {\n          return Promise.all(i).then(function () {\n            return e;\n          });\n        });\n      });\n    }, e.prototype.loadAnimationAsync = function (s, l) {\n      var u = this;\n      return Q.GLTFLoader.LoadExtensionAsync(s, l, this.name, function (a, i) {\n        return u._loader.loadAnimationAsync(s, l).then(function (e) {\n          var t = new Array();\n          Q.ArrayItem.Assign(i.events);\n\n          for (var n = 0, r = i.events; n < r.length; n++) {\n            var o = r[n];\n            t.push(u._loadAnimationEventAsync(a + \"/events/\" + o.index, s, l, o, e));\n          }\n\n          return Promise.all(t).then(function () {\n            return e;\n          });\n        });\n      });\n    }, e.prototype._loadClipAsync = function (e, t) {\n      if (t._objectURL) return t._objectURL;\n      var n;\n      if (t.uri) n = this._loader.loadUriAsync(e, t.uri);else {\n        var r = Q.ArrayItem.Get(e + \"/bufferView\", this._loader.gltf.bufferViews, t.bufferView);\n        n = this._loader.loadBufferViewAsync(\"#/bufferViews/\" + r.index, r);\n      }\n      return t._objectURL = n.then(function (e) {\n        return URL.createObjectURL(new Blob([e], {\n          type: t.mimeType\n        }));\n      }), t._objectURL;\n    }, e.prototype._loadEmitterAsync = function (e, r) {\n      var o = this;\n\n      if (r._babylonSounds = r._babylonSounds || [], !r._babylonData) {\n        for (var a = new Array(), i = r.name || \"emitter\" + r.index, s = {\n          loop: !1,\n          autoplay: !1,\n          volume: null == r.volume ? 1 : r.volume\n        }, t = function (n) {\n          var e = \"#/extensions/\" + l.name + \"/clips\",\n              t = Q.ArrayItem.Get(e, l._clips, r.clips[n].clip);\n          a.push(l._loadClipAsync(e + \"/\" + r.clips[n].clip, t).then(function (e) {\n            var t = r._babylonSounds[n] = new Z.Sound(i, e, o._loader.babylonScene, null, s);\n            t.refDistance = r.refDistance || 1, t.maxDistance = r.maxDistance || 256, t.rolloffFactor = r.rolloffFactor || 1, t.distanceModel = r.distanceModel || \"exponential\", t._positionInEmitterSpace = !0;\n          }));\n        }, l = this, n = 0; n < r.clips.length; n++) t(n);\n\n        var u = Promise.all(a).then(function () {\n          var e = r.clips.map(function (e) {\n            return e.weight || 1;\n          }),\n              t = new Z.WeightedSound(r.loop || !1, r._babylonSounds, e);\n          r.innerAngle && (t.directionalConeInnerAngle = 2 * Z.Tools.ToDegrees(r.innerAngle)), r.outerAngle && (t.directionalConeOuterAngle = 2 * Z.Tools.ToDegrees(r.outerAngle)), r.volume && (t.volume = r.volume), r._babylonData.sound = t;\n        });\n        r._babylonData = {\n          loaded: u\n        };\n      }\n\n      return r._babylonData.loaded;\n    }, e.prototype._getEventAction = function (e, n, t, r, o) {\n      switch (t) {\n        case \"play\":\n          return function (e) {\n            var t = (o || 0) + (e - r);\n            n.play(t);\n          };\n\n        case \"stop\":\n          return function (e) {\n            n.stop();\n          };\n\n        case \"pause\":\n          return function (e) {\n            n.pause();\n          };\n\n        default:\n          throw new Error(e + \": Unsupported action \" + t);\n      }\n    }, e.prototype._loadAnimationEventAsync = function (n, e, t, r, o) {\n      var a = this;\n      if (0 == o.targetedAnimations.length) return Promise.resolve();\n      var i = o.targetedAnimations[0],\n          s = r.emitter,\n          l = Q.ArrayItem.Get(\"#/extensions/\" + this.name + \"/emitters\", this._emitters, s);\n      return this._loadEmitterAsync(n, l).then(function () {\n        var e = l._babylonData.sound;\n\n        if (e) {\n          var t = new Z.AnimationEvent(r.time, a._getEventAction(n, e, r.action, r.time, r.startOffset));\n          i.animation.addEvent(t), o.onAnimationGroupEndObservable.add(function () {\n            e.stop();\n          }), o.onAnimationGroupPauseObservable.add(function () {\n            e.pause();\n          });\n        }\n      });\n    }, e;\n  }(), J.MSFT_audio_emitter = X, Q.GLTFLoader.RegisterExtension(q, function (e) {\n    return new X(e);\n  }), z = e || (e = {}), $ = z.GLTF2 || (z.GLTF2 = {}), ee = $.Loader || ($.Loader = {}), te = ee.Extensions || (ee.Extensions = {}), ne = \"KHR_draco_mesh_compression\", re = function () {\n    function e(e) {\n      this.name = ne, this.enabled = z.DracoCompression.DecoderAvailable, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      this._dracoCompression && (this._dracoCompression.dispose(), delete this._dracoCompression), delete this._loader;\n    }, e.prototype._loadVertexDataAsync = function (a, i, s) {\n      var l = this;\n      return $.GLTFLoader.LoadExtensionAsync(a, i, this.name, function (e, r) {\n        if (null != i.mode) {\n          if (5 !== i.mode && 4 !== i.mode) throw new Error(a + \": Unsupported mode \" + i.mode);\n          if (5 === i.mode) throw new Error(a + \": Mode \" + i.mode + \" is not currently supported\");\n        }\n\n        var o = {},\n            t = function (e, t) {\n          var n = r.attributes[e];\n          null != n && (s._delayInfo = s._delayInfo || [], -1 === s._delayInfo.indexOf(t) && s._delayInfo.push(t), o[t] = n);\n        };\n\n        t(\"POSITION\", z.VertexBuffer.PositionKind), t(\"NORMAL\", z.VertexBuffer.NormalKind), t(\"TANGENT\", z.VertexBuffer.TangentKind), t(\"TEXCOORD_0\", z.VertexBuffer.UVKind), t(\"TEXCOORD_1\", z.VertexBuffer.UV2Kind), t(\"JOINTS_0\", z.VertexBuffer.MatricesIndicesKind), t(\"WEIGHTS_0\", z.VertexBuffer.MatricesWeightsKind), t(\"COLOR_0\", z.VertexBuffer.ColorKind);\n        var n = $.ArrayItem.Get(e, l._loader.gltf.bufferViews, r.bufferView);\n        return n._dracoBabylonGeometry || (n._dracoBabylonGeometry = l._loader.loadBufferViewAsync(\"#/bufferViews/\" + n.index, n).then(function (e) {\n          return l._dracoCompression || (l._dracoCompression = new z.DracoCompression()), l._dracoCompression.decodeMeshAsync(e, o).then(function (e) {\n            var t = new z.Geometry(s.name, l._loader.babylonScene);\n            return e.applyToGeometry(t), t;\n          }).catch(function (e) {\n            throw new Error(a + \": \" + e.message);\n          });\n        })), n._dracoBabylonGeometry;\n      });\n    }, e;\n  }(), te.KHR_draco_mesh_compression = re, $.GLTFLoader.RegisterExtension(ne, function (e) {\n    return new re(e);\n  }), oe = e || (e = {}), ae = oe.GLTF2 || (oe.GLTF2 = {}), ie = ae.Loader || (ae.Loader = {}), se = ie.Extensions || (ie.Extensions = {}), le = \"KHR_materials_pbrSpecularGlossiness\", ue = function () {\n    function e(e) {\n      this.name = le, this.enabled = !0, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader;\n    }, e.prototype.loadMaterialPropertiesAsync = function (r, o, a) {\n      var i = this;\n      return ae.GLTFLoader.LoadExtensionAsync(r, o, this.name, function (e, t) {\n        var n = new Array();\n        return n.push(i._loader.loadMaterialBasePropertiesAsync(r, o, a)), n.push(i._loadSpecularGlossinessPropertiesAsync(e, o, t, a)), i._loader.loadMaterialAlphaProperties(r, o, a), Promise.all(n).then(function () {});\n      });\n    }, e.prototype._loadSpecularGlossinessPropertiesAsync = function (e, t, n, r) {\n      if (!(r instanceof oe.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n      var o = new Array();\n      return r.metallic = null, r.roughness = null, n.diffuseFactor ? (r.albedoColor = oe.Color3.FromArray(n.diffuseFactor), r.alpha = n.diffuseFactor[3]) : r.albedoColor = oe.Color3.White(), r.reflectivityColor = n.specularFactor ? oe.Color3.FromArray(n.specularFactor) : oe.Color3.White(), r.microSurface = null == n.glossinessFactor ? 1 : n.glossinessFactor, n.diffuseTexture && o.push(this._loader.loadTextureInfoAsync(e + \"/diffuseTexture\", n.diffuseTexture, function (e) {\n        return r.albedoTexture = e, Promise.resolve();\n      })), n.specularGlossinessTexture && (o.push(this._loader.loadTextureInfoAsync(e + \"/specularGlossinessTexture\", n.specularGlossinessTexture, function (e) {\n        return r.reflectivityTexture = e, Promise.resolve();\n      })), r.reflectivityTexture.hasAlpha = !0, r.useMicroSurfaceFromReflectivityMapAlpha = !0), Promise.all(o).then(function () {});\n    }, e;\n  }(), se.KHR_materials_pbrSpecularGlossiness = ue, ae.GLTFLoader.RegisterExtension(le, function (e) {\n    return new ue(e);\n  }), ce = e || (e = {}), de = ce.GLTF2 || (ce.GLTF2 = {}), fe = de.Loader || (de.Loader = {}), he = fe.Extensions || (fe.Extensions = {}), pe = \"KHR_materials_unlit\", me = function () {\n    function e(e) {\n      this.name = pe, this.enabled = !0, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader;\n    }, e.prototype.loadMaterialPropertiesAsync = function (e, t, n) {\n      var r = this;\n      return de.GLTFLoader.LoadExtensionAsync(e, t, this.name, function () {\n        return r._loadUnlitPropertiesAsync(e, t, n);\n      });\n    }, e.prototype._loadUnlitPropertiesAsync = function (e, t, n) {\n      if (!(n instanceof ce.PBRMaterial)) throw new Error(e + \": Material type not supported\");\n      var r = new Array();\n      n.unlit = !0;\n      var o = t.pbrMetallicRoughness;\n      return o && (o.baseColorFactor ? (n.albedoColor = ce.Color3.FromArray(o.baseColorFactor), n.alpha = o.baseColorFactor[3]) : n.albedoColor = ce.Color3.White(), o.baseColorTexture && r.push(this._loader.loadTextureInfoAsync(e + \"/baseColorTexture\", o.baseColorTexture, function (e) {\n        return n.albedoTexture = e, Promise.resolve();\n      }))), t.doubleSided && (n.backFaceCulling = !1, n.twoSidedLighting = !0), this._loader.loadMaterialAlphaProperties(e, t, n), Promise.all(r).then(function () {});\n    }, e;\n  }(), he.KHR_materials_unlit = me, de.GLTFLoader.RegisterExtension(pe, function (e) {\n    return new me(e);\n  }), ye = e || (e = {}), _e = ye.GLTF2 || (ye.GLTF2 = {}), function (e) {\n    var u,\n        t,\n        n = \"KHR_lights_punctual\";\n    (t = u || (u = {})).DIRECTIONAL = \"directional\", t.POINT = \"point\", t.SPOT = \"spot\";\n\n    var r = function () {\n      function e(e) {\n        this.name = n, this.enabled = !0, this._loader = e;\n      }\n\n      return e.prototype.dispose = function () {\n        delete this._loader, delete this._lights;\n      }, e.prototype.onLoading = function () {\n        var e = this._loader.gltf.extensions;\n\n        if (e && e[this.name]) {\n          var t = e[this.name];\n          this._lights = t.lights;\n        }\n      }, e.prototype.loadNodeAsync = function (e, t, s) {\n        var l = this;\n        return _e.GLTFLoader.LoadExtensionAsync(e, t, this.name, function (a, i) {\n          return l._loader.loadNodeAsync(e, t, function (e) {\n            var t,\n                n = _e.ArrayItem.Get(a, l._lights, i.light),\n                r = n.name || e.name;\n\n            switch (n.type) {\n              case u.DIRECTIONAL:\n                t = new ye.DirectionalLight(r, ye.Vector3.Backward(), l._loader.babylonScene);\n                break;\n\n              case u.POINT:\n                t = new ye.PointLight(r, ye.Vector3.Zero(), l._loader.babylonScene);\n                break;\n\n              case u.SPOT:\n                var o = new ye.SpotLight(r, ye.Vector3.Zero(), ye.Vector3.Backward(), 0, 1, l._loader.babylonScene);\n                o.angle = 2 * (n.spot && n.spot.outerConeAngle || Math.PI / 4), o.innerAngle = 2 * (n.spot && n.spot.innerConeAngle || 0), t = o;\n                break;\n\n              default:\n                throw new Error(a + \": Invalid light type (\" + n.type + \")\");\n            }\n\n            t.falloffType = ye.Light.FALLOFF_GLTF, t.diffuse = n.color ? ye.Color3.FromArray(n.color) : ye.Color3.White(), t.intensity = null == n.intensity ? 1 : n.intensity, t.range = null == n.range ? Number.MAX_VALUE : n.range, t.parent = e, s(e);\n          });\n        });\n      }, e;\n    }();\n\n    e.KHR_lights = r, _e.GLTFLoader.RegisterExtension(n, function (e) {\n      return new r(e);\n    });\n  }((Ae = _e.Loader || (_e.Loader = {})).Extensions || (Ae.Extensions = {})), ge = e || (e = {}), ve = ge.GLTF2 || (ge.GLTF2 = {}), be = ve.Loader || (ve.Loader = {}), Te = be.Extensions || (be.Extensions = {}), Ee = \"KHR_texture_transform\", Le = function () {\n    function e(e) {\n      this.name = Ee, this.enabled = !0, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader;\n    }, e.prototype.loadTextureInfoAsync = function (e, r, o) {\n      var a = this;\n      return ve.GLTFLoader.LoadExtensionAsync(e, r, this.name, function (t, n) {\n        return a._loader.loadTextureInfoAsync(e, r, function (e) {\n          if (!(e instanceof ge.Texture)) throw new Error(t + \": Texture type not supported\");\n          n.offset && (e.uOffset = n.offset[0], e.vOffset = n.offset[1]), e.uRotationCenter = 0, e.vRotationCenter = 0, n.rotation && (e.wAng = -n.rotation), n.scale && (e.uScale = n.scale[0], e.vScale = n.scale[1]), null != n.texCoord && (e.coordinatesIndex = n.texCoord), o(e);\n        });\n      });\n    }, e;\n  }(), Te.KHR_texture_transform = Le, ve.GLTFLoader.RegisterExtension(Ee, function (e) {\n    return new Le(e);\n  }), xe = e || (e = {}), Oe = xe.GLTF2 || (xe.GLTF2 = {}), Me = Oe.Loader || (Oe.Loader = {}), we = Me.Extensions || (Me.Extensions = {}), Se = \"EXT_lights_image_based\", Ne = function () {\n    function e(e) {\n      this.name = Se, this.enabled = !0, this._loader = e;\n    }\n\n    return e.prototype.dispose = function () {\n      delete this._loader, delete this._lights;\n    }, e.prototype.onLoading = function () {\n      var e = this._loader.gltf.extensions;\n\n      if (e && e[this.name]) {\n        var t = e[this.name];\n        this._lights = t.lights;\n      }\n    }, e.prototype.loadSceneAsync = function (o, a) {\n      var i = this;\n      return Oe.GLTFLoader.LoadExtensionAsync(o, a, this.name, function (e, t) {\n        var n = new Array();\n        n.push(i._loader.loadSceneAsync(o, a)), i._loader.logOpen(\"\" + e);\n        var r = Oe.ArrayItem.Get(e + \"/light\", i._lights, t.light);\n        return n.push(i._loadLightAsync(\"#/extensions/\" + i.name + \"/lights/\" + t.light, r).then(function (e) {\n          i._loader.babylonScene.environmentTexture = e;\n        })), i._loader.logClose(), Promise.all(n).then(function () {});\n      });\n    }, e.prototype._loadLightAsync = function (i, s) {\n      var a = this;\n\n      if (!s._loaded) {\n        var l = new Array();\n\n        this._loader.logOpen(\"\" + i);\n\n        for (var u = new Array(s.specularImages.length), e = function (o) {\n          var a = s.specularImages[o];\n          u[o] = new Array(a.length);\n\n          for (var e = function (t) {\n            var e = i + \"/specularImages/\" + o + \"/\" + t;\n\n            c._loader.logOpen(\"\" + e);\n\n            var n = a[t],\n                r = Oe.ArrayItem.Get(e, c._loader.gltf.images, n);\n            l.push(c._loader.loadImageAsync(\"#/images/\" + n, r).then(function (e) {\n              u[o][t] = e;\n            })), c._loader.logClose();\n          }, t = 0; t < a.length; t++) e(t);\n        }, c = this, t = 0; t < s.specularImages.length; t++) e(t);\n\n        this._loader.logClose(), s._loaded = Promise.all(l).then(function () {\n          var e = new xe.RawCubeTexture(a._loader.babylonScene, null, s.specularImageSize);\n\n          if (s._babylonTexture = e, null != s.intensity && (e.level = s.intensity), s.rotation) {\n            var t = xe.Quaternion.FromArray(s.rotation);\n            a._loader.babylonScene.useRightHandedSystem || (t = xe.Quaternion.Inverse(t)), xe.Matrix.FromQuaternionToRef(t, e.getReflectionTextureMatrix());\n          }\n\n          var n = xe.SphericalHarmonics.FromArray(s.irradianceCoefficients);\n          n.scale(s.intensity), n.convertIrradianceToLambertianRadiance();\n          var r = xe.SphericalPolynomial.FromHarmonics(n),\n              o = (u.length - 1) / xe.Scalar.Log2(s.specularImageSize);\n          return e.updateRGBDAsync(u, r, o);\n        });\n      }\n\n      return s._loaded.then(function () {\n        return s._babylonTexture;\n      });\n    }, e;\n  }(), we.EXT_lights_image_based = Ne, Oe.GLTFLoader.RegisterExtension(Se, function (e) {\n    return new Ne(e);\n  }), e;\n});","map":null,"metadata":{},"sourceType":"script"}